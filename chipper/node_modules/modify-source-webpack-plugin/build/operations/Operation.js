"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
exports.__esModule = true;
exports.Operation = void 0;
var ConcatOperation_1 = require("./ConcatOperation");
var ReplaceOperation_1 = require("./ReplaceOperation");
function isSerializableOfOperation(serializable, operation) {
    return serializable.operationName === operation.name;
}
function throwUnknownOperationType(op, opType) {
    var allowedTypes = op instanceof ConcatOperation_1.ConcatOperation
        ? ConcatOperation_1.ConcatOperation.getAllowedTypes()
        : ReplaceOperation_1.ReplaceOperation.getAllowedTypes();
    throw new Error("Incorrect operation type '".concat(opType, "' for ").concat(op.constructor.name, ". Allowed types: '").concat(allowedTypes.join("', '"), "'."));
}
var Operation = /** @class */ (function () {
    function Operation() {
    }
    Operation.makeSerializable = function (op) {
        var propertyValues = op.getSerializableProperties().reduce(function (acc, val) {
            var _a;
            return __assign(__assign({}, acc), (_a = {}, _a[val] = op[val], _a));
        }, {});
        return __assign({ operationName: op.constructor.name }, propertyValues);
    };
    Operation.fromSerializable = function (serializable) {
        if (isSerializableOfOperation(serializable, ConcatOperation_1.ConcatOperation)) {
            var type = serializable.type, value = serializable.value;
            return new ConcatOperation_1.ConcatOperation(type, value);
        }
        if (isSerializableOfOperation(serializable, ReplaceOperation_1.ReplaceOperation)) {
            var type = serializable.type, searchValue = serializable.searchValue, replaceValue = serializable.replaceValue;
            return new ReplaceOperation_1.ReplaceOperation(type, searchValue, replaceValue);
        }
        throw new Error('Incorrect serializable provided: ' + JSON.stringify(serializable));
    };
    Operation.fillConstants = function (operation, constants) {
        var filledTextProps = operation
            .getTextProperties()
            .reduce(function (acc, propName) {
            var _a;
            var propValue = operation[propName];
            Object.keys(constants).forEach(function (constant) {
                propValue = propValue.replace(new RegExp("\\$".concat(constant), 'g'), String(constants[constant]));
            });
            return __assign(__assign({}, acc), (_a = {}, _a[propName] = propValue, _a));
        }, {});
        var mergedObject = __assign(__assign({}, Operation.makeSerializable(operation)), filledTextProps);
        return Operation.fromSerializable(mergedObject);
    };
    Operation.apply = function (src, operation) {
        if (operation instanceof ConcatOperation_1.ConcatOperation) {
            switch (operation.type) {
                case 'start':
                    return operation.value + src;
                case 'end':
                    return src + operation.value;
                default:
                    throwUnknownOperationType(operation, operation.type);
            }
        }
        if (operation instanceof ReplaceOperation_1.ReplaceOperation) {
            switch (operation.type) {
                case 'once':
                    return src.replace(operation.searchValue, operation.replaceValue);
                case 'all':
                    return src.replace(new RegExp(operation.searchValue, 'g'), operation.replaceValue);
                default:
                    throwUnknownOperationType(operation, operation.type);
            }
        }
        throw new Error('Unknown operation instance: ' + operation.constructor.name);
    };
    return Operation;
}());
exports.Operation = Operation;
//# sourceMappingURL=Operation.js.map