"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.localizedStrings = exports["default"] = void 0;
var _PhetioObject = _interopRequireDefault(require("../../tandem/js/PhetioObject.js"));
var _Tandem = _interopRequireDefault(require("../../tandem/js/Tandem.js"));
var _CouldNotYetDeserializeError = _interopRequireDefault(require("../../tandem/js/CouldNotYetDeserializeError.js"));
var _IOType = _interopRequireDefault(require("../../tandem/js/types/IOType.js"));
var _ObjectLiteralIO = _interopRequireDefault(require("../../tandem/js/types/ObjectLiteralIO.js"));
var _LocalizedString = _interopRequireDefault(require("./LocalizedString.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); } // Copyright 2020-2024, University of Colorado Boulder
/**
 * Given a requirejsNamespace, we filter out strings from phet.chipper.strings that start with it, and construct an
 * object with locale fallbacks already pre-computed, so that the correct strings can be accessed via object literal
 * access, e.g. getStringModule( 'JOIST' ).ResetAllButton.name will give the desired string value for whatever locale
 * the sim is being run with.
 *
 * A string "key" is in the form of "NAMESPACE/key.from.strings.json"
 *
 * NOTE: This file likely belongs in joist/js/i18n/, but should stay here to make maintenance-release maintainability easier.
 *
 * @author Jonathan Olson <jonathan.olson>
 */
// constants
var FALLBACK_LOCALE = 'en';

// Holds all of our localizedStrings, so that we can save our phet-io string change state
var localizedStrings = exports.localizedStrings = [];

// For developer internal use, particularly for memory leak detection
// e.g. _.max( phet.chipper.localizedStrings.map( ls => ls.property.tinyProperty.listeners.size ) ) to see if there is
// likely a leak
window.phet.chipper.localizedStrings = localizedStrings;

// For developer internal use, similar to the stringTest query parameter
window.phet.chipper.setAllStrings = function (str) {
  localizedStrings.forEach(function (localizedString) {
    localizedString.property.value = str;
  });
};
var stringKeyToTandemName = function stringKeyToTandemName(key) {
  return key.replace(/(?:[-_\s]\w)/g, function (word) {
    return word[1].toUpperCase();
  });
};
var StringStateIOType = new _IOType["default"]('StringStateIO', {
  valueType: _PhetioObject["default"],
  toStateObject: function toStateObject() {
    var data = {};
    localizedStrings.forEach(function (localizedString) {
      var state = localizedString.getStateDelta();

      // Only create an entry if there is anything (we can save bytes by not including the tandem here)
      if (Object.keys(state).length > 0) {
        data[localizedString.property.tandem.phetioID] = state;
      }
    });
    return {
      data: data // Data nested for a valid schema
    };
  },
  stateSchema: {
    data: _ObjectLiteralIO["default"]
  },
  applyState: function applyState(ignored, state) {
    // Every string in state has to be in localizedStrings to continue
    Object.keys(state.data).forEach(function (phetioID) {
      var match = localizedStrings.find(function (localizedString) {
        return localizedString.property.tandem.phetioID === phetioID;
      });

      // When PhetioDynamicElementContainer elements such as PhetioGroup members add localizedStrings, we wait until
      // all of the members have been created (populating localizedStrings) before trying to set any of the strings.
      if (!match) {
        throw new _CouldNotYetDeserializeError["default"]();
      }
    });

    // We need to iterate through every string in this runtime, since it might need to revert back to "initial" state.
    localizedStrings.forEach(function (localizedString) {
      localizedString.setStateDelta(state.data[localizedString.property.tandem.phetioID] || {});
    });
  }
});
_PhetioObject["default"].create({
  phetioType: StringStateIOType,
  tandem: _Tandem["default"].GENERAL_MODEL.createTandem('stringsState'),
  phetioDocumentation: 'Strings that have changed from their initial values. Each string value is specific to the locale it changed in.',
  phetioState: true
});
/**
 * @param requirejsNamespace - E.g. 'JOIST', to pull string keys out from that namespace
 * @returns Nested object to be accessed like JoistStrings.ResetAllButton.name
 */
var getStringModule = function getStringModule(requirejsNamespace) {
  // Our string information is pulled globally, e.g. phet.chipper.strings[ locale ][ stringKey ] = stringValue;
  // Our locale information is from phet.chipper.locale

  assert && assert(typeof phet.chipper.locale === 'string', 'phet.chipper.locale should have been loaded by now');
  assert && assert(Object.keys(phet.chipper.localeData).includes(phet.chipper.locale), 'phet.chipper.locale should have been loaded by now');
  assert && assert(phet.chipper.strings, 'phet.chipper.strings should have been loaded by now');

  // Construct locales in increasing specificity, e.g. [ 'en', 'zh', 'zh_CN' ], so we get fallbacks in order
  // const locales = [ FALLBACK_LOCALE ];
  var stringKeyPrefix = "".concat(requirejsNamespace, "/");

  // We may have other older (unused) keys in babel, and we are only doing the search that matters with the English
  // string keys.
  var allStringKeysInRepo = Object.keys(phet.chipper.strings[FALLBACK_LOCALE]).filter(function (stringKey) {
    return stringKey.startsWith(stringKeyPrefix);
  });

  // TODO: https://github.com/phetsims/phet-io/issues/1877 What if this list doesn't exist?  Should that be an error?
  // Or an error if running an api-stable phet-io sim?
  // TODO: https://github.com/phetsims/phet-io/issues/1877 What will happen if this is stale? How will a developer know
  // to update it? Should it run in daily-grunt-work?
  if (phet.chipper.usedStringsEN) {
    allStringKeysInRepo = allStringKeysInRepo.filter(function (stringKey) {
      return phet.chipper.usedStringsEN.hasOwnProperty(stringKey);
    });
  }

  // localizedStringMap[ stringKey ]
  var localizedStringMap = {};
  var stringModule = {};
  allStringKeysInRepo.forEach(function (stringKey) {
    // strip off the requirejsNamespace, e.g. 'JOIST/ResetAllButton.name' => 'ResetAllButton.name'
    var stringKeyWithoutPrefix = stringKey.slice(stringKeyPrefix.length);
    var keyParts = stringKeyWithoutPrefix.split('.');
    var lastKeyPart = keyParts[keyParts.length - 1];
    var allButLastKeyPart = keyParts.slice(0, keyParts.length - 1);

    // During traversal into the string object, this will hold the object where the next level needs to be defined,
    // whether that's another child object, or the string value itself.
    var reference = stringModule;

    // We'll traverse down through the parts of a string key (separated by '.'), creating a new level in the
    // string object for each one. This is done for all BUT the last part, since we'll want to assign the result
    // of that to a raw string value (rather than an object).
    var partialKey = stringKeyPrefix;
    allButLastKeyPart.forEach(function (keyPart, i) {
      // When concatenating each level into the final string key, we don't want to put a '.' directly after the
      // slash, because `JOIST/.ResetAllButton.name` would be invalid.
      // See https://github.com/phetsims/chipper/issues/922
      partialKey += "".concat(i > 0 ? '.' : '').concat(keyPart);

      // Don't allow e.g. JOIST/a and JOIST/a.b, since localeObject.a would need to be a string AND an object at the
      // same time.
      assert && assert(typeof reference[keyPart] !== 'string', 'It is not allowed to have two different string keys where one is extended by adding a period (.) at the end ' + "of the other. The string key ".concat(partialKey, " is extended by ").concat(stringKey, " in this case, and should be changed."));

      // Create the next nested level, and move into it
      if (!reference[keyPart]) {
        reference[keyPart] = {};
      }
      reference = reference[keyPart]; // since we are on all but the last key part, it cannot be stringlike
    });
    assert && assert(_typeof(reference[lastKeyPart]) !== 'object', 'It is not allowed to have two different string keys where one is extended by adding a period (.) at the end ' + "of the other. The string key ".concat(stringKey, " is extended by another key, something containing ").concat(reference[lastKeyPart] && Object.keys(reference[lastKeyPart]), "."));
    assert && assert(!reference[lastKeyPart], "We should not have defined this place in the object (".concat(stringKey, "), otherwise it means a duplicated string key OR extended string key"));

    // In case our assertions are not enabled, we'll need to proceed without failing out (so we allow for the
    // extended string keys in our actual code, even though assertions should prevent that).
    if (typeof reference !== 'string') {
      var tandem = _Tandem["default"].STRINGS.createTandem(_.camelCase(requirejsNamespace));
      for (var i = 0; i < keyParts.length; i++) {
        var tandemName = stringKeyToTandemName(keyParts[i]);

        // If it is the tail of the string key, then make the tandem be a "*StringProperty"
        if (i === keyParts.length - 1) {
          var currentTandemName = tandemName;
          var j = 0;
          var tandemNameTaken = true;

          // Handle the case where two unique string keys map to the same camel case value, i.e. "Solid" and "solid".
          // Here we will be solidStringProperty and solid2StringProperty
          while (tandemNameTaken) {
            j++;
            currentTandemName = "".concat(tandemName).concat(j === 1 ? '' : j, "StringProperty");
            tandemNameTaken = tandem.hasChild(currentTandemName);
          }
          tandemName = currentTandemName;
        }
        tandem = tandem.createTandem(tandemName);
      }

      // strings nested under the a11y section are not currently PhET-iO instrumented, see https://github.com/phetsims/chipper/issues/1352
      if (tandem.phetioID.includes('.a11y.')) {
        tandem = _Tandem["default"].OPT_OUT;
      }
      var localeToTranslationMap = {};
      Object.keys(phet.chipper.strings).forEach(function (locale) {
        var string = phet.chipper.strings[locale][stringKey];
        // Ignore zero-length strings, see https://github.com/phetsims/chipper/issues/1343
        if (locale === FALLBACK_LOCALE || typeof string === 'string' && string !== '') {
          localeToTranslationMap[locale] = phet.chipper.mapString(string);
        }
      });
      var localizedString = new _LocalizedString["default"](stringKey, localeToTranslationMap, tandem, phet.chipper.stringMetadata[stringKey]);
      localizedStringMap[stringKey] = localizedString;

      // Put our Property in the stringModule
      reference["".concat(lastKeyPart, "StringProperty")] = localizedString.property;

      // Change our stringModule based on the Property value
      localizedString.property.link(function (string) {
        reference[lastKeyPart] = string;
      });
    }
  });
  return stringModule;
};
var _default = exports["default"] = getStringModule;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfUGhldGlvT2JqZWN0IiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsInJlcXVpcmUiLCJfVGFuZGVtIiwiX0NvdWxkTm90WWV0RGVzZXJpYWxpemVFcnJvciIsIl9JT1R5cGUiLCJfT2JqZWN0TGl0ZXJhbElPIiwiX0xvY2FsaXplZFN0cmluZyIsIm9iaiIsIl9fZXNNb2R1bGUiLCJfdHlwZW9mIiwibyIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJGQUxMQkFDS19MT0NBTEUiLCJsb2NhbGl6ZWRTdHJpbmdzIiwiZXhwb3J0cyIsIndpbmRvdyIsInBoZXQiLCJjaGlwcGVyIiwic2V0QWxsU3RyaW5ncyIsInN0ciIsImZvckVhY2giLCJsb2NhbGl6ZWRTdHJpbmciLCJwcm9wZXJ0eSIsInZhbHVlIiwic3RyaW5nS2V5VG9UYW5kZW1OYW1lIiwia2V5IiwicmVwbGFjZSIsIndvcmQiLCJ0b1VwcGVyQ2FzZSIsIlN0cmluZ1N0YXRlSU9UeXBlIiwiSU9UeXBlIiwidmFsdWVUeXBlIiwiUGhldGlvT2JqZWN0IiwidG9TdGF0ZU9iamVjdCIsImRhdGEiLCJzdGF0ZSIsImdldFN0YXRlRGVsdGEiLCJPYmplY3QiLCJrZXlzIiwibGVuZ3RoIiwidGFuZGVtIiwicGhldGlvSUQiLCJzdGF0ZVNjaGVtYSIsIk9iamVjdExpdGVyYWxJTyIsImFwcGx5U3RhdGUiLCJpZ25vcmVkIiwibWF0Y2giLCJmaW5kIiwiQ291bGROb3RZZXREZXNlcmlhbGl6ZUVycm9yIiwic2V0U3RhdGVEZWx0YSIsImNyZWF0ZSIsInBoZXRpb1R5cGUiLCJUYW5kZW0iLCJHRU5FUkFMX01PREVMIiwiY3JlYXRlVGFuZGVtIiwicGhldGlvRG9jdW1lbnRhdGlvbiIsInBoZXRpb1N0YXRlIiwiZ2V0U3RyaW5nTW9kdWxlIiwicmVxdWlyZWpzTmFtZXNwYWNlIiwiYXNzZXJ0IiwibG9jYWxlIiwibG9jYWxlRGF0YSIsImluY2x1ZGVzIiwic3RyaW5ncyIsInN0cmluZ0tleVByZWZpeCIsImNvbmNhdCIsImFsbFN0cmluZ0tleXNJblJlcG8iLCJmaWx0ZXIiLCJzdHJpbmdLZXkiLCJzdGFydHNXaXRoIiwidXNlZFN0cmluZ3NFTiIsImhhc093blByb3BlcnR5IiwibG9jYWxpemVkU3RyaW5nTWFwIiwic3RyaW5nTW9kdWxlIiwic3RyaW5nS2V5V2l0aG91dFByZWZpeCIsInNsaWNlIiwia2V5UGFydHMiLCJzcGxpdCIsImxhc3RLZXlQYXJ0IiwiYWxsQnV0TGFzdEtleVBhcnQiLCJyZWZlcmVuY2UiLCJwYXJ0aWFsS2V5Iiwia2V5UGFydCIsImkiLCJTVFJJTkdTIiwiXyIsImNhbWVsQ2FzZSIsInRhbmRlbU5hbWUiLCJjdXJyZW50VGFuZGVtTmFtZSIsImoiLCJ0YW5kZW1OYW1lVGFrZW4iLCJoYXNDaGlsZCIsIk9QVF9PVVQiLCJsb2NhbGVUb1RyYW5zbGF0aW9uTWFwIiwic3RyaW5nIiwibWFwU3RyaW5nIiwiTG9jYWxpemVkU3RyaW5nIiwic3RyaW5nTWV0YWRhdGEiLCJsaW5rIiwiX2RlZmF1bHQiXSwic291cmNlcyI6WyJnZXRTdHJpbmdNb2R1bGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMjAtMjAyNCwgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXHJcblxyXG4vKipcclxuICogR2l2ZW4gYSByZXF1aXJlanNOYW1lc3BhY2UsIHdlIGZpbHRlciBvdXQgc3RyaW5ncyBmcm9tIHBoZXQuY2hpcHBlci5zdHJpbmdzIHRoYXQgc3RhcnQgd2l0aCBpdCwgYW5kIGNvbnN0cnVjdCBhblxyXG4gKiBvYmplY3Qgd2l0aCBsb2NhbGUgZmFsbGJhY2tzIGFscmVhZHkgcHJlLWNvbXB1dGVkLCBzbyB0aGF0IHRoZSBjb3JyZWN0IHN0cmluZ3MgY2FuIGJlIGFjY2Vzc2VkIHZpYSBvYmplY3QgbGl0ZXJhbFxyXG4gKiBhY2Nlc3MsIGUuZy4gZ2V0U3RyaW5nTW9kdWxlKCAnSk9JU1QnICkuUmVzZXRBbGxCdXR0b24ubmFtZSB3aWxsIGdpdmUgdGhlIGRlc2lyZWQgc3RyaW5nIHZhbHVlIGZvciB3aGF0ZXZlciBsb2NhbGVcclxuICogdGhlIHNpbSBpcyBiZWluZyBydW4gd2l0aC5cclxuICpcclxuICogQSBzdHJpbmcgXCJrZXlcIiBpcyBpbiB0aGUgZm9ybSBvZiBcIk5BTUVTUEFDRS9rZXkuZnJvbS5zdHJpbmdzLmpzb25cIlxyXG4gKlxyXG4gKiBOT1RFOiBUaGlzIGZpbGUgbGlrZWx5IGJlbG9uZ3MgaW4gam9pc3QvanMvaTE4bi8sIGJ1dCBzaG91bGQgc3RheSBoZXJlIHRvIG1ha2UgbWFpbnRlbmFuY2UtcmVsZWFzZSBtYWludGFpbmFiaWxpdHkgZWFzaWVyLlxyXG4gKlxyXG4gKiBAYXV0aG9yIEpvbmF0aGFuIE9sc29uIDxqb25hdGhhbi5vbHNvbj5cclxuICovXHJcblxyXG5pbXBvcnQgUGhldGlvT2JqZWN0IGZyb20gJy4uLy4uL3RhbmRlbS9qcy9QaGV0aW9PYmplY3QuanMnO1xyXG5pbXBvcnQgVGFuZGVtIGZyb20gJy4uLy4uL3RhbmRlbS9qcy9UYW5kZW0uanMnO1xyXG5pbXBvcnQgQ291bGROb3RZZXREZXNlcmlhbGl6ZUVycm9yIGZyb20gJy4uLy4uL3RhbmRlbS9qcy9Db3VsZE5vdFlldERlc2VyaWFsaXplRXJyb3IuanMnO1xyXG5pbXBvcnQgSU9UeXBlIGZyb20gJy4uLy4uL3RhbmRlbS9qcy90eXBlcy9JT1R5cGUuanMnO1xyXG5pbXBvcnQgT2JqZWN0TGl0ZXJhbElPIGZyb20gJy4uLy4uL3RhbmRlbS9qcy90eXBlcy9PYmplY3RMaXRlcmFsSU8uanMnO1xyXG5pbXBvcnQgTG9jYWxpemVkU3RyaW5nLCB7IExvY2FsaXplZFN0cmluZ1N0YXRlRGVsdGEsIFN0cmluZ3NTdGF0ZVN0YXRlT2JqZWN0IH0gZnJvbSAnLi9Mb2NhbGl6ZWRTdHJpbmcuanMnO1xyXG5pbXBvcnQgVFJlYWRPbmx5UHJvcGVydHkgZnJvbSAnLi4vLi4vYXhvbi9qcy9UUmVhZE9ubHlQcm9wZXJ0eS5qcyc7XHJcbmltcG9ydCB7IExvY2FsZSB9IGZyb20gJy4uLy4uL2pvaXN0L2pzL2kxOG4vbG9jYWxlUHJvcGVydHkuanMnO1xyXG5pbXBvcnQgeyBQaGV0aW9JRCB9IGZyb20gJy4uLy4uL3RhbmRlbS9qcy9UYW5kZW1Db25zdGFudHMuanMnO1xyXG5cclxuLy8gY29uc3RhbnRzXHJcbmNvbnN0IEZBTExCQUNLX0xPQ0FMRSA9ICdlbic7XHJcblxyXG4vLyBIb2xkcyBhbGwgb2Ygb3VyIGxvY2FsaXplZFN0cmluZ3MsIHNvIHRoYXQgd2UgY2FuIHNhdmUgb3VyIHBoZXQtaW8gc3RyaW5nIGNoYW5nZSBzdGF0ZVxyXG5leHBvcnQgY29uc3QgbG9jYWxpemVkU3RyaW5nczogTG9jYWxpemVkU3RyaW5nW10gPSBbXTtcclxuXHJcbi8vIEZvciBkZXZlbG9wZXIgaW50ZXJuYWwgdXNlLCBwYXJ0aWN1bGFybHkgZm9yIG1lbW9yeSBsZWFrIGRldGVjdGlvblxyXG4vLyBlLmcuIF8ubWF4KCBwaGV0LmNoaXBwZXIubG9jYWxpemVkU3RyaW5ncy5tYXAoIGxzID0+IGxzLnByb3BlcnR5LnRpbnlQcm9wZXJ0eS5saXN0ZW5lcnMuc2l6ZSApICkgdG8gc2VlIGlmIHRoZXJlIGlzXHJcbi8vIGxpa2VseSBhIGxlYWtcclxud2luZG93LnBoZXQuY2hpcHBlci5sb2NhbGl6ZWRTdHJpbmdzID0gbG9jYWxpemVkU3RyaW5ncztcclxuXHJcbi8vIEZvciBkZXZlbG9wZXIgaW50ZXJuYWwgdXNlLCBzaW1pbGFyIHRvIHRoZSBzdHJpbmdUZXN0IHF1ZXJ5IHBhcmFtZXRlclxyXG53aW5kb3cucGhldC5jaGlwcGVyLnNldEFsbFN0cmluZ3MgPSAoIHN0cjogc3RyaW5nICkgPT4ge1xyXG4gIGxvY2FsaXplZFN0cmluZ3MuZm9yRWFjaCggbG9jYWxpemVkU3RyaW5nID0+IHtcclxuICAgIGxvY2FsaXplZFN0cmluZy5wcm9wZXJ0eS52YWx1ZSA9IHN0cjtcclxuICB9ICk7XHJcbn07XHJcblxyXG5jb25zdCBzdHJpbmdLZXlUb1RhbmRlbU5hbWUgPSAoIGtleTogc3RyaW5nICkgPT4ge1xyXG4gIHJldHVybiBrZXkucmVwbGFjZSggLyg/OlstX1xcc11cXHcpL2csIHdvcmQgPT4gd29yZFsgMSBdLnRvVXBwZXJDYXNlKCkgKTtcclxufTtcclxuXHJcbmNvbnN0IFN0cmluZ1N0YXRlSU9UeXBlID0gbmV3IElPVHlwZTxQaGV0aW9PYmplY3QsIFN0cmluZ3NTdGF0ZVN0YXRlT2JqZWN0PiggJ1N0cmluZ1N0YXRlSU8nLCB7XHJcbiAgdmFsdWVUeXBlOiBQaGV0aW9PYmplY3QsXHJcbiAgdG9TdGF0ZU9iamVjdDogKCk6IFN0cmluZ3NTdGF0ZVN0YXRlT2JqZWN0ID0+IHtcclxuICAgIGNvbnN0IGRhdGE6IFJlY29yZDxQaGV0aW9JRCwgTG9jYWxpemVkU3RyaW5nU3RhdGVEZWx0YT4gPSB7fTtcclxuXHJcbiAgICBsb2NhbGl6ZWRTdHJpbmdzLmZvckVhY2goIGxvY2FsaXplZFN0cmluZyA9PiB7XHJcbiAgICAgIGNvbnN0IHN0YXRlID0gbG9jYWxpemVkU3RyaW5nLmdldFN0YXRlRGVsdGEoKTtcclxuXHJcbiAgICAgIC8vIE9ubHkgY3JlYXRlIGFuIGVudHJ5IGlmIHRoZXJlIGlzIGFueXRoaW5nICh3ZSBjYW4gc2F2ZSBieXRlcyBieSBub3QgaW5jbHVkaW5nIHRoZSB0YW5kZW0gaGVyZSlcclxuICAgICAgaWYgKCBPYmplY3Qua2V5cyggc3RhdGUgKS5sZW5ndGggPiAwICkge1xyXG4gICAgICAgIGRhdGFbIGxvY2FsaXplZFN0cmluZy5wcm9wZXJ0eS50YW5kZW0ucGhldGlvSUQgXSA9IHN0YXRlO1xyXG4gICAgICB9XHJcbiAgICB9ICk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBkYXRhOiBkYXRhIC8vIERhdGEgbmVzdGVkIGZvciBhIHZhbGlkIHNjaGVtYVxyXG4gICAgfTtcclxuICB9LFxyXG4gIHN0YXRlU2NoZW1hOiB7XHJcbiAgICBkYXRhOiBPYmplY3RMaXRlcmFsSU9cclxuICB9LFxyXG4gIGFwcGx5U3RhdGU6ICggaWdub3JlZCwgc3RhdGUgKSA9PiB7XHJcblxyXG4gICAgLy8gRXZlcnkgc3RyaW5nIGluIHN0YXRlIGhhcyB0byBiZSBpbiBsb2NhbGl6ZWRTdHJpbmdzIHRvIGNvbnRpbnVlXHJcbiAgICBPYmplY3Qua2V5cyggc3RhdGUuZGF0YSApLmZvckVhY2goIHBoZXRpb0lEID0+IHtcclxuICAgICAgY29uc3QgbWF0Y2ggPSBsb2NhbGl6ZWRTdHJpbmdzLmZpbmQoIGxvY2FsaXplZFN0cmluZyA9PiBsb2NhbGl6ZWRTdHJpbmcucHJvcGVydHkudGFuZGVtLnBoZXRpb0lEID09PSBwaGV0aW9JRCApO1xyXG5cclxuICAgICAgLy8gV2hlbiBQaGV0aW9EeW5hbWljRWxlbWVudENvbnRhaW5lciBlbGVtZW50cyBzdWNoIGFzIFBoZXRpb0dyb3VwIG1lbWJlcnMgYWRkIGxvY2FsaXplZFN0cmluZ3MsIHdlIHdhaXQgdW50aWxcclxuICAgICAgLy8gYWxsIG9mIHRoZSBtZW1iZXJzIGhhdmUgYmVlbiBjcmVhdGVkIChwb3B1bGF0aW5nIGxvY2FsaXplZFN0cmluZ3MpIGJlZm9yZSB0cnlpbmcgdG8gc2V0IGFueSBvZiB0aGUgc3RyaW5ncy5cclxuICAgICAgaWYgKCAhbWF0Y2ggKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IENvdWxkTm90WWV0RGVzZXJpYWxpemVFcnJvcigpO1xyXG4gICAgICB9XHJcbiAgICB9ICk7XHJcblxyXG4gICAgLy8gV2UgbmVlZCB0byBpdGVyYXRlIHRocm91Z2ggZXZlcnkgc3RyaW5nIGluIHRoaXMgcnVudGltZSwgc2luY2UgaXQgbWlnaHQgbmVlZCB0byByZXZlcnQgYmFjayB0byBcImluaXRpYWxcIiBzdGF0ZS5cclxuICAgIGxvY2FsaXplZFN0cmluZ3MuZm9yRWFjaCggbG9jYWxpemVkU3RyaW5nID0+IHtcclxuICAgICAgbG9jYWxpemVkU3RyaW5nLnNldFN0YXRlRGVsdGEoIHN0YXRlLmRhdGFbIGxvY2FsaXplZFN0cmluZy5wcm9wZXJ0eS50YW5kZW0ucGhldGlvSUQgXSB8fCB7fSApO1xyXG4gICAgfSApO1xyXG4gIH1cclxufSApO1xyXG5cclxuUGhldGlvT2JqZWN0LmNyZWF0ZSgge1xyXG4gIHBoZXRpb1R5cGU6IFN0cmluZ1N0YXRlSU9UeXBlLFxyXG4gIHRhbmRlbTogVGFuZGVtLkdFTkVSQUxfTU9ERUwuY3JlYXRlVGFuZGVtKCAnc3RyaW5nc1N0YXRlJyApLFxyXG4gIHBoZXRpb0RvY3VtZW50YXRpb246ICdTdHJpbmdzIHRoYXQgaGF2ZSBjaGFuZ2VkIGZyb20gdGhlaXIgaW5pdGlhbCB2YWx1ZXMuIEVhY2ggc3RyaW5nIHZhbHVlIGlzIHNwZWNpZmljIHRvIHRoZSBsb2NhbGUgaXQgY2hhbmdlZCBpbi4nLFxyXG4gIHBoZXRpb1N0YXRlOiB0cnVlXHJcbn0gKTtcclxuXHJcbnR5cGUgVFN0cmluZ01vZHVsZSA9IHtcclxuICBbIGtleTogc3RyaW5nIF06IFRTdHJpbmdNb2R1bGUgfCBzdHJpbmcgfCBUUmVhZE9ubHlQcm9wZXJ0eTxzdHJpbmc+O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSByZXF1aXJlanNOYW1lc3BhY2UgLSBFLmcuICdKT0lTVCcsIHRvIHB1bGwgc3RyaW5nIGtleXMgb3V0IGZyb20gdGhhdCBuYW1lc3BhY2VcclxuICogQHJldHVybnMgTmVzdGVkIG9iamVjdCB0byBiZSBhY2Nlc3NlZCBsaWtlIEpvaXN0U3RyaW5ncy5SZXNldEFsbEJ1dHRvbi5uYW1lXHJcbiAqL1xyXG5jb25zdCBnZXRTdHJpbmdNb2R1bGUgPSAoIHJlcXVpcmVqc05hbWVzcGFjZTogc3RyaW5nICk6IG9iamVjdCA9PiB7XHJcbiAgLy8gT3VyIHN0cmluZyBpbmZvcm1hdGlvbiBpcyBwdWxsZWQgZ2xvYmFsbHksIGUuZy4gcGhldC5jaGlwcGVyLnN0cmluZ3NbIGxvY2FsZSBdWyBzdHJpbmdLZXkgXSA9IHN0cmluZ1ZhbHVlO1xyXG4gIC8vIE91ciBsb2NhbGUgaW5mb3JtYXRpb24gaXMgZnJvbSBwaGV0LmNoaXBwZXIubG9jYWxlXHJcblxyXG4gIGFzc2VydCAmJiBhc3NlcnQoIHR5cGVvZiBwaGV0LmNoaXBwZXIubG9jYWxlID09PSAnc3RyaW5nJywgJ3BoZXQuY2hpcHBlci5sb2NhbGUgc2hvdWxkIGhhdmUgYmVlbiBsb2FkZWQgYnkgbm93JyApO1xyXG4gIGFzc2VydCAmJiBhc3NlcnQoIE9iamVjdC5rZXlzKCBwaGV0LmNoaXBwZXIubG9jYWxlRGF0YSApLmluY2x1ZGVzKCBwaGV0LmNoaXBwZXIubG9jYWxlICksICdwaGV0LmNoaXBwZXIubG9jYWxlIHNob3VsZCBoYXZlIGJlZW4gbG9hZGVkIGJ5IG5vdycgKTtcclxuICBhc3NlcnQgJiYgYXNzZXJ0KCBwaGV0LmNoaXBwZXIuc3RyaW5ncywgJ3BoZXQuY2hpcHBlci5zdHJpbmdzIHNob3VsZCBoYXZlIGJlZW4gbG9hZGVkIGJ5IG5vdycgKTtcclxuXHJcbiAgLy8gQ29uc3RydWN0IGxvY2FsZXMgaW4gaW5jcmVhc2luZyBzcGVjaWZpY2l0eSwgZS5nLiBbICdlbicsICd6aCcsICd6aF9DTicgXSwgc28gd2UgZ2V0IGZhbGxiYWNrcyBpbiBvcmRlclxyXG4gIC8vIGNvbnN0IGxvY2FsZXMgPSBbIEZBTExCQUNLX0xPQ0FMRSBdO1xyXG4gIGNvbnN0IHN0cmluZ0tleVByZWZpeCA9IGAke3JlcXVpcmVqc05hbWVzcGFjZX0vYDtcclxuXHJcbiAgLy8gV2UgbWF5IGhhdmUgb3RoZXIgb2xkZXIgKHVudXNlZCkga2V5cyBpbiBiYWJlbCwgYW5kIHdlIGFyZSBvbmx5IGRvaW5nIHRoZSBzZWFyY2ggdGhhdCBtYXR0ZXJzIHdpdGggdGhlIEVuZ2xpc2hcclxuICAvLyBzdHJpbmcga2V5cy5cclxuICBsZXQgYWxsU3RyaW5nS2V5c0luUmVwbyA9IE9iamVjdC5rZXlzKCBwaGV0LmNoaXBwZXIuc3RyaW5nc1sgRkFMTEJBQ0tfTE9DQUxFIF0gKS5maWx0ZXIoIHN0cmluZ0tleSA9PiBzdHJpbmdLZXkuc3RhcnRzV2l0aCggc3RyaW5nS2V5UHJlZml4ICkgKTtcclxuXHJcbiAgLy8gVE9ETzogaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL3BoZXQtaW8vaXNzdWVzLzE4NzcgV2hhdCBpZiB0aGlzIGxpc3QgZG9lc24ndCBleGlzdD8gIFNob3VsZCB0aGF0IGJlIGFuIGVycm9yP1xyXG4gIC8vIE9yIGFuIGVycm9yIGlmIHJ1bm5pbmcgYW4gYXBpLXN0YWJsZSBwaGV0LWlvIHNpbT9cclxuICAvLyBUT0RPOiBodHRwczovL2dpdGh1Yi5jb20vcGhldHNpbXMvcGhldC1pby9pc3N1ZXMvMTg3NyBXaGF0IHdpbGwgaGFwcGVuIGlmIHRoaXMgaXMgc3RhbGU/IEhvdyB3aWxsIGEgZGV2ZWxvcGVyIGtub3dcclxuICAvLyB0byB1cGRhdGUgaXQ/IFNob3VsZCBpdCBydW4gaW4gZGFpbHktZ3J1bnQtd29yaz9cclxuICBpZiAoIHBoZXQuY2hpcHBlci51c2VkU3RyaW5nc0VOICkge1xyXG4gICAgYWxsU3RyaW5nS2V5c0luUmVwbyA9IGFsbFN0cmluZ0tleXNJblJlcG8uZmlsdGVyKCBzdHJpbmdLZXkgPT4gcGhldC5jaGlwcGVyLnVzZWRTdHJpbmdzRU4uaGFzT3duUHJvcGVydHkoIHN0cmluZ0tleSApICk7XHJcbiAgfVxyXG5cclxuICAvLyBsb2NhbGl6ZWRTdHJpbmdNYXBbIHN0cmluZ0tleSBdXHJcbiAgY29uc3QgbG9jYWxpemVkU3RyaW5nTWFwOiBSZWNvcmQ8c3RyaW5nLCBMb2NhbGl6ZWRTdHJpbmc+ID0ge307XHJcblxyXG4gIGNvbnN0IHN0cmluZ01vZHVsZTogVFN0cmluZ01vZHVsZSA9IHt9O1xyXG5cclxuICBhbGxTdHJpbmdLZXlzSW5SZXBvLmZvckVhY2goIHN0cmluZ0tleSA9PiB7XHJcbiAgICAvLyBzdHJpcCBvZmYgdGhlIHJlcXVpcmVqc05hbWVzcGFjZSwgZS5nLiAnSk9JU1QvUmVzZXRBbGxCdXR0b24ubmFtZScgPT4gJ1Jlc2V0QWxsQnV0dG9uLm5hbWUnXHJcbiAgICBjb25zdCBzdHJpbmdLZXlXaXRob3V0UHJlZml4ID0gc3RyaW5nS2V5LnNsaWNlKCBzdHJpbmdLZXlQcmVmaXgubGVuZ3RoICk7XHJcblxyXG4gICAgY29uc3Qga2V5UGFydHMgPSBzdHJpbmdLZXlXaXRob3V0UHJlZml4LnNwbGl0KCAnLicgKTtcclxuICAgIGNvbnN0IGxhc3RLZXlQYXJ0ID0ga2V5UGFydHNbIGtleVBhcnRzLmxlbmd0aCAtIDEgXTtcclxuICAgIGNvbnN0IGFsbEJ1dExhc3RLZXlQYXJ0ID0ga2V5UGFydHMuc2xpY2UoIDAsIGtleVBhcnRzLmxlbmd0aCAtIDEgKTtcclxuXHJcbiAgICAvLyBEdXJpbmcgdHJhdmVyc2FsIGludG8gdGhlIHN0cmluZyBvYmplY3QsIHRoaXMgd2lsbCBob2xkIHRoZSBvYmplY3Qgd2hlcmUgdGhlIG5leHQgbGV2ZWwgbmVlZHMgdG8gYmUgZGVmaW5lZCxcclxuICAgIC8vIHdoZXRoZXIgdGhhdCdzIGFub3RoZXIgY2hpbGQgb2JqZWN0LCBvciB0aGUgc3RyaW5nIHZhbHVlIGl0c2VsZi5cclxuICAgIGxldCByZWZlcmVuY2U6IFRTdHJpbmdNb2R1bGUgPSBzdHJpbmdNb2R1bGU7XHJcblxyXG4gICAgLy8gV2UnbGwgdHJhdmVyc2UgZG93biB0aHJvdWdoIHRoZSBwYXJ0cyBvZiBhIHN0cmluZyBrZXkgKHNlcGFyYXRlZCBieSAnLicpLCBjcmVhdGluZyBhIG5ldyBsZXZlbCBpbiB0aGVcclxuICAgIC8vIHN0cmluZyBvYmplY3QgZm9yIGVhY2ggb25lLiBUaGlzIGlzIGRvbmUgZm9yIGFsbCBCVVQgdGhlIGxhc3QgcGFydCwgc2luY2Ugd2UnbGwgd2FudCB0byBhc3NpZ24gdGhlIHJlc3VsdFxyXG4gICAgLy8gb2YgdGhhdCB0byBhIHJhdyBzdHJpbmcgdmFsdWUgKHJhdGhlciB0aGFuIGFuIG9iamVjdCkuXHJcbiAgICBsZXQgcGFydGlhbEtleSA9IHN0cmluZ0tleVByZWZpeDtcclxuICAgIGFsbEJ1dExhc3RLZXlQYXJ0LmZvckVhY2goICgga2V5UGFydCwgaSApID0+IHtcclxuICAgICAgLy8gV2hlbiBjb25jYXRlbmF0aW5nIGVhY2ggbGV2ZWwgaW50byB0aGUgZmluYWwgc3RyaW5nIGtleSwgd2UgZG9uJ3Qgd2FudCB0byBwdXQgYSAnLicgZGlyZWN0bHkgYWZ0ZXIgdGhlXHJcbiAgICAgIC8vIHNsYXNoLCBiZWNhdXNlIGBKT0lTVC8uUmVzZXRBbGxCdXR0b24ubmFtZWAgd291bGQgYmUgaW52YWxpZC5cclxuICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waGV0c2ltcy9jaGlwcGVyL2lzc3Vlcy85MjJcclxuICAgICAgcGFydGlhbEtleSArPSBgJHtpID4gMCA/ICcuJyA6ICcnfSR7a2V5UGFydH1gO1xyXG5cclxuICAgICAgLy8gRG9uJ3QgYWxsb3cgZS5nLiBKT0lTVC9hIGFuZCBKT0lTVC9hLmIsIHNpbmNlIGxvY2FsZU9iamVjdC5hIHdvdWxkIG5lZWQgdG8gYmUgYSBzdHJpbmcgQU5EIGFuIG9iamVjdCBhdCB0aGVcclxuICAgICAgLy8gc2FtZSB0aW1lLlxyXG4gICAgICBhc3NlcnQgJiYgYXNzZXJ0KCB0eXBlb2YgcmVmZXJlbmNlWyBrZXlQYXJ0IF0gIT09ICdzdHJpbmcnLFxyXG4gICAgICAgICdJdCBpcyBub3QgYWxsb3dlZCB0byBoYXZlIHR3byBkaWZmZXJlbnQgc3RyaW5nIGtleXMgd2hlcmUgb25lIGlzIGV4dGVuZGVkIGJ5IGFkZGluZyBhIHBlcmlvZCAoLikgYXQgdGhlIGVuZCAnICtcclxuICAgICAgICBgb2YgdGhlIG90aGVyLiBUaGUgc3RyaW5nIGtleSAke3BhcnRpYWxLZXl9IGlzIGV4dGVuZGVkIGJ5ICR7c3RyaW5nS2V5fSBpbiB0aGlzIGNhc2UsIGFuZCBzaG91bGQgYmUgY2hhbmdlZC5gICk7XHJcblxyXG4gICAgICAvLyBDcmVhdGUgdGhlIG5leHQgbmVzdGVkIGxldmVsLCBhbmQgbW92ZSBpbnRvIGl0XHJcbiAgICAgIGlmICggIXJlZmVyZW5jZVsga2V5UGFydCBdICkge1xyXG4gICAgICAgIHJlZmVyZW5jZVsga2V5UGFydCBdID0ge307XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJlZmVyZW5jZSA9IHJlZmVyZW5jZVsga2V5UGFydCBdIGFzIFRTdHJpbmdNb2R1bGU7IC8vIHNpbmNlIHdlIGFyZSBvbiBhbGwgYnV0IHRoZSBsYXN0IGtleSBwYXJ0LCBpdCBjYW5ub3QgYmUgc3RyaW5nbGlrZVxyXG4gICAgfSApO1xyXG5cclxuICAgIGFzc2VydCAmJiBhc3NlcnQoIHR5cGVvZiByZWZlcmVuY2VbIGxhc3RLZXlQYXJ0IF0gIT09ICdvYmplY3QnLFxyXG4gICAgICAnSXQgaXMgbm90IGFsbG93ZWQgdG8gaGF2ZSB0d28gZGlmZmVyZW50IHN0cmluZyBrZXlzIHdoZXJlIG9uZSBpcyBleHRlbmRlZCBieSBhZGRpbmcgYSBwZXJpb2QgKC4pIGF0IHRoZSBlbmQgJyArXHJcbiAgICAgIGBvZiB0aGUgb3RoZXIuIFRoZSBzdHJpbmcga2V5ICR7c3RyaW5nS2V5fSBpcyBleHRlbmRlZCBieSBhbm90aGVyIGtleSwgc29tZXRoaW5nIGNvbnRhaW5pbmcgJHtyZWZlcmVuY2VbIGxhc3RLZXlQYXJ0IF0gJiYgT2JqZWN0LmtleXMoIHJlZmVyZW5jZVsgbGFzdEtleVBhcnQgXSApfS5gICk7XHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCAhcmVmZXJlbmNlWyBsYXN0S2V5UGFydCBdLFxyXG4gICAgICBgV2Ugc2hvdWxkIG5vdCBoYXZlIGRlZmluZWQgdGhpcyBwbGFjZSBpbiB0aGUgb2JqZWN0ICgke3N0cmluZ0tleX0pLCBvdGhlcndpc2UgaXQgbWVhbnMgYSBkdXBsaWNhdGVkIHN0cmluZyBrZXkgT1IgZXh0ZW5kZWQgc3RyaW5nIGtleWAgKTtcclxuXHJcbiAgICAvLyBJbiBjYXNlIG91ciBhc3NlcnRpb25zIGFyZSBub3QgZW5hYmxlZCwgd2UnbGwgbmVlZCB0byBwcm9jZWVkIHdpdGhvdXQgZmFpbGluZyBvdXQgKHNvIHdlIGFsbG93IGZvciB0aGVcclxuICAgIC8vIGV4dGVuZGVkIHN0cmluZyBrZXlzIGluIG91ciBhY3R1YWwgY29kZSwgZXZlbiB0aG91Z2ggYXNzZXJ0aW9ucyBzaG91bGQgcHJldmVudCB0aGF0KS5cclxuICAgIGlmICggdHlwZW9mIHJlZmVyZW5jZSAhPT0gJ3N0cmluZycgKSB7XHJcbiAgICAgIGxldCB0YW5kZW0gPSBUYW5kZW0uU1RSSU5HUy5jcmVhdGVUYW5kZW0oIF8uY2FtZWxDYXNlKCByZXF1aXJlanNOYW1lc3BhY2UgKSApO1xyXG4gICAgICBmb3IgKCBsZXQgaSA9IDA7IGkgPCBrZXlQYXJ0cy5sZW5ndGg7IGkrKyApIHtcclxuXHJcbiAgICAgICAgbGV0IHRhbmRlbU5hbWUgPSBzdHJpbmdLZXlUb1RhbmRlbU5hbWUoIGtleVBhcnRzWyBpIF0gKTtcclxuXHJcbiAgICAgICAgLy8gSWYgaXQgaXMgdGhlIHRhaWwgb2YgdGhlIHN0cmluZyBrZXksIHRoZW4gbWFrZSB0aGUgdGFuZGVtIGJlIGEgXCIqU3RyaW5nUHJvcGVydHlcIlxyXG4gICAgICAgIGlmICggaSA9PT0ga2V5UGFydHMubGVuZ3RoIC0gMSApIHtcclxuXHJcbiAgICAgICAgICBsZXQgY3VycmVudFRhbmRlbU5hbWUgPSB0YW5kZW1OYW1lO1xyXG4gICAgICAgICAgbGV0IGogPSAwO1xyXG4gICAgICAgICAgbGV0IHRhbmRlbU5hbWVUYWtlbiA9IHRydWU7XHJcblxyXG4gICAgICAgICAgLy8gSGFuZGxlIHRoZSBjYXNlIHdoZXJlIHR3byB1bmlxdWUgc3RyaW5nIGtleXMgbWFwIHRvIHRoZSBzYW1lIGNhbWVsIGNhc2UgdmFsdWUsIGkuZS4gXCJTb2xpZFwiIGFuZCBcInNvbGlkXCIuXHJcbiAgICAgICAgICAvLyBIZXJlIHdlIHdpbGwgYmUgc29saWRTdHJpbmdQcm9wZXJ0eSBhbmQgc29saWQyU3RyaW5nUHJvcGVydHlcclxuICAgICAgICAgIHdoaWxlICggdGFuZGVtTmFtZVRha2VuICkge1xyXG4gICAgICAgICAgICBqKys7XHJcblxyXG4gICAgICAgICAgICBjdXJyZW50VGFuZGVtTmFtZSA9IGAke3RhbmRlbU5hbWV9JHtqID09PSAxID8gJycgOiBqfVN0cmluZ1Byb3BlcnR5YDtcclxuXHJcbiAgICAgICAgICAgIHRhbmRlbU5hbWVUYWtlbiA9IHRhbmRlbS5oYXNDaGlsZCggY3VycmVudFRhbmRlbU5hbWUgKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHRhbmRlbU5hbWUgPSBjdXJyZW50VGFuZGVtTmFtZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRhbmRlbSA9IHRhbmRlbS5jcmVhdGVUYW5kZW0oIHRhbmRlbU5hbWUgKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gc3RyaW5ncyBuZXN0ZWQgdW5kZXIgdGhlIGExMXkgc2VjdGlvbiBhcmUgbm90IGN1cnJlbnRseSBQaEVULWlPIGluc3RydW1lbnRlZCwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waGV0c2ltcy9jaGlwcGVyL2lzc3Vlcy8xMzUyXHJcbiAgICAgIGlmICggdGFuZGVtLnBoZXRpb0lELmluY2x1ZGVzKCAnLmExMXkuJyApICkge1xyXG4gICAgICAgIHRhbmRlbSA9IFRhbmRlbS5PUFRfT1VUO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBsb2NhbGVUb1RyYW5zbGF0aW9uTWFwOiBMb2NhbGl6ZWRTdHJpbmdTdGF0ZURlbHRhID0ge307XHJcbiAgICAgICggT2JqZWN0LmtleXMoIHBoZXQuY2hpcHBlci5zdHJpbmdzICkgYXMgTG9jYWxlW10gKS5mb3JFYWNoKCAoIGxvY2FsZTogTG9jYWxlICkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHN0cmluZzogc3RyaW5nID0gcGhldC5jaGlwcGVyLnN0cmluZ3NbIGxvY2FsZSBdWyBzdHJpbmdLZXkgXTtcclxuICAgICAgICAvLyBJZ25vcmUgemVyby1sZW5ndGggc3RyaW5ncywgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waGV0c2ltcy9jaGlwcGVyL2lzc3Vlcy8xMzQzXHJcbiAgICAgICAgaWYgKCBsb2NhbGUgPT09IEZBTExCQUNLX0xPQ0FMRSB8fCAoIHR5cGVvZiBzdHJpbmcgPT09ICdzdHJpbmcnICYmIHN0cmluZyAhPT0gJycgKSApIHtcclxuICAgICAgICAgIGxvY2FsZVRvVHJhbnNsYXRpb25NYXBbIGxvY2FsZSBdID0gcGhldC5jaGlwcGVyLm1hcFN0cmluZyggc3RyaW5nICk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9ICk7XHJcblxyXG4gICAgICBjb25zdCBsb2NhbGl6ZWRTdHJpbmcgPSBuZXcgTG9jYWxpemVkU3RyaW5nKFxyXG4gICAgICAgIHN0cmluZ0tleSxcclxuICAgICAgICBsb2NhbGVUb1RyYW5zbGF0aW9uTWFwLFxyXG4gICAgICAgIHRhbmRlbSxcclxuICAgICAgICBwaGV0LmNoaXBwZXIuc3RyaW5nTWV0YWRhdGFbIHN0cmluZ0tleSBdXHJcbiAgICAgICk7XHJcbiAgICAgIGxvY2FsaXplZFN0cmluZ01hcFsgc3RyaW5nS2V5IF0gPSBsb2NhbGl6ZWRTdHJpbmc7XHJcblxyXG4gICAgICAvLyBQdXQgb3VyIFByb3BlcnR5IGluIHRoZSBzdHJpbmdNb2R1bGVcclxuICAgICAgcmVmZXJlbmNlWyBgJHtsYXN0S2V5UGFydH1TdHJpbmdQcm9wZXJ0eWAgXSA9IGxvY2FsaXplZFN0cmluZy5wcm9wZXJ0eTtcclxuXHJcbiAgICAgIC8vIENoYW5nZSBvdXIgc3RyaW5nTW9kdWxlIGJhc2VkIG9uIHRoZSBQcm9wZXJ0eSB2YWx1ZVxyXG4gICAgICBsb2NhbGl6ZWRTdHJpbmcucHJvcGVydHkubGluayggc3RyaW5nID0+IHtcclxuICAgICAgICByZWZlcmVuY2VbIGxhc3RLZXlQYXJ0IF0gPSBzdHJpbmc7XHJcbiAgICAgIH0gKTtcclxuICAgIH1cclxuICB9ICk7XHJcblxyXG4gIHJldHVybiBzdHJpbmdNb2R1bGU7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBnZXRTdHJpbmdNb2R1bGU7Il0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFlQSxJQUFBQSxhQUFBLEdBQUFDLHNCQUFBLENBQUFDLE9BQUE7QUFDQSxJQUFBQyxPQUFBLEdBQUFGLHNCQUFBLENBQUFDLE9BQUE7QUFDQSxJQUFBRSw0QkFBQSxHQUFBSCxzQkFBQSxDQUFBQyxPQUFB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