"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.combineOptions = combineOptions;
exports["default"] = optionize;
exports.optionize3 = optionize3;
exports.optionize4 = optionize4;
var _phetCore = _interopRequireDefault(require("./phetCore.js"));
var _merge = _interopRequireDefault(require("./merge.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
// Copyright 2022-2024, University of Colorado Boulder

/**
 * Optionize is a TypeScript layer built on PHET_CORE/merge. Its goal is to satisfy type safety within PhET's "options"
 * pattern.
 *
 * For up-to-date examples on how to use this file, see WILDER/WilderOptionsPatterns.ts
 *
 * This pattern is still being solidified. Although the long term location of PhET's options pattern documentation
 * can be found at https://github.com/phetsims/phet-info/blob/main/doc/phet-software-design-patterns.md#options-and-config,
 * that document is currently out of date. Please see https://github.com/phetsims/phet-core/issues/128 for current
 * progress on this pattern.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Michael Kauzmann (PhET Interactive Simulations)
 */

// Gets the parts of an object that are optional

// This is the type for the `defaults` argument to optionize

// eslint-disable-line @typescript-eslint/ban-types

// Factor out the merge arrow closure to avoid heap/cpu at runtime
var merge4 = function merge4(a, b, c, d) {
  return (0, _merge["default"])(a, b, c, d);
};

// ProvidedOptions = The type of this class's public API (type of the providedOptions parameter in the constructor)
// SelfOptions = Options that are defined by "this" class. Anything optional in this block must have a default provided in "defaults"
// ParentOptions = The public API for parent options, this will be exported by the parent class, like "NodeOptions"
// KeysUsedInSubclassConstructor = list of keys from ParentOptions that are used in this constructor.
function optionize() {
  return merge4;
}

// Use this function to gain the typing that optionize provides but in a case where the first argument is an empty object.
function optionize3() {
  return merge4;
}

/**
 * Use this function to replace merge in cases like:
 *
 * const options = m-e-r-g-e(
 *   {},
 *
 *   // ParentOptions defaults that are common throughout the sim
 *   MyConstants.SOME_COMMON_OPTIONS,
 *
 *   // SelfOptions and ParentOptions defaults that are provided by this class
 *   { ... },
 *
 *   // option values that are provided by the caller
 *   providedOptions );
 */
function optionize4() {
  return merge4;
}

// Use combineOptions to combine object literals (typically options) that all have the same type.
function combineOptions(target) {
  for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    sources[_key - 1] = arguments[_key];
  }
  return merge4.apply(void 0, [target].concat(sources));
}

// function optionize<ProvidedOptions, // eslint-disable-line no-redeclare
//   SelfOptions = ProvidedOptions,
//   ParentOptions = EmptySelfOptions>():
//   <KeysUsedInSubclassConstructor extends keyof ( ParentOptions )>(
//     emptyObject: ObjectWithNoKeys,
//     defaults: OptionizeDefaults<SelfOptions, ParentOptions>,
//     providedOptions?: ProvidedOptions
//   ) => OptionizeDefaults<SelfOptions, ParentOptions> & ProvidedOptions & Required<Pick<ParentOptions, KeysUsedInSubclassConstructor>>;
//
// function optionize<ProvidedOptions, // eslint-disable-line no-redeclare
//   SelfOptions = ProvidedOptions,
//   ParentOptions = EmptySelfOptions,
//   KeysUsedInSubclassConstructor extends keyof ParentOptions = never>():
//   (
//     empytObject: ObjectWithNoKeys,
//     defaults: OptionizeDefaults<SelfOptions, ParentOptions, KeysUsedInSubclassConstructor>,
//     providedOptions?: ProvidedOptions
//   ) => ObjectWithNoKeys & OptionizeDefaults<SelfOptions, ParentOptions, KeysUsedInSubclassConstructor> & ProvidedOptions;

// The implementation gets "any" types because of the above signatures
// function optionize<???>() { return ( a: any, b?: any, c?: any ) => merge( a, b, c ); } // eslint-disable-line no-redeclare,bad-text

// TypeScript is all-or-none on inferring generic parameter types (per function), so we must use the nested strategy in
// https://stackoverflow.com/questions/63678306/typescript-partial-type-inference to specify the types we want
// while still allowing definitions to flow through.
// This also works, we will keep it here now in case it helps with further improvements with inference.
// const optionize = <S, P, M extends keyof P = never>() => {
//   return <B>( defaults: Required<Options<S>> & Partial<P> & Required<Pick<P, M>>, providedOptions?: B ) => {
//     return merge( defaults, providedOptions );
//   };
// };

/*
Limitation (I):

This gets us half way there, when you have required args to the parent, this makes sure that you don't make
providedOptions optional (with a question mark). We still need a way to note when the required param is specified via the self options.
const optionize = <S, P = EmptySelfOptions, M extends keyof P = never, A = S & P>(
  defaults: Required<Options<S>> & Partial<P> & Required<Pick<P, M>>,
  providedOptions: RequiredKeys<A> extends never ? ( A | undefined ) : A
) => {
  return merge( defaults, providedOptions );
};

TEST TO SEE IF WE CAN GET TYPESCRIPT TO KNOW ABOUT REQUIRED ARGUMENTS TO POTENTIALLY COME FROM EITHER ARG.
const optionize = <S, P = EmptySelfOptions, M extends keyof P = never, A = S & P>() => {
  type FirstArg = Required<Options<S>> & Partial<P> & Required<Pick<P, M>>;
  return (
    defaults: FirstArg,
    //NOT WORKING: If any required elements were in the first arg, then we don't need them here, and potentially can mark providedOptions as a whole as optional
    providedOptions: RequiredKeys<FirstArg> extends never ? RequiredKeys<A> extends never ? ( A | undefined ) : A : A
  ) => {
    return merge( defaults, providedOptions );
  };
};
 */

_phetCore["default"].register('optionize', optionize);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfcGhldENvcmUiLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwicmVxdWlyZSIsIl9tZXJnZSIsIm9iaiIsIl9fZXNNb2R1bGUiLCJtZXJnZTQiLCJhIiwiYiIsImMiLCJkIiwibWVyZ2UiLCJvcHRpb25pemUiLCJvcHRpb25pemUzIiwib3B0aW9uaXplNCIsImNvbWJpbmVPcHRpb25zIiwidGFyZ2V0IiwiX2xlbiIsImFyZ3VtZW50cyIsImxlbmd0aCIsInNvdXJjZXMiLCJBcnJheSIsIl9rZXkiLCJhcHBseSIsImNvbmNhdCIsInBoZXRDb3JlIiwicmVnaXN0ZXIiXSwic291cmNlcyI6WyJvcHRpb25pemUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMjItMjAyNCwgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXHJcblxyXG4vKipcclxuICogT3B0aW9uaXplIGlzIGEgVHlwZVNjcmlwdCBsYXllciBidWlsdCBvbiBQSEVUX0NPUkUvbWVyZ2UuIEl0cyBnb2FsIGlzIHRvIHNhdGlzZnkgdHlwZSBzYWZldHkgd2l0aGluIFBoRVQncyBcIm9wdGlvbnNcIlxyXG4gKiBwYXR0ZXJuLlxyXG4gKlxyXG4gKiBGb3IgdXAtdG8tZGF0ZSBleGFtcGxlcyBvbiBob3cgdG8gdXNlIHRoaXMgZmlsZSwgc2VlIFdJTERFUi9XaWxkZXJPcHRpb25zUGF0dGVybnMudHNcclxuICpcclxuICogVGhpcyBwYXR0ZXJuIGlzIHN0aWxsIGJlaW5nIHNvbGlkaWZpZWQuIEFsdGhvdWdoIHRoZSBsb25nIHRlcm0gbG9jYXRpb24gb2YgUGhFVCdzIG9wdGlvbnMgcGF0dGVybiBkb2N1bWVudGF0aW9uXHJcbiAqIGNhbiBiZSBmb3VuZCBhdCBodHRwczovL2dpdGh1Yi5jb20vcGhldHNpbXMvcGhldC1pbmZvL2Jsb2IvbWFpbi9kb2MvcGhldC1zb2Z0d2FyZS1kZXNpZ24tcGF0dGVybnMubWQjb3B0aW9ucy1hbmQtY29uZmlnLFxyXG4gKiB0aGF0IGRvY3VtZW50IGlzIGN1cnJlbnRseSBvdXQgb2YgZGF0ZS4gUGxlYXNlIHNlZSBodHRwczovL2dpdGh1Yi5jb20vcGhldHNpbXMvcGhldC1jb3JlL2lzc3Vlcy8xMjggZm9yIGN1cnJlbnRcclxuICogcHJvZ3Jlc3Mgb24gdGhpcyBwYXR0ZXJuLlxyXG4gKlxyXG4gKiBAYXV0aG9yIFNhbSBSZWlkIChQaEVUIEludGVyYWN0aXZlIFNpbXVsYXRpb25zKVxyXG4gKiBAYXV0aG9yIE1pY2hhZWwgS2F1em1hbm4gKFBoRVQgSW50ZXJhY3RpdmUgU2ltdWxhdGlvbnMpXHJcbiAqL1xyXG5cclxuaW1wb3J0IHBoZXRDb3JlIGZyb20gJy4vcGhldENvcmUuanMnO1xyXG5pbXBvcnQgbWVyZ2UgZnJvbSAnLi9tZXJnZS5qcyc7XHJcbmltcG9ydCBJbnRlbnRpb25hbEFueSBmcm9tICcuL3R5cGVzL0ludGVudGlvbmFsQW55LmpzJztcclxuaW1wb3J0IFJlcXVpcmVkS2V5cyBmcm9tICcuL3R5cGVzL1JlcXVpcmVkS2V5cy5qcyc7XHJcbmltcG9ydCBPcHRpb25hbEtleXMgZnJvbSAnLi90eXBlcy9PcHRpb25hbEtleXMuanMnO1xyXG5cclxuLy8gR2V0cyB0aGUgcGFydHMgb2YgYW4gb2JqZWN0IHRoYXQgYXJlIG9wdGlvbmFsXHJcbnR5cGUgT3B0aW9uczxUPiA9IFBpY2s8VCwgT3B0aW9uYWxLZXlzPFQ+PjtcclxuXHJcbnR5cGUgT2JqZWN0V2l0aE5vS2V5cyA9IFJlY29yZDxzdHJpbmcgfCBudW1iZXIsIG5ldmVyPjtcclxuXHJcbmV4cG9ydCB0eXBlIEVtcHR5U2VsZk9wdGlvbnMgPSB7XHJcbiAgX2VtcHR5U2VsZk9wdGlvbnNLZXk/OiBuZXZlcjtcclxufTtcclxuXHJcbnR5cGUgRW1wdHlTZWxmT3B0aW9uc0tleXMgPSBrZXlvZiBFbXB0eVNlbGZPcHRpb25zO1xyXG5cclxuLy8gVGhpcyBpcyB0aGUgdHlwZSBmb3IgdGhlIGBkZWZhdWx0c2AgYXJndW1lbnQgdG8gb3B0aW9uaXplXHJcbnR5cGUgT3B0aW9uaXplRGVmYXVsdHM8U2VsZk9wdGlvbnMgPSBFbXB0eVNlbGZPcHRpb25zLCBQYXJlbnRPcHRpb25zID0gRW1wdHlTZWxmT3B0aW9ucywgUHJvdmlkZWRPcHRpb25zID0gRW1wdHlTZWxmT3B0aW9ucz4gPVxyXG5cclxuLy8gRXZlcnl0aGluZyBvcHRpb25hbCBmcm9tIFNlbGZPcHRpb25zIG11c3QgaGF2ZSBhIGRlZmF1bHQgc3BlY2lmaWVkXHJcbiAgT21pdDxSZXF1aXJlZDxPcHRpb25zPFNlbGZPcHRpb25zPj4sIEVtcHR5U2VsZk9wdGlvbnNLZXlzPiAmIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlc1xyXG5cclxuICAvLyBBbnl0aGluZyByZXF1aXJlZCBpbiB0aGUgUHJvdmlkZWRPcHRpb25zIHNob3VsZCBub3Qgc2hvdyB1cCBpbiB0aGUgXCJkZWZhdWx0c1wiIG9iamVjdFxyXG4gIHsgW2sgaW4gUmVxdWlyZWRLZXlzPFByb3ZpZGVkT3B0aW9ucz5dPzogbmV2ZXI7IH0gJlxyXG5cclxuICAvLyBBbnkgb3Igbm9uZSBvZiBQYXJlbnQgb3B0aW9ucyBjYW4gYmUgcHJvdmlkZWRcclxuICBQYXJ0aWFsPFBhcmVudE9wdGlvbnM+XHJcblxyXG4gIC8vIEluY2x1ZGUgdGhlIHJlcXVpcmVkIHByb3BlcnRpZXMgZnJvbSBQYXJlbnRPcHRpb25zIHRoYXQgYXJlIG5vdCBpbiB0aGUgUHJvdmlkZWRPcHRpb25zXHJcbiAgJiBSZXF1aXJlZDxPbWl0PFBpY2s8UGFyZW50T3B0aW9ucywgUmVxdWlyZWRLZXlzPFBhcmVudE9wdGlvbnM+PiwgUmVxdWlyZWRLZXlzPFByb3ZpZGVkT3B0aW9ucz4+PjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXR5cGVzXHJcblxyXG4vLyBGYWN0b3Igb3V0IHRoZSBtZXJnZSBhcnJvdyBjbG9zdXJlIHRvIGF2b2lkIGhlYXAvY3B1IGF0IHJ1bnRpbWVcclxuY29uc3QgbWVyZ2U0ID0gKCBhOiBJbnRlbnRpb25hbEFueSwgYj86IEludGVudGlvbmFsQW55LCBjPzogSW50ZW50aW9uYWxBbnksIGQ/OiBJbnRlbnRpb25hbEFueSApID0+IG1lcmdlKCBhLCBiLCBjLCBkICk7XHJcblxyXG4vLyBQcm92aWRlZE9wdGlvbnMgPSBUaGUgdHlwZSBvZiB0aGlzIGNsYXNzJ3MgcHVibGljIEFQSSAodHlwZSBvZiB0aGUgcHJvdmlkZWRPcHRpb25zIHBhcmFtZXRlciBpbiB0aGUgY29uc3RydWN0b3IpXHJcbi8vIFNlbGZPcHRpb25zID0gT3B0aW9ucyB0aGF0IGFyZSBkZWZpbmVkIGJ5IFwidGhpc1wiIGNsYXNzLiBBbnl0aGluZyBvcHRpb25hbCBpbiB0aGlzIGJsb2NrIG11c3QgaGF2ZSBhIGRlZmF1bHQgcHJvdmlkZWQgaW4gXCJkZWZhdWx0c1wiXHJcbi8vIFBhcmVudE9wdGlvbnMgPSBUaGUgcHVibGljIEFQSSBmb3IgcGFyZW50IG9wdGlvbnMsIHRoaXMgd2lsbCBiZSBleHBvcnRlZCBieSB0aGUgcGFyZW50IGNsYXNzLCBsaWtlIFwiTm9kZU9wdGlvbnNcIlxyXG4vLyBLZXlzVXNlZEluU3ViY2xhc3NDb25zdHJ1Y3RvciA9IGxpc3Qgb2Yga2V5cyBmcm9tIFBhcmVudE9wdGlvbnMgdGhhdCBhcmUgdXNlZCBpbiB0aGlzIGNvbnN0cnVjdG9yLlxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBvcHRpb25pemU8UHJvdmlkZWRPcHRpb25zLFxyXG4gIFNlbGZPcHRpb25zID0gUHJvdmlkZWRPcHRpb25zLCAvLyBCeSBkZWZhdWx0LCBldmVyeSBvcHRpb25hbCBvcHRpb24gaW4gdGhlIFByb3ZpZGVkT3B0aW9ucyBtdXN0IGhhdmUgYSBkZWZhdWx0IHVubGVzcyB5b3Ugc3BlY2lmeSBhbm90aGVyIG9iamVjdCBmb3IgU2VsZk9wdGlvbnNcclxuICBQYXJlbnRPcHRpb25zID0gUmVjb3JkPG5ldmVyLCBuZXZlcj4+KCk6XHJcbiAgPEtleXNVc2VkSW5TdWJjbGFzc0NvbnN0cnVjdG9yIGV4dGVuZHMga2V5b2YgKCBQYXJlbnRPcHRpb25zICk+KFxyXG4gICAgZGVmYXVsdHM6IE9wdGlvbml6ZURlZmF1bHRzPFNlbGZPcHRpb25zLCBQYXJlbnRPcHRpb25zLCBQcm92aWRlZE9wdGlvbnM+LFxyXG4gICAgcHJvdmlkZWRPcHRpb25zPzogUHJvdmlkZWRPcHRpb25zXHJcbiAgKSA9PiBPcHRpb25pemVEZWZhdWx0czxTZWxmT3B0aW9ucywgUGFyZW50T3B0aW9ucz4gJiBQcm92aWRlZE9wdGlvbnMgJiBSZXF1aXJlZDxQaWNrPFBhcmVudE9wdGlvbnMsIEtleXNVc2VkSW5TdWJjbGFzc0NvbnN0cnVjdG9yPj4ge1xyXG4gIHJldHVybiBtZXJnZTQ7XHJcbn1cclxuXHJcbi8vIFVzZSB0aGlzIGZ1bmN0aW9uIHRvIGdhaW4gdGhlIHR5cGluZyB0aGF0IG9wdGlvbml6ZSBwcm92aWRlcyBidXQgaW4gYSBjYXNlIHdoZXJlIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBhbiBlbXB0eSBvYmplY3QuXHJcbmV4cG9ydCBmdW5jdGlvbiBvcHRpb25pemUzPFByb3ZpZGVkT3B0aW9ucyxcclxuICBTZWxmT3B0aW9ucyA9IFByb3ZpZGVkT3B0aW9ucywgLy8gQnkgZGVmYXVsdCwgZXZlcnkgb3B0aW9uYWwgb3B0aW9uIGluIHRoZSBQcm92aWRlZE9wdGlvbnMgbXVzdCBoYXZlIGEgZGVmYXVsdCB1bmxlc3MgeW91IHNwZWNpZnkgYW5vdGhlciBvYmplY3QgZm9yIFNlbGZPcHRpb25zXHJcbiAgUGFyZW50T3B0aW9ucyA9IFJlY29yZDxuZXZlciwgbmV2ZXI+PigpOlxyXG4gIDxLZXlzVXNlZEluU3ViY2xhc3NDb25zdHJ1Y3RvciBleHRlbmRzIGtleW9mICggUGFyZW50T3B0aW9ucyApPihcclxuICAgIGVtcHR5T2JqZWN0OiBPYmplY3RXaXRoTm9LZXlzLFxyXG4gICAgZGVmYXVsdHM6IE9wdGlvbml6ZURlZmF1bHRzPFNlbGZPcHRpb25zLCBQYXJlbnRPcHRpb25zPixcclxuICAgIHByb3ZpZGVkT3B0aW9ucz86IFByb3ZpZGVkT3B0aW9uc1xyXG4gICkgPT4gT3B0aW9uaXplRGVmYXVsdHM8U2VsZk9wdGlvbnMsIFBhcmVudE9wdGlvbnM+ICYgUHJvdmlkZWRPcHRpb25zICYgUmVxdWlyZWQ8UGljazxQYXJlbnRPcHRpb25zLCBLZXlzVXNlZEluU3ViY2xhc3NDb25zdHJ1Y3Rvcj4+IHtcclxuICByZXR1cm4gbWVyZ2U0O1xyXG59XHJcblxyXG4vKipcclxuICogVXNlIHRoaXMgZnVuY3Rpb24gdG8gcmVwbGFjZSBtZXJnZSBpbiBjYXNlcyBsaWtlOlxyXG4gKlxyXG4gKiBjb25zdCBvcHRpb25zID0gbS1lLXItZy1lKFxyXG4gKiAgIHt9LFxyXG4gKlxyXG4gKiAgIC8vIFBhcmVudE9wdGlvbnMgZGVmYXVsdHMgdGhhdCBhcmUgY29tbW9uIHRocm91Z2hvdXQgdGhlIHNpbVxyXG4gKiAgIE15Q29uc3RhbnRzLlNPTUVfQ09NTU9OX09QVElPTlMsXHJcbiAqXHJcbiAqICAgLy8gU2VsZk9wdGlvbnMgYW5kIFBhcmVudE9wdGlvbnMgZGVmYXVsdHMgdGhhdCBhcmUgcHJvdmlkZWQgYnkgdGhpcyBjbGFzc1xyXG4gKiAgIHsgLi4uIH0sXHJcbiAqXHJcbiAqICAgLy8gb3B0aW9uIHZhbHVlcyB0aGF0IGFyZSBwcm92aWRlZCBieSB0aGUgY2FsbGVyXHJcbiAqICAgcHJvdmlkZWRPcHRpb25zICk7XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gb3B0aW9uaXplNDxQcm92aWRlZE9wdGlvbnMsXHJcbiAgU2VsZk9wdGlvbnMgPSBQcm92aWRlZE9wdGlvbnMsXHJcbiAgUGFyZW50T3B0aW9ucyA9IG9iamVjdD4oKTpcclxuICA8S2V5c1VzZWRJblN1YmNsYXNzQ29uc3RydWN0b3IgZXh0ZW5kcyBrZXlvZiAoIFBhcmVudE9wdGlvbnMgKT4oXHJcbiAgICBlbXB0eU9iamVjdDogT2JqZWN0V2l0aE5vS2V5cyxcclxuICAgIG9wdGlvbnNGcm9tQ29uc3RhbnQ6IFBhcnRpYWw8UGFyZW50T3B0aW9ucz4sXHJcbiAgICBkZWZhdWx0czI6IE9wdGlvbml6ZURlZmF1bHRzPFNlbGZPcHRpb25zLCBQYXJlbnRPcHRpb25zPixcclxuICAgIHByb3ZpZGVkT3B0aW9ucz86IFByb3ZpZGVkT3B0aW9uc1xyXG4gICkgPT4gT3B0aW9uaXplRGVmYXVsdHM8U2VsZk9wdGlvbnMsIFBhcmVudE9wdGlvbnM+ICYgUHJvdmlkZWRPcHRpb25zICYgUmVxdWlyZWQ8UGljazxQYXJlbnRPcHRpb25zLCBLZXlzVXNlZEluU3ViY2xhc3NDb25zdHJ1Y3Rvcj4+IHtcclxuICByZXR1cm4gbWVyZ2U0O1xyXG59XHJcblxyXG4vLyBVc2UgY29tYmluZU9wdGlvbnMgdG8gY29tYmluZSBvYmplY3QgbGl0ZXJhbHMgKHR5cGljYWxseSBvcHRpb25zKSB0aGF0IGFsbCBoYXZlIHRoZSBzYW1lIHR5cGUuXHJcbmV4cG9ydCBmdW5jdGlvbiBjb21iaW5lT3B0aW9uczxUeXBlIGV4dGVuZHMgb2JqZWN0PiggdGFyZ2V0OiBQYXJ0aWFsPFR5cGU+LCAuLi5zb3VyY2VzOiBBcnJheTxQYXJ0aWFsPFR5cGU+IHwgdW5kZWZpbmVkPiApOiBUeXBlIHtcclxuICByZXR1cm4gbWVyZ2U0KCB0YXJnZXQsIC4uLnNvdXJjZXMgKTtcclxufVxyXG5cclxuXHJcbi8vIGZ1bmN0aW9uIG9wdGlvbml6ZTxQcm92aWRlZE9wdGlvbnMsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcmVkZWNsYXJlXHJcbi8vICAgU2VsZk9wdGlvbnMgPSBQcm92aWRlZE9wdGlvbnMsXHJcbi8vICAgUGFyZW50T3B0aW9ucyA9IEVtcHR5U2VsZk9wdGlvbnM+KCk6XHJcbi8vICAgPEtleXNVc2VkSW5TdWJjbGFzc0NvbnN0cnVjdG9yIGV4dGVuZHMga2V5b2YgKCBQYXJlbnRPcHRpb25zICk+KFxyXG4vLyAgICAgZW1wdHlPYmplY3Q6IE9iamVjdFdpdGhOb0tleXMsXHJcbi8vICAgICBkZWZhdWx0czogT3B0aW9uaXplRGVmYXVsdHM8U2VsZk9wdGlvbnMsIFBhcmVudE9wdGlvbnM+LFxyXG4vLyAgICAgcHJvdmlkZWRPcHRpb25zPzogUHJvdmlkZWRPcHRpb25zXHJcbi8vICAgKSA9PiBPcHRpb25pemVEZWZhdWx0czxTZWxmT3B0aW9ucywgUGFyZW50T3B0aW9ucz4gJiBQcm92aWRlZE9wdGlvbnMgJiBSZXF1aXJlZDxQaWNrPFBhcmVudE9wdGlvbnMsIEtleXNVc2VkSW5TdWJjbGFzc0NvbnN0cnVjdG9yPj47XHJcbi8vXHJcbi8vIGZ1bmN0aW9uIG9wdGlvbml6ZTxQcm92aWRlZE9wdGlvbnMsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcmVkZWNsYXJlXHJcbi8vICAgU2VsZk9wdGlvbnMgPSBQcm92aWRlZE9wdGlvbnMsXHJcbi8vICAgUGFyZW50T3B0aW9ucyA9IEVtcHR5U2VsZk9wdGlvbnMsXHJcbi8vICAgS2V5c1VzZWRJblN1YmNsYXNzQ29uc3RydWN0b3IgZXh0ZW5kcyBrZXlvZiBQYXJlbnRPcHRpb25zID0gbmV2ZXI+KCk6XHJcbi8vICAgKFxyXG4vLyAgICAgZW1weXRPYmplY3Q6IE9iamVjdFdpdGhOb0tleXMsXHJcbi8vICAgICBkZWZhdWx0czogT3B0aW9uaXplRGVmYXVsdHM8U2VsZk9wdGlvbnMsIFBhcmVudE9wdGlvbnMsIEtleXNVc2VkSW5TdWJjbGFzc0NvbnN0cnVjdG9yPixcclxuLy8gICAgIHByb3ZpZGVkT3B0aW9ucz86IFByb3ZpZGVkT3B0aW9uc1xyXG4vLyAgICkgPT4gT2JqZWN0V2l0aE5vS2V5cyAmIE9wdGlvbml6ZURlZmF1bHRzPFNlbGZPcHRpb25zLCBQYXJlbnRPcHRpb25zLCBLZXlzVXNlZEluU3ViY2xhc3NDb25zdHJ1Y3Rvcj4gJiBQcm92aWRlZE9wdGlvbnM7XHJcblxyXG4vLyBUaGUgaW1wbGVtZW50YXRpb24gZ2V0cyBcImFueVwiIHR5cGVzIGJlY2F1c2Ugb2YgdGhlIGFib3ZlIHNpZ25hdHVyZXNcclxuLy8gZnVuY3Rpb24gb3B0aW9uaXplPD8/Pz4oKSB7IHJldHVybiAoIGE6IGFueSwgYj86IGFueSwgYz86IGFueSApID0+IG1lcmdlKCBhLCBiLCBjICk7IH0gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1yZWRlY2xhcmUsYmFkLXRleHRcclxuXHJcbi8vIFR5cGVTY3JpcHQgaXMgYWxsLW9yLW5vbmUgb24gaW5mZXJyaW5nIGdlbmVyaWMgcGFyYW1ldGVyIHR5cGVzIChwZXIgZnVuY3Rpb24pLCBzbyB3ZSBtdXN0IHVzZSB0aGUgbmVzdGVkIHN0cmF0ZWd5IGluXHJcbi8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzYzNjc4MzA2L3R5cGVzY3JpcHQtcGFydGlhbC10eXBlLWluZmVyZW5jZSB0byBzcGVjaWZ5IHRoZSB0eXBlcyB3ZSB3YW50XHJcbi8vIHdoaWxlIHN0aWxsIGFsbG93aW5nIGRlZmluaXRpb25zIHRvIGZsb3cgdGhyb3VnaC5cclxuLy8gVGhpcyBhbHNvIHdvcmtzLCB3ZSB3aWxsIGtlZXAgaXQgaGVyZSBub3cgaW4gY2FzZSBpdCBoZWxwcyB3aXRoIGZ1cnRoZXIgaW1wcm92ZW1lbnRzIHdpdGggaW5mZXJlbmNlLlxyXG4vLyBjb25zdCBvcHRpb25pemUgPSA8UywgUCwgTSBleHRlbmRzIGtleW9mIFAgPSBuZXZlcj4oKSA9PiB7XHJcbi8vICAgcmV0dXJuIDxCPiggZGVmYXVsdHM6IFJlcXVpcmVkPE9wdGlvbnM8Uz4+ICYgUGFydGlhbDxQPiAmIFJlcXVpcmVkPFBpY2s8UCwgTT4+LCBwcm92aWRlZE9wdGlvbnM/OiBCICkgPT4ge1xyXG4vLyAgICAgcmV0dXJuIG1lcmdlKCBkZWZhdWx0cywgcHJvdmlkZWRPcHRpb25zICk7XHJcbi8vICAgfTtcclxuLy8gfTtcclxuXHJcbi8qXHJcbkxpbWl0YXRpb24gKEkpOlxyXG5cclxuVGhpcyBnZXRzIHVzIGhhbGYgd2F5IHRoZXJlLCB3aGVuIHlvdSBoYXZlIHJlcXVpcmVkIGFyZ3MgdG8gdGhlIHBhcmVudCwgdGhpcyBtYWtlcyBzdXJlIHRoYXQgeW91IGRvbid0IG1ha2VcclxucHJvdmlkZWRPcHRpb25zIG9wdGlvbmFsICh3aXRoIGEgcXVlc3Rpb24gbWFyaykuIFdlIHN0aWxsIG5lZWQgYSB3YXkgdG8gbm90ZSB3aGVuIHRoZSByZXF1aXJlZCBwYXJhbSBpcyBzcGVjaWZpZWQgdmlhIHRoZSBzZWxmIG9wdGlvbnMuXHJcbmNvbnN0IG9wdGlvbml6ZSA9IDxTLCBQID0gRW1wdHlTZWxmT3B0aW9ucywgTSBleHRlbmRzIGtleW9mIFAgPSBuZXZlciwgQSA9IFMgJiBQPihcclxuICBkZWZhdWx0czogUmVxdWlyZWQ8T3B0aW9uczxTPj4gJiBQYXJ0aWFsPFA+ICYgUmVxdWlyZWQ8UGljazxQLCBNPj4sXHJcbiAgcHJvdmlkZWRPcHRpb25zOiBSZXF1aXJlZEtleXM8QT4gZXh0ZW5kcyBuZXZlciA/ICggQSB8IHVuZGVmaW5lZCApIDogQVxyXG4pID0+IHtcclxuICByZXR1cm4gbWVyZ2UoIGRlZmF1bHRzLCBwcm92aWRlZE9wdGlvbnMgKTtcclxufTtcclxuXHJcblRFU1QgVE8gU0VFIElGIFdFIENBTiBHRVQgVFlQRVNDUklQVCBUTyBLTk9XIEFCT1VUIFJFUVVJUkVEIEFSR1VNRU5UUyBUTyBQT1RFTlRJQUxMWSBDT01FIEZST00gRUlUSEVSIEFSRy5cclxuY29uc3Qgb3B0aW9uaXplID0gPFMsIFAgPSBFbXB0eVNlbGZPcHRpb25zLCBNIGV4dGVuZHMga2V5b2YgUCA9IG5ldmVyLCBBID0gUyAmIFA+KCkgPT4ge1xyXG4gIHR5cGUgRmlyc3RBcmcgPSBSZXF1aXJlZDxPcHRpb25zPFM+PiAmIFBhcnRpYWw8UD4gJiBSZXF1aXJlZDxQaWNrPFAsIE0+PjtcclxuICByZXR1cm4gKFxyXG4gICAgZGVmYXVsdHM6IEZpcnN0QXJnLFxyXG4gICAgLy9OT1QgV09SS0lORzogSWYgYW55IHJlcXVpcmVkIGVsZW1lbnRzIHdlcmUgaW4gdGhlIGZpcnN0IGFyZywgdGhlbiB3ZSBkb24ndCBuZWVkIHRoZW0gaGVyZSwgYW5kIHBvdGVudGlhbGx5IGNhbiBtYXJrIHByb3ZpZGVkT3B0aW9ucyBhcyBhIHdob2xlIGFzIG9wdGlvbmFsXHJcbiAgICBwcm92aWRlZE9wdGlvbnM6IFJlcXVpcmVkS2V5czxGaXJzdEFyZz4gZXh0ZW5kcyBuZXZlciA/IFJlcXVpcmVkS2V5czxBPiBleHRlbmRzIG5ldmVyID8gKCBBIHwgdW5kZWZpbmVkICkgOiBBIDogQVxyXG4gICkgPT4ge1xyXG4gICAgcmV0dXJuIG1lcmdlKCBkZWZhdWx0cywgcHJvdmlkZWRPcHRpb25zICk7XHJcbiAgfTtcclxufTtcclxuICovXHJcblxyXG5waGV0Q29yZS5yZWdpc3RlciggJ29wdGlvbml6ZScsIG9wdGlvbml6ZSApO1xyXG5leHBvcnQgdHlwZSB7IE9wdGlvbml6ZURlZmF1bHRzIH07Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFpQkEsSUFBQUEsU0FBQSxHQUFBQyxzQkFBQSxDQUFBQyxPQUFBO0FBQ0EsSUFBQUMsTUFBQSxHQUFBRixzQkFBQSxDQUFBQyxPQUFBO0FBQStCLFNBQUFELHVCQUFBRyxHQUFBLFdBQUFBLEdBQUEsSUFBQUEsR0FBQSxDQUFBQyxVQUFBLEdBQUFELEdBQUEsZ0JBQUFBLEdBQUE7QUFsQi9COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBUUE7O0FBV0E7O0FBYXFHOztBQUVyRztBQUNBLElBQU1FLE1BQU0sR0FBRyxTQUFUQSxNQUFNQSxDQUFLQyxDQUFpQixFQUFFQyxDQUFrQixFQUFFQyxDQUFrQixFQUFFQyxDQUFrQjtFQUFBLE9BQU0sSUFBQUMsaUJBQUssRUFBRUosQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBRSxDQUFDO0FBQUE7O0FBRXZIO0FBQ0E7QUFDQTtBQUNBO0FBQ2UsU0FBU0UsU0FBU0EsQ0FBQSxFQU1xRztFQUNwSSxPQUFPTixNQUFNO0FBQ2Y7O0FBRUE7QUFDTyxTQUFTTyxVQUFVQSxDQUFBLEVBTzRHO0VBQ3BJLE9BQU9QLE1BQU07QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxTQUFTUSxVQUFVQSxDQUFBLEVBUTRHO0VBQ3BJLE9BQU9SLE1BQU07QUFDZjs7QUFFQTtBQUNPLFNBQVNTLGNBQWNBLENBQXVCQyxNQUFxQixFQUF1RDtFQUFBLFNBQUFDLElBQUEsR0FBQUMsU0FBQSxDQUFBQyxNQUFBLEVBQWxEQyxPQUFPLE9BQUFDLEtBQUEsQ0FBQUosSUFBQSxPQUFBQSxJQUFBLFdBQUFLLElBQUEsTUFBQUEsSUFBQSxHQUFBTCxJQUFBLEVBQUFLLElBQUE7SUFBUEYsT0FBTyxDQUFBRSxJQUFBLFFBQUFKLFNBQUEsQ0FBQUksSUFBQTtFQUFBO0VBQ3BGLE9BQU9oQixNQUFNLENBQUFpQixLQUFBLFVBQUVQLE1BQU0sRUFBQVEsTUFBQSxDQUFLSixPQUFPLENBQUMsQ0FBQztBQUNyQzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBSyxvQkFBUSxDQUFDQyxRQUFRLENBQUUsV0FBVyxFQUFFZCxTQUFVLENBQUMiLCJpZ25vcmVMaXN0IjpbXX0=