// Copyright 2020-2024, University of Colorado Boulder

/**
 * Given a requirejsNamespace, we filter out strings from phet.chipper.strings that start with it, and construct an
 * object with locale fallbacks already pre-computed, so that the correct strings can be accessed via object literal
 * access, e.g. getStringModule( 'JOIST' ).ResetAllButton.name will give the desired string value for whatever locale
 * the sim is being run with.
 *
 * A string "key" is in the form of "NAMESPACE/key.from.strings.json"
 *
 * NOTE: This file likely belongs in joist/js/i18n/, but should stay here to make maintenance-release maintainability easier.
 *
 * @author Jonathan Olson <jonathan.olson>
 */

import PhetioObject from '../../tandem/js/PhetioObject.js';
import Tandem from '../../tandem/js/Tandem.js';
import CouldNotYetDeserializeError from '../../tandem/js/CouldNotYetDeserializeError.js';
import IOType from '../../tandem/js/types/IOType.js';
import ObjectLiteralIO from '../../tandem/js/types/ObjectLiteralIO.js';
import LocalizedString from './LocalizedString.js';
// constants
const FALLBACK_LOCALE = 'en';

// Holds all of our localizedStrings, so that we can save our phet-io string change state
export const localizedStrings = [];

// For developer internal use, particularly for memory leak detection
// e.g. _.max( phet.chipper.localizedStrings.map( ls => ls.property.tinyProperty.listeners.size ) ) to see if there is
// likely a leak
window.phet.chipper.localizedStrings = localizedStrings;

// For developer internal use, similar to the stringTest query parameter
window.phet.chipper.setAllStrings = str => {
  localizedStrings.forEach(localizedString => {
    localizedString.property.value = str;
  });
};
const stringKeyToTandemName = key => {
  return key.replace(/(?:[-_\s]\w)/g, word => word[1].toUpperCase());
};
const StringStateIOType = new IOType('StringStateIO', {
  valueType: PhetioObject,
  toStateObject: () => {
    const data = {};
    localizedStrings.forEach(localizedString => {
      const state = localizedString.getStateDelta();

      // Only create an entry if there is anything (we can save bytes by not including the tandem here)
      if (Object.keys(state).length > 0) {
        data[localizedString.property.tandem.phetioID] = state;
      }
    });
    return {
      data: data // Data nested for a valid schema
    };
  },
  stateSchema: {
    data: ObjectLiteralIO
  },
  applyState: (ignored, state) => {
    // Every string in state has to be in localizedStrings to continue
    Object.keys(state.data).forEach(phetioID => {
      const match = localizedStrings.find(localizedString => localizedString.property.tandem.phetioID === phetioID);

      // When PhetioDynamicElementContainer elements such as PhetioGroup members add localizedStrings, we wait until
      // all of the members have been created (populating localizedStrings) before trying to set any of the strings.
      if (!match) {
        throw new CouldNotYetDeserializeError();
      }
    });

    // We need to iterate through every string in this runtime, since it might need to revert back to "initial" state.
    localizedStrings.forEach(localizedString => {
      localizedString.setStateDelta(state.data[localizedString.property.tandem.phetioID] || {});
    });
  }
});
PhetioObject.create({
  phetioType: StringStateIOType,
  tandem: Tandem.GENERAL_MODEL.createTandem('stringsState'),
  phetioDocumentation: 'Strings that have changed from their initial values. Each string value is specific to the locale it changed in.',
  phetioState: true
});
/**
 * @param requirejsNamespace - E.g. 'JOIST', to pull string keys out from that namespace
 * @returns Nested object to be accessed like JoistStrings.ResetAllButton.name
 */
const getStringModule = requirejsNamespace => {
  // Our string information is pulled globally, e.g. phet.chipper.strings[ locale ][ stringKey ] = stringValue;
  // Our locale information is from phet.chipper.locale

  assert && assert(typeof phet.chipper.locale === 'string', 'phet.chipper.locale should have been loaded by now');
  assert && assert(Object.keys(phet.chipper.localeData).includes(phet.chipper.locale), 'phet.chipper.locale should have been loaded by now');
  assert && assert(phet.chipper.strings, 'phet.chipper.strings should have been loaded by now');

  // Construct locales in increasing specificity, e.g. [ 'en', 'zh', 'zh_CN' ], so we get fallbacks in order
  // const locales = [ FALLBACK_LOCALE ];
  const stringKeyPrefix = `${requirejsNamespace}/`;

  // We may have other older (unused) keys in babel, and we are only doing the search that matters with the English
  // string keys.
  let allStringKeysInRepo = Object.keys(phet.chipper.strings[FALLBACK_LOCALE]).filter(stringKey => stringKey.startsWith(stringKeyPrefix));

  // TODO: https://github.com/phetsims/phet-io/issues/1877 What if this list doesn't exist?  Should that be an error?
  // Or an error if running an api-stable phet-io sim?
  // TODO: https://github.com/phetsims/phet-io/issues/1877 What will happen if this is stale? How will a developer know
  // to update it? Should it run in daily-grunt-work?
  if (phet.chipper.usedStringsEN) {
    allStringKeysInRepo = allStringKeysInRepo.filter(stringKey => phet.chipper.usedStringsEN.hasOwnProperty(stringKey));
  }

  // localizedStringMap[ stringKey ]
  const localizedStringMap = {};
  const stringModule = {};
  allStringKeysInRepo.forEach(stringKey => {
    // strip off the requirejsNamespace, e.g. 'JOIST/ResetAllButton.name' => 'ResetAllButton.name'
    const stringKeyWithoutPrefix = stringKey.slice(stringKeyPrefix.length);
    const keyParts = stringKeyWithoutPrefix.split('.');
    const lastKeyPart = keyParts[keyParts.length - 1];
    const allButLastKeyPart = keyParts.slice(0, keyParts.length - 1);

    // During traversal into the string object, this will hold the object where the next level needs to be defined,
    // whether that's another child object, or the string value itself.
    let reference = stringModule;

    // We'll traverse down through the parts of a string key (separated by '.'), creating a new level in the
    // string object for each one. This is done for all BUT the last part, since we'll want to assign the result
    // of that to a raw string value (rather than an object).
    let partialKey = stringKeyPrefix;
    allButLastKeyPart.forEach((keyPart, i) => {
      // When concatenating each level into the final string key, we don't want to put a '.' directly after the
      // slash, because `JOIST/.ResetAllButton.name` would be invalid.
      // See https://github.com/phetsims/chipper/issues/922
      partialKey += `${i > 0 ? '.' : ''}${keyPart}`;

      // Don't allow e.g. JOIST/a and JOIST/a.b, since localeObject.a would need to be a string AND an object at the
      // same time.
      assert && assert(typeof reference[keyPart] !== 'string', 'It is not allowed to have two different string keys where one is extended by adding a period (.) at the end ' + `of the other. The string key ${partialKey} is extended by ${stringKey} in this case, and should be changed.`);

      // Create the next nested level, and move into it
      if (!reference[keyPart]) {
        reference[keyPart] = {};
      }
      reference = reference[keyPart]; // since we are on all but the last key part, it cannot be stringlike
    });
    assert && assert(typeof reference[lastKeyPart] !== 'object', 'It is not allowed to have two different string keys where one is extended by adding a period (.) at the end ' + `of the other. The string key ${stringKey} is extended by another key, something containing ${reference[lastKeyPart] && Object.keys(reference[lastKeyPart])}.`);
    assert && assert(!reference[lastKeyPart], `We should not have defined this place in the object (${stringKey}), otherwise it means a duplicated string key OR extended string key`);

    // In case our assertions are not enabled, we'll need to proceed without failing out (so we allow for the
    // extended string keys in our actual code, even though assertions should prevent that).
    if (typeof reference !== 'string') {
      let tandem = Tandem.STRINGS.createTandem(_.camelCase(requirejsNamespace));
      for (let i = 0; i < keyParts.length; i++) {
        let tandemName = stringKeyToTandemName(keyParts[i]);

        // If it is the tail of the string key, then make the tandem be a "*StringProperty"
        if (i === keyParts.length - 1) {
          let currentTandemName = tandemName;
          let j = 0;
          let tandemNameTaken = true;

          // Handle the case where two unique string keys map to the same camel case value, i.e. "Solid" and "solid".
          // Here we will be solidStringProperty and solid2StringProperty
          while (tandemNameTaken) {
            j++;
            currentTandemName = `${tandemName}${j === 1 ? '' : j}StringProperty`;
            tandemNameTaken = tandem.hasChild(currentTandemName);
          }
          tandemName = currentTandemName;
        }
        tandem = tandem.createTandem(tandemName);
      }

      // strings nested under the a11y section are not currently PhET-iO instrumented, see https://github.com/phetsims/chipper/issues/1352
      if (tandem.phetioID.includes('.a11y.')) {
        tandem = Tandem.OPT_OUT;
      }
      const localeToTranslationMap = {};
      Object.keys(phet.chipper.strings).forEach(locale => {
        const string = phet.chipper.strings[locale][stringKey];
        // Ignore zero-length strings, see https://github.com/phetsims/chipper/issues/1343
        if (locale === FALLBACK_LOCALE || typeof string === 'string' && string !== '') {
          localeToTranslationMap[locale] = phet.chipper.mapString(string);
        }
      });
      const localizedString = new LocalizedString(stringKey, localeToTranslationMap, tandem, phet.chipper.stringMetadata[stringKey]);
      localizedStringMap[stringKey] = localizedString;

      // Put our Property in the stringModule
      reference[`${lastKeyPart}StringProperty`] = localizedString.property;

      // Change our stringModule based on the Property value
      localizedString.property.link(string => {
        reference[lastKeyPart] = string;
      });
    }
  });
  return stringModule;
};
export default getStringModule;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJQaGV0aW9PYmplY3QiLCJUYW5kZW0iLCJDb3VsZE5vdFlldERlc2VyaWFsaXplRXJyb3IiLCJJT1R5cGUiLCJPYmplY3RMaXRlcmFsSU8iLCJMb2NhbGl6ZWRTdHJpbmciLCJGQUxMQkFDS19MT0NBTEUiLCJsb2NhbGl6ZWRTdHJpbmdzIiwid2luZG93IiwicGhldCIsImNoaXBwZXIiLCJzZXRBbGxTdHJpbmdzIiwic3RyIiwiZm9yRWFjaCIsImxvY2FsaXplZFN0cmluZyIsInByb3BlcnR5IiwidmFsdWUiLCJzdHJpbmdLZXlUb1RhbmRlbU5hbWUiLCJrZXkiLCJyZXBsYWNlIiwid29yZCIsInRvVXBwZXJDYXNlIiwiU3RyaW5nU3RhdGVJT1R5cGUiLCJ2YWx1ZVR5cGUiLCJ0b1N0YXRlT2JqZWN0IiwiZGF0YSIsInN0YXRlIiwiZ2V0U3RhdGVEZWx0YSIsIk9iamVjdCIsImtleXMiLCJsZW5ndGgiLCJ0YW5kZW0iLCJwaGV0aW9JRCIsInN0YXRlU2NoZW1hIiwiYXBwbHlTdGF0ZSIsImlnbm9yZWQiLCJtYXRjaCIsImZpbmQiLCJzZXRTdGF0ZURlbHRhIiwiY3JlYXRlIiwicGhldGlvVHlwZSIsIkdFTkVSQUxfTU9ERUwiLCJjcmVhdGVUYW5kZW0iLCJwaGV0aW9Eb2N1bWVudGF0aW9uIiwicGhldGlvU3RhdGUiLCJnZXRTdHJpbmdNb2R1bGUiLCJyZXF1aXJlanNOYW1lc3BhY2UiLCJhc3NlcnQiLCJsb2NhbGUiLCJsb2NhbGVEYXRhIiwiaW5jbHVkZXMiLCJzdHJpbmdzIiwic3RyaW5nS2V5UHJlZml4IiwiYWxsU3RyaW5nS2V5c0luUmVwbyIsImZpbHRlciIsInN0cmluZ0tleSIsInN0YXJ0c1dpdGgiLCJ1c2VkU3RyaW5nc0VOIiwiaGFzT3duUHJvcGVydHkiLCJsb2NhbGl6ZWRTdHJpbmdNYXAiLCJzdHJpbmdNb2R1bGUiLCJzdHJpbmdLZXlXaXRob3V0UHJlZml4Iiwic2xpY2UiLCJrZXlQYXJ0cyIsInNwbGl0IiwibGFzdEtleVBhcnQiLCJhbGxCdXRMYXN0S2V5UGFydCIsInJlZmVyZW5jZSIsInBhcnRpYWxLZXkiLCJrZXlQYXJ0IiwiaSIsIlNUUklOR1MiLCJfIiwiY2FtZWxDYXNlIiwidGFuZGVtTmFtZSIsImN1cnJlbnRUYW5kZW1OYW1lIiwiaiIsInRhbmRlbU5hbWVUYWtlbiIsImhhc0NoaWxkIiwiT1BUX09VVCIsImxvY2FsZVRvVHJhbnNsYXRpb25NYXAiLCJzdHJpbmciLCJtYXBTdHJpbmciLCJzdHJpbmdNZXRhZGF0YSIsImxpbmsiXSwic291cmNlcyI6WyJnZXRTdHJpbmdNb2R1bGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMjAtMjAyNCwgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXHJcblxyXG4vKipcclxuICogR2l2ZW4gYSByZXF1aXJlanNOYW1lc3BhY2UsIHdlIGZpbHRlciBvdXQgc3RyaW5ncyBmcm9tIHBoZXQuY2hpcHBlci5zdHJpbmdzIHRoYXQgc3RhcnQgd2l0aCBpdCwgYW5kIGNvbnN0cnVjdCBhblxyXG4gKiBvYmplY3Qgd2l0aCBsb2NhbGUgZmFsbGJhY2tzIGFscmVhZHkgcHJlLWNvbXB1dGVkLCBzbyB0aGF0IHRoZSBjb3JyZWN0IHN0cmluZ3MgY2FuIGJlIGFjY2Vzc2VkIHZpYSBvYmplY3QgbGl0ZXJhbFxyXG4gKiBhY2Nlc3MsIGUuZy4gZ2V0U3RyaW5nTW9kdWxlKCAnSk9JU1QnICkuUmVzZXRBbGxCdXR0b24ubmFtZSB3aWxsIGdpdmUgdGhlIGRlc2lyZWQgc3RyaW5nIHZhbHVlIGZvciB3aGF0ZXZlciBsb2NhbGVcclxuICogdGhlIHNpbSBpcyBiZWluZyBydW4gd2l0aC5cclxuICpcclxuICogQSBzdHJpbmcgXCJrZXlcIiBpcyBpbiB0aGUgZm9ybSBvZiBcIk5BTUVTUEFDRS9rZXkuZnJvbS5zdHJpbmdzLmpzb25cIlxyXG4gKlxyXG4gKiBOT1RFOiBUaGlzIGZpbGUgbGlrZWx5IGJlbG9uZ3MgaW4gam9pc3QvanMvaTE4bi8sIGJ1dCBzaG91bGQgc3RheSBoZXJlIHRvIG1ha2UgbWFpbnRlbmFuY2UtcmVsZWFzZSBtYWludGFpbmFiaWxpdHkgZWFzaWVyLlxyXG4gKlxyXG4gKiBAYXV0aG9yIEpvbmF0aGFuIE9sc29uIDxqb25hdGhhbi5vbHNvbj5cclxuICovXHJcblxyXG5pbXBvcnQgUGhldGlvT2JqZWN0IGZyb20gJy4uLy4uL3RhbmRlbS9qcy9QaGV0aW9PYmplY3QuanMnO1xyXG5pbXBvcnQgVGFuZGVtIGZyb20gJy4uLy4uL3RhbmRlbS9qcy9UYW5kZW0uanMnO1xyXG5pbXBvcnQgQ291bGROb3RZZXREZXNlcmlhbGl6ZUVycm9yIGZyb20gJy4uLy4uL3RhbmRlbS9qcy9Db3VsZE5vdFlldERlc2VyaWFsaXplRXJyb3IuanMnO1xyXG5pbXBvcnQgSU9UeXBlIGZyb20gJy4uLy4uL3RhbmRlbS9qcy90eXBlcy9JT1R5cGUuanMnO1xyXG5pbXBvcnQgT2JqZWN0TGl0ZXJhbElPIGZyb20gJy4uLy4uL3RhbmRlbS9qcy90eXBlcy9PYmplY3RMaXRlcmFsSU8uanMnO1xyXG5pbXBvcnQgTG9jYWxpemVkU3RyaW5nLCB7IExvY2FsaXplZFN0cmluZ1N0YXRlRGVsdGEsIFN0cmluZ3NTdGF0ZVN0YXRlT2JqZWN0IH0gZnJvbSAnLi9Mb2NhbGl6ZWRTdHJpbmcuanMnO1xyXG5pbXBvcnQgVFJlYWRPbmx5UHJvcGVydHkgZnJvbSAnLi4vLi4vYXhvbi9qcy9UUmVhZE9ubHlQcm9wZXJ0eS5qcyc7XHJcbmltcG9ydCB7IExvY2FsZSB9IGZyb20gJy4uLy4uL2pvaXN0L2pzL2kxOG4vbG9jYWxlUHJvcGVydHkuanMnO1xyXG5pbXBvcnQgeyBQaGV0aW9JRCB9IGZyb20gJy4uLy4uL3RhbmRlbS9qcy9UYW5kZW1Db25zdGFudHMuanMnO1xyXG5cclxuLy8gY29uc3RhbnRzXHJcbmNvbnN0IEZBTExCQUNLX0xPQ0FMRSA9ICdlbic7XHJcblxyXG4vLyBIb2xkcyBhbGwgb2Ygb3VyIGxvY2FsaXplZFN0cmluZ3MsIHNvIHRoYXQgd2UgY2FuIHNhdmUgb3VyIHBoZXQtaW8gc3RyaW5nIGNoYW5nZSBzdGF0ZVxyXG5leHBvcnQgY29uc3QgbG9jYWxpemVkU3RyaW5nczogTG9jYWxpemVkU3RyaW5nW10gPSBbXTtcclxuXHJcbi8vIEZvciBkZXZlbG9wZXIgaW50ZXJuYWwgdXNlLCBwYXJ0aWN1bGFybHkgZm9yIG1lbW9yeSBsZWFrIGRldGVjdGlvblxyXG4vLyBlLmcuIF8ubWF4KCBwaGV0LmNoaXBwZXIubG9jYWxpemVkU3RyaW5ncy5tYXAoIGxzID0+IGxzLnByb3BlcnR5LnRpbnlQcm9wZXJ0eS5saXN0ZW5lcnMuc2l6ZSApICkgdG8gc2VlIGlmIHRoZXJlIGlzXHJcbi8vIGxpa2VseSBhIGxlYWtcclxud2luZG93LnBoZXQuY2hpcHBlci5sb2NhbGl6ZWRTdHJpbmdzID0gbG9jYWxpemVkU3RyaW5ncztcclxuXHJcbi8vIEZvciBkZXZlbG9wZXIgaW50ZXJuYWwgdXNlLCBzaW1pbGFyIHRvIHRoZSBzdHJpbmdUZXN0IHF1ZXJ5IHBhcmFtZXRlclxyXG53aW5kb3cucGhldC5jaGlwcGVyLnNldEFsbFN0cmluZ3MgPSAoIHN0cjogc3RyaW5nICkgPT4ge1xyXG4gIGxvY2FsaXplZFN0cmluZ3MuZm9yRWFjaCggbG9jYWxpemVkU3RyaW5nID0+IHtcclxuICAgIGxvY2FsaXplZFN0cmluZy5wcm9wZXJ0eS52YWx1ZSA9IHN0cjtcclxuICB9ICk7XHJcbn07XHJcblxyXG5jb25zdCBzdHJpbmdLZXlUb1RhbmRlbU5hbWUgPSAoIGtleTogc3RyaW5nICkgPT4ge1xyXG4gIHJldHVybiBrZXkucmVwbGFjZSggLyg/OlstX1xcc11cXHcpL2csIHdvcmQgPT4gd29yZFsgMSBdLnRvVXBwZXJDYXNlKCkgKTtcclxufTtcclxuXHJcbmNvbnN0IFN0cmluZ1N0YXRlSU9UeXBlID0gbmV3IElPVHlwZTxQaGV0aW9PYmplY3QsIFN0cmluZ3NTdGF0ZVN0YXRlT2JqZWN0PiggJ1N0cmluZ1N0YXRlSU8nLCB7XHJcbiAgdmFsdWVUeXBlOiBQaGV0aW9PYmplY3QsXHJcbiAgdG9TdGF0ZU9iamVjdDogKCk6IFN0cmluZ3NTdGF0ZVN0YXRlT2JqZWN0ID0+IHtcclxuICAgIGNvbnN0IGRhdGE6IFJlY29yZDxQaGV0aW9JRCwgTG9jYWxpemVkU3RyaW5nU3RhdGVEZWx0YT4gPSB7fTtcclxuXHJcbiAgICBsb2NhbGl6ZWRTdHJpbmdzLmZvckVhY2goIGxvY2FsaXplZFN0cmluZyA9PiB7XHJcbiAgICAgIGNvbnN0IHN0YXRlID0gbG9jYWxpemVkU3RyaW5nLmdldFN0YXRlRGVsdGEoKTtcclxuXHJcbiAgICAgIC8vIE9ubHkgY3JlYXRlIGFuIGVudHJ5IGlmIHRoZXJlIGlzIGFueXRoaW5nICh3ZSBjYW4gc2F2ZSBieXRlcyBieSBub3QgaW5jbHVkaW5nIHRoZSB0YW5kZW0gaGVyZSlcclxuICAgICAgaWYgKCBPYmplY3Qua2V5cyggc3RhdGUgKS5sZW5ndGggPiAwICkge1xyXG4gICAgICAgIGRhdGFbIGxvY2FsaXplZFN0cmluZy5wcm9wZXJ0eS50YW5kZW0ucGhldGlvSUQgXSA9IHN0YXRlO1xyXG4gICAgICB9XHJcbiAgICB9ICk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBkYXRhOiBkYXRhIC8vIERhdGEgbmVzdGVkIGZvciBhIHZhbGlkIHNjaGVtYVxyXG4gICAgfTtcclxuICB9LFxyXG4gIHN0YXRlU2NoZW1hOiB7XHJcbiAgICBkYXRhOiBPYmplY3RMaXRlcmFsSU9cclxuICB9LFxyXG4gIGFwcGx5U3RhdGU6ICggaWdub3JlZCwgc3RhdGUgKSA9PiB7XHJcblxyXG4gICAgLy8gRXZlcnkgc3RyaW5nIGluIHN0YXRlIGhhcyB0byBiZSBpbiBsb2NhbGl6ZWRTdHJpbmdzIHRvIGNvbnRpbnVlXHJcbiAgICBPYmplY3Qua2V5cyggc3RhdGUuZGF0YSApLmZvckVhY2goIHBoZXRpb0lEID0+IHtcclxuICAgICAgY29uc3QgbWF0Y2ggPSBsb2NhbGl6ZWRTdHJpbmdzLmZpbmQoIGxvY2FsaXplZFN0cmluZyA9PiBsb2NhbGl6ZWRTdHJpbmcucHJvcGVydHkudGFuZGVtLnBoZXRpb0lEID09PSBwaGV0aW9JRCApO1xyXG5cclxuICAgICAgLy8gV2hlbiBQaGV0aW9EeW5hbWljRWxlbWVudENvbnRhaW5lciBlbGVtZW50cyBzdWNoIGFzIFBoZXRpb0dyb3VwIG1lbWJlcnMgYWRkIGxvY2FsaXplZFN0cmluZ3MsIHdlIHdhaXQgdW50aWxcclxuICAgICAgLy8gYWxsIG9mIHRoZSBtZW1iZXJzIGhhdmUgYmVlbiBjcmVhdGVkIChwb3B1bGF0aW5nIGxvY2FsaXplZFN0cmluZ3MpIGJlZm9yZSB0cnlpbmcgdG8gc2V0IGFueSBvZiB0aGUgc3RyaW5ncy5cclxuICAgICAgaWYgKCAhbWF0Y2ggKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IENvdWxkTm90WWV0RGVzZXJpYWxpemVFcnJvcigpO1xyXG4gICAgICB9XHJcbiAgICB9ICk7XHJcblxyXG4gICAgLy8gV2UgbmVlZCB0byBpdGVyYXRlIHRocm91Z2ggZXZlcnkgc3RyaW5nIGluIHRoaXMgcnVudGltZSwgc2luY2UgaXQgbWlnaHQgbmVlZCB0byByZXZlcnQgYmFjayB0byBcImluaXRpYWxcIiBzdGF0ZS5cclxuICAgIGxvY2FsaXplZFN0cmluZ3MuZm9yRWFjaCggbG9jYWxpemVkU3RyaW5nID0+IHtcclxuICAgICAgbG9jYWxpemVkU3RyaW5nLnNldFN0YXRlRGVsdGEoIHN0YXRlLmRhdGFbIGxvY2FsaXplZFN0cmluZy5wcm9wZXJ0eS50YW5kZW0ucGhldGlvSUQgXSB8fCB7fSApO1xyXG4gICAgfSApO1xyXG4gIH1cclxufSApO1xyXG5cclxuUGhldGlvT2JqZWN0LmNyZWF0ZSgge1xyXG4gIHBoZXRpb1R5cGU6IFN0cmluZ1N0YXRlSU9UeXBlLFxyXG4gIHRhbmRlbTogVGFuZGVtLkdFTkVSQUxfTU9ERUwuY3JlYXRlVGFuZGVtKCAnc3RyaW5nc1N0YXRlJyApLFxyXG4gIHBoZXRpb0RvY3VtZW50YXRpb246ICdTdHJpbmdzIHRoYXQgaGF2ZSBjaGFuZ2VkIGZyb20gdGhlaXIgaW5pdGlhbCB2YWx1ZXMuIEVhY2ggc3RyaW5nIHZhbHVlIGlzIHNwZWNpZmljIHRvIHRoZSBsb2NhbGUgaXQgY2hhbmdlZCBpbi4nLFxyXG4gIHBoZXRpb1N0YXRlOiB0cnVlXHJcbn0gKTtcclxuXHJcbnR5cGUgVFN0cmluZ01vZHVsZSA9IHtcclxuICBbIGtleTogc3RyaW5nIF06IFRTdHJpbmdNb2R1bGUgfCBzdHJpbmcgfCBUUmVhZE9ubHlQcm9wZXJ0eTxzdHJpbmc+O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSByZXF1aXJlanNOYW1lc3BhY2UgLSBFLmcuICdKT0lTVCcsIHRvIHB1bGwgc3RyaW5nIGtleXMgb3V0IGZyb20gdGhhdCBuYW1lc3BhY2VcclxuICogQHJldHVybnMgTmVzdGVkIG9iamVjdCB0byBiZSBhY2Nlc3NlZCBsaWtlIEpvaXN0U3RyaW5ncy5SZXNldEFsbEJ1dHRvbi5uYW1lXHJcbiAqL1xyXG5jb25zdCBnZXRTdHJpbmdNb2R1bGUgPSAoIHJlcXVpcmVqc05hbWVzcGFjZTogc3RyaW5nICk6IG9iamVjdCA9PiB7XHJcbiAgLy8gT3VyIHN0cmluZyBpbmZvcm1hdGlvbiBpcyBwdWxsZWQgZ2xvYmFsbHksIGUuZy4gcGhldC5jaGlwcGVyLnN0cmluZ3NbIGxvY2FsZSBdWyBzdHJpbmdLZXkgXSA9IHN0cmluZ1ZhbHVlO1xyXG4gIC8vIE91ciBsb2NhbGUgaW5mb3JtYXRpb24gaXMgZnJvbSBwaGV0LmNoaXBwZXIubG9jYWxlXHJcblxyXG4gIGFzc2VydCAmJiBhc3NlcnQoIHR5cGVvZiBwaGV0LmNoaXBwZXIubG9jYWxlID09PSAnc3RyaW5nJywgJ3BoZXQuY2hpcHBlci5sb2NhbGUgc2hvdWxkIGhhdmUgYmVlbiBsb2FkZWQgYnkgbm93JyApO1xyXG4gIGFzc2VydCAmJiBhc3NlcnQoIE9iamVjdC5rZXlzKCBwaGV0LmNoaXBwZXIubG9jYWxlRGF0YSApLmluY2x1ZGVzKCBwaGV0LmNoaXBwZXIubG9jYWxlICksICdwaGV0LmNoaXBwZXIubG9jYWxlIHNob3VsZCBoYXZlIGJlZW4gbG9hZGVkIGJ5IG5vdycgKTtcclxuICBhc3NlcnQgJiYgYXNzZXJ0KCBwaGV0LmNoaXBwZXIuc3RyaW5ncywgJ3BoZXQuY2hpcHBlci5zdHJpbmdzIHNob3VsZCBoYXZlIGJlZW4gbG9hZGVkIGJ5IG5vdycgKTtcclxuXHJcbiAgLy8gQ29uc3RydWN0IGxvY2FsZXMgaW4gaW5jcmVhc2luZyBzcGVjaWZpY2l0eSwgZS5nLiBbICdlbicsICd6aCcsICd6aF9DTicgXSwgc28gd2UgZ2V0IGZhbGxiYWNrcyBpbiBvcmRlclxyXG4gIC8vIGNvbnN0IGxvY2FsZXMgPSBbIEZBTExCQUNLX0xPQ0FMRSBdO1xyXG4gIGNvbnN0IHN0cmluZ0tleVByZWZpeCA9IGAke3JlcXVpcmVqc05hbWVzcGFjZX0vYDtcclxuXHJcbiAgLy8gV2UgbWF5IGhhdmUgb3RoZXIgb2xkZXIgKHVudXNlZCkga2V5cyBpbiBiYWJlbCwgYW5kIHdlIGFyZSBvbmx5IGRvaW5nIHRoZSBzZWFyY2ggdGhhdCBtYXR0ZXJzIHdpdGggdGhlIEVuZ2xpc2hcclxuICAvLyBzdHJpbmcga2V5cy5cclxuICBsZXQgYWxsU3RyaW5nS2V5c0luUmVwbyA9IE9iamVjdC5rZXlzKCBwaGV0LmNoaXBwZXIuc3RyaW5nc1sgRkFMTEJBQ0tfTE9DQUxFIF0gKS5maWx0ZXIoIHN0cmluZ0tleSA9PiBzdHJpbmdLZXkuc3RhcnRzV2l0aCggc3RyaW5nS2V5UHJlZml4ICkgKTtcclxuXHJcbiAgLy8gVE9ETzogaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL3BoZXQtaW8vaXNzdWVzLzE4NzcgV2hhdCBpZiB0aGlzIGxpc3QgZG9lc24ndCBleGlzdD8gIFNob3VsZCB0aGF0IGJlIGFuIGVycm9yP1xyXG4gIC8vIE9yIGFuIGVycm9yIGlmIHJ1bm5pbmcgYW4gYXBpLXN0YWJsZSBwaGV0LWlvIHNpbT9cclxuICAvLyBUT0RPOiBodHRwczovL2dpdGh1Yi5jb20vcGhldHNpbXMvcGhldC1pby9pc3N1ZXMvMTg3NyBXaGF0IHdpbGwgaGFwcGVuIGlmIHRoaXMgaXMgc3RhbGU/IEhvdyB3aWxsIGEgZGV2ZWxvcGVyIGtub3dcclxuICAvLyB0byB1cGRhdGUgaXQ/IFNob3VsZCBpdCBydW4gaW4gZGFpbHktZ3J1bnQtd29yaz9cclxuICBpZiAoIHBoZXQuY2hpcHBlci51c2VkU3RyaW5nc0VOICkge1xyXG4gICAgYWxsU3RyaW5nS2V5c0luUmVwbyA9IGFsbFN0cmluZ0tleXNJblJlcG8uZmlsdGVyKCBzdHJpbmdLZXkgPT4gcGhldC5jaGlwcGVyLnVzZWRTdHJpbmdzRU4uaGFzT3duUHJvcGVydHkoIHN0cmluZ0tleSApICk7XHJcbiAgfVxyXG5cclxuICAvLyBsb2NhbGl6ZWRTdHJpbmdNYXBbIHN0cmluZ0tleSBdXHJcbiAgY29uc3QgbG9jYWxpemVkU3RyaW5nTWFwOiBSZWNvcmQ8c3RyaW5nLCBMb2NhbGl6ZWRTdHJpbmc+ID0ge307XHJcblxyXG4gIGNvbnN0IHN0cmluZ01vZHVsZTogVFN0cmluZ01vZHVsZSA9IHt9O1xyXG5cclxuICBhbGxTdHJpbmdLZXlzSW5SZXBvLmZvckVhY2goIHN0cmluZ0tleSA9PiB7XHJcbiAgICAvLyBzdHJpcCBvZmYgdGhlIHJlcXVpcmVqc05hbWVzcGFjZSwgZS5nLiAnSk9JU1QvUmVzZXRBbGxCdXR0b24ubmFtZScgPT4gJ1Jlc2V0QWxsQnV0dG9uLm5hbWUnXHJcbiAgICBjb25zdCBzdHJpbmdLZXlXaXRob3V0UHJlZml4ID0gc3RyaW5nS2V5LnNsaWNlKCBzdHJpbmdLZXlQcmVmaXgubGVuZ3RoICk7XHJcblxyXG4gICAgY29uc3Qga2V5UGFydHMgPSBzdHJpbmdLZXlXaXRob3V0UHJlZml4LnNwbGl0KCAnLicgKTtcclxuICAgIGNvbnN0IGxhc3RLZXlQYXJ0ID0ga2V5UGFydHNbIGtleVBhcnRzLmxlbmd0aCAtIDEgXTtcclxuICAgIGNvbnN0IGFsbEJ1dExhc3RLZXlQYXJ0ID0ga2V5UGFydHMuc2xpY2UoIDAsIGtleVBhcnRzLmxlbmd0aCAtIDEgKTtcclxuXHJcbiAgICAvLyBEdXJpbmcgdHJhdmVyc2FsIGludG8gdGhlIHN0cmluZyBvYmplY3QsIHRoaXMgd2lsbCBob2xkIHRoZSBvYmplY3Qgd2hlcmUgdGhlIG5leHQgbGV2ZWwgbmVlZHMgdG8gYmUgZGVmaW5lZCxcclxuICAgIC8vIHdoZXRoZXIgdGhhdCdzIGFub3RoZXIgY2hpbGQgb2JqZWN0LCBvciB0aGUgc3RyaW5nIHZhbHVlIGl0c2VsZi5cclxuICAgIGxldCByZWZlcmVuY2U6IFRTdHJpbmdNb2R1bGUgPSBzdHJpbmdNb2R1bGU7XHJcblxyXG4gICAgLy8gV2UnbGwgdHJhdmVyc2UgZG93biB0aHJvdWdoIHRoZSBwYXJ0cyBvZiBhIHN0cmluZyBrZXkgKHNlcGFyYXRlZCBieSAnLicpLCBjcmVhdGluZyBhIG5ldyBsZXZlbCBpbiB0aGVcclxuICAgIC8vIHN0cmluZyBvYmplY3QgZm9yIGVhY2ggb25lLiBUaGlzIGlzIGRvbmUgZm9yIGFsbCBCVVQgdGhlIGxhc3QgcGFydCwgc2luY2Ugd2UnbGwgd2FudCB0byBhc3NpZ24gdGhlIHJlc3VsdFxyXG4gICAgLy8gb2YgdGhhdCB0byBhIHJhdyBzdHJpbmcgdmFsdWUgKHJhdGhlciB0aGFuIGFuIG9iamVjdCkuXHJcbiAgICBsZXQgcGFydGlhbEtleSA9IHN0cmluZ0tleVByZWZpeDtcclxuICAgIGFsbEJ1dExhc3RLZXlQYXJ0LmZvckVhY2goICgga2V5UGFydCwgaSApID0+IHtcclxuICAgICAgLy8gV2hlbiBjb25jYXRlbmF0aW5nIGVhY2ggbGV2ZWwgaW50byB0aGUgZmluYWwgc3RyaW5nIGtleSwgd2UgZG9uJ3Qgd2FudCB0byBwdXQgYSAnLicgZGlyZWN0bHkgYWZ0ZXIgdGhlXHJcbiAgICAgIC8vIHNsYXNoLCBiZWNhdXNlIGBKT0lTVC8uUmVzZXRBbGxCdXR0b24ubmFtZWAgd291bGQgYmUgaW52YWxpZC5cclxuICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waGV0c2ltcy9jaGlwcGVyL2lzc3Vlcy85MjJcclxuICAgICAgcGFydGlhbEtleSArPSBgJHtpID4gMCA/ICcuJyA6ICcnfSR7a2V5UGFydH1gO1xyXG5cclxuICAgICAgLy8gRG9uJ3QgYWxsb3cgZS5nLiBKT0lTVC9hIGFuZCBKT0lTVC9hLmIsIHNpbmNlIGxvY2FsZU9iamVjdC5hIHdvdWxkIG5lZWQgdG8gYmUgYSBzdHJpbmcgQU5EIGFuIG9iamVjdCBhdCB0aGVcclxuICAgICAgLy8gc2FtZSB0aW1lLlxyXG4gICAgICBhc3NlcnQgJiYgYXNzZXJ0KCB0eXBlb2YgcmVmZXJlbmNlWyBrZXlQYXJ0IF0gIT09ICdzdHJpbmcnLFxyXG4gICAgICAgICdJdCBpcyBub3QgYWxsb3dlZCB0byBoYXZlIHR3byBkaWZmZXJlbnQgc3RyaW5nIGtleXMgd2hlcmUgb25lIGlzIGV4dGVuZGVkIGJ5IGFkZGluZyBhIHBlcmlvZCAoLikgYXQgdGhlIGVuZCAnICtcclxuICAgICAgICBgb2YgdGhlIG90aGVyLiBUaGUgc3RyaW5nIGtleSAke3BhcnRpYWxLZXl9IGlzIGV4dGVuZGVkIGJ5ICR7c3RyaW5nS2V5fSBpbiB0aGlzIGNhc2UsIGFuZCBzaG91bGQgYmUgY2hhbmdlZC5gICk7XHJcblxyXG4gICAgICAvLyBDcmVhdGUgdGhlIG5leHQgbmVzdGVkIGxldmVsLCBhbmQgbW92ZSBpbnRvIGl0XHJcbiAgICAgIGlmICggIXJlZmVyZW5jZVsga2V5UGFydCBdICkge1xyXG4gICAgICAgIHJlZmVyZW5jZVsga2V5UGFydCBdID0ge307XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJlZmVyZW5jZSA9IHJlZmVyZW5jZVsga2V5UGFydCBdIGFzIFRTdHJpbmdNb2R1bGU7IC8vIHNpbmNlIHdlIGFyZSBvbiBhbGwgYnV0IHRoZSBsYXN0IGtleSBwYXJ0LCBpdCBjYW5ub3QgYmUgc3RyaW5nbGlrZVxyXG4gICAgfSApO1xyXG5cclxuICAgIGFzc2VydCAmJiBhc3NlcnQoIHR5cGVvZiByZWZlcmVuY2VbIGxhc3RLZXlQYXJ0IF0gIT09ICdvYmplY3QnLFxyXG4gICAgICAnSXQgaXMgbm90IGFsbG93ZWQgdG8gaGF2ZSB0d28gZGlmZmVyZW50IHN0cmluZyBrZXlzIHdoZXJlIG9uZSBpcyBleHRlbmRlZCBieSBhZGRpbmcgYSBwZXJpb2QgKC4pIGF0IHRoZSBlbmQgJyArXHJcbiAgICAgIGBvZiB0aGUgb3RoZXIuIFRoZSBzdHJpbmcga2V5ICR7c3RyaW5nS2V5fSBpcyBleHRlbmRlZCBieSBhbm90aGVyIGtleSwgc29tZXRoaW5nIGNvbnRhaW5pbmcgJHtyZWZlcmVuY2VbIGxhc3RLZXlQYXJ0IF0gJiYgT2JqZWN0LmtleXMoIHJlZmVyZW5jZVsgbGFzdEtleVBhcnQgXSApfS5gICk7XHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCAhcmVmZXJlbmNlWyBsYXN0S2V5UGFydCBdLFxyXG4gICAgICBgV2Ugc2hvdWxkIG5vdCBoYXZlIGRlZmluZWQgdGhpcyBwbGFjZSBpbiB0aGUgb2JqZWN0ICgke3N0cmluZ0tleX0pLCBvdGhlcndpc2UgaXQgbWVhbnMgYSBkdXBsaWNhdGVkIHN0cmluZyBrZXkgT1IgZXh0ZW5kZWQgc3RyaW5nIGtleWAgKTtcclxuXHJcbiAgICAvLyBJbiBjYXNlIG91ciBhc3NlcnRpb25zIGFyZSBub3QgZW5hYmxlZCwgd2UnbGwgbmVlZCB0byBwcm9jZWVkIHdpdGhvdXQgZmFpbGluZyBvdXQgKHNvIHdlIGFsbG93IGZvciB0aGVcclxuICAgIC8vIGV4dGVuZGVkIHN0cmluZyBrZXlzIGluIG91ciBhY3R1YWwgY29kZSwgZXZlbiB0aG91Z2ggYXNzZXJ0aW9ucyBzaG91bGQgcHJldmVudCB0aGF0KS5cclxuICAgIGlmICggdHlwZW9mIHJlZmVyZW5jZSAhPT0gJ3N0cmluZycgKSB7XHJcbiAgICAgIGxldCB0YW5kZW0gPSBUYW5kZW0uU1RSSU5HUy5jcmVhdGVUYW5kZW0oIF8uY2FtZWxDYXNlKCByZXF1aXJlanNOYW1lc3BhY2UgKSApO1xyXG4gICAgICBmb3IgKCBsZXQgaSA9IDA7IGkgPCBrZXlQYXJ0cy5sZW5ndGg7IGkrKyApIHtcclxuXHJcbiAgICAgICAgbGV0IHRhbmRlbU5hbWUgPSBzdHJpbmdLZXlUb1RhbmRlbU5hbWUoIGtleVBhcnRzWyBpIF0gKTtcclxuXHJcbiAgICAgICAgLy8gSWYgaXQgaXMgdGhlIHRhaWwgb2YgdGhlIHN0cmluZyBrZXksIHRoZW4gbWFrZSB0aGUgdGFuZGVtIGJlIGEgXCIqU3RyaW5nUHJvcGVydHlcIlxyXG4gICAgICAgIGlmICggaSA9PT0ga2V5UGFydHMubGVuZ3RoIC0gMSApIHtcclxuXHJcbiAgICAgICAgICBsZXQgY3VycmVudFRhbmRlbU5hbWUgPSB0YW5kZW1OYW1lO1xyXG4gICAgICAgICAgbGV0IGogPSAwO1xyXG4gICAgICAgICAgbGV0IHRhbmRlbU5hbWVUYWtlbiA9IHRydWU7XHJcblxyXG4gICAgICAgICAgLy8gSGFuZGxlIHRoZSBjYXNlIHdoZXJlIHR3byB1bmlxdWUgc3RyaW5nIGtleXMgbWFwIHRvIHRoZSBzYW1lIGNhbWVsIGNhc2UgdmFsdWUsIGkuZS4gXCJTb2xpZFwiIGFuZCBcInNvbGlkXCIuXHJcbiAgICAgICAgICAvLyBIZXJlIHdlIHdpbGwgYmUgc29saWRTdHJpbmdQcm9wZXJ0eSBhbmQgc29saWQyU3RyaW5nUHJvcGVydHlcclxuICAgICAgICAgIHdoaWxlICggdGFuZGVtTmFtZVRha2VuICkge1xyXG4gICAgICAgICAgICBqKys7XHJcblxyXG4gICAgICAgICAgICBjdXJyZW50VGFuZGVtTmFtZSA9IGAke3RhbmRlbU5hbWV9JHtqID09PSAxID8gJycgOiBqfVN0cmluZ1Byb3BlcnR5YDtcclxuXHJcbiAgICAgICAgICAgIHRhbmRlbU5hbWVUYWtlbiA9IHRhbmRlbS5oYXNDaGlsZCggY3VycmVudFRhbmRlbU5hbWUgKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHRhbmRlbU5hbWUgPSBjdXJyZW50VGFuZGVtTmFtZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRhbmRlbSA9IHRhbmRlbS5jcmVhdGVUYW5kZW0oIHRhbmRlbU5hbWUgKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gc3RyaW5ncyBuZXN0ZWQgdW5kZXIgdGhlIGExMXkgc2VjdGlvbiBhcmUgbm90IGN1cnJlbnRseSBQaEVULWlPIGluc3RydW1lbnRlZCwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waGV0c2ltcy9jaGlwcGVyL2lzc3Vlcy8xMzUyXHJcbiAgICAgIGlmICggdGFuZGVtLnBoZXRpb0lELmluY2x1ZGVzKCAnLmExMXkuJyApICkge1xyXG4gICAgICAgIHRhbmRlbSA9IFRhbmRlbS5PUFRfT1VUO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBsb2NhbGVUb1RyYW5zbGF0aW9uTWFwOiBMb2NhbGl6ZWRTdHJpbmdTdGF0ZURlbHRhID0ge307XHJcbiAgICAgICggT2JqZWN0LmtleXMoIHBoZXQuY2hpcHBlci5zdHJpbmdzICkgYXMgTG9jYWxlW10gKS5mb3JFYWNoKCAoIGxvY2FsZTogTG9jYWxlICkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHN0cmluZzogc3RyaW5nID0gcGhldC5jaGlwcGVyLnN0cmluZ3NbIGxvY2FsZSBdWyBzdHJpbmdLZXkgXTtcclxuICAgICAgICAvLyBJZ25vcmUgemVyby1sZW5ndGggc3RyaW5ncywgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waGV0c2ltcy9jaGlwcGVyL2lzc3Vlcy8xMzQzXHJcbiAgICAgICAgaWYgKCBsb2NhbGUgPT09IEZBTExCQUNLX0xPQ0FMRSB8fCAoIHR5cGVvZiBzdHJpbmcgPT09ICdzdHJpbmcnICYmIHN0cmluZyAhPT0gJycgKSApIHtcclxuICAgICAgICAgIGxvY2FsZVRvVHJhbnNsYXRpb25NYXBbIGxvY2FsZSBdID0gcGhldC5jaGlwcGVyLm1hcFN0cmluZyggc3RyaW5nICk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9ICk7XHJcblxyXG4gICAgICBjb25zdCBsb2NhbGl6ZWRTdHJpbmcgPSBuZXcgTG9jYWxpemVkU3RyaW5nKFxyXG4gICAgICAgIHN0cmluZ0tleSxcclxuICAgICAgICBsb2NhbGVUb1RyYW5zbGF0aW9uTWFwLFxyXG4gICAgICAgIHRhbmRlbSxcclxuICAgICAgICBwaGV0LmNoaXBwZXIuc3RyaW5nTWV0YWRhdGFbIHN0cmluZ0tleSBdXHJcbiAgICAgICk7XHJcbiAgICAgIGxvY2FsaXplZFN0cmluZ01hcFsgc3RyaW5nS2V5IF0gPSBsb2NhbGl6ZWRTdHJpbmc7XHJcblxyXG4gICAgICAvLyBQdXQgb3VyIFByb3BlcnR5IGluIHRoZSBzdHJpbmdNb2R1bGVcclxuICAgICAgcmVmZXJlbmNlWyBgJHtsYXN0S2V5UGFydH1TdHJpbmdQcm9wZXJ0eWAgXSA9IGxvY2FsaXplZFN0cmluZy5wcm9wZXJ0eTtcclxuXHJcbiAgICAgIC8vIENoYW5nZSBvdXIgc3RyaW5nTW9kdWxlIGJhc2VkIG9uIHRoZSBQcm9wZXJ0eSB2YWx1ZVxyXG4gICAgICBsb2NhbGl6ZWRTdHJpbmcucHJvcGVydHkubGluayggc3RyaW5nID0+IHtcclxuICAgICAgICByZWZlcmVuY2VbIGxhc3RLZXlQYXJ0IF0gPSBzdHJpbmc7XHJcbiAgICAgIH0gKTtcclxuICAgIH1cclxuICB9ICk7XHJcblxyXG4gIHJldHVybiBzdHJpbmdNb2R1bGU7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBnZXRTdHJpbmdNb2R1bGU7Il0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBT0EsWUFBWSxNQUFNLGlDQUFpQztBQUMxRCxPQUFPQyxNQUFNLE1BQU0sMkJBQTJCO0FBQzlDLE9BQU9DLDJCQUEyQixNQUFNLGdEQUFnRDtBQUN4RixPQUFPQyxNQUFNLE1BQU0saUNBQWlDO0FBQ3BELE9BQU9DLGVBQWUsTUFBTSwwQ0FBMEM7QUFDdEUsT0FBT0MsZUFBZSxNQUE4RCxzQkFBc0I7QUFLMUc7QUFDQSxNQUFNQyxlQUFlLEdBQUcsSUFBSTs7QUFFNUI7QUFDQSxPQUFPLE1BQU1DLGdCQUFtQyxHQUFHLEVBQUU7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBQyxNQUFNLENBQUNDLElBQUksQ0FBQ0MsT0FBTyxDQUFDSCxn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