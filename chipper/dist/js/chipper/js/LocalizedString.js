// Copyright 2022-2024, University of Colorado Boulder

/**
 * Sets up a system of Properties to handle translation fallback and phet-io support for a single translated string.
 *
 * @author Jonathan Olson <jonathan.olson>
 */

import TinyProperty from '../../axon/js/TinyProperty.js';
import chipper from './chipper.js';
import { localizedStrings } from './getStringModule.js';
import arrayRemove from '../../phet-core/js/arrayRemove.js';
import LocalizedStringProperty from './LocalizedStringProperty.js';

// constants
const FALLBACK_LOCALE = 'en';

// for readability/docs

// Where "string" is a phetioID

const localeData = phet.chipper.localeData;
assert && assert(localeData);
class LocalizedString {
  // Public-facing IProperty<string>, used by string modules

  // Uses lazy creation of locales
  localePropertyMap = new Map();

  // Store initial values, so we can handle state deltas
  initialValues = {};
  constructor(stringKey,
  // Store initial values, so we can handle state deltas
  localeToTranslationMap, tandem, metadata) {
    this.stringKey = stringKey;
    this.localeToTranslationMap = localeToTranslationMap;
    this.property = new LocalizedStringProperty(this, tandem, metadata);

    // Add to a global list to support PhET-iO serialization and internal testing
    localizedStrings.push(this);
  }

  /**
   * Returns an object that shows the changes of strings from their initial values. This includes whether strings are
   * marked as "overridden"
   */
  getStateDelta() {
    const result = {};
    this.usedLocales.forEach(locale => {
      const initialValue = this.initialValues[locale];
      const currentValue = this.getLocaleSpecificProperty(locale).value;
      if (currentValue !== initialValue) {
        result[locale] = currentValue;
      }
    });
    return result;
  }

  /**
   * Take a state from getStateDelta, and apply it.
   */
  setStateDelta(state) {
    // Create potential new locales (since locale-specific Properties are lazily created as needed
    Object.keys(state).forEach(locale => this.getLocaleSpecificProperty(locale));
    this.usedLocales.forEach(locale => {
      const localeSpecificProperty = this.getLocaleSpecificProperty(locale);
      const initialValue = this.initialValues[locale];
      assert && assert(initialValue !== undefined);
      const stateValue = state[locale] !== undefined ? state[locale] : null;
      localeSpecificProperty.value = stateValue ?? initialValue;
    });
  }
  get usedLocales() {
    return [...this.localePropertyMap.keys()];
  }

  /**
   * Returns the locale-specific Property for any locale (lazily creating it if necessary)
   */
  getLocaleSpecificProperty(locale) {
    // Lazy creation
    if (!this.localePropertyMap.has(locale)) {
      // Locales in order of fallback
      const orderedLocales = [locale, ...(localeData[locale].fallbackLocales || []), FALLBACK_LOCALE];

      // Find the first-defined value
      let initialValue = null;
      for (const locale of orderedLocales) {
        if (this.localeToTranslationMap[locale] !== undefined) {
          initialValue = this.localeToTranslationMap[locale];
          break;
        }
      }
      // Should be guaranteed because of `en` as a fallback
      assert && assert(initialValue !== undefined, 'no initial value found for', locale);
      this.initialValues[locale] = initialValue;
      this.localePropertyMap.set(locale, new TinyProperty(initialValue));
    }
    return this.localePropertyMap.get(locale);
  }
  dispose() {
    this.property.dispose();
    arrayRemove(localizedStrings, this);
  }

  /**
   * Reset to the initial value for the specified locale, used for testing.
   */
  restoreInitialValue(locale) {
    assert && assert(typeof this.initialValues[locale] === 'string', 'initial value expected for', locale);
    this.property.value = this.initialValues[locale];
  }
}
chipper.register('LocalizedString', LocalizedString);
export default LocalizedString;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJUaW55UHJvcGVydHkiLCJjaGlwcGVyIiwibG9jYWxpemVkU3RyaW5ncyIsImFycmF5UmVtb3ZlIiwiTG9jYWxpemVkU3RyaW5nUHJvcGVydHkiLCJGQUxMQkFDS19MT0NBTEUiLCJsb2NhbGVEYXRhIiwicGhldCIsImFzc2VydCIsIkxvY2FsaXplZFN0cmluZyIsImxvY2FsZVByb3BlcnR5TWFwIiwiTWFwIiwiaW5pdGlhbFZhbHVlcyIsImNvbnN0cnVjdG9yIiwic3RyaW5nS2V5IiwibG9jYWxlVG9UcmFuc2xhdGlvbk1hcCIsInRhbmRlbSIsIm1ldGFkYXRhIiwicHJvcGVydHkiLCJwdXNoIiwiZ2V0U3RhdGVEZWx0YSIsInJlc3VsdCIsInVzZWRMb2NhbGVzIiwiZm9yRWFjaCIsImxvY2FsZSIsImluaXRpYWxWYWx1ZSIsImN1cnJlbnRWYWx1ZSIsImdldExvY2FsZVNwZWNpZmljUHJvcGVydHkiLCJ2YWx1ZSIsInNldFN0YXRlRGVsdGEiLCJzdGF0ZSIsIk9iamVjdCIsImtleXMiLCJsb2NhbGVTcGVjaWZpY1Byb3BlcnR5IiwidW5kZWZpbmVkIiwic3RhdGVWYWx1ZSIsImhhcyIsIm9yZGVyZWRMb2NhbGVzIiwiZmFsbGJhY2tMb2NhbGVzIiwic2V0IiwiZ2V0IiwiZGlzcG9zZSIsInJlc3RvcmVJbml0aWFsVmFsdWUiLCJyZWdpc3RlciJdLCJzb3VyY2VzIjpbIkxvY2FsaXplZFN0cmluZy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAyMi0yMDI0LCBVbml2ZXJzaXR5IG9mIENvbG9yYWRvIEJvdWxkZXJcclxuXHJcbi8qKlxyXG4gKiBTZXRzIHVwIGEgc3lzdGVtIG9mIFByb3BlcnRpZXMgdG8gaGFuZGxlIHRyYW5zbGF0aW9uIGZhbGxiYWNrIGFuZCBwaGV0LWlvIHN1cHBvcnQgZm9yIGEgc2luZ2xlIHRyYW5zbGF0ZWQgc3RyaW5nLlxyXG4gKlxyXG4gKiBAYXV0aG9yIEpvbmF0aGFuIE9sc29uIDxqb25hdGhhbi5vbHNvbj5cclxuICovXHJcblxyXG5pbXBvcnQgVGlueVByb3BlcnR5IGZyb20gJy4uLy4uL2F4b24vanMvVGlueVByb3BlcnR5LmpzJztcclxuaW1wb3J0IHsgTG9jYWxlIH0gZnJvbSAnLi4vLi4vam9pc3QvanMvaTE4bi9sb2NhbGVQcm9wZXJ0eS5qcyc7XHJcbmltcG9ydCBUYW5kZW0gZnJvbSAnLi4vLi4vdGFuZGVtL2pzL1RhbmRlbS5qcyc7XHJcbmltcG9ydCBjaGlwcGVyIGZyb20gJy4vY2hpcHBlci5qcyc7XHJcbmltcG9ydCBUUHJvcGVydHkgZnJvbSAnLi4vLi4vYXhvbi9qcy9UUHJvcGVydHkuanMnO1xyXG5pbXBvcnQgeyBsb2NhbGl6ZWRTdHJpbmdzIH0gZnJvbSAnLi9nZXRTdHJpbmdNb2R1bGUuanMnO1xyXG5pbXBvcnQgYXJyYXlSZW1vdmUgZnJvbSAnLi4vLi4vcGhldC1jb3JlL2pzL2FycmF5UmVtb3ZlLmpzJztcclxuaW1wb3J0IHsgUGhldGlvSUQgfSBmcm9tICcuLi8uLi90YW5kZW0vanMvVGFuZGVtQ29uc3RhbnRzLmpzJztcclxuaW1wb3J0IExvY2FsaXplZFN0cmluZ1Byb3BlcnR5IGZyb20gJy4vTG9jYWxpemVkU3RyaW5nUHJvcGVydHkuanMnO1xyXG5cclxuLy8gY29uc3RhbnRzXHJcbmNvbnN0IEZBTExCQUNLX0xPQ0FMRSA9ICdlbic7XHJcblxyXG4vLyBmb3IgcmVhZGFiaWxpdHkvZG9jc1xyXG50eXBlIFRyYW5zbGF0aW9uU3RyaW5nID0gc3RyaW5nO1xyXG5leHBvcnQgdHlwZSBMb2NhbGl6ZWRTdHJpbmdTdGF0ZURlbHRhID0gUGFydGlhbDxSZWNvcmQ8TG9jYWxlLCBUcmFuc2xhdGlvblN0cmluZz4+O1xyXG5cclxuLy8gV2hlcmUgXCJzdHJpbmdcIiBpcyBhIHBoZXRpb0lEXHJcbmV4cG9ydCB0eXBlIFN0cmluZ3NTdGF0ZVN0YXRlT2JqZWN0ID0geyBkYXRhOiBSZWNvcmQ8UGhldGlvSUQsIExvY2FsaXplZFN0cmluZ1N0YXRlRGVsdGE+IH07XHJcblxyXG5jb25zdCBsb2NhbGVEYXRhID0gcGhldC5jaGlwcGVyLmxvY2FsZURhdGE7XHJcbmFzc2VydCAmJiBhc3NlcnQoIGxvY2FsZURhdGEgKTtcclxuXHJcbmNsYXNzIExvY2FsaXplZFN0cmluZyB7XHJcblxyXG4gIC8vIFB1YmxpYy1mYWNpbmcgSVByb3BlcnR5PHN0cmluZz4sIHVzZWQgYnkgc3RyaW5nIG1vZHVsZXNcclxuICBwdWJsaWMgcmVhZG9ubHkgcHJvcGVydHk6IExvY2FsaXplZFN0cmluZ1Byb3BlcnR5O1xyXG5cclxuICAvLyBVc2VzIGxhenkgY3JlYXRpb24gb2YgbG9jYWxlc1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgbG9jYWxlUHJvcGVydHlNYXAgPSBuZXcgTWFwPExvY2FsZSwgVGlueVByb3BlcnR5PFRyYW5zbGF0aW9uU3RyaW5nPj4oKTtcclxuXHJcbiAgLy8gU3RvcmUgaW5pdGlhbCB2YWx1ZXMsIHNvIHdlIGNhbiBoYW5kbGUgc3RhdGUgZGVsdGFzXHJcbiAgcHJpdmF0ZSByZWFkb25seSBpbml0aWFsVmFsdWVzOiBMb2NhbGl6ZWRTdHJpbmdTdGF0ZURlbHRhID0ge307XHJcblxyXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihcclxuICAgIHB1YmxpYyByZWFkb25seSBzdHJpbmdLZXk6IHN0cmluZyxcclxuICAgIC8vIFN0b3JlIGluaXRpYWwgdmFsdWVzLCBzbyB3ZSBjYW4gaGFuZGxlIHN0YXRlIGRlbHRhc1xyXG4gICAgcHJpdmF0ZSByZWFkb25seSBsb2NhbGVUb1RyYW5zbGF0aW9uTWFwOiBMb2NhbGl6ZWRTdHJpbmdTdGF0ZURlbHRhLFxyXG4gICAgdGFuZGVtOiBUYW5kZW0sXHJcbiAgICBtZXRhZGF0YT86IFJlY29yZDxzdHJpbmcsIHVua25vd24+XHJcbiAgKSB7XHJcbiAgICB0aGlzLnByb3BlcnR5ID0gbmV3IExvY2FsaXplZFN0cmluZ1Byb3BlcnR5KCB0aGlzLCB0YW5kZW0sIG1ldGFkYXRhICk7XHJcblxyXG4gICAgLy8gQWRkIHRvIGEgZ2xvYmFsIGxpc3QgdG8gc3VwcG9ydCBQaEVULWlPIHNlcmlhbGl6YXRpb24gYW5kIGludGVybmFsIHRlc3RpbmdcclxuICAgIGxvY2FsaXplZFN0cmluZ3MucHVzaCggdGhpcyApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBhbiBvYmplY3QgdGhhdCBzaG93cyB0aGUgY2hhbmdlcyBvZiBzdHJpbmdzIGZyb20gdGhlaXIgaW5pdGlhbCB2YWx1ZXMuIFRoaXMgaW5jbHVkZXMgd2hldGhlciBzdHJpbmdzIGFyZVxyXG4gICAqIG1hcmtlZCBhcyBcIm92ZXJyaWRkZW5cIlxyXG4gICAqL1xyXG4gIHB1YmxpYyBnZXRTdGF0ZURlbHRhKCk6IExvY2FsaXplZFN0cmluZ1N0YXRlRGVsdGEge1xyXG4gICAgY29uc3QgcmVzdWx0OiBMb2NhbGl6ZWRTdHJpbmdTdGF0ZURlbHRhID0ge307XHJcblxyXG4gICAgdGhpcy51c2VkTG9jYWxlcy5mb3JFYWNoKCBsb2NhbGUgPT4ge1xyXG4gICAgICBjb25zdCBpbml0aWFsVmFsdWU6IHN0cmluZyA9IHRoaXMuaW5pdGlhbFZhbHVlc1sgbG9jYWxlIF0hO1xyXG4gICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSB0aGlzLmdldExvY2FsZVNwZWNpZmljUHJvcGVydHkoIGxvY2FsZSApLnZhbHVlO1xyXG5cclxuICAgICAgaWYgKCBjdXJyZW50VmFsdWUgIT09IGluaXRpYWxWYWx1ZSApIHtcclxuICAgICAgICByZXN1bHRbIGxvY2FsZSBdID0gY3VycmVudFZhbHVlO1xyXG4gICAgICB9XHJcbiAgICB9ICk7XHJcblxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRha2UgYSBzdGF0ZSBmcm9tIGdldFN0YXRlRGVsdGEsIGFuZCBhcHBseSBpdC5cclxuICAgKi9cclxuICBwdWJsaWMgc2V0U3RhdGVEZWx0YSggc3RhdGU6IExvY2FsaXplZFN0cmluZ1N0YXRlRGVsdGEgKTogdm9pZCB7XHJcblxyXG4gICAgLy8gQ3JlYXRlIHBvdGVudGlhbCBuZXcgbG9jYWxlcyAoc2luY2UgbG9jYWxlLXNwZWNpZmljIFByb3BlcnRpZXMgYXJlIGxhemlseSBjcmVhdGVkIGFzIG5lZWRlZFxyXG4gICAgT2JqZWN0LmtleXMoIHN0YXRlICkuZm9yRWFjaCggbG9jYWxlID0+IHRoaXMuZ2V0TG9jYWxlU3BlY2lmaWNQcm9wZXJ0eSggbG9jYWxlIGFzIExvY2FsZSApICk7XHJcblxyXG4gICAgdGhpcy51c2VkTG9jYWxlcy5mb3JFYWNoKCBsb2NhbGUgPT4ge1xyXG4gICAgICBjb25zdCBsb2NhbGVTcGVjaWZpY1Byb3BlcnR5ID0gdGhpcy5nZXRMb2NhbGVTcGVjaWZpY1Byb3BlcnR5KCBsb2NhbGUgKTtcclxuICAgICAgY29uc3QgaW5pdGlhbFZhbHVlOiBzdHJpbmcgPSB0aGlzLmluaXRpYWxWYWx1ZXNbIGxvY2FsZSBdITtcclxuICAgICAgYXNzZXJ0ICYmIGFzc2VydCggaW5pdGlhbFZhbHVlICE9PSB1bmRlZmluZWQgKTtcclxuXHJcbiAgICAgIGNvbnN0IHN0YXRlVmFsdWU6IHN0cmluZyB8IG51bGwgPSBzdGF0ZVsgbG9jYWxlIF0gIT09IHVuZGVmaW5lZCA/IHN0YXRlWyBsb2NhbGUgXSEgOiBudWxsO1xyXG5cclxuICAgICAgbG9jYWxlU3BlY2lmaWNQcm9wZXJ0eS52YWx1ZSA9IHN0YXRlVmFsdWUgPz8gaW5pdGlhbFZhbHVlO1xyXG4gICAgfSApO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBnZXQgdXNlZExvY2FsZXMoKTogTG9jYWxlW10ge1xyXG4gICAgcmV0dXJuIFsgLi4udGhpcy5sb2NhbGVQcm9wZXJ0eU1hcC5rZXlzKCkgXTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIGxvY2FsZS1zcGVjaWZpYyBQcm9wZXJ0eSBmb3IgYW55IGxvY2FsZSAobGF6aWx5IGNyZWF0aW5nIGl0IGlmIG5lY2Vzc2FyeSlcclxuICAgKi9cclxuICBwdWJsaWMgZ2V0TG9jYWxlU3BlY2lmaWNQcm9wZXJ0eSggbG9jYWxlOiBMb2NhbGUgKTogVFByb3BlcnR5PHN0cmluZz4ge1xyXG4gICAgLy8gTGF6eSBjcmVhdGlvblxyXG4gICAgaWYgKCAhdGhpcy5sb2NhbGVQcm9wZXJ0eU1hcC5oYXMoIGxvY2FsZSApICkge1xyXG4gICAgICAvLyBMb2NhbGVzIGluIG9yZGVyIG9mIGZhbGxiYWNrXHJcbiAgICAgIGNvbnN0IG9yZGVyZWRMb2NhbGVzOiBMb2NhbGVbXSA9IFtcclxuICAgICAgICBsb2NhbGUsXHJcbiAgICAgICAgLi4uKCBsb2NhbGVEYXRhWyBsb2NhbGUgXS5mYWxsYmFja0xvY2FsZXMgfHwgW10gKSxcclxuICAgICAgICBGQUxMQkFDS19MT0NBTEVcclxuICAgICAgXTtcclxuXHJcbiAgICAgIC8vIEZpbmQgdGhlIGZpcnN0LWRlZmluZWQgdmFsdWVcclxuICAgICAgbGV0IGluaXRpYWxWYWx1ZTogc3RyaW5nIHwgbnVsbCA9IG51bGw7XHJcbiAgICAgIGZvciAoIGNvbnN0IGxvY2FsZSBvZiBvcmRlcmVkTG9jYWxlcyApIHtcclxuICAgICAgICBpZiAoIHRoaXMubG9jYWxlVG9UcmFuc2xhdGlvbk1hcFsgbG9jYWxlIF0gIT09IHVuZGVmaW5lZCApIHtcclxuICAgICAgICAgIGluaXRpYWxWYWx1ZSA9IHRoaXMubG9jYWxlVG9UcmFuc2xhdGlvbk1hcFsgbG9jYWxlIF0hO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIC8vIFNob3VsZCBiZSBndWFyYW50ZWVkIGJlY2F1c2Ugb2YgYGVuYCBhcyBhIGZhbGxiYWNrXHJcbiAgICAgIGFzc2VydCAmJiBhc3NlcnQoIGluaXRpYWxWYWx1ZSAhPT0gdW5kZWZpbmVkLCAnbm8gaW5pdGlhbCB2YWx1ZSBmb3VuZCBmb3InLCBsb2NhbGUgKTtcclxuXHJcbiAgICAgIHRoaXMuaW5pdGlhbFZhbHVlc1sgbG9jYWxlIF0gPSBpbml0aWFsVmFsdWUhO1xyXG4gICAgICB0aGlzLmxvY2FsZVByb3BlcnR5TWFwLnNldCggbG9jYWxlLCBuZXcgVGlueVByb3BlcnR5KCBpbml0aWFsVmFsdWUhICkgKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy5sb2NhbGVQcm9wZXJ0eU1hcC5nZXQoIGxvY2FsZSApITtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBkaXNwb3NlKCk6IHZvaWQge1xyXG4gICAgdGhpcy5wcm9wZXJ0eS5kaXNwb3NlKCk7XHJcbiAgICBhcnJheVJlbW92ZSggbG9jYWxpemVkU3RyaW5ncywgdGhpcyApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVzZXQgdG8gdGhlIGluaXRpYWwgdmFsdWUgZm9yIHRoZSBzcGVjaWZpZWQgbG9jYWxlLCB1c2VkIGZvciB0ZXN0aW5nLlxyXG4gICAqL1xyXG4gIHB1YmxpYyByZXN0b3JlSW5pdGlhbFZhbHVlKCBsb2NhbGU6IExvY2FsZSApOiB2b2lkIHtcclxuICAgIGFzc2VydCAmJiBhc3NlcnQoIHR5cGVvZiB0aGlzLmluaXRpYWxWYWx1ZXNbIGxvY2FsZSBdID09PSAnc3RyaW5nJywgJ2luaXRpYWwgdmFsdWUgZXhwZWN0ZWQgZm9yJywgbG9jYWxlICk7XHJcbiAgICB0aGlzLnByb3BlcnR5LnZhbHVlID0gdGhpcy5pbml0aWFsVmFsdWVzWyBsb2NhbGUgXSE7XHJcbiAgfVxyXG59XHJcblxyXG5jaGlwcGVyLnJlZ2lzdGVyKCAnTG9jYWxpemVkU3RyaW5nJywgTG9jYWxpemVkU3RyaW5nICk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBMb2NhbGl6ZWRTdHJpbmc7Il0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU9BLFlBQVksTUFBTSwrQkFBK0I7QUFHeEQsT0FBT0MsT0FBTyxNQUFNLGNBQWM7QUFFbEMsU0FBU0MsZ0JBQWdCLFFBQVEsc0JBQXNCO0FBQ3ZELE9BQU9DLFdBQVcsTUFBTSxtQ0FBbUM7QUFFM0QsT0FBT0MsdUJBQXVCLE1BQU0sOEJBQThCOztBQUVsRTtBQUNBLE1BQU1DLGVBQWUs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