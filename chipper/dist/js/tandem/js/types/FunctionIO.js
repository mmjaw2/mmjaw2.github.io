// Copyright 2018-2024, University of Colorado Boulder

/**
 * PhET-iO Type for JS's built-in function type.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Andrew Adare (PhET Interactive Simulations)
 */

import tandemNamespace from '../tandemNamespace.js';
import IOType from './IOType.js';
import IOTypeCache from '../IOTypeCache.js';

// cache each parameterized IOType so that it is only created once
const cache = new IOTypeCache();

/**
 * Parametric IOType constructor--given return type and parameter types, this function returns a type wrapped IOType for
 * that "class" of functions. "Class" here refers to the supported parameter and return IOTypes.
 * This caching implementation should be kept in sync with the other parametric IOType caching implementations.
 * @param returnType - IOType of the return type of the function that can support cross-frame serialization
 * @param functionParameterTypes - IOTypes for the individual arguments of the function.
 */
const FunctionIO = (returnType, functionParameterTypes) => {
  for (let i = 0; i < functionParameterTypes.length; i++) {
    assert && assert(functionParameterTypes[i], 'parameter type was not truthy');
  }
  assert && assert(returnType, 'return type was not truthy');

  // REVIEW https://github.com/phetsims/tandem/issues/169 Why is this different than the typeName later in this file?
  const cacheKey = `${returnType.typeName}.${functionParameterTypes.map(type => type.typeName).join(',')}`;
  if (!cache.has(cacheKey)) {
    // gather a list of argument names for the documentation string
    let argsString = functionParameterTypes.map(parameterType => parameterType.typeName).join(', ');
    if (argsString === '') {
      argsString = 'none';
    }
    const parameterTypesString = functionParameterTypes.map(parameterType => parameterType.typeName).join(',');
    cache.set(cacheKey, new IOType(`FunctionIO(${parameterTypesString})=>${returnType.typeName}`, {
      valueType: 'function',
      isFunctionType: true,
      // These are the parameters to this FunctionIO, not to the function it wraps. That is why it includes the return type.
      // NOTE: the order is very important, for instance phetioCommandProcessor relies on the parameters being before
      // the return type.  If we decide this is too brittle, perhaps we should subclass IOType to FunctionIOType, and it
      // can track its functionParameterTypes separately from the returnType.
      parameterTypes: functionParameterTypes.concat([returnType]),
      documentation: `${'Wrapper for the built-in JS function type.<br>' + '<strong>Arguments:</strong> '}${argsString}<br>` + `<strong>Return Type:</strong> ${returnType.typeName}`
    }));
  }
  return cache.get(cacheKey);
};
tandemNamespace.register('FunctionIO', FunctionIO);
export default FunctionIO;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJ0YW5kZW1OYW1lc3BhY2UiLCJJT1R5cGUiLCJJT1R5cGVDYWNoZSIsImNhY2hlIiwiRnVuY3Rpb25JTyIsInJldHVyblR5cGUiLCJmdW5jdGlvblBhcmFtZXRlclR5cGVzIiwiaSIsImxlbmd0aCIsImFzc2VydCIsImNhY2hlS2V5IiwidHlwZU5hbWUiLCJtYXAiLCJ0eXBlIiwiam9pbiIsImhhcyIsImFyZ3NTdHJpbmciLCJwYXJhbWV0ZXJUeXBlIiwicGFyYW1ldGVyVHlwZXNTdHJpbmciLCJzZXQiLCJ2YWx1ZVR5cGUiLCJpc0Z1bmN0aW9uVHlwZSIsInBhcmFtZXRlclR5cGVzIiwiY29uY2F0IiwiZG9jdW1lbnRhdGlvbiIsImdldCIsInJlZ2lzdGVyIl0sInNvdXJjZXMiOlsiRnVuY3Rpb25JTy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAxOC0yMDI0LCBVbml2ZXJzaXR5IG9mIENvbG9yYWRvIEJvdWxkZXJcclxuXHJcbi8qKlxyXG4gKiBQaEVULWlPIFR5cGUgZm9yIEpTJ3MgYnVpbHQtaW4gZnVuY3Rpb24gdHlwZS5cclxuICpcclxuICogQGF1dGhvciBTYW0gUmVpZCAoUGhFVCBJbnRlcmFjdGl2ZSBTaW11bGF0aW9ucylcclxuICogQGF1dGhvciBBbmRyZXcgQWRhcmUgKFBoRVQgSW50ZXJhY3RpdmUgU2ltdWxhdGlvbnMpXHJcbiAqL1xyXG5cclxuaW1wb3J0IHRhbmRlbU5hbWVzcGFjZSBmcm9tICcuLi90YW5kZW1OYW1lc3BhY2UuanMnO1xyXG5pbXBvcnQgSU9UeXBlIGZyb20gJy4vSU9UeXBlLmpzJztcclxuaW1wb3J0IElPVHlwZUNhY2hlIGZyb20gJy4uL0lPVHlwZUNhY2hlLmpzJztcclxuXHJcblxyXG4vLyBjYWNoZSBlYWNoIHBhcmFtZXRlcml6ZWQgSU9UeXBlIHNvIHRoYXQgaXQgaXMgb25seSBjcmVhdGVkIG9uY2VcclxuY29uc3QgY2FjaGUgPSBuZXcgSU9UeXBlQ2FjaGU8c3RyaW5nPigpO1xyXG5cclxuLyoqXHJcbiAqIFBhcmFtZXRyaWMgSU9UeXBlIGNvbnN0cnVjdG9yLS1naXZlbiByZXR1cm4gdHlwZSBhbmQgcGFyYW1ldGVyIHR5cGVzLCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgYSB0eXBlIHdyYXBwZWQgSU9UeXBlIGZvclxyXG4gKiB0aGF0IFwiY2xhc3NcIiBvZiBmdW5jdGlvbnMuIFwiQ2xhc3NcIiBoZXJlIHJlZmVycyB0byB0aGUgc3VwcG9ydGVkIHBhcmFtZXRlciBhbmQgcmV0dXJuIElPVHlwZXMuXHJcbiAqIFRoaXMgY2FjaGluZyBpbXBsZW1lbnRhdGlvbiBzaG91bGQgYmUga2VwdCBpbiBzeW5jIHdpdGggdGhlIG90aGVyIHBhcmFtZXRyaWMgSU9UeXBlIGNhY2hpbmcgaW1wbGVtZW50YXRpb25zLlxyXG4gKiBAcGFyYW0gcmV0dXJuVHlwZSAtIElPVHlwZSBvZiB0aGUgcmV0dXJuIHR5cGUgb2YgdGhlIGZ1bmN0aW9uIHRoYXQgY2FuIHN1cHBvcnQgY3Jvc3MtZnJhbWUgc2VyaWFsaXphdGlvblxyXG4gKiBAcGFyYW0gZnVuY3Rpb25QYXJhbWV0ZXJUeXBlcyAtIElPVHlwZXMgZm9yIHRoZSBpbmRpdmlkdWFsIGFyZ3VtZW50cyBvZiB0aGUgZnVuY3Rpb24uXHJcbiAqL1xyXG5jb25zdCBGdW5jdGlvbklPID0gKCByZXR1cm5UeXBlOiBJT1R5cGUsIGZ1bmN0aW9uUGFyYW1ldGVyVHlwZXM6IElPVHlwZVtdICk6IElPVHlwZSA9PiB7XHJcbiAgZm9yICggbGV0IGkgPSAwOyBpIDwgZnVuY3Rpb25QYXJhbWV0ZXJUeXBlcy5sZW5ndGg7IGkrKyApIHtcclxuICAgIGFzc2VydCAmJiBhc3NlcnQoIGZ1bmN0aW9uUGFyYW1ldGVyVHlwZXNbIGkgXSwgJ3BhcmFtZXRlciB0eXBlIHdhcyBub3QgdHJ1dGh5JyApO1xyXG4gIH1cclxuICBhc3NlcnQgJiYgYXNzZXJ0KCByZXR1cm5UeXBlLCAncmV0dXJuIHR5cGUgd2FzIG5vdCB0cnV0aHknICk7XHJcblxyXG4gIC8vIFJFVklFVyBodHRwczovL2dpdGh1Yi5jb20vcGhldHNpbXMvdGFuZGVtL2lzc3Vlcy8xNjkgV2h5IGlzIHRoaXMgZGlmZmVyZW50IHRoYW4gdGhlIHR5cGVOYW1lIGxhdGVyIGluIHRoaXMgZmlsZT9cclxuICBjb25zdCBjYWNoZUtleSA9IGAke3JldHVyblR5cGUudHlwZU5hbWV9LiR7ZnVuY3Rpb25QYXJhbWV0ZXJUeXBlcy5tYXAoIHR5cGUgPT4gdHlwZS50eXBlTmFtZSApLmpvaW4oICcsJyApfWA7XHJcblxyXG4gIGlmICggIWNhY2hlLmhhcyggY2FjaGVLZXkgKSApIHtcclxuXHJcbiAgICAvLyBnYXRoZXIgYSBsaXN0IG9mIGFyZ3VtZW50IG5hbWVzIGZvciB0aGUgZG9jdW1lbnRhdGlvbiBzdHJpbmdcclxuICAgIGxldCBhcmdzU3RyaW5nID0gZnVuY3Rpb25QYXJhbWV0ZXJUeXBlcy5tYXAoIHBhcmFtZXRlclR5cGUgPT4gcGFyYW1ldGVyVHlwZS50eXBlTmFtZSApLmpvaW4oICcsICcgKTtcclxuICAgIGlmICggYXJnc1N0cmluZyA9PT0gJycgKSB7XHJcbiAgICAgIGFyZ3NTdHJpbmcgPSAnbm9uZSc7XHJcbiAgICB9XHJcbiAgICBjb25zdCBwYXJhbWV0ZXJUeXBlc1N0cmluZyA9IGZ1bmN0aW9uUGFyYW1ldGVyVHlwZXMubWFwKCBwYXJhbWV0ZXJUeXBlID0+IHBhcmFtZXRlclR5cGUudHlwZU5hbWUgKS5qb2luKCAnLCcgKTtcclxuXHJcbiAgICBjYWNoZS5zZXQoIGNhY2hlS2V5LCBuZXcgSU9UeXBlKCBgRnVuY3Rpb25JTygke3BhcmFtZXRlclR5cGVzU3RyaW5nfSk9PiR7cmV0dXJuVHlwZS50eXBlTmFtZX1gLCB7XHJcbiAgICAgIHZhbHVlVHlwZTogJ2Z1bmN0aW9uJyxcclxuXHJcbiAgICAgIGlzRnVuY3Rpb25UeXBlOiB0cnVlLFxyXG5cclxuICAgICAgLy8gVGhlc2UgYXJlIHRoZSBwYXJhbWV0ZXJzIHRvIHRoaXMgRnVuY3Rpb25JTywgbm90IHRvIHRoZSBmdW5jdGlvbiBpdCB3cmFwcy4gVGhhdCBpcyB3aHkgaXQgaW5jbHVkZXMgdGhlIHJldHVybiB0eXBlLlxyXG4gICAgICAvLyBOT1RFOiB0aGUgb3JkZXIgaXMgdmVyeSBpbXBvcnRhbnQsIGZvciBpbnN0YW5jZSBwaGV0aW9Db21tYW5kUHJvY2Vzc29yIHJlbGllcyBvbiB0aGUgcGFyYW1ldGVycyBiZWluZyBiZWZvcmVcclxuICAgICAgLy8gdGhlIHJldHVybiB0eXBlLiAgSWYgd2UgZGVjaWRlIHRoaXMgaXMgdG9vIGJyaXR0bGUsIHBlcmhhcHMgd2Ugc2hvdWxkIHN1YmNsYXNzIElPVHlwZSB0byBGdW5jdGlvbklPVHlwZSwgYW5kIGl0XHJcbiAgICAgIC8vIGNhbiB0cmFjayBpdHMgZnVuY3Rpb25QYXJhbWV0ZXJUeXBlcyBzZXBhcmF0ZWx5IGZyb20gdGhlIHJldHVyblR5cGUuXHJcbiAgICAgIHBhcmFtZXRlclR5cGVzOiBmdW5jdGlvblBhcmFtZXRlclR5cGVzLmNvbmNhdCggWyByZXR1cm5UeXBlIF0gKSxcclxuICAgICAgZG9jdW1lbnRhdGlvbjogYCR7J1dyYXBwZXIgZm9yIHRoZSBidWlsdC1pbiBKUyBmdW5jdGlvbiB0eXBlLjxicj4nICtcclxuICAgICAgICAgICAgICAgICAgICAgJzxzdHJvbmc+QXJndW1lbnRzOjwvc3Ryb25nPiAnfSR7YXJnc1N0cmluZ308YnI+YCArXHJcbiAgICAgICAgICAgICAgICAgICAgIGA8c3Ryb25nPlJldHVybiBUeXBlOjwvc3Ryb25nPiAke3JldHVyblR5cGUudHlwZU5hbWV9YFxyXG4gICAgfSApICk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gY2FjaGUuZ2V0KCBjYWNoZUtleSApITtcclxufTtcclxuXHJcbnRhbmRlbU5hbWVzcGFjZS5yZWdpc3RlciggJ0Z1bmN0aW9uSU8nLCBGdW5jdGlvbklPICk7XHJcbmV4cG9ydCBkZWZhdWx0IEZ1bmN0aW9uSU87Il0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBT0EsZUFBZSxNQUFNLHVCQUF1QjtBQUNuRCxPQUFPQyxNQUFNLE1BQU0sYUFBYTtBQUNoQyxPQUFPQyxXQUFXLE1BQU0sbUJBQW1COztBQUczQztBQUNBLE1BQU1DLEtBQUssR0FBRyxJQUFJRCxXQUFXLENBQVMsQ0FBQzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNRSxVQUFVLEdBQUdBLENBQUVDLFVBQWtCLEVBQUVDLHNCQUFnQyxLQUFjO0VBQ3JGLEtBQU0sSUFBSUMsQ0FBQyxHQUFHLENBQUMsRUFBRUEsQ0FBQyxHQUFHRCxzQkFBc0IsQ0FBQ0UsTUFBTSxFQUFFRCxDQUFDLEVBQUUsRUFBRztJQUN4REUsTUFBTSxJQUFJQSxNQUFNLENBQUVILHNCQUFzQixDQUFFQyxDQUFDLENBQUUsRUFBRSwrQkFBZ0MsQ0FBQztFQUNsRjtFQUNBRSxNQUFNLElBQUlBLE1BQU0sQ0FBRUosVUFBVSxFQUFFLDRCQUE2QixDQUFDOztFQUU1RDtFQUNBLE1BQU1LLFFBQVEsR0FBSSxHQUFFTCxVQUFVLENBQUNNLFFBQVMsSUFBR0wsc0JBQXNCLENBQUNNLEdBQUcsQ0FBRUMsSUFBSSxJQUFJQSxJQUFJLENBQUNGLFFBQVMsQ0FBQyxDQUFDRyxJQUFJLENBQUUsR0FBSSxDQUFFLEVBQUM7RUFFNUcsSUFBSyxDQUFDWCxLQUFLLENBQUNZLEdBQUcsQ0FBRUwsUUFBUyxDQUFDLEVBQUc7SUFFNUI7SUFDQSxJQUFJTSxVQUFVLEdBQUdWLHNCQUFzQixDQUFDTSxHQUFHLENBQUVLLGFBQWEsSUFBSUEsYUFBYSxDQUFDTixRQUFTLENBQUMsQ0FBQ0csSUFBSSxDQUFFLElBQUssQ0FBQztJQUNuRyxJQUFLRSxVQUFVLEtBQUssRUFBRSxFQUFHO01BQ3ZCQSxVQUFVLEdBQUcsTUFBTTtJQUNyQjtJQUNBLE1BQU1FLG9CQUFvQixHQUFHWixzQkFBc0IsQ0FBQ00sR0FBRyxDQUFFSyxhQUFhLElBQUlBLGFBQWEsQ0FBQ04sUUFBUyxDQUFDLENBQUNHLElBQUksQ0FBRSxHQUFJLENBQUM7SUFFOUdYLEtBQUssQ0FBQ2dCLEdBQUcsQ0FBRVQsUUFBUSxFQUFFLElBQUlULE1BQU0sQ0FBRyxjQUFhaUIsb0JBQXFCLE1BQUtiLFVBQVUsQ0FBQ00sUUFBUyxFQUFDLEVBQUU7TUFDOUZTLFNBQVMsRUFBRSxVQUFVO01BRXJCQyxjQUFjLEVBQUUsSUFBSTtNQUVwQjtNQUNBO01BQ0E7TUFDQTtNQUNBQyxjQUFjLEVBQUVoQixzQkFBc0IsQ0FBQ2lCLE1BQU0sQ0FBRSxDQUFFbEIsVUFBVSxDQUFHLENBQUM7TUFDL0RtQixhQUFhLEVBQUcsR0FBRSxnREFBZ0QsR0FDbkQsOEJBQStCLEdBQUVSLFVBQVcsTUFBSyxHQUNoRCxpQ0FBZ0NYLFVBQVUsQ0FBQ00sUUFBUztJQUN0RSxDQUFFLENBQUUsQ0FBQztFQUNQO0VBRUEsT0FBT1IsS0FBSyxDQUFDc0IsR0FBRyxDQUFFZixRQUFTLENBQUM7QUFDOUIsQ0FBQztBQUVEVixlQUFlLENBQUMwQixRQUFRLENBQUUsWUFBWSxFQUFFdEIsVUFBVyxDQUFDO0FBQ3BELGVBQWVBLFVBQVUiLCJpZ25vcmVMaXN0IjpbXX0=