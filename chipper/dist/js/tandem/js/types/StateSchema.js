// Copyright 2021-2024, University of Colorado Boulder

/**
 * Class responsible for storing information about the schema of PhET-iO state. See IOType stateSchema option for usage
 * and more information.
 *
 * There are two types of StateSchema:
 * - The first is a stateSchema "value". This is when the state of an IOType is itself a value in the state. In
 * effect, this just serves as boilerplate, and isn't the primary usage of stateSchema. For example, a StringIO or
 * NumberIO.
 * - The second is a "composite", where the state of an IOType is made from subcomponents, each of which have an IOType.
 * A composite schema was named because it is a sum of its parts. For example a BunnyIO has multiple components that
 * make it up (mother/father/age/etc). Check which type of StateSchema your instance is with StateSchema.isComposite().
 *
 * When stored in the API, StateSchema values are stored as strings, see StateSchema.asValue, and composite state schemas
 * are stored as objects with values that are each IOType names.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Michael Kauzmann (PhET Interactive Simulations)
 */

import Validation from '../../../axon/js/Validation.js';
import assertMutuallyExclusiveOptions from '../../../phet-core/js/assertMutuallyExclusiveOptions.js';
import optionize from '../../../phet-core/js/optionize.js';
import tandemNamespace from '../tandemNamespace.js';
import IOType from './IOType.js';

/**
 * This is the primary functionality of the StateSchema class. An IOType can be provided a composite schema like so:
 * {
 *   subcomponent1: StringIO;
 *   subcomponent2: NumberIO;
 * }
 * By providing this, you are giving the schema to allow StateSchema to serialize and deserialize itself based on the
 * composite schema.
 */

// As provided in the PhET-iO API json.

// The schema of the stateObject value

// Pluck the result toStateObject types from the CompositeSchema. For instance, map a state schema like so:
// {name: StringIO} => {name: string}

export default class StateSchema {
  // "composite" state schemas are treated differently that value state schemas

  constructor(providedOptions) {
    // Either create with compositeSchema, or specify a that this state is just a value
    assert && assertMutuallyExclusiveOptions(providedOptions, ['compositeSchema'], ['displayString', 'validator']);
    const options = optionize()({
      displayString: '',
      validator: null,
      compositeSchema: null
    }, providedOptions);
    this.displayString = options.displayString;
    this.validator = options.validator;
    this.compositeSchema = options.compositeSchema;
  }

  /**
   * This method provides a default implementation for setting a stateObject onto an object from the stateSchema information.
   * It supports the coreObject keys as private, underscore-prefixed field, as
   * well as if the coreObject has an es5 setter instead of an actual field.
   */
  defaultApplyState(coreObject, stateObject) {
    assert && assert(this.isComposite(), 'defaultApplyState from stateSchema only applies to composite stateSchemas');
    for (const stateKey in this.compositeSchema) {
      if (this.compositeSchema.hasOwnProperty(stateKey)) {
        assert && assert(stateObject.hasOwnProperty(stateKey), `stateObject does not have expected schema key: ${stateKey}`);

        // The IOType for the key in the composite.
        const schemaIOType = this.compositeSchema[stateKey];
        const coreObjectAccessorName = this.getCoreObjectAccessorName(stateKey, coreObject);

        // Using fromStateObject to deserialize sub-component
        if (schemaIOType.defaultDeserializationMethod === 'fromStateObject') {
          // @ts-expect-error, I don't know how to tell typescript that we are accessing an expected key on the PhetioObject subtype. Likely there is no way with making things generic.
          coreObject[coreObjectAccessorName] = this.compositeSchema[stateKey].fromStateObject(stateObject[stateKey]);
        } else {
          assert && assert(schemaIOType.defaultDeserializationMethod === 'applyState', 'unexpected deserialization method');

          // Using applyState to deserialize sub-component
          // @ts-expect-error, I don't know how to tell typescript that we are accessing an expected key on the PhetioObject subtype. Likely there is no way with making things generic.
          this.compositeSchema[stateKey].applyState(coreObject[coreObjectAccessorName], stateObject[stateKey]);
        }
      }
    }
  }

  /**
   * This method provides a default implementation for creating a stateObject from the stateSchema by accessing those
   * same key names on the coreObject instance. It supports those keys as private, underscore-prefixed field, as
   * well as if the coreObject has an es5 getter instead of an actual field.
   */
  defaultToStateObject(coreObject) {
    assert && assert(this.isComposite(), 'defaultToStateObject from stateSchema only applies to composite stateSchemas');
    const stateObject = {};
    for (const stateKey in this.compositeSchema) {
      if (this.compositeSchema.hasOwnProperty(stateKey)) {
        const coreObjectAccessorName = this.getCoreObjectAccessorName(stateKey, coreObject);
        if (assert) {
          const descriptor = Object.getOwnPropertyDescriptor(coreObject, coreObjectAccessorName);
          let isGetter = false;

          // @ts-expect-error Subtype T for this method better
          if (coreObject.constructor.prototype) {
            // The prototype is what has the getter on it
            // @ts-expect-error Subtype T for this method better
            const prototypeDescriptor = Object.getOwnPropertyDescriptor(coreObject.constructor.prototype, coreObjectAccessorName);
            isGetter = !!prototypeDescriptor && !!prototypeDescriptor.get;
          }
          const isValue = !!descriptor && descriptor.hasOwnProperty('value') && descriptor.writable;
          assert && assert(isValue || isGetter, `cannot get state because coreObject does not have expected schema key: ${coreObjectAccessorName}`);
        }

        // @ts-expect-error https://github.com/phetsims/tandem/issues/261
        stateObject[stateKey] = this.compositeSchema[stateKey].toStateObject(coreObject[coreObjectAccessorName]);
      }
    }
    return stateObject;
  }

  /**
   * Provide the member string key that should be used to get/set an instance's field. Used only internally for the
   * default implementations of toStateObject and applyState.
   */
  getCoreObjectAccessorName(stateKey, coreObject) {
    assert && assert(!stateKey.startsWith('__'), 'State keys should not start with too many underscores: ' + stateKey + '. When serializing ', coreObject);

    // Does the class field start with an underscore? We need to cover two cases here. The first is where the underscore
    // was added to make a private state key. The second, is where the core class only has the underscore-prefixed
    // field key name available for setting. The easiest algorithm to cover all cases is to see if the coreObject has
    // the underscore-prefixed key name, and use that if available, otherwise use the stateKey without an underscore.
    const noUnderscore = stateKey.startsWith('_') ? stateKey.substring(1) : stateKey;
    const underscored = `_${noUnderscore}`;
    let coreObjectAccessorName;

    // @ts-expect-error - T is not specific to composite schemas, so NumberIO doesn't actually need a hasOwnProperty method
    if (coreObject.hasOwnProperty(underscored)) {
      coreObjectAccessorName = underscored;
    } else {
      coreObjectAccessorName = noUnderscore;
    }
    return coreObjectAccessorName;
  }

  /**
   * True if the StateSchema is a composite schema. See the header documentation in this file for the definition
   * of "composite" schema.
   */
  isComposite() {
    return !!this.compositeSchema;
  }

  /**
   * Check if a given stateObject is as valid as can be determined by this StateSchema. Will return null if valid, but
   * needs more checking up and down the hierarchy.
   *
   * @param stateObject - the stateObject to validate against
   * @param toAssert - whether to assert when invalid
   * @param schemaKeysPresentInStateObject - to be populated with any keys this StateSchema is responsible for.
   * @returns boolean if validity can be checked, null if valid, but next in the hierarchy is needed
   */
  checkStateObjectValid(stateObject, toAssert, schemaKeysPresentInStateObject) {
    if (this.isComposite()) {
      const compositeStateObject = stateObject;
      const schema = this.compositeSchema;
      let valid = null;
      if (!compositeStateObject) {
        assert && toAssert && assert(false, 'There was no stateObject, but there was a state schema saying there should be', schema);
        valid = false;
        return valid;
      }
      const keys = Object.keys(schema);
      keys.forEach(key => {
        if (typeof key === 'string') {
          if (!compositeStateObject.hasOwnProperty(key)) {
            assert && toAssert && assert(false, `${key} in state schema but not in the state object`);
            valid = false;
          } else {
            if (!schema[key].isStateObjectValid(compositeStateObject[key], false)) {
              assert && toAssert && assert(false, `stateObject is not valid for ${key}. stateObject=`, compositeStateObject[key], 'schema=', schema[key]);
              valid = false;
            }
          }
          schemaKeysPresentInStateObject.push(key);
        } else {
          console.error('key should be a string', key);
          assert && assert(false, 'key should be a string');
        }
      });
      return valid;
    } else {
      assert && assert(this.validator, 'validator must be present if not composite');
      const valueStateObject = stateObject;
      if (assert && toAssert) {
        const validationError = Validation.getValidationError(valueStateObject, this.validator);
        assert(validationError === null, 'valueStateObject failed validation', valueStateObject, validationError);
      }
      return Validation.isValueValid(valueStateObject, this.validator);
    }
  }

  /**
   * Get a list of all IOTypes associated with this StateSchema
   */
  getRelatedTypes() {
    const relatedTypes = [];
    if (this.compositeSchema) {
      const keys = Object.keys(this.compositeSchema);
      keys.forEach(stateSchemaKey => {
        this.compositeSchema[stateSchemaKey] instanceof IOType && relatedTypes.push(this.compositeSchema[stateSchemaKey]);
      });
    }
    return relatedTypes;
  }

  /**
   * Returns a unique identified for this stateSchema, or an object of the stateSchemas for each sub-component in the composite
   * (phet-io internal)
   */
  getStateSchemaAPI() {
    if (this.isComposite()) {
      return _.mapValues(this.compositeSchema, value => value.typeName);
    } else {
      return this.displayString;
    }
  }

  /**
   * Factory function for StateSchema instances that represent a single value of state. This is opposed to a composite
   * schema of sub-components.
   */
  static asValue(displayString, validator) {
    assert && assert(validator, 'validator required');
    return new StateSchema({
      validator: validator,
      displayString: displayString
    });
  }
}
tandemNamespace.register('StateSchema', StateSchema);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJWYWxpZGF0aW9uIiwiYXNzZXJ0TXV0dWFsbHlFeGNsdXNpdmVPcHRpb25zIiwib3B0aW9uaXplIiwidGFuZGVtTmFtZXNwYWNlIiwiSU9UeXBlIiwiU3RhdGVTY2hlbWEiLCJjb25zdHJ1Y3RvciIsInByb3ZpZGVkT3B0aW9ucyIsImFzc2VydCIsIm9wdGlvbnMiLCJkaXNwbGF5U3RyaW5nIiwidmFsaWRhdG9yIiwiY29tcG9zaXRlU2NoZW1hIiwiZGVmYXVsdEFwcGx5U3RhdGUiLCJjb3JlT2JqZWN0Iiwic3RhdGVPYmplY3QiLCJpc0NvbXBvc2l0ZSIsInN0YXRlS2V5IiwiaGFzT3duUHJvcGVydHkiLCJzY2hlbWFJT1R5cGUiLCJjb3JlT2JqZWN0QWNjZXNzb3JOYW1lIiwiZ2V0Q29yZU9iamVjdEFjY2Vzc29yTmFtZSIsImRlZmF1bHREZXNlcmlhbGl6YXRpb25NZXRob2QiLCJmcm9tU3RhdGVPYmplY3QiLCJhcHBseVN0YXRlIiwiZGVmYXVsdFRvU3RhdGVPYmplY3QiLCJkZXNjcmlwdG9yIiwiT2JqZWN0IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiaXNHZXR0ZXIiLCJwcm90b3R5cGUiLCJwcm90b3R5cGVEZXNjcmlwdG9yIiwiZ2V0IiwiaXNWYWx1ZSIsIndyaXRhYmxlIiwidG9TdGF0ZU9iamVjdCIsInN0YXJ0c1dpdGgiLCJub1VuZGVyc2NvcmUiLCJzdWJzdHJpbmciLCJ1bmRlcnNjb3JlZCIsImNoZWNrU3RhdGVPYmplY3RWYWxpZCIsInRvQXNzZXJ0Iiwic2NoZW1hS2V5c1ByZXNlbnRJblN0YXRlT2JqZWN0IiwiY29tcG9zaXRlU3RhdGVPYmplY3QiLCJzY2hlbWEiLCJ2YWxpZCIsImtleXMiLCJmb3JFYWNoIiwia2V5IiwiaXNTdGF0ZU9iamVjdFZhbGlkIiwicHVzaCIsImNvbnNvbGUiLCJlcnJvciIsInZhbHVlU3RhdGVPYmplY3QiLCJ2YWxpZGF0aW9uRXJyb3IiLCJnZXRWYWxpZGF0aW9uRXJyb3IiLCJpc1ZhbHVlVmFsaWQiLCJnZXRSZWxhdGVkVHlwZXMiLCJyZWxhdGVkVHlwZXMiLCJzdGF0ZVNjaGVtYUtleSIsImdldFN0YXRlU2NoZW1hQVBJIiwiXyIsIm1hcFZhbHVlcyIsInZhbHVlIiwidHlwZU5hbWUiLCJhc1ZhbHVlIiwicmVnaXN0ZXIiXSwic291cmNlcyI6WyJTdGF0ZVNjaGVtYS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAyMS0yMDI0LCBVbml2ZXJzaXR5IG9mIENvbG9yYWRvIEJvdWxkZXJcclxuXHJcbi8qKlxyXG4gKiBDbGFzcyByZXNwb25zaWJsZSBmb3Igc3RvcmluZyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgc2NoZW1hIG9mIFBoRVQtaU8gc3RhdGUuIFNlZSBJT1R5cGUgc3RhdGVTY2hlbWEgb3B0aW9uIGZvciB1c2FnZVxyXG4gKiBhbmQgbW9yZSBpbmZvcm1hdGlvbi5cclxuICpcclxuICogVGhlcmUgYXJlIHR3byB0eXBlcyBvZiBTdGF0ZVNjaGVtYTpcclxuICogLSBUaGUgZmlyc3QgaXMgYSBzdGF0ZVNjaGVtYSBcInZhbHVlXCIuIFRoaXMgaXMgd2hlbiB0aGUgc3RhdGUgb2YgYW4gSU9UeXBlIGlzIGl0c2VsZiBhIHZhbHVlIGluIHRoZSBzdGF0ZS4gSW5cclxuICogZWZmZWN0LCB0aGlzIGp1c3Qgc2VydmVzIGFzIGJvaWxlcnBsYXRlLCBhbmQgaXNuJ3QgdGhlIHByaW1hcnkgdXNhZ2Ugb2Ygc3RhdGVTY2hlbWEuIEZvciBleGFtcGxlLCBhIFN0cmluZ0lPIG9yXHJcbiAqIE51bWJlcklPLlxyXG4gKiAtIFRoZSBzZWNvbmQgaXMgYSBcImNvbXBvc2l0ZVwiLCB3aGVyZSB0aGUgc3RhdGUgb2YgYW4gSU9UeXBlIGlzIG1hZGUgZnJvbSBzdWJjb21wb25lbnRzLCBlYWNoIG9mIHdoaWNoIGhhdmUgYW4gSU9UeXBlLlxyXG4gKiBBIGNvbXBvc2l0ZSBzY2hlbWEgd2FzIG5hbWVkIGJlY2F1c2UgaXQgaXMgYSBzdW0gb2YgaXRzIHBhcnRzLiBGb3IgZXhhbXBsZSBhIEJ1bm55SU8gaGFzIG11bHRpcGxlIGNvbXBvbmVudHMgdGhhdFxyXG4gKiBtYWtlIGl0IHVwIChtb3RoZXIvZmF0aGVyL2FnZS9ldGMpLiBDaGVjayB3aGljaCB0eXBlIG9mIFN0YXRlU2NoZW1hIHlvdXIgaW5zdGFuY2UgaXMgd2l0aCBTdGF0ZVNjaGVtYS5pc0NvbXBvc2l0ZSgpLlxyXG4gKlxyXG4gKiBXaGVuIHN0b3JlZCBpbiB0aGUgQVBJLCBTdGF0ZVNjaGVtYSB2YWx1ZXMgYXJlIHN0b3JlZCBhcyBzdHJpbmdzLCBzZWUgU3RhdGVTY2hlbWEuYXNWYWx1ZSwgYW5kIGNvbXBvc2l0ZSBzdGF0ZSBzY2hlbWFzXHJcbiAqIGFyZSBzdG9yZWQgYXMgb2JqZWN0cyB3aXRoIHZhbHVlcyB0aGF0IGFyZSBlYWNoIElPVHlwZSBuYW1lcy5cclxuICpcclxuICogQGF1dGhvciBTYW0gUmVpZCAoUGhFVCBJbnRlcmFjdGl2ZSBTaW11bGF0aW9ucylcclxuICogQGF1dGhvciBNaWNoYWVsIEthdXptYW5uIChQaEVUIEludGVyYWN0aXZlIFNpbXVsYXRpb25zKVxyXG4gKi9cclxuXHJcbmltcG9ydCBWYWxpZGF0aW9uLCB7IFZhbGlkYXRvciB9IGZyb20gJy4uLy4uLy4uL2F4b24vanMvVmFsaWRhdGlvbi5qcyc7XHJcbmltcG9ydCBhc3NlcnRNdXR1YWxseUV4Y2x1c2l2ZU9wdGlvbnMgZnJvbSAnLi4vLi4vLi4vcGhldC1jb3JlL2pzL2Fzc2VydE11dHVhbGx5RXhjbHVzaXZlT3B0aW9ucy5qcyc7XHJcbmltcG9ydCBvcHRpb25pemUgZnJvbSAnLi4vLi4vLi4vcGhldC1jb3JlL2pzL29wdGlvbml6ZS5qcyc7XHJcbmltcG9ydCB0YW5kZW1OYW1lc3BhY2UgZnJvbSAnLi4vdGFuZGVtTmFtZXNwYWNlLmpzJztcclxuaW1wb3J0IElPVHlwZSBmcm9tICcuL0lPVHlwZS5qcyc7XHJcbmltcG9ydCBJbnRlbnRpb25hbEFueSBmcm9tICcuLi8uLi8uLi9waGV0LWNvcmUvanMvdHlwZXMvSW50ZW50aW9uYWxBbnkuanMnO1xyXG5pbXBvcnQgeyBJT1R5cGVOYW1lIH0gZnJvbSAnLi4vVGFuZGVtQ29uc3RhbnRzLmpzJztcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGlzIHRoZSBwcmltYXJ5IGZ1bmN0aW9uYWxpdHkgb2YgdGhlIFN0YXRlU2NoZW1hIGNsYXNzLiBBbiBJT1R5cGUgY2FuIGJlIHByb3ZpZGVkIGEgY29tcG9zaXRlIHNjaGVtYSBsaWtlIHNvOlxyXG4gKiB7XHJcbiAqICAgc3ViY29tcG9uZW50MTogU3RyaW5nSU87XHJcbiAqICAgc3ViY29tcG9uZW50MjogTnVtYmVySU87XHJcbiAqIH1cclxuICogQnkgcHJvdmlkaW5nIHRoaXMsIHlvdSBhcmUgZ2l2aW5nIHRoZSBzY2hlbWEgdG8gYWxsb3cgU3RhdGVTY2hlbWEgdG8gc2VyaWFsaXplIGFuZCBkZXNlcmlhbGl6ZSBpdHNlbGYgYmFzZWQgb24gdGhlXHJcbiAqIGNvbXBvc2l0ZSBzY2hlbWEuXHJcbiAqL1xyXG5leHBvcnQgdHlwZSBDb21wb3NpdGVTY2hlbWE8U2VsZlN0YXRlVHlwZT4gPSB7XHJcbiAgW0sgaW4ga2V5b2YgU2VsZlN0YXRlVHlwZV06IElPVHlwZVxyXG59O1xyXG5cclxuLy8gQXMgcHJvdmlkZWQgaW4gdGhlIFBoRVQtaU8gQVBJIGpzb24uXHJcbnR5cGUgQ29tcG9zaXRlU2NoZW1hQVBJID0gUmVjb3JkPHN0cmluZywgSU9UeXBlTmFtZT47XHJcblxyXG4vLyBUaGUgc2NoZW1hIG9mIHRoZSBzdGF0ZU9iamVjdCB2YWx1ZVxyXG5leHBvcnQgdHlwZSBDb21wb3NpdGVTdGF0ZU9iamVjdFR5cGUgPSBSZWNvcmQ8c3RyaW5nLCBJbnRlbnRpb25hbEFueT47XHJcblxyXG4vLyBQbHVjayB0aGUgcmVzdWx0IHRvU3RhdGVPYmplY3QgdHlwZXMgZnJvbSB0aGUgQ29tcG9zaXRlU2NoZW1hLiBGb3IgaW5zdGFuY2UsIG1hcCBhIHN0YXRlIHNjaGVtYSBsaWtlIHNvOlxyXG4vLyB7bmFtZTogU3RyaW5nSU99ID0+IHtuYW1lOiBzdHJpbmd9XHJcbmV4cG9ydCB0eXBlIFN0YXRlT2JqZWN0PFQgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCBJT1R5cGU+PiA9IHtcclxuICBba2V5IGluIGtleW9mIFRdOiBSZXR1cm5UeXBlPFRba2V5XVsndG9TdGF0ZU9iamVjdCddPjtcclxufTtcclxuXHJcbnR5cGUgU3RhdGVTY2hlbWFPcHRpb25zPFNlbGZTdGF0ZVR5cGU+ID0ge1xyXG5cclxuICAvLyBXaGF0IHRoZSBJT1R5cGUgd2lsbCBkaXNwbGF5IGFzIGluIHRoZSBBUEkuXHJcbiAgZGlzcGxheVN0cmluZz86IHN0cmluZztcclxuXHJcbiAgLy8gUHJvdmlkZWQgdG8gdmFsaWRhdGUgdGhlIGNvbnRlbnRzIG9mIHRoZSBzdGF0ZU9iamVjdC4gTm90IHRoZSBpbnN0YW5jZSBpdCBjYW1lIGZyb21cclxuICB2YWxpZGF0b3I/OiBWYWxpZGF0b3I8SW50ZW50aW9uYWxBbnk+IHwgbnVsbDtcclxuXHJcbiAgLy8gVGhlIHByaW1hcnkgd2F5IHRvIHByb3ZpZGUgdGhlIGRldGFpbGVkIHNjaGVtYSBhYm91dCB0aGUgc3RhdGUgZm9yIHRoaXMgaW5zdGFuY2UuIENvbXBvc2l0ZSBzY2hlbWFzIGFyZSBhIHN1bSBvZlxyXG4gIC8vIHRoZWlyIHN0YXRlZnVsIHBhcnRzLCBpbnN0ZWFkIG9mIGEgXCJ2YWx1ZVwiIHRoZW1zZWx2ZXMuXHJcbiAgLy8gQW4gb2JqZWN0IGxpdGVyYWwgb2Yga2V5cyB0aGF0IGNvcnJlc3BvbmQgdG8gYW4gSU9UeXBlXHJcbiAgY29tcG9zaXRlU2NoZW1hPzogbnVsbCB8IENvbXBvc2l0ZVNjaGVtYTxTZWxmU3RhdGVUeXBlPjtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0YXRlU2NoZW1hPFQsIFNlbGZTdGF0ZVR5cGU+IHtcclxuICBwcml2YXRlIHJlYWRvbmx5IGRpc3BsYXlTdHJpbmc6IHN0cmluZztcclxuICBwcml2YXRlIHJlYWRvbmx5IHZhbGlkYXRvcjogVmFsaWRhdG9yPFNlbGZTdGF0ZVR5cGU+IHwgbnVsbDtcclxuXHJcbiAgLy8gXCJjb21wb3NpdGVcIiBzdGF0ZSBzY2hlbWFzIGFyZSB0cmVhdGVkIGRpZmZlcmVudGx5IHRoYXQgdmFsdWUgc3RhdGUgc2NoZW1hc1xyXG4gIHB1YmxpYyByZWFkb25seSBjb21wb3NpdGVTY2hlbWE6IG51bGwgfCBDb21wb3NpdGVTY2hlbWE8U2VsZlN0YXRlVHlwZT47XHJcblxyXG4gIHB1YmxpYyBjb25zdHJ1Y3RvciggcHJvdmlkZWRPcHRpb25zPzogU3RhdGVTY2hlbWFPcHRpb25zPFNlbGZTdGF0ZVR5cGU+ICkge1xyXG5cclxuICAgIC8vIEVpdGhlciBjcmVhdGUgd2l0aCBjb21wb3NpdGVTY2hlbWEsIG9yIHNwZWNpZnkgYSB0aGF0IHRoaXMgc3RhdGUgaXMganVzdCBhIHZhbHVlXHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0TXV0dWFsbHlFeGNsdXNpdmVPcHRpb25zKCBwcm92aWRlZE9wdGlvbnMsIFsgJ2NvbXBvc2l0ZVNjaGVtYScgXSwgWyAnZGlzcGxheVN0cmluZycsICd2YWxpZGF0b3InIF0gKTtcclxuXHJcbiAgICBjb25zdCBvcHRpb25zID0gb3B0aW9uaXplPFN0YXRlU2NoZW1hT3B0aW9uczxTZWxmU3RhdGVUeXBlPj4oKSgge1xyXG4gICAgICBkaXNwbGF5U3RyaW5nOiAnJyxcclxuICAgICAgdmFsaWRhdG9yOiBudWxsLFxyXG4gICAgICBjb21wb3NpdGVTY2hlbWE6IG51bGxcclxuICAgIH0sIHByb3ZpZGVkT3B0aW9ucyApO1xyXG5cclxuICAgIHRoaXMuZGlzcGxheVN0cmluZyA9IG9wdGlvbnMuZGlzcGxheVN0cmluZztcclxuICAgIHRoaXMudmFsaWRhdG9yID0gb3B0aW9ucy52YWxpZGF0b3I7XHJcblxyXG4gICAgdGhpcy5jb21wb3NpdGVTY2hlbWEgPSBvcHRpb25zLmNvbXBvc2l0ZVNjaGVtYTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgbWV0aG9kIHByb3ZpZGVzIGEgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBmb3Igc2V0dGluZyBhIHN0YXRlT2JqZWN0IG9udG8gYW4gb2JqZWN0IGZyb20gdGhlIHN0YXRlU2NoZW1hIGluZm9ybWF0aW9uLlxyXG4gICAqIEl0IHN1cHBvcnRzIHRoZSBjb3JlT2JqZWN0IGtleXMgYXMgcHJpdmF0ZSwgdW5kZXJzY29yZS1wcmVmaXhlZCBmaWVsZCwgYXNcclxuICAgKiB3ZWxsIGFzIGlmIHRoZSBjb3JlT2JqZWN0IGhhcyBhbiBlczUgc2V0dGVyIGluc3RlYWQgb2YgYW4gYWN0dWFsIGZpZWxkLlxyXG4gICAqL1xyXG4gIHB1YmxpYyBkZWZhdWx0QXBwbHlTdGF0ZSggY29yZU9iamVjdDogVCwgc3RhdGVPYmplY3Q6IENvbXBvc2l0ZVN0YXRlT2JqZWN0VHlwZSApOiB2b2lkIHtcclxuXHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCB0aGlzLmlzQ29tcG9zaXRlKCksICdkZWZhdWx0QXBwbHlTdGF0ZSBmcm9tIHN0YXRlU2NoZW1hIG9ubHkgYXBwbGllcyB0byBjb21wb3NpdGUgc3RhdGVTY2hlbWFzJyApO1xyXG4gICAgZm9yICggY29uc3Qgc3RhdGVLZXkgaW4gdGhpcy5jb21wb3NpdGVTY2hlbWEgKSB7XHJcbiAgICAgIGlmICggdGhpcy5jb21wb3NpdGVTY2hlbWEuaGFzT3duUHJvcGVydHkoIHN0YXRlS2V5ICkgKSB7XHJcbiAgICAgICAgYXNzZXJ0ICYmIGFzc2VydCggc3RhdGVPYmplY3QuaGFzT3duUHJvcGVydHkoIHN0YXRlS2V5ICksIGBzdGF0ZU9iamVjdCBkb2VzIG5vdCBoYXZlIGV4cGVjdGVkIHNjaGVtYSBrZXk6ICR7c3RhdGVLZXl9YCApO1xyXG5cclxuICAgICAgICAvLyBUaGUgSU9UeXBlIGZvciB0aGUga2V5IGluIHRoZSBjb21wb3NpdGUuXHJcbiAgICAgICAgY29uc3Qgc2NoZW1hSU9UeXBlID0gdGhpcy5jb21wb3NpdGVTY2hlbWFbIHN0YXRlS2V5IF07XHJcblxyXG4gICAgICAgIGNvbnN0IGNvcmVPYmplY3RBY2Nlc3Nvck5hbWUgPSB0aGlzLmdldENvcmVPYmplY3RBY2Nlc3Nvck5hbWUoIHN0YXRlS2V5LCBjb3JlT2JqZWN0ICk7XHJcblxyXG4gICAgICAgIC8vIFVzaW5nIGZyb21TdGF0ZU9iamVjdCB0byBkZXNlcmlhbGl6ZSBzdWItY29tcG9uZW50XHJcbiAgICAgICAgaWYgKCBzY2hlbWFJT1R5cGUuZGVmYXVsdERlc2VyaWFsaXphdGlvbk1ldGhvZCA9PT0gJ2Zyb21TdGF0ZU9iamVjdCcgKSB7XHJcblxyXG4gICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciwgSSBkb24ndCBrbm93IGhvdyB0byB0ZWxsIHR5cGVzY3JpcHQgdGhhdCB3ZSBhcmUgYWNjZXNzaW5nIGFuIGV4cGVjdGVkIGtleSBvbiB0aGUgUGhldGlvT2JqZWN0IHN1YnR5cGUuIExpa2VseSB0aGVyZSBpcyBubyB3YXkgd2l0aCBtYWtpbmcgdGhpbmdzIGdlbmVyaWMuXHJcbiAgICAgICAgICBjb3JlT2JqZWN0WyBjb3JlT2JqZWN0QWNjZXNzb3JOYW1lIF0gPSB0aGlzLmNvbXBvc2l0ZVNjaGVtYVsgc3RhdGVLZXkgXS5mcm9tU3RhdGVPYmplY3QoIHN0YXRlT2JqZWN0WyBzdGF0ZUtleSBdICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgYXNzZXJ0ICYmIGFzc2VydCggc2NoZW1hSU9UeXBlLmRlZmF1bHREZXNlcmlhbGl6YXRpb25NZXRob2QgPT09ICdhcHBseVN0YXRlJywgJ3VuZXhwZWN0ZWQgZGVzZXJpYWxpemF0aW9uIG1ldGhvZCcgKTtcclxuXHJcbiAgICAgICAgICAvLyBVc2luZyBhcHBseVN0YXRlIHRvIGRlc2VyaWFsaXplIHN1Yi1jb21wb25lbnRcclxuICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IsIEkgZG9uJ3Qga25vdyBob3cgdG8gdGVsbCB0eXBlc2NyaXB0IHRoYXQgd2UgYXJlIGFjY2Vzc2luZyBhbiBleHBlY3RlZCBrZXkgb24gdGhlIFBoZXRpb09iamVjdCBzdWJ0eXBlLiBMaWtlbHkgdGhlcmUgaXMgbm8gd2F5IHdpdGggbWFraW5nIHRoaW5ncyBnZW5lcmljLlxyXG4gICAgICAgICAgdGhpcy5jb21wb3NpdGVTY2hlbWFbIHN0YXRlS2V5IF0uYXBwbHlTdGF0ZSggY29yZU9iamVjdFsgY29yZU9iamVjdEFjY2Vzc29yTmFtZSBdLCBzdGF0ZU9iamVjdFsgc3RhdGVLZXkgXSApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBtZXRob2QgcHJvdmlkZXMgYSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGZvciBjcmVhdGluZyBhIHN0YXRlT2JqZWN0IGZyb20gdGhlIHN0YXRlU2NoZW1hIGJ5IGFjY2Vzc2luZyB0aG9zZVxyXG4gICAqIHNhbWUga2V5IG5hbWVzIG9uIHRoZSBjb3JlT2JqZWN0IGluc3RhbmNlLiBJdCBzdXBwb3J0cyB0aG9zZSBrZXlzIGFzIHByaXZhdGUsIHVuZGVyc2NvcmUtcHJlZml4ZWQgZmllbGQsIGFzXHJcbiAgICogd2VsbCBhcyBpZiB0aGUgY29yZU9iamVjdCBoYXMgYW4gZXM1IGdldHRlciBpbnN0ZWFkIG9mIGFuIGFjdHVhbCBmaWVsZC5cclxuICAgKi9cclxuICBwdWJsaWMgZGVmYXVsdFRvU3RhdGVPYmplY3QoIGNvcmVPYmplY3Q6IFQgKTogU2VsZlN0YXRlVHlwZSB7XHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCB0aGlzLmlzQ29tcG9zaXRlKCksICdkZWZhdWx0VG9TdGF0ZU9iamVjdCBmcm9tIHN0YXRlU2NoZW1hIG9ubHkgYXBwbGllcyB0byBjb21wb3NpdGUgc3RhdGVTY2hlbWFzJyApO1xyXG5cclxuICAgIGNvbnN0IHN0YXRlT2JqZWN0ID0ge307XHJcbiAgICBmb3IgKCBjb25zdCBzdGF0ZUtleSBpbiB0aGlzLmNvbXBvc2l0ZVNjaGVtYSApIHtcclxuICAgICAgaWYgKCB0aGlzLmNvbXBvc2l0ZVNjaGVtYS5oYXNPd25Qcm9wZXJ0eSggc3RhdGVLZXkgKSApIHtcclxuXHJcbiAgICAgICAgY29uc3QgY29yZU9iamVjdEFjY2Vzc29yTmFtZSA9IHRoaXMuZ2V0Q29yZU9iamVjdEFjY2Vzc29yTmFtZSggc3RhdGVLZXksIGNvcmVPYmplY3QgKTtcclxuXHJcbiAgICAgICAgaWYgKCBhc3NlcnQgKSB7XHJcbiAgICAgICAgICBjb25zdCBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciggY29yZU9iamVjdCwgY29yZU9iamVjdEFjY2Vzc29yTmFtZSApITtcclxuXHJcbiAgICAgICAgICBsZXQgaXNHZXR0ZXIgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFN1YnR5cGUgVCBmb3IgdGhpcyBtZXRob2QgYmV0dGVyXHJcbiAgICAgICAgICBpZiAoIGNvcmVPYmplY3QuY29uc3RydWN0b3IucHJvdG90eXBlICkge1xyXG5cclxuICAgICAgICAgICAgLy8gVGhlIHByb3RvdHlwZSBpcyB3aGF0IGhhcyB0aGUgZ2V0dGVyIG9uIGl0XHJcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgU3VidHlwZSBUIGZvciB0aGlzIG1ldGhvZCBiZXR0ZXJcclxuICAgICAgICAgICAgY29uc3QgcHJvdG90eXBlRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoIGNvcmVPYmplY3QuY29uc3RydWN0b3IhLnByb3RvdHlwZSwgY29yZU9iamVjdEFjY2Vzc29yTmFtZSApO1xyXG4gICAgICAgICAgICBpc0dldHRlciA9ICEhcHJvdG90eXBlRGVzY3JpcHRvciAmJiAhIXByb3RvdHlwZURlc2NyaXB0b3IuZ2V0O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGNvbnN0IGlzVmFsdWUgPSAhIWRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci5oYXNPd25Qcm9wZXJ0eSggJ3ZhbHVlJyApICYmIGRlc2NyaXB0b3Iud3JpdGFibGU7XHJcbiAgICAgICAgICBhc3NlcnQgJiYgYXNzZXJ0KCBpc1ZhbHVlIHx8IGlzR2V0dGVyLFxyXG4gICAgICAgICAgICBgY2Fubm90IGdldCBzdGF0ZSBiZWNhdXNlIGNvcmVPYmplY3QgZG9lcyBub3QgaGF2ZSBleHBlY3RlZCBzY2hlbWEga2V5OiAke2NvcmVPYmplY3RBY2Nlc3Nvck5hbWV9YCApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL3RhbmRlbS9pc3N1ZXMvMjYxXHJcbiAgICAgICAgc3RhdGVPYmplY3RbIHN0YXRlS2V5IF0gPSB0aGlzLmNvbXBvc2l0ZVNjaGVtYVsgc3RhdGVLZXkgXS50b1N0YXRlT2JqZWN0KCBjb3JlT2JqZWN0WyBjb3JlT2JqZWN0QWNjZXNzb3JOYW1lIF0gKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHN0YXRlT2JqZWN0IGFzIFNlbGZTdGF0ZVR5cGU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQcm92aWRlIHRoZSBtZW1iZXIgc3RyaW5nIGtleSB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIGdldC9zZXQgYW4gaW5zdGFuY2UncyBmaWVsZC4gVXNlZCBvbmx5IGludGVybmFsbHkgZm9yIHRoZVxyXG4gICAqIGRlZmF1bHQgaW1wbGVtZW50YXRpb25zIG9mIHRvU3RhdGVPYmplY3QgYW5kIGFwcGx5U3RhdGUuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBnZXRDb3JlT2JqZWN0QWNjZXNzb3JOYW1lKCBzdGF0ZUtleTogc3RyaW5nLCBjb3JlT2JqZWN0OiBUICk6IHN0cmluZyB7XHJcblxyXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggIXN0YXRlS2V5LnN0YXJ0c1dpdGgoICdfXycgKSwgJ1N0YXRlIGtleXMgc2hvdWxkIG5vdCBzdGFydCB3aXRoIHRvbyBtYW55IHVuZGVyc2NvcmVzOiAnICsgc3RhdGVLZXkgKyAnLiBXaGVuIHNlcmlhbGl6aW5nICcsIGNvcmVPYmplY3QgKTtcclxuXHJcbiAgICAvLyBEb2VzIHRoZSBjbGFzcyBmaWVsZCBzdGFydCB3aXRoIGFuIHVuZGVyc2NvcmU/IFdlIG5lZWQgdG8gY292ZXIgdHdvIGNhc2VzIGhlcmUuIFRoZSBmaXJzdCBpcyB3aGVyZSB0aGUgdW5kZXJzY29yZVxyXG4gICAgLy8gd2FzIGFkZGVkIHRvIG1ha2UgYSBwcml2YXRlIHN0YXRlIGtleS4gVGhlIHNlY29uZCwgaXMgd2hlcmUgdGhlIGNvcmUgY2xhc3Mgb25seSBoYXMgdGhlIHVuZGVyc2NvcmUtcHJlZml4ZWRcclxuICAgIC8vIGZpZWxkIGtleSBuYW1lIGF2YWlsYWJsZSBmb3Igc2V0dGluZy4gVGhlIGVhc2llc3QgYWxnb3JpdGhtIHRvIGNvdmVyIGFsbCBjYXNlcyBpcyB0byBzZWUgaWYgdGhlIGNvcmVPYmplY3QgaGFzXHJcbiAgICAvLyB0aGUgdW5kZXJzY29yZS1wcmVmaXhlZCBrZXkgbmFtZSwgYW5kIHVzZSB0aGF0IGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIHVzZSB0aGUgc3RhdGVLZXkgd2l0aG91dCBhbiB1bmRlcnNjb3JlLlxyXG4gICAgY29uc3Qgbm9VbmRlcnNjb3JlID0gc3RhdGVLZXkuc3RhcnRzV2l0aCggJ18nICkgPyBzdGF0ZUtleS5zdWJzdHJpbmcoIDEgKSA6IHN0YXRlS2V5O1xyXG4gICAgY29uc3QgdW5kZXJzY29yZWQgPSBgXyR7bm9VbmRlcnNjb3JlfWA7XHJcbiAgICBsZXQgY29yZU9iamVjdEFjY2Vzc29yTmFtZTogc3RyaW5nO1xyXG5cclxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLSBUIGlzIG5vdCBzcGVjaWZpYyB0byBjb21wb3NpdGUgc2NoZW1hcywgc28gTnVtYmVySU8gZG9lc24ndCBhY3R1YWxseSBuZWVkIGEgaGFzT3duUHJvcGVydHkgbWV0aG9kXHJcbiAgICBpZiAoIGNvcmVPYmplY3QuaGFzT3duUHJvcGVydHkoIHVuZGVyc2NvcmVkICkgKSB7XHJcbiAgICAgIGNvcmVPYmplY3RBY2Nlc3Nvck5hbWUgPSB1bmRlcnNjb3JlZDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICBjb3JlT2JqZWN0QWNjZXNzb3JOYW1lID0gbm9VbmRlcnNjb3JlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNvcmVPYmplY3RBY2Nlc3Nvck5hbWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUcnVlIGlmIHRoZSBTdGF0ZVNjaGVtYSBpcyBhIGNvbXBvc2l0ZSBzY2hlbWEuIFNlZSB0aGUgaGVhZGVyIGRvY3VtZW50YXRpb24gaW4gdGhpcyBmaWxlIGZvciB0aGUgZGVmaW5pdGlvblxyXG4gICAqIG9mIFwiY29tcG9zaXRlXCIgc2NoZW1hLlxyXG4gICAqL1xyXG4gIHB1YmxpYyBpc0NvbXBvc2l0ZSgpOiBib29sZWFuIHtcclxuICAgIHJldHVybiAhIXRoaXMuY29tcG9zaXRlU2NoZW1hO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBnaXZlbiBzdGF0ZU9iamVjdCBpcyBhcyB2YWxpZCBhcyBjYW4gYmUgZGV0ZXJtaW5lZCBieSB0aGlzIFN0YXRlU2NoZW1hLiBXaWxsIHJldHVybiBudWxsIGlmIHZhbGlkLCBidXRcclxuICAgKiBuZWVkcyBtb3JlIGNoZWNraW5nIHVwIGFuZCBkb3duIHRoZSBoaWVyYXJjaHkuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gc3RhdGVPYmplY3QgLSB0aGUgc3RhdGVPYmplY3QgdG8gdmFsaWRhdGUgYWdhaW5zdFxyXG4gICAqIEBwYXJhbSB0b0Fzc2VydCAtIHdoZXRoZXIgdG8gYXNzZXJ0IHdoZW4gaW52YWxpZFxyXG4gICAqIEBwYXJhbSBzY2hlbWFLZXlzUHJlc2VudEluU3RhdGVPYmplY3QgLSB0byBiZSBwb3B1bGF0ZWQgd2l0aCBhbnkga2V5cyB0aGlzIFN0YXRlU2NoZW1hIGlzIHJlc3BvbnNpYmxlIGZvci5cclxuICAgKiBAcmV0dXJucyBib29sZWFuIGlmIHZhbGlkaXR5IGNhbiBiZSBjaGVja2VkLCBudWxsIGlmIHZhbGlkLCBidXQgbmV4dCBpbiB0aGUgaGllcmFyY2h5IGlzIG5lZWRlZFxyXG4gICAqL1xyXG4gIHB1YmxpYyBjaGVja1N0YXRlT2JqZWN0VmFsaWQoIHN0YXRlT2JqZWN0OiBTZWxmU3RhdGVUeXBlLCB0b0Fzc2VydDogYm9vbGVhbiwgc2NoZW1hS2V5c1ByZXNlbnRJblN0YXRlT2JqZWN0OiBzdHJpbmdbXSApOiBib29sZWFuIHwgbnVsbCB7XHJcbiAgICBpZiAoIHRoaXMuaXNDb21wb3NpdGUoKSApIHtcclxuICAgICAgY29uc3QgY29tcG9zaXRlU3RhdGVPYmplY3QgPSBzdGF0ZU9iamVjdCBhcyBDb21wb3NpdGVTdGF0ZU9iamVjdFR5cGU7XHJcbiAgICAgIGNvbnN0IHNjaGVtYSA9IHRoaXMuY29tcG9zaXRlU2NoZW1hITtcclxuXHJcbiAgICAgIGxldCB2YWxpZCA9IG51bGw7XHJcbiAgICAgIGlmICggIWNvbXBvc2l0ZVN0YXRlT2JqZWN0ICkge1xyXG4gICAgICAgIGFzc2VydCAmJiB0b0Fzc2VydCAmJiBhc3NlcnQoIGZhbHNlLCAnVGhlcmUgd2FzIG5vIHN0YXRlT2JqZWN0LCBidXQgdGhlcmUgd2FzIGEgc3RhdGUgc2NoZW1hIHNheWluZyB0aGVyZSBzaG91bGQgYmUnLCBzY2hlbWEgKTtcclxuICAgICAgICB2YWxpZCA9IGZhbHNlO1xyXG4gICAgICAgIHJldHVybiB2YWxpZDtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoIHNjaGVtYSApIGFzICgga2V5b2YgQ29tcG9zaXRlU2NoZW1hPFNlbGZTdGF0ZVR5cGU+IClbXTtcclxuICAgICAga2V5cy5mb3JFYWNoKCBrZXkgPT4ge1xyXG5cclxuICAgICAgICBpZiAoIHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICkge1xyXG5cclxuICAgICAgICAgIGlmICggIWNvbXBvc2l0ZVN0YXRlT2JqZWN0Lmhhc093blByb3BlcnR5KCBrZXkgKSApIHtcclxuICAgICAgICAgICAgYXNzZXJ0ICYmIHRvQXNzZXJ0ICYmIGFzc2VydCggZmFsc2UsIGAke2tleX0gaW4gc3RhdGUgc2NoZW1hIGJ1dCBub3QgaW4gdGhlIHN0YXRlIG9iamVjdGAgKTtcclxuICAgICAgICAgICAgdmFsaWQgPSBmYWxzZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoICFzY2hlbWFbIGtleSBdLmlzU3RhdGVPYmplY3RWYWxpZCggY29tcG9zaXRlU3RhdGVPYmplY3RbIGtleSBdLCBmYWxzZSApICkge1xyXG4gICAgICAgICAgICAgIGFzc2VydCAmJiB0b0Fzc2VydCAmJiBhc3NlcnQoIGZhbHNlLCBgc3RhdGVPYmplY3QgaXMgbm90IHZhbGlkIGZvciAke2tleX0uIHN0YXRlT2JqZWN0PWAsIGNvbXBvc2l0ZVN0YXRlT2JqZWN0WyBrZXkgXSwgJ3NjaGVtYT0nLCBzY2hlbWFbIGtleSBdICk7XHJcbiAgICAgICAgICAgICAgdmFsaWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgc2NoZW1hS2V5c1ByZXNlbnRJblN0YXRlT2JqZWN0LnB1c2goIGtleSApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoICdrZXkgc2hvdWxkIGJlIGEgc3RyaW5nJywga2V5ICk7XHJcbiAgICAgICAgICBhc3NlcnQgJiYgYXNzZXJ0KCBmYWxzZSwgJ2tleSBzaG91bGQgYmUgYSBzdHJpbmcnICk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9ICk7XHJcbiAgICAgIHJldHVybiB2YWxpZDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICBhc3NlcnQgJiYgYXNzZXJ0KCB0aGlzLnZhbGlkYXRvciwgJ3ZhbGlkYXRvciBtdXN0IGJlIHByZXNlbnQgaWYgbm90IGNvbXBvc2l0ZScgKTtcclxuICAgICAgY29uc3QgdmFsdWVTdGF0ZU9iamVjdCA9IHN0YXRlT2JqZWN0O1xyXG5cclxuICAgICAgaWYgKCBhc3NlcnQgJiYgdG9Bc3NlcnQgKSB7XHJcbiAgICAgICAgY29uc3QgdmFsaWRhdGlvbkVycm9yID0gVmFsaWRhdGlvbi5nZXRWYWxpZGF0aW9uRXJyb3IoIHZhbHVlU3RhdGVPYmplY3QsIHRoaXMudmFsaWRhdG9yISApO1xyXG4gICAgICAgIGFzc2VydCggdmFsaWRhdGlvbkVycm9yID09PSBudWxsLCAndmFsdWVTdGF0ZU9iamVjdCBmYWlsZWQgdmFsaWRhdGlvbicsIHZhbHVlU3RhdGVPYmplY3QsIHZhbGlkYXRpb25FcnJvciApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gVmFsaWRhdGlvbi5pc1ZhbHVlVmFsaWQoIHZhbHVlU3RhdGVPYmplY3QsIHRoaXMudmFsaWRhdG9yISApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IGEgbGlzdCBvZiBhbGwgSU9UeXBlcyBhc3NvY2lhdGVkIHdpdGggdGhpcyBTdGF0ZVNjaGVtYVxyXG4gICAqL1xyXG4gIHB1YmxpYyBnZXRSZWxhdGVkVHlwZXMoKTogSU9UeXBlW10ge1xyXG4gICAgY29uc3QgcmVsYXRlZFR5cGVzOiBJT1R5cGVbXSA9IFtdO1xyXG5cclxuICAgIGlmICggdGhpcy5jb21wb3NpdGVTY2hlbWEgKSB7XHJcblxyXG4gICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoIHRoaXMuY29tcG9zaXRlU2NoZW1hICkgYXMgKCBrZXlvZiBDb21wb3NpdGVTY2hlbWE8U2VsZlN0YXRlVHlwZT4gKVtdO1xyXG4gICAgICBrZXlzLmZvckVhY2goIHN0YXRlU2NoZW1hS2V5ID0+IHtcclxuICAgICAgICB0aGlzLmNvbXBvc2l0ZVNjaGVtYSFbIHN0YXRlU2NoZW1hS2V5IF0gaW5zdGFuY2VvZiBJT1R5cGUgJiYgcmVsYXRlZFR5cGVzLnB1c2goIHRoaXMuY29tcG9zaXRlU2NoZW1hIVsgc3RhdGVTY2hlbWFLZXkgXSApO1xyXG4gICAgICB9ICk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVsYXRlZFR5cGVzO1xyXG4gIH1cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgYSB1bmlxdWUgaWRlbnRpZmllZCBmb3IgdGhpcyBzdGF0ZVNjaGVtYSwgb3IgYW4gb2JqZWN0IG9mIHRoZSBzdGF0ZVNjaGVtYXMgZm9yIGVhY2ggc3ViLWNvbXBvbmVudCBpbiB0aGUgY29tcG9zaXRlXHJcbiAgICogKHBoZXQtaW8gaW50ZXJuYWwpXHJcbiAgICovXHJcbiAgcHVibGljIGdldFN0YXRlU2NoZW1hQVBJKCk6IHN0cmluZyB8IENvbXBvc2l0ZVNjaGVtYUFQSSB7XHJcbiAgICBpZiAoIHRoaXMuaXNDb21wb3NpdGUoKSApIHtcclxuICAgICAgcmV0dXJuIF8ubWFwVmFsdWVzKCB0aGlzLmNvbXBvc2l0ZVNjaGVtYSwgdmFsdWUgPT4gdmFsdWUudHlwZU5hbWUgKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICByZXR1cm4gdGhpcy5kaXNwbGF5U3RyaW5nO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIEZhY3RvcnkgZnVuY3Rpb24gZm9yIFN0YXRlU2NoZW1hIGluc3RhbmNlcyB0aGF0IHJlcHJlc2VudCBhIHNpbmdsZSB2YWx1ZSBvZiBzdGF0ZS4gVGhpcyBpcyBvcHBvc2VkIHRvIGEgY29tcG9zaXRlXHJcbiAgICogc2NoZW1hIG9mIHN1Yi1jb21wb25lbnRzLlxyXG4gICAqL1xyXG4gIHB1YmxpYyBzdGF0aWMgYXNWYWx1ZTxULCBTdGF0ZVR5cGU+KCBkaXNwbGF5U3RyaW5nOiBzdHJpbmcsIHZhbGlkYXRvcjogVmFsaWRhdG9yPEludGVudGlvbmFsQW55PiApOiBTdGF0ZVNjaGVtYTxULCBTdGF0ZVR5cGU+IHtcclxuICAgIGFzc2VydCAmJiBhc3NlcnQoIHZhbGlkYXRvciwgJ3ZhbGlkYXRvciByZXF1aXJlZCcgKTtcclxuICAgIHJldHVybiBuZXcgU3RhdGVTY2hlbWE8VCwgU3RhdGVUeXBlPigge1xyXG4gICAgICB2YWxpZGF0b3I6IHZhbGlkYXRvcixcclxuICAgICAgZGlzcGxheVN0cmluZzogZGlzcGxheVN0cmluZ1xyXG4gICAgfSApO1xyXG4gIH1cclxufVxyXG5cclxudGFuZGVtTmFtZXNwYWNlLnJlZ2lzdGVyKCAnU3RhdGVTY2hlbWEnLCBTdGF0ZVNjaGVtYSApOyJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU9BLFVBQVUsTUFBcUIsZ0NBQWdDO0FBQ3RFLE9BQU9DLDhCQUE4QixNQUFNLHlEQUF5RDtBQUNwRyxPQUFPQyxTQUFTLE1BQU0sb0NBQW9DO0FBQzFELE9BQU9DLGVBQWUsTUFBTSx1QkFBdUI7QUFDbkQsT0FBT0MsTUFBTSxNQUFNLGFBQWE7O0FBSWhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFLQTs7QUFHQTs7QUFHQTtBQUNBOztBQW1CQSxlQUFlLE1BQU1DLFdBQVcsQ0FBbUI7RUFJakQ7O0VBR09DLFdBQVdBLENBQUVDLGVBQW1ELEVBQUc7SUFFeEU7SUFDQUMsTUFBTSxJQUFJUCw4QkFBOEIsQ0FBRU0sZUFBZSxFQUFFLENBQUUsaUJBQWlCLENBQUUsRUFBRSxDQUFFLGVBQWUsRUFBRSxXQUFXLENBQUcsQ0FBQztJQUVwSCxNQUFNRSxPQUFPLEdBQUdQLFNBQVMsQ0FBb0MsQ0FBQyxDQUFFO01BQzlEUSxhQUFhLEVBQUUsRUFBRTtNQUNqQkMsU0FBUyxFQUFFLElBQUk7TUFDZkMsZUFBZSxFQUFFO0lBQ25CLENBQUMsRUFBRUwsZUFBZ0IsQ0FBQztJQUVwQixJQUFJLENBQUNHLGFBQWEsR0FBR0QsT0FBTyxDQUFDQyxhQUFhO0lBQzFDLElBQUksQ0FBQ0MsU0FBUyxHQUFHRixPQUFPLENBQUNFLFNBQVM7SUFFbEMsSUFBSSxDQUFDQyxlQUFlLEdBQUdILE9BQU8sQ0FBQ0csZUFBZTtFQUNoRDs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0VBQ1NDLGlCQUFp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