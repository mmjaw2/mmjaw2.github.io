// Copyright 2020-2024, University of Colorado Boulder

/**
 * IOTypes form a synthetic type system used to describe PhET-iO Elements. A PhET-iO Element is an instrumented PhetioObject
 * that is interoperable from the "wrapper" frame (outside the sim frame). An IOType includes documentation, methods,
 * names, serialization, etc.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 */

import validate from '../../../axon/js/validate.js';
import Validation from '../../../axon/js/Validation.js';
import optionize from '../../../phet-core/js/optionize.js';
import PhetioConstants from '../PhetioConstants.js';
import TandemConstants from '../TandemConstants.js';
import tandemNamespace from '../tandemNamespace.js';
import StateSchema from './StateSchema.js';
// constants
const VALIDATE_OPTIONS_FALSE = {
  validateValidator: false
};

/**
 * Estimate the core type name from a given IOType name.
 */
const getCoreTypeName = ioTypeName => {
  const index = ioTypeName.indexOf(PhetioConstants.IO_TYPE_SUFFIX);
  assert && assert(index >= 0, 'IO should be in the type name');
  return ioTypeName.substring(0, index);
};
// StateType is the whole thing, SelfStateType is just at this level
// export default class IOType<T = any, SelfStateType = any, ParentStateType = EmptyParent, StateType extends SelfStateType & ParentStateType = SelfStateType & ParentStateType> { // eslint-disable-line @typescript-eslint/no-explicit-any
export default class IOType {
  // eslint-disable-line @typescript-eslint/no-explicit-any
  // See documentation in options type declaration

  // TODO: instead of unknown this is the second parameter type for PhetioDynamicElementContainer. How? https://github.com/phetsims/tandem/issues/261

  // The StateSchema (type) that the option is made into. The option is more flexible than the class.

  // The base IOType for the entire hierarchy.

  /**
   * @param typeName - The name that this IOType will have in the public PhET-iO API. In general, this should
   *    only be word characters, ending in "IO". Parametric types are a special subset of IOTypes that include their
   *    parameters in their typeName. If an IOType's parameters are other IOType(s), then they should be included within
   *    angle brackets, like "PropertyIO<BooleanIO>". Some other types use a more custom format for displaying their
   *    parameter types, in this case the parameter section of the type name (immediately following "IO") should begin
   *    with an open paren, "(". Thus the schema for a typeName could be defined (using regex) as `[A-Z]\w*IO([(<].*){0,1}`.
   *    Parameterized types should also include a `parameterTypes` field on the IOType.
   * @param providedOptions
   */
  constructor(typeName, providedOptions) {
    this.typeName = typeName;
    // For reference in the options
    const supertype = providedOptions.supertype || IOType.ObjectIO;
    const toStateObjectSupplied = !!providedOptions.toStateObject;
    const applyStateSupplied = !!providedOptions.applyState;
    const stateSchemaSupplied = !!providedOptions.stateSchema;
    const options = optionize()({
      supertype: IOType.ObjectIO,
      methods: {},
      events: [],
      metadataDefaults: {},
      //  Most likely this will remain PhET-iO internal, and shouldn't need to be used when creating IOTypes outside of tandem/.
      dataDefaults: {},
      methodOrder: [],
      parameterTypes: [],
      documentation: `PhET-iO Type for ${getCoreTypeName(typeName)}`,
      isFunctionType: false,
      /**** STATE ****/

      toStateObject: supertype && supertype.toStateObject,
      fromStateObject: supertype && supertype.fromStateObject,
      stateObjectToCreateElementArguments: supertype && supertype.stateObjectToCreateElementArguments,
      applyState: supertype && supertype.applyState,
      stateSchema: null,
      defaultDeserializationMethod: 'fromStateObject',
      addChildElement: supertype && supertype.addChildElement
    }, providedOptions);
    if (assert && supertype) {
      Object.keys(options.metadataDefaults).forEach(metadataDefaultKey => {
        assert && supertype.getAllMetadataDefaults().hasOwnProperty(metadataDefaultKey) && assert(supertype.getAllMetadataDefaults()[metadataDefaultKey] !== options.metadataDefaults[metadataDefaultKey], `${metadataDefaultKey} should not have the same default value as the ancestor metadata default.`);
      });
    }
    this.supertype = supertype;
    this.documentation = options.documentation;
    this.methods = options.methods;
    this.events = options.events;
    this.metadataDefaults = options.metadataDefaults;
    this.dataDefaults = options.dataDefaults;
    this.methodOrder = options.methodOrder;
    this.parameterTypes = options.parameterTypes;

    // Validation
    this.validator = _.pick(options, Validation.VALIDATOR_KEYS);
    this.validator.validationMessage = this.validator.validationMessage || `Validation failed IOType Validator: ${this.typeName}`;
    this.defaultDeserializationMethod = options.defaultDeserializationMethod;
    if (options.stateSchema === null || options.stateSchema instanceof StateSchema) {
      // @ts-expect-error https://github.com/phetsims/tandem/issues/263
      this.stateSchema = options.stateSchema;
    } else {
      const compositeSchema = typeof options.stateSchema === 'function' ? options.stateSchema(this) : options.stateSchema;
      this.stateSchema = new StateSchema({
        compositeSchema: compositeSchema
      });
    }

    // Assert that toStateObject method is provided for value StateSchemas. Do this with the following logic:
    // 1. It is acceptable to not provide a stateSchema (for IOTypes that aren't stateful)
    // 2. You must either provide a toStateObject, or have a composite StateSchema. Composite state schemas support default serialization methods.
    assert && assert(!this.stateSchema || toStateObjectSupplied || this.stateSchema.isComposite(), 'toStateObject method must be provided for value StateSchemas');
    this.toStateObject = coreObject => {
      validate(coreObject, this.validator, VALIDATE_OPTIONS_FALSE);
      let toStateObject;

      // Only do this non-standard toStateObject function if there is a stateSchema but no toStateObject provided
      if (!toStateObjectSupplied && stateSchemaSupplied && this.stateSchema && this.stateSchema.isComposite()) {
        toStateObject = this.defaultToStateObject(coreObject);
      } else {
        toStateObject = options.toStateObject(coreObject);
      }

      // Validate, but only if this IOType instance has more to validate than the supertype
      if (toStateObjectSupplied || stateSchemaSupplied) {
        // Only validate the stateObject if it is phetioState:true.
        // This is an n*m algorithm because for each time toStateObject is called and needs validation, this.validateStateObject
        // looks all the way up the IOType hierarchy. This is not efficient, but gains us the ability to make sure that
        // the stateObject doesn't have any superfluous, unexpected keys. The "m" portion is based on how many sub-properties
        // in a state call `toStateObject`, and the "n" portion is based on how many IOTypes in the hierarchy define a
        // toStateObject or stateSchema. In the future we could potentially improve performance by having validateStateObject
        // only check against the schema at this level, but then extra keys in the stateObject would not be caught. From work done in https://github.com/phetsims/phet-io/issues/1774
        assert && this.validateStateObject(toStateObject);
      }
      return toStateObject;
    };
    this.fromStateObject = options.fromStateObject;
    this.stateObjectToCreateElementArguments = options.stateObjectToCreateElementArguments;
    this.applyState = (coreObject, stateObject) => {
      validate(coreObject, this.validator, VALIDATE_OPTIONS_FALSE);

      // Validate, but only if this IOType instance has more to validate than the supertype
      if (applyStateSupplied || stateSchemaSupplied) {
        // Validate that the provided stateObject is of the expected schema
        // NOTE: Cannot use this.validateStateObject because options adopts supertype.applyState, which is bounds to the
        // parent IOType. This prevents correct validation because the supertype doesn't know about the subtype schemas.
        // @ts-expect-error we cannot type check against PhetioObject from this file
        assert && coreObject.phetioType && coreObject.phetioType.validateStateObject(stateObject);
      }

      // Only do this non-standard applyState function from stateSchema if there is a stateSchema but no applyState provided
      if (!applyStateSupplied && stateSchemaSupplied && this.stateSchema && this.stateSchema.isComposite()) {
        this.defaultApplyState(coreObject, stateObject);
      } else {
        options.applyState(coreObject, stateObject);
      }
    };
    this.isFunctionType = options.isFunctionType;
    this.addChildElement = options.addChildElement;
    if (assert) {
      assert && assert(supertype || this.typeName === 'ObjectIO', 'supertype is required');
      assert && assert(!this.typeName.includes('.'), 'Dots should not appear in type names');
      assert && assert(this.typeName.split(/[<(]/)[0].endsWith(PhetioConstants.IO_TYPE_SUFFIX), `IOType name must end with ${PhetioConstants.IO_TYPE_SUFFIX}`);
      assert && assert(this.hasOwnProperty('typeName'), 'this.typeName is required');

      // assert that each public method adheres to the expected schema
      this.methods && Object.values(this.methods).forEach(methodObject => {
        if (typeof methodObject === 'object') {
          assert && methodObject.invocableForReadOnlyElements && assert(typeof methodObject.invocableForReadOnlyElements === 'boolean', `invocableForReadOnlyElements must be of type boolean: ${methodObject.invocableForReadOnlyElements}`);
        }
      });
      assert && assert(this.documentation.length > 0, 'documentation must be provided');
      this.methods && this.hasOwnProperty('methodOrder') && this.methodOrder.forEach(methodName => {
        assert && assert(this.methods[methodName], `methodName not in public methods: ${methodName}`);
      });
      if (supertype) {
        const typeHierarchy = supertype.getTypeHierarchy();
        assert && this.events && this.events.forEach(event => {
          // Make sure events are not listed again
          assert && assert(!_.some(typeHierarchy, t => t.events.includes(event)), `IOType should not declare event that parent also has: ${event}`);
        });
      } else {
        // The root IOType must supply all 4 state methods.
        assert && assert(typeof options.toStateObject === 'function', 'toStateObject must be defined');
        assert && assert(typeof options.fromStateObject === 'function', 'fromStateObject must be defined');
        assert && assert(typeof options.stateObjectToCreateElementArguments === 'function', 'stateObjectToCreateElementArguments must be defined');
        assert && assert(typeof options.applyState === 'function', 'applyState must be defined');
      }
    }
  }

  // Include state from all composite state schemas up and down the type hierarchy (children overriding parents).
  defaultToStateObject(coreObject) {
    let superStateObject = {};
    if (this.supertype) {
      superStateObject = this.supertype.defaultToStateObject(coreObject);
    }
    if (this.stateSchema && this.stateSchema.isComposite()) {
      return _.merge(superStateObject, this.stateSchema.defaultToStateObject(coreObject));
    } else {
      return superStateObject;
    }
  }

  // Include state from all composite state schemas up and down the type hierarchy (children overriding parents).
  defaultApplyState(coreObject, stateObject) {
    if (this.supertype) {
      this.supertype.defaultApplyState(coreObject, stateObject);
    }
    if (this.stateSchema && this.stateSchema.isComposite()) {
      this.stateSchema.defaultApplyState(coreObject, stateObject);
    }
  }

  /**
   * Gets an array of IOTypes of the self type and all the supertype ancestors.
   */
  getTypeHierarchy() {
    const array = [];
    let ioType = this; // eslint-disable-line consistent-this, @typescript-eslint/no-this-alias
    while (ioType) {
      array.push(ioType);
      ioType = ioType.supertype;
    }
    return array;
  }

  /**
   * Returns true if this IOType is a subtype of the passed-in type (or if they are the same).
   */
  extends(type) {
    // memory-based implementation OK since this method is only used in assertions
    return this.getTypeHierarchy().includes(type);
  }

  /**
   * Return all the metadata defaults (for the entire IOType hierarchy)
   */
  getAllMetadataDefaults() {
    return _.merge({}, this.supertype ? this.supertype.getAllMetadataDefaults() : {}, this.metadataDefaults);
  }

  /**
   * Return all the data defaults (for the entire IOType hierarchy)
   */
  getAllDataDefaults() {
    return _.merge({}, this.supertype ? this.supertype.getAllDataDefaults() : {}, this.dataDefaults);
  }

  /**
   * @param stateObject - the stateObject to validate against
   * @param toAssert=false - whether to assert when invalid
   * @param schemaKeysPresentInStateObject=[]
   * @returns if the stateObject is valid or not.
   */
  isStateObjectValid(stateObject, toAssert = false, schemaKeysPresentInStateObject = []) {
    // Set to false when invalid
    let valid = true;

    // make sure the stateObject has everything the schema requires and nothing more
    if (this.stateSchema) {
      const validSoFar = this.stateSchema.checkStateObjectValid(stateObject, toAssert, schemaKeysPresentInStateObject);

      // null as a marker to keep checking up the hierarchy, otherwise we reached our based case because the stateSchema was a value, not a composite
      if (validSoFar !== null) {
        return validSoFar;
      }
    }
    if (this.supertype) {
      return valid && this.supertype.isStateObjectValid(stateObject, toAssert, schemaKeysPresentInStateObject);
    }

    // When we reach the root, make sure there isn't anything in the stateObject that isn't described by a schema
    if (!this.supertype && stateObject && typeof stateObject !== 'string' && !Array.isArray(stateObject)) {
      // Visit the state
      Object.keys(stateObject).forEach(key => {
        const keyValid = schemaKeysPresentInStateObject.includes(key);
        if (!keyValid) {
          valid = false;
        }
        assert && toAssert && assert(keyValid, `stateObject provided a key that is not in the schema: ${key}`);
      });
      return valid;
    }
    return true;
  }

  /**
   * Assert if the provided stateObject is not valid to this IOType's stateSchema
   */
  validateStateObject(stateObject) {
    this.isStateObjectValid(stateObject, true);
  }
  toString() {
    return this.typeName;
  }
}

// default state value
const DEFAULT_STATE = null;

// This must be declared after the class declaration to avoid a circular dependency with PhetioObject.
// @readonly
IOType.ObjectIO = new IOType(TandemConstants.OBJECT_IO_TYPE_NAME, {
  isValidValue: () => true,
  supertype: null,
  documentation: 'The root of the PhET-iO Type hierarchy',
  toStateObject: coreObject => {
    if (phet && phet.tandem && phet.tandem.Tandem.VALIDATION) {
      assert && assert(coreObject.tandem, 'coreObject must be PhET-iO object');
      assert && assert(!coreObject.phetioState, `fell back to root serialization state for ${coreObject.tandem.phetioID}. Potential solutions:
         * mark the type as phetioState: false
         * create a custom toStateObject method in your IOType
         * perhaps you have everything right, but forgot to pass in the IOType via phetioType in the constructor`);
    }
    return DEFAULT_STATE;
  },
  fromStateObject: () => {
    throw new Error('ObjectIO.fromStateObject should not be called');
  },
  stateObjectToCreateElementArguments: () => [],
  applyState: _.noop,
  metadataDefaults: TandemConstants.PHET_IO_OBJECT_METADATA_DEFAULTS,
  dataDefaults: {
    initialState: DEFAULT_STATE
  },
  stateSchema: null
});
tandemNamespace.register('IOType', IOType);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJ2YWxpZGF0ZSIsIlZhbGlkYXRpb24iLCJvcHRpb25pemUiLCJQaGV0aW9Db25zdGFudHMiLCJUYW5kZW1Db25zdGFudHMiLCJ0YW5kZW1OYW1lc3BhY2UiLCJTdGF0ZVNjaGVtYSIsIlZBTElEQVRFX09QVElPTlNfRkFMU0UiLCJ2YWxpZGF0ZVZhbGlkYXRvciIsImdldENvcmVUeXBlTmFtZSIsImlvVHlwZU5hbWUiLCJpbmRleCIsImluZGV4T2YiLCJJT19UWVBFX1NVRkZJWCIsImFzc2VydCIsInN1YnN0cmluZyIsIklPVHlwZSIsImNvbnN0cnVjdG9yIiwidHlwZU5hbWUiLCJwcm92aWRlZE9wdGlvbnMiLCJzdXBlcnR5cGUiLCJPYmplY3RJTyIsInRvU3RhdGVPYmplY3RTdXBwbGllZCIsInRvU3RhdGVPYmplY3QiLCJhcHBseVN0YXRlU3VwcGxpZWQiLCJhcHBseVN0YXRlIiwic3RhdGVTY2hlbWFTdXBwbGllZCIsInN0YXRlU2NoZW1hIiwib3B0aW9ucyIsIm1ldGhvZHMiLCJldmVudHMiLCJtZXRhZGF0YURlZmF1bHRzIiwiZGF0YURlZmF1bHRzIiwibWV0aG9kT3JkZXIiLCJwYXJhbWV0ZXJUeXBlcyIsImRvY3VtZW50YXRpb24iLCJpc0Z1bmN0aW9uVHlwZSIsImZyb21TdGF0ZU9iamVjdCIsInN0YXRlT2JqZWN0VG9DcmVhdGVFbGVtZW50QXJndW1lbnRzIiwiZGVmYXVsdERlc2VyaWFsaXphdGlvbk1ldGhvZCIsImFkZENoaWxkRWxlbWVudCIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwibWV0YWRhdGFEZWZhdWx0S2V5IiwiZ2V0QWxsTWV0YWRhdGFEZWZhdWx0cyIsImhhc093blByb3BlcnR5IiwidmFsaWRhdG9yIiwiXyIsInBpY2siLCJWQUxJREFUT1JfS0VZUyIsInZhbGlkYXRpb25NZXNzYWdlIiwiY29tcG9zaXRlU2NoZW1hIiwiaXNDb21wb3NpdGUiLCJjb3JlT2JqZWN0IiwiZGVmYXVsdFRvU3RhdGVPYmplY3QiLCJ2YWxpZGF0ZVN0YXRlT2JqZWN0Iiwic3RhdGVPYmplY3QiLCJwaGV0aW9UeXBlIiwiZGVmYXVsdEFwcGx5U3RhdGUiLCJpbmNsdWRlcyIsInNwbGl0IiwiZW5kc1dpdGgiLCJ2YWx1ZXMiLCJtZXRob2RPYmplY3QiLCJpbnZvY2FibGVGb3JSZWFkT25seUVsZW1lbnRzIiwibGVuZ3RoIiwibWV0aG9kTmFtZSIsInR5cGVIaWVyYXJjaHkiLCJnZXRUeXBlSGllcmFyY2h5IiwiZXZlbnQiLCJzb21lIiwidCIsInN1cGVyU3RhdGVPYmplY3QiLCJtZXJnZSIsImFycmF5IiwiaW9UeXBlIiwicHVzaCIsImV4dGVuZHMiLCJ0eXBlIiwiZ2V0QWxsRGF0YURlZmF1bHRzIiwiaXNTdGF0ZU9iamVjdFZhbGlkIiwidG9Bc3NlcnQiLCJzY2hlbWFLZXlzUHJlc2VudEluU3RhdGVPYmplY3QiLCJ2YWxpZCIsInZhbGlkU29GYXIiLCJjaGVja1N0YXRlT2JqZWN0VmFsaWQiLCJBcnJheSIsImlzQXJyYXkiLCJrZXkiLCJrZXlWYWxpZCIsInRvU3RyaW5nIiwiREVGQVVMVF9TVEFURSIsIk9CSkVDVF9JT19UWVBFX05BTUUiLCJpc1ZhbGlkVmFsdWUiLCJwaGV0IiwidGFuZGVtIiwiVGFuZGVtIiwiVkFMSURBVElPTiIsInBoZXRpb1N0YXRlIiwicGhldGlvSUQiLCJFcnJvciIsIm5vb3AiLCJQSEVUX0lPX09CSkVDVF9NRVRBREFUQV9ERUZBVUxUUyIsImluaXRpYWxTdGF0ZSIsInJlZ2lzdGVyIl0sInNvdXJjZXMiOlsiSU9UeXBlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDIwLTIwMjQsIFVuaXZlcnNpdHkgb2YgQ29sb3JhZG8gQm91bGRlclxyXG5cclxuLyoqXHJcbiAqIElPVHlwZXMgZm9ybSBhIHN5bnRoZXRpYyB0eXBlIHN5c3RlbSB1c2VkIHRvIGRlc2NyaWJlIFBoRVQtaU8gRWxlbWVudHMuIEEgUGhFVC1pTyBFbGVtZW50IGlzIGFuIGluc3RydW1lbnRlZCBQaGV0aW9PYmplY3RcclxuICogdGhhdCBpcyBpbnRlcm9wZXJhYmxlIGZyb20gdGhlIFwid3JhcHBlclwiIGZyYW1lIChvdXRzaWRlIHRoZSBzaW0gZnJhbWUpLiBBbiBJT1R5cGUgaW5jbHVkZXMgZG9jdW1lbnRhdGlvbiwgbWV0aG9kcyxcclxuICogbmFtZXMsIHNlcmlhbGl6YXRpb24sIGV0Yy5cclxuICpcclxuICogQGF1dGhvciBTYW0gUmVpZCAoUGhFVCBJbnRlcmFjdGl2ZSBTaW11bGF0aW9ucylcclxuICovXHJcblxyXG5pbXBvcnQgdmFsaWRhdGUgZnJvbSAnLi4vLi4vLi4vYXhvbi9qcy92YWxpZGF0ZS5qcyc7XHJcbmltcG9ydCBWYWxpZGF0aW9uLCB7IFZhbGlkYXRvciB9IGZyb20gJy4uLy4uLy4uL2F4b24vanMvVmFsaWRhdGlvbi5qcyc7XHJcbmltcG9ydCBvcHRpb25pemUgZnJvbSAnLi4vLi4vLi4vcGhldC1jb3JlL2pzL29wdGlvbml6ZS5qcyc7XHJcbmltcG9ydCBQaGV0aW9Db25zdGFudHMgZnJvbSAnLi4vUGhldGlvQ29uc3RhbnRzLmpzJztcclxuaW1wb3J0IFRhbmRlbUNvbnN0YW50cywgeyBJT1R5cGVOYW1lLCBQaGV0aW9FbGVtZW50TWV0YWRhdGEgfSBmcm9tICcuLi9UYW5kZW1Db25zdGFudHMuanMnO1xyXG5pbXBvcnQgdGFuZGVtTmFtZXNwYWNlIGZyb20gJy4uL3RhbmRlbU5hbWVzcGFjZS5qcyc7XHJcbmltcG9ydCBTdGF0ZVNjaGVtYSwgeyBDb21wb3NpdGVTY2hlbWEsIENvbXBvc2l0ZVN0YXRlT2JqZWN0VHlwZSB9IGZyb20gJy4vU3RhdGVTY2hlbWEuanMnO1xyXG5pbXBvcnQgdHlwZSBQaGV0aW9PYmplY3QgZnJvbSAnLi4vUGhldGlvT2JqZWN0LmpzJztcclxuaW1wb3J0IEludGVudGlvbmFsQW55IGZyb20gJy4uLy4uLy4uL3BoZXQtY29yZS9qcy90eXBlcy9JbnRlbnRpb25hbEFueS5qcyc7XHJcbmltcG9ydCBQaGV0aW9EeW5hbWljRWxlbWVudENvbnRhaW5lciBmcm9tICcuLi9QaGV0aW9EeW5hbWljRWxlbWVudENvbnRhaW5lci5qcyc7XHJcblxyXG4vLyBjb25zdGFudHNcclxuY29uc3QgVkFMSURBVEVfT1BUSU9OU19GQUxTRSA9IHsgdmFsaWRhdGVWYWxpZGF0b3I6IGZhbHNlIH07XHJcblxyXG4vKipcclxuICogRXN0aW1hdGUgdGhlIGNvcmUgdHlwZSBuYW1lIGZyb20gYSBnaXZlbiBJT1R5cGUgbmFtZS5cclxuICovXHJcbmNvbnN0IGdldENvcmVUeXBlTmFtZSA9ICggaW9UeXBlTmFtZTogSU9UeXBlTmFtZSApOiBzdHJpbmcgPT4ge1xyXG4gIGNvbnN0IGluZGV4ID0gaW9UeXBlTmFtZS5pbmRleE9mKCBQaGV0aW9Db25zdGFudHMuSU9fVFlQRV9TVUZGSVggKTtcclxuICBhc3NlcnQgJiYgYXNzZXJ0KCBpbmRleCA+PSAwLCAnSU8gc2hvdWxkIGJlIGluIHRoZSB0eXBlIG5hbWUnICk7XHJcbiAgcmV0dXJuIGlvVHlwZU5hbWUuc3Vic3RyaW5nKCAwLCBpbmRleCApO1xyXG59O1xyXG5cclxudHlwZSBBZGRDaGlsZEVsZW1lbnQgPSAoIGdyb3VwOiBQaGV0aW9EeW5hbWljRWxlbWVudENvbnRhaW5lcjxQaGV0aW9PYmplY3Q+LCBjb21wb25lbnROYW1lOiBzdHJpbmcsIHN0YXRlT2JqZWN0OiB1bmtub3duICkgPT4gUGhldGlvT2JqZWN0O1xyXG5cclxuZXhwb3J0IHR5cGUgSU9UeXBlTWV0aG9kID0ge1xyXG4gIHJldHVyblR5cGU6IElPVHlwZTtcclxuICBwYXJhbWV0ZXJUeXBlczogSU9UeXBlW107XHJcblxyXG4gIC8vdGhlIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgd2hlbiB0aGlzIG1ldGhvZCBpcyBjYWxsZWQuIFRoaXMgZnVuY3Rpb24ncyBwYXJhbWV0ZXJzIHdpbGwgYmUgYmFzZWQgb24gYHBhcmFtZXRlclR5cGVzYCxcclxuICAvLyBhbmQgc2hvdWxkIHJldHVybiB0aGUgdHlwZSBzcGVjaWZpZWQgYnkgYHJldHVyblR5cGVgXHJcbiAgaW1wbGVtZW50YXRpb246ICggLi4uYXJnczogSW50ZW50aW9uYWxBbnlbXSApID0+IHVua25vd247XHJcbiAgZG9jdW1lbnRhdGlvbjogc3RyaW5nO1xyXG5cclxuICAvLyBieSBkZWZhdWx0LCBhbGwgbWV0aG9kcyBhcmUgaW52b2NhYmxlIGZvciBhbGwgZWxlbWVudHMuIEhvd2V2ZXIsIGZvciBzb21lIHJlYWQtb25seSBlbGVtZW50cywgY2VydGFpbiBtZXRob2RzXHJcbiAgLy8gc2hvdWxkIG5vdCBiZSBpbnZvY2FibGUuIEluIHRoYXQgY2FzZSwgdGhleSBhcmUgbWFya2VkIGFzIGludm9jYWJsZUZvclJlYWRPbmx5RWxlbWVudHM6IGZhbHNlLlxyXG4gIGludm9jYWJsZUZvclJlYWRPbmx5RWxlbWVudHM/OiBib29sZWFuO1xyXG59O1xyXG5cclxudHlwZSBEZXNlcmlhbGl6YXRpb25UeXBlID0gJ2Zyb21TdGF0ZU9iamVjdCcgfCAnYXBwbHlTdGF0ZSc7XHJcblxyXG50eXBlIFN0YXRlU2NoZW1hT3B0aW9uPFQsIFN0YXRlVHlwZSBleHRlbmRzIFNlbGZTdGF0ZVR5cGUsIFNlbGZTdGF0ZVR5cGU+ID0gKFxyXG4gICggaW9UeXBlOiBJT1R5cGU8VCwgU3RhdGVUeXBlLCBTZWxmU3RhdGVUeXBlPiApID0+IENvbXBvc2l0ZVNjaGVtYTxTZWxmU3RhdGVUeXBlPiApIHxcclxuICBTdGF0ZVNjaGVtYTxULCBTdGF0ZVR5cGU+IHxcclxuICBDb21wb3NpdGVTY2hlbWE8U2VsZlN0YXRlVHlwZT4gfFxyXG4gIG51bGw7XHJcblxyXG50eXBlIFNlbGZPcHRpb25zPFQsIFN0YXRlVHlwZSBleHRlbmRzIFNlbGZTdGF0ZVR5cGUsIFNlbGZTdGF0ZVR5cGU+ID0ge1xyXG5cclxuICAvLyBJT1R5cGVzIGZvcm0gYW4gb2JqZWN0IHRyZWUgbGlrZSBhIHR5cGUgaGllcmFyY2h5LiBJZiB0aGUgc3VwZXJ0eXBlIGlzIHNwZWNpZmllZCwgYXR0cmlidXRlcyBzdWNoIGFzXHJcbiAgLy8gdG9TdGF0ZU9iamVjdCwgZnJvbVN0YXRlT2JqZWN0LCBzdGF0ZU9iamVjdFRvQ3JlYXRlRWxlbWVudEFyZ3VtZW50cywgYXBwbHlTdGF0ZSwgYWRkQ2hpbGRFbGVtZW50XHJcbiAgLy8gd2lsbCBiZSBpbmhlcml0ZWQgZnJvbSB0aGUgc3VwZXJ0eXBlICh1bmxlc3Mgb3ZlcnJpZGRlbikuICBJdCBpcyBhbHNvIHVzZWQgaW4gZmVhdHVyZXMgc3VjaCBhcyBzY2hlbWEgdmFsaWRhdGlvbixcclxuICAvLyBkYXRhL21ldGFkYXRhIGRlZmF1bHQgY2FsY3VsYXRpb25zLlxyXG4gIHN1cGVydHlwZT86IElPVHlwZSB8IG51bGw7XHJcblxyXG4gIC8vIFRoZSBsaXN0IG9mIGV2ZW50cyB0aGF0IGNhbiBiZSBlbWl0dGVkIGF0IHRoaXMgbGV2ZWwgKGRvZXMgbm90IGluY2x1ZGUgZXZlbnRzIGZyb20gc3VwZXJ0eXBlcykuXHJcbiAgZXZlbnRzPzogc3RyaW5nW107XHJcblxyXG4gIC8vIEtleS92YWx1ZSBwYWlycyBpbmRpY2F0aW5nIHRoZSBkZWZhdWx0cyBmb3IgdGhlIElPVHlwZSBkYXRhLCBqdXN0IGZvciB0aGlzIGxldmVsIChkbyBub3Qgc3BlY2lmeSBwYXJlbnQgZGVmYXVsdHMpXHJcbiAgZGF0YURlZmF1bHRzPzogUmVjb3JkPHN0cmluZywgdW5rbm93bj47XHJcblxyXG4gIC8vIEtleS92YWx1ZSBwYWlycyBpbmRpY2F0aW5nIHRoZSBkZWZhdWx0cyBmb3IgdGhlIElPVHlwZSBtZXRhZGF0YS5cclxuICAvLyBJZiBhbnl0aGluZyBpcyBwcm92aWRlZCBoZXJlLCB0aGVuIGNvcnJlc3BvbmRpbmcgUGhldGlvT2JqZWN0cyB0aGF0IHVzZSB0aGlzIElPVHlwZSBzaG91bGQgb3ZlcnJpZGVcclxuICAvLyBQaGV0aW9PYmplY3QuZ2V0TWV0YWRhdGEoKSB0byBhZGQgd2hhdCBrZXlzIHRoZXkgbmVlZCBmb3IgdGhlaXIgc3BlY2lmaWMgdHlwZS4gIENhbm5vdCBzcGVjaWZ5IHJlZHVuZGFudCB2YWx1ZXNcclxuICAvLyAodGhhdCBhbiBhbmNlc3RvciBhbHJlYWR5IHNwZWNpZmllZCkuXHJcbiAgbWV0YWRhdGFEZWZhdWx0cz86IFBhcnRpYWw8UGhldGlvRWxlbWVudE1ldGFkYXRhPjtcclxuXHJcbiAgLy8gVGV4dCB0aGF0IGRlc2NyaWJlcyB0aGUgSU9UeXBlLCBwcmVzZW50ZWQgdG8gdGhlIFBoRVQtaU8gQ2xpZW50IGluIFN0dWRpbywgc3VwcG9ydHMgSFRNTCBtYXJrdXAuXHJcbiAgZG9jdW1lbnRhdGlvbj86IHN0cmluZztcclxuXHJcbiAgLy8gVGhlIHB1YmxpYyBtZXRob2RzIGF2YWlsYWJsZSBmb3IgdGhpcyBJT1R5cGUuIEVhY2ggbWV0aG9kIGlzIG5vdCBqdXN0IGEgZnVuY3Rpb24sXHJcbiAgLy8gYnV0IGEgY29sbGVjdGlvbiBvZiBtZXRhZGF0YSBhYm91dCB0aGUgbWV0aG9kIHRvIGJlIGFibGUgdG8gc2VyaWFsaXplIHBhcmFtZXRlcnMgYW5kIHJldHVybiB0eXBlcyBhbmQgcHJvdmlkZVxyXG4gIC8vIGJldHRlciBkb2N1bWVudGF0aW9uLlxyXG4gIG1ldGhvZHM/OiBSZWNvcmQ8c3RyaW5nLCBJT1R5cGVNZXRob2Q+O1xyXG5cclxuICAvLyBJT1R5cGVzIGNhbiBzcGVjaWZ5IHRoZSBvcmRlciB0aGF0IG1ldGhvZHMgYXBwZWFyIGluIHRoZSBkb2N1bWVudGF0aW9uIGJ5IHB1dHRpbmcgdGhlaXIgbmFtZXMgaW4gdGhpc1xyXG4gIC8vIGxpc3QuIFRoaXMgbGlzdCBpcyBvbmx5IGZvciB0aGUgbWV0aG9kcyBkZWZpbmVkIGF0IHRoaXMgbGV2ZWwgaW4gdGhlIHR5cGUgaGllcmFyY2h5LiBBZnRlciB0aGUgbWV0aG9kT3JkZXJcclxuICAvLyBzcGVjaWZpZWQsIHRoZSBtZXRob2RzIGZvbGxvdyBpbiB0aGUgb3JkZXIgZGVjbGFyZWQgaW4gdGhlIGltcGxlbWVudGF0aW9uICh3aGljaCBpc24ndCBuZWNlc3NhcmlseSBzdGFibGUpLlxyXG4gIG1ldGhvZE9yZGVyPzogc3RyaW5nW107XHJcblxyXG4gIC8vIEZvciBwYXJhbWV0cmljIHR5cGVzLCB0aGV5IG11c3QgaW5kaWNhdGUgdGhlIHR5cGVzIG9mIHRoZSBwYXJhbWV0ZXJzIGhlcmUuIEVtcHR5IGFycmF5IGlmIG5vbi1wYXJhbWV0cmljLlxyXG4gIHBhcmFtZXRlclR5cGVzPzogSU9UeXBlW107XHJcblxyXG4gIC8vIEZvciBpbnRlcm5hbCBwaGV0LWlvIHVzZSBvbmx5LiBGdW5jdGlvbnMgY2Fubm90IGJlIHNlbnQgZnJvbSBvbmUgaWZyYW1lIHRvIGFub3RoZXIsIHNvIG11c3QgYmUgd3JhcHBlZC4gU2VlXHJcbiAgLy8gcGhldGlvQ29tbWFuZFByb2Nlc3Nvci53cmFwRnVuY3Rpb25cclxuICBpc0Z1bmN0aW9uVHlwZT86IGJvb2xlYW47XHJcblxyXG4gIC8vICoqKioqKioqIFNUQVRFICoqKioqKioqIC8vXHJcblxyXG4gIC8vIFRoZSBzcGVjaWZpY2F0aW9uIGZvciBob3cgdGhlIFBoRVQtaU8gc3RhdGUgd2lsbCBsb29rIGZvciBpbnN0YW5jZXMgb2YgdGhpcyB0eXBlLiBudWxsIHNwZWNpZmllcyB0aGF0IHRoZSBvYmplY3RcclxuICAvLyBpcyBub3Qgc2VyaWFsaXplZC4gQSBjb21wb3NpdGUgU3RhdGVTY2hlbWEgY2FuIHN1cHBseSBhIHRvU3RhdGVPYmplY3QgYW5kIGFwcGx5U3RhdGUgc2VyaWFsaXphdGlvbiBzdHJhdGVneS4gVGhpc1xyXG4gIC8vIGRlZmF1bHQgc2VyaWFsaXphdGlvbiBzdHJhdGVneSBvbmx5IGFwcGxpZXMgdG8gdGhpcyBsZXZlbCwgYW5kIGRvZXMgbm90IHJlY3Vyc2UgdG8gcGFyZW50cy4gSWYgeW91IG5lZWQgdG8gYWRkXHJcbiAgLy8gc2VyaWFsaXphdGlvbiBmcm9tIHBhcmVudCBsZXZlbHMsIHRoaXMgY2FuIGJlIGRvbmUgYnkgbWFudWFsbHkgaW1wbGVtZW50aW5nIGEgY3VzdG9tIHRvU3RhdGVPYmplY3QuIEJ5IGRlZmF1bHQsIGl0XHJcbiAgLy8gd2lsbCBhc3N1bWUgdGhhdCBlYWNoIGNvbXBvc2l0ZSBjaGlsZCBvZiB0aGlzIHN0YXRlU2NoZW1hIGRlc2VyaWFsaXplcyB2aWEgXCJmcm9tU3RhdGVPYmplY3RcIiwgaWYgaW5zdGVhZCBpdCB1c2VzXHJcbiAgLy8gYXBwbHlTdGF0ZSwgcGxlYXNlIHNwZWNpZnkgdGhhdCBwZXIgSU9UeXBlIHdpdGggZGVmYXVsdERlc2VyaWFsaXphdGlvbk1ldGhvZC5cclxuICAvLyBGb3IgcGhldGlvU3RhdGU6IHRydWUgb2JqZWN0cywgdGhpcyBzaG91bGQgYmUgcmVxdWlyZWQsIGJ1dCBtYXkgYmUgc3BlY2lmaWVkIGluIHRoZSBwYXJlbnQgSU9UeXBlLCBsaWtlIGluIERlcml2ZWRQcm9wZXJ0eUlPXHJcbiAgc3RhdGVTY2hlbWE/OiBTdGF0ZVNjaGVtYU9wdGlvbjxULCBTdGF0ZVR5cGUsIFNlbGZTdGF0ZVR5cGU+O1xyXG5cclxuICAvLyBTZXJpYWxpemUgdGhlIGNvcmUgb2JqZWN0LiBNb3N0IG9mdGVuIHRoaXMgbG9va3MgbGlrZSBhbiBvYmplY3QgbGl0ZXJhbCB0aGF0IGhvbGRzIGRhdGEgYWJvdXQgdGhlIFBoZXRpb09iamVjdFxyXG4gIC8vIGluc3RhbmNlLiBUaGlzIGlzIGxpa2VseSBzdXBlcmZsdW91cyB0byBqdXN0IHByb3ZpZGluZyBhIHN0YXRlU2NoZW1hIG9mIGNvbXBvc2l0ZSBrZXkvSU9UeXBlIHZhbHVlcywgd2hpY2ggd2lsbFxyXG4gIC8vIGNyZWF0ZSBhIGRlZmF1bHQgdG9TdGF0ZU9iamVjdCBiYXNlZCBvbiB0aGUgc2NoZW1hLlxyXG4gIHRvU3RhdGVPYmplY3Q/OiAoIHQ6IFQgKSA9PiBTdGF0ZVR5cGU7XHJcblxyXG4gIC8vICoqKioqKioqIERFU0VSSUFMSVpBVElPTiAqKioqKioqKiAvL1xyXG5cclxuICAvLyBGb3IgRGF0YSBUeXBlIERlc2VyaWFsaXphdGlvbi4gRGVjb2RlcyB0aGUgb2JqZWN0IGZyb20gYSBzdGF0ZSAoc2VlIHRvU3RhdGVPYmplY3QpIGludG8gYW4gaW5zdGFuY2Ugb2YgdGhlIGNvcmUgdHlwZS5cclxuICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL3BoZXQtaW8vYmxvYi9tYWluL2RvYy9waGV0LWlvLWluc3RydW1lbnRhdGlvbi10ZWNobmljYWwtZ3VpZGUubWQjdGhyZWUtdHlwZXMtb2YtZGVzZXJpYWxpemF0aW9uXHJcbiAgZnJvbVN0YXRlT2JqZWN0PzogKCBzOiBTdGF0ZVR5cGUgKSA9PiBUO1xyXG5cclxuICAvLyBGb3IgRHluYW1pYyBFbGVtZW50IERlc2VyaWFsaXphdGlvbjogY29udmVydHMgdGhlIHN0YXRlIG9iamVjdCB0byBhcmd1bWVudHNcclxuICAvLyBmb3IgYSBgY3JlYXRlYCBmdW5jdGlvbiBpbiBQaGV0aW9Hcm91cCBvciBvdGhlciBQaGV0aW9EeW5hbWljRWxlbWVudENvbnRhaW5lciBjcmVhdGlvbiBmdW5jdGlvbi4gTm90ZSB0aGF0XHJcbiAgLy8gb3RoZXIgbm9uLXNlcmlhbGl6ZWQgYXJncyAobm90IGRlYWx0IHdpdGggaGVyZSkgbWF5IGJlIHN1cHBsaWVkIGFzIGNsb3N1cmUgdmFyaWFibGVzLiBUaGlzIGZ1bmN0aW9uIG9ubHkgbmVlZHNcclxuICAvLyB0byBiZSBpbXBsZW1lbnRlZCBvbiBJT1R5cGVzIHdob3NlIGNvcmUgdHlwZSBpcyBwaGV0aW9EeW5hbWljRWxlbWVudDogdHJ1ZSwgc3VjaCBhcyBQaGV0aW9EeW5hbWljRWxlbWVudENvbnRhaW5lclxyXG4gIC8vIGVsZW1lbnRzLlxyXG4gIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vcGhldHNpbXMvcGhldC1pby9ibG9iL21haW4vZG9jL3BoZXQtaW8taW5zdHJ1bWVudGF0aW9uLXRlY2huaWNhbC1ndWlkZS5tZCN0aHJlZS10eXBlcy1vZi1kZXNlcmlhbGl6YXRpb25cclxuICBzdGF0ZU9iamVjdFRvQ3JlYXRlRWxlbWVudEFyZ3VtZW50cz86ICggczogU3RhdGVUeXBlICkgPT4gdW5rbm93bltdO1xyXG5cclxuICAvLyBGb3IgUmVmZXJlbmNlIFR5cGUgRGVzZXJpYWxpemF0aW9uOiAgQXBwbGllcyB0aGUgc3RhdGUgKHNlZSB0b1N0YXRlT2JqZWN0KVxyXG4gIC8vIHZhbHVlIHRvIHRoZSBpbnN0YW5jZS4gV2hlbiBzZXR0aW5nIFBoRVQtaU8gc3RhdGUsIHRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgb24gYW4gaW5zdHJ1bWVudGVkIGluc3RhbmNlIHRvIHNldCB0aGVcclxuICAvLyBzdGF0ZU9iamVjdCdzIHZhbHVlIHRvIGl0LiBTdGF0ZVNjaGVtYSBtYWtlcyB0aGlzIG1ldGhvZCBvZnRlbiBzdXBlcmZsdW91cy4gQSBjb21wb3NpdGUgc3RhdGVTY2hlbWEgY2FuIGJlIHVzZWRcclxuICAvLyB0byBhdXRvbWF0aWNhbGx5IGZvcm11bGF0ZSB0aGUgYXBwbHlTdGF0ZSBmdW5jdGlvbi4gSWYgdXNpbmcgc3RhdGVTY2hlbWEgZm9yIHRoZSBhcHBseVN0YXRlIG1ldGhvZCwgbWFrZSBzdXJlIHRoYXRcclxuICAvLyBlYWNoIGNvbXBvc2UgSU9UeXBlIGhhcyB0aGUgY29ycmVjdCBkZWZhdWx0RGVzZXJpYWxpemF0aW9uTWV0aG9kLiBNb3N0IG9mIHRoZSB0aW1lLCBjb21wb3NpdGUgSU9UeXBlcyB1c2UgZnJvbVN0YXRlT2JqZWN0XHJcbiAgLy8gdG8gZGVzZXJpYWxpemUgZWFjaCBzdWItY29tcG9uZW50LCBidXQgaW4gc29tZSBjaXJjdW1zdGFuY2VzLCB5b3Ugd2lsbCB3YW50IHlvdXIgY2hpbGQgdG8gZGVzZXJpYWxpemUgYnkgYWxzbyB1c2luZyBhcHBseVN0YXRlLlxyXG4gIC8vIFNlZSBvcHRpb25zLmRlZmF1bHREZXNlcmlhbGl6YXRpb25NZXRob2QgdG8gY29uZmlndXJlIHRoaXMgY2FzZS5cclxuICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL3BoZXQtaW8vYmxvYi9tYWluL2RvYy9waGV0LWlvLWluc3RydW1lbnRhdGlvbi10ZWNobmljYWwtZ3VpZGUubWQjdGhyZWUtdHlwZXMtb2YtZGVzZXJpYWxpemF0aW9uXHJcbiAgYXBwbHlTdGF0ZT86ICggdDogVCwgc3RhdGU6IFN0YXRlVHlwZSApID0+IHZvaWQ7XHJcblxyXG4gIC8vIEZvciB1c2Ugd2hlbiB0aGlzIElPVHlwZSBpcyBwYXJ0IG9mIGEgY29tcG9zaXRlIHN0YXRlU2NoZW1hIGluIGFub3RoZXIgSU9UeXBlLiAgV2hlblxyXG4gIC8vIHVzaW5nIHNlcmlhbGl6YXRpb24gbWV0aG9kcyBieSBzdXBwbHlpbmcgb25seSBzdGF0ZVNjaGVtYSwgdGhlbiBkZXNlcmlhbGl6YXRpb25cclxuICAvLyBjYW4gdGFrZSBhIHZhcmlldHkgb2YgZm9ybXMsIGFuZCB0aGlzIHdpbGwgdmFyeSBiYXNlZCBvbiB0aGUgSU9UeXBlLiBJbiBtb3N0IGNhc2VzIGRlc2VyaWFsaXphdGlvbiBvZiBhIGNvbXBvbmVudFxyXG4gIC8vIGlzIGRvbmUgdmlhIGZyb21TdGF0ZU9iamVjdC4gSWYgbm90LCBzcGVjaWZ5IHRoaXMgb3B0aW9uIHNvIHRoYXQgdGhlIHN0YXRlU2NoZW1hIHdpbGwgYmUgYWJsZSB0byBrbm93IHRvIGNhbGxcclxuICAvLyB0aGUgYXBwcm9wcmlhdGUgZGVzZXJpYWxpemF0aW9uIG1ldGhvZCB3aGVuIGRlc2VyaWFsaXppbmcgc29tZXRoaW5nIG9mIHRoaXMgSU9UeXBlLlxyXG4gIGRlZmF1bHREZXNlcmlhbGl6YXRpb25NZXRob2Q/OiBEZXNlcmlhbGl6YXRpb25UeXBlO1xyXG5cclxuICAvLyBGb3IgZHluYW1pYyBlbGVtZW50IGNvbnRhaW5lcnMsIHNlZSBleGFtcGxlcyBpbiBJT1R5cGVzIGZvciBQaGV0aW9EeW5hbWljRWxlbWVudENvbnRhaW5lciBjbGFzc2VzXHJcbiAgYWRkQ2hpbGRFbGVtZW50PzogQWRkQ2hpbGRFbGVtZW50O1xyXG59O1xyXG5cclxudHlwZSBJT1R5cGVPcHRpb25zPFQsIFN0YXRlVHlwZSBleHRlbmRzIFNlbGZTdGF0ZVR5cGUsIFNlbGZTdGF0ZVR5cGU+ID0gU2VsZk9wdGlvbnM8VCwgU3RhdGVUeXBlLCBTZWxmU3RhdGVUeXBlPiAmIFZhbGlkYXRvcjxUPjtcclxuXHJcbi8vIFN0YXRlVHlwZSBpcyB0aGUgd2hvbGUgdGhpbmcsIFNlbGZTdGF0ZVR5cGUgaXMganVzdCBhdCB0aGlzIGxldmVsXHJcbi8vIGV4cG9ydCBkZWZhdWx0IGNsYXNzIElPVHlwZTxUID0gYW55LCBTZWxmU3RhdGVUeXBlID0gYW55LCBQYXJlbnRTdGF0ZVR5cGUgPSBFbXB0eVBhcmVudCwgU3RhdGVUeXBlIGV4dGVuZHMgU2VsZlN0YXRlVHlwZSAmIFBhcmVudFN0YXRlVHlwZSA9IFNlbGZTdGF0ZVR5cGUgJiBQYXJlbnRTdGF0ZVR5cGU+IHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIElPVHlwZTxUID0gYW55LCBTdGF0ZVR5cGUgZXh0ZW5kcyBTZWxmU3RhdGVUeXBlID0gYW55LCBTZWxmU3RhdGVUeXBlID0gU3RhdGVUeXBlPiB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gIC8vIFNlZSBkb2N1bWVudGF0aW9uIGluIG9wdGlvbnMgdHlwZSBkZWNsYXJhdGlvblxyXG4gIHB1YmxpYyByZWFkb25seSBzdXBlcnR5cGU/OiBJT1R5cGU7XHJcbiAgcHVibGljIHJlYWRvbmx5IGRvY3VtZW50YXRpb24/OiBzdHJpbmc7XHJcbiAgcHVibGljIHJlYWRvbmx5IG1ldGhvZHM/OiBSZWNvcmQ8c3RyaW5nLCBJT1R5cGVNZXRob2Q+O1xyXG4gIHB1YmxpYyByZWFkb25seSBldmVudHM6IHN0cmluZ1tdO1xyXG4gIHB1YmxpYyByZWFkb25seSBtZXRhZGF0YURlZmF1bHRzPzogUGFydGlhbDxQaGV0aW9FbGVtZW50TWV0YWRhdGE+O1xyXG4gIHB1YmxpYyByZWFkb25seSBkYXRhRGVmYXVsdHM/OiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcclxuICBwdWJsaWMgcmVhZG9ubHkgbWV0aG9kT3JkZXI/OiBzdHJpbmdbXTtcclxuICBwdWJsaWMgcmVhZG9ubHkgcGFyYW1ldGVyVHlwZXM/OiBJT1R5cGVbXTtcclxuICBwdWJsaWMgcmVhZG9ubHkgdG9TdGF0ZU9iamVjdDogKCB0OiBUICkgPT4gU3RhdGVUeXBlO1xyXG4gIHB1YmxpYyByZWFkb25seSBmcm9tU3RhdGVPYmplY3Q6ICggc3RhdGU6IFN0YXRlVHlwZSApID0+IFQ7XHJcbiAgcHVibGljIHJlYWRvbmx5IHN0YXRlT2JqZWN0VG9DcmVhdGVFbGVtZW50QXJndW1lbnRzOiAoIHM6IFN0YXRlVHlwZSApID0+IHVua25vd25bXTsgLy8gVE9ETzogaW5zdGVhZCBvZiB1bmtub3duIHRoaXMgaXMgdGhlIHNlY29uZCBwYXJhbWV0ZXIgdHlwZSBmb3IgUGhldGlvRHluYW1pY0VsZW1lbnRDb250YWluZXIuIEhvdz8gaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL3RhbmRlbS9pc3N1ZXMvMjYxXHJcbiAgcHVibGljIHJlYWRvbmx5IGFwcGx5U3RhdGU6ICggb2JqZWN0OiBULCBzdGF0ZTogU3RhdGVUeXBlICkgPT4gdm9pZDtcclxuICBwdWJsaWMgcmVhZG9ubHkgYWRkQ2hpbGRFbGVtZW50OiBBZGRDaGlsZEVsZW1lbnQ7XHJcbiAgcHVibGljIHJlYWRvbmx5IHZhbGlkYXRvcjogVmFsaWRhdG9yPFQ+O1xyXG4gIHB1YmxpYyByZWFkb25seSBkZWZhdWx0RGVzZXJpYWxpemF0aW9uTWV0aG9kOiBEZXNlcmlhbGl6YXRpb25UeXBlO1xyXG4gIHB1YmxpYyByZWFkb25seSBpc0Z1bmN0aW9uVHlwZTogYm9vbGVhbjtcclxuXHJcbiAgLy8gVGhlIFN0YXRlU2NoZW1hICh0eXBlKSB0aGF0IHRoZSBvcHRpb24gaXMgbWFkZSBpbnRvLiBUaGUgb3B0aW9uIGlzIG1vcmUgZmxleGlibGUgdGhhbiB0aGUgY2xhc3MuXHJcbiAgcHVibGljIHJlYWRvbmx5IHN0YXRlU2NoZW1hOiBTdGF0ZVNjaGVtYTxULCBTZWxmU3RhdGVUeXBlPjtcclxuXHJcbiAgLy8gVGhlIGJhc2UgSU9UeXBlIGZvciB0aGUgZW50aXJlIGhpZXJhcmNoeS5cclxuICBwdWJsaWMgc3RhdGljIE9iamVjdElPOiBJT1R5cGU7XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB0eXBlTmFtZSAtIFRoZSBuYW1lIHRoYXQgdGhpcyBJT1R5cGUgd2lsbCBoYXZlIGluIHRoZSBwdWJsaWMgUGhFVC1pTyBBUEkuIEluIGdlbmVyYWwsIHRoaXMgc2hvdWxkXHJcbiAgICogICAgb25seSBiZSB3b3JkIGNoYXJhY3RlcnMsIGVuZGluZyBpbiBcIklPXCIuIFBhcmFtZXRyaWMgdHlwZXMgYXJlIGEgc3BlY2lhbCBzdWJzZXQgb2YgSU9UeXBlcyB0aGF0IGluY2x1ZGUgdGhlaXJcclxuICAgKiAgICBwYXJhbWV0ZXJzIGluIHRoZWlyIHR5cGVOYW1lLiBJZiBhbiBJT1R5cGUncyBwYXJhbWV0ZXJzIGFyZSBvdGhlciBJT1R5cGUocyksIHRoZW4gdGhleSBzaG91bGQgYmUgaW5jbHVkZWQgd2l0aGluXHJcbiAgICogICAgYW5nbGUgYnJhY2tldHMsIGxpa2UgXCJQcm9wZXJ0eUlPPEJvb2xlYW5JTz5cIi4gU29tZSBvdGhlciB0eXBlcyB1c2UgYSBtb3JlIGN1c3RvbSBmb3JtYXQgZm9yIGRpc3BsYXlpbmcgdGhlaXJcclxuICAgKiAgICBwYXJhbWV0ZXIgdHlwZXMsIGluIHRoaXMgY2FzZSB0aGUgcGFyYW1ldGVyIHNlY3Rpb24gb2YgdGhlIHR5cGUgbmFtZSAoaW1tZWRpYXRlbHkgZm9sbG93aW5nIFwiSU9cIikgc2hvdWxkIGJlZ2luXHJcbiAgICogICAgd2l0aCBhbiBvcGVuIHBhcmVuLCBcIihcIi4gVGh1cyB0aGUgc2NoZW1hIGZvciBhIHR5cGVOYW1lIGNvdWxkIGJlIGRlZmluZWQgKHVzaW5nIHJlZ2V4KSBhcyBgW0EtWl1cXHcqSU8oWyg8XS4qKXswLDF9YC5cclxuICAgKiAgICBQYXJhbWV0ZXJpemVkIHR5cGVzIHNob3VsZCBhbHNvIGluY2x1ZGUgYSBgcGFyYW1ldGVyVHlwZXNgIGZpZWxkIG9uIHRoZSBJT1R5cGUuXHJcbiAgICogQHBhcmFtIHByb3ZpZGVkT3B0aW9uc1xyXG4gICAqL1xyXG4gIHB1YmxpYyBjb25zdHJ1Y3RvciggcHVibGljIHJlYWRvbmx5IHR5cGVOYW1lOiBJT1R5cGVOYW1lLCBwcm92aWRlZE9wdGlvbnM6IElPVHlwZU9wdGlvbnM8VCwgU3RhdGVUeXBlLCBTZWxmU3RhdGVUeXBlPiApIHtcclxuXHJcbiAgICAvLyBGb3IgcmVmZXJlbmNlIGluIHRoZSBvcHRpb25zXHJcbiAgICBjb25zdCBzdXBlcnR5cGUgPSBwcm92aWRlZE9wdGlvbnMuc3VwZXJ0eXBlIHx8IElPVHlwZS5PYmplY3RJTztcclxuICAgIGNvbnN0IHRvU3RhdGVPYmplY3RTdXBwbGllZCA9ICEhKCBwcm92aWRlZE9wdGlvbnMudG9TdGF0ZU9iamVjdCApO1xyXG4gICAgY29uc3QgYXBwbHlTdGF0ZVN1cHBsaWVkID0gISEoIHByb3ZpZGVkT3B0aW9ucy5hcHBseVN0YXRlICk7XHJcbiAgICBjb25zdCBzdGF0ZVNjaGVtYVN1cHBsaWVkID0gISEoIHByb3ZpZGVkT3B0aW9ucy5zdGF0ZVNjaGVtYSApO1xyXG5cclxuICAgIGNvbnN0IG9wdGlvbnMgPSBvcHRpb25pemU8SU9UeXBlT3B0aW9uczxULCBTdGF0ZVR5cGUsIFNlbGZTdGF0ZVR5cGU+LCBTZWxmT3B0aW9uczxULCBTdGF0ZVR5cGUsIFNlbGZTdGF0ZVR5cGU+PigpKCB7XHJcblxyXG4gICAgICBzdXBlcnR5cGU6IElPVHlwZS5PYmplY3RJTyxcclxuICAgICAgbWV0aG9kczoge30sXHJcbiAgICAgIGV2ZW50czogW10sXHJcbiAgICAgIG1ldGFkYXRhRGVmYXVsdHM6IHt9LFxyXG5cclxuICAgICAgLy8gIE1vc3QgbGlrZWx5IHRoaXMgd2lsbCByZW1haW4gUGhFVC1pTyBpbnRlcm5hbCwgYW5kIHNob3VsZG4ndCBuZWVkIHRvIGJlIHVzZWQgd2hlbiBjcmVhdGluZyBJT1R5cGVzIG91dHNpZGUgb2YgdGFuZGVtLy5cclxuICAgICAgZGF0YURlZmF1bHRzOiB7fSxcclxuICAgICAgbWV0aG9kT3JkZXI6IFtdLFxyXG4gICAgICBwYXJhbWV0ZXJUeXBlczogW10sXHJcbiAgICAgIGRvY3VtZW50YXRpb246IGBQaEVULWlPIFR5cGUgZm9yICR7Z2V0Q29yZVR5cGVOYW1lKCB0eXBlTmFtZSApfWAsXHJcbiAgICAgIGlzRnVuY3Rpb25UeXBlOiBmYWxzZSxcclxuXHJcbiAgICAgIC8qKioqIFNUQVRFICoqKiovXHJcblxyXG4gICAgICB0b1N0YXRlT2JqZWN0OiBzdXBlcnR5cGUgJiYgc3VwZXJ0eXBlLnRvU3RhdGVPYmplY3QsXHJcbiAgICAgIGZyb21TdGF0ZU9iamVjdDogc3VwZXJ0eXBlICYmIHN1cGVydHlwZS5mcm9tU3RhdGVPYmplY3QsXHJcbiAgICAgIHN0YXRlT2JqZWN0VG9DcmVhdGVFbGVtZW50QXJndW1lbnRzOiBzdXBlcnR5cGUgJiYgc3VwZXJ0eXBlLnN0YXRlT2JqZWN0VG9DcmVhdGVFbGVtZW50QXJndW1lbnRzLFxyXG4gICAgICBhcHBseVN0YXRlOiBzdXBlcnR5cGUgJiYgc3VwZXJ0eXBlLmFwcGx5U3RhdGUsXHJcblxyXG4gICAgICBzdGF0ZVNjaGVtYTogbnVsbCxcclxuICAgICAgZGVmYXVsdERlc2VyaWFsaXphdGlvbk1ldGhvZDogJ2Zyb21TdGF0ZU9iamVjdCcsXHJcbiAgICAgIGFkZENoaWxkRWxlbWVudDogc3VwZXJ0eXBlICYmIHN1cGVydHlwZS5hZGRDaGlsZEVsZW1lbnRcclxuICAgIH0sIHByb3ZpZGVkT3B0aW9ucyApO1xyXG5cclxuICAgIGlmICggYXNzZXJ0ICYmIHN1cGVydHlwZSApIHtcclxuICAgICAgKCBPYmplY3Qua2V5cyggb3B0aW9ucy5tZXRhZGF0YURlZmF1bHRzICkgYXMgKCBrZXlvZiBQaGV0aW9FbGVtZW50TWV0YWRhdGEgKVtdICkuZm9yRWFjaCggbWV0YWRhdGFEZWZhdWx0S2V5ID0+IHtcclxuICAgICAgICBhc3NlcnQgJiYgc3VwZXJ0eXBlLmdldEFsbE1ldGFkYXRhRGVmYXVsdHMoKS5oYXNPd25Qcm9wZXJ0eSggbWV0YWRhdGFEZWZhdWx0S2V5ICkgJiZcclxuICAgICAgICBhc3NlcnQoIHN1cGVydHlwZS5nZXRBbGxNZXRhZGF0YURlZmF1bHRzKClbIG1ldGFkYXRhRGVmYXVsdEtleSBdICE9PSBvcHRpb25zLm1ldGFkYXRhRGVmYXVsdHNbIG1ldGFkYXRhRGVmYXVsdEtleSBdLFxyXG4gICAgICAgICAgYCR7bWV0YWRhdGFEZWZhdWx0S2V5fSBzaG91bGQgbm90IGhhdmUgdGhlIHNhbWUgZGVmYXVsdCB2YWx1ZSBhcyB0aGUgYW5jZXN0b3IgbWV0YWRhdGEgZGVmYXVsdC5gICk7XHJcbiAgICAgIH0gKTtcclxuICAgIH1cclxuICAgIHRoaXMuc3VwZXJ0eXBlID0gc3VwZXJ0eXBlO1xyXG4gICAgdGhpcy5kb2N1bWVudGF0aW9uID0gb3B0aW9ucy5kb2N1bWVudGF0aW9uO1xyXG4gICAgdGhpcy5tZXRob2RzID0gb3B0aW9ucy5tZXRob2RzO1xyXG4gICAgdGhpcy5ldmVudHMgPSBvcHRpb25zLmV2ZW50cztcclxuICAgIHRoaXMubWV0YWRhdGFEZWZhdWx0cyA9IG9wdGlvbnMubWV0YWRhdGFEZWZhdWx0cztcclxuICAgIHRoaXMuZGF0YURlZmF1bHRzID0gb3B0aW9ucy5kYXRhRGVmYXVsdHM7XHJcbiAgICB0aGlzLm1ldGhvZE9yZGVyID0gb3B0aW9ucy5tZXRob2RPcmRlcjtcclxuICAgIHRoaXMucGFyYW1ldGVyVHlwZXMgPSBvcHRpb25zLnBhcmFtZXRlclR5cGVzO1xyXG5cclxuICAgIC8vIFZhbGlkYXRpb25cclxuICAgIHRoaXMudmFsaWRhdG9yID0gXy5waWNrKCBvcHRpb25zLCBWYWxpZGF0aW9uLlZBTElEQVRPUl9LRVlTICk7XHJcbiAgICB0aGlzLnZhbGlkYXRvci52YWxpZGF0aW9uTWVzc2FnZSA9IHRoaXMudmFsaWRhdG9yLnZhbGlkYXRpb25NZXNzYWdlIHx8IGBWYWxpZGF0aW9uIGZhaWxlZCBJT1R5cGUgVmFsaWRhdG9yOiAke3RoaXMudHlwZU5hbWV9YDtcclxuXHJcbiAgICB0aGlzLmRlZmF1bHREZXNlcmlhbGl6YXRpb25NZXRob2QgPSBvcHRpb25zLmRlZmF1bHREZXNlcmlhbGl6YXRpb25NZXRob2Q7XHJcblxyXG4gICAgaWYgKCBvcHRpb25zLnN0YXRlU2NoZW1hID09PSBudWxsIHx8IG9wdGlvbnMuc3RhdGVTY2hlbWEgaW5zdGFuY2VvZiBTdGF0ZVNjaGVtYSApIHtcclxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBodHRwczovL2dpdGh1Yi5jb20vcGhldHNpbXMvdGFuZGVtL2lzc3Vlcy8yNjNcclxuICAgICAgdGhpcy5zdGF0ZVNjaGVtYSA9IG9wdGlvbnMuc3RhdGVTY2hlbWE7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgY29uc3QgY29tcG9zaXRlU2NoZW1hID0gdHlwZW9mIG9wdGlvbnMuc3RhdGVTY2hlbWEgPT09ICdmdW5jdGlvbicgPyBvcHRpb25zLnN0YXRlU2NoZW1hKCB0aGlzICkgOiBvcHRpb25zLnN0YXRlU2NoZW1hO1xyXG5cclxuICAgICAgdGhpcy5zdGF0ZVNjaGVtYSA9IG5ldyBTdGF0ZVNjaGVtYTxULCBTZWxmU3RhdGVUeXBlPiggeyBjb21wb3NpdGVTY2hlbWE6IGNvbXBvc2l0ZVNjaGVtYSB9ICk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQXNzZXJ0IHRoYXQgdG9TdGF0ZU9iamVjdCBtZXRob2QgaXMgcHJvdmlkZWQgZm9yIHZhbHVlIFN0YXRlU2NoZW1hcy4gRG8gdGhpcyB3aXRoIHRoZSBmb2xsb3dpbmcgbG9naWM6XHJcbiAgICAvLyAxLiBJdCBpcyBhY2NlcHRhYmxlIHRvIG5vdCBwcm92aWRlIGEgc3RhdGVTY2hlbWEgKGZvciBJT1R5cGVzIHRoYXQgYXJlbid0IHN0YXRlZnVsKVxyXG4gICAgLy8gMi4gWW91IG11c3QgZWl0aGVyIHByb3ZpZGUgYSB0b1N0YXRlT2JqZWN0LCBvciBoYXZlIGEgY29tcG9zaXRlIFN0YXRlU2NoZW1hLiBDb21wb3NpdGUgc3RhdGUgc2NoZW1hcyBzdXBwb3J0IGRlZmF1bHQgc2VyaWFsaXphdGlvbiBtZXRob2RzLlxyXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggIXRoaXMuc3RhdGVTY2hlbWEgfHwgKCB0b1N0YXRlT2JqZWN0U3VwcGxpZWQgfHwgdGhpcy5zdGF0ZVNjaGVtYS5pc0NvbXBvc2l0ZSgpICksXHJcbiAgICAgICd0b1N0YXRlT2JqZWN0IG1ldGhvZCBtdXN0IGJlIHByb3ZpZGVkIGZvciB2YWx1ZSBTdGF0ZVNjaGVtYXMnICk7XHJcblxyXG4gICAgdGhpcy50b1N0YXRlT2JqZWN0ID0gKCBjb3JlT2JqZWN0OiBUICkgPT4ge1xyXG4gICAgICB2YWxpZGF0ZSggY29yZU9iamVjdCwgdGhpcy52YWxpZGF0b3IsIFZBTElEQVRFX09QVElPTlNfRkFMU0UgKTtcclxuXHJcbiAgICAgIGxldCB0b1N0YXRlT2JqZWN0O1xyXG5cclxuICAgICAgLy8gT25seSBkbyB0aGlzIG5vbi1zdGFuZGFyZCB0b1N0YXRlT2JqZWN0IGZ1bmN0aW9uIGlmIHRoZXJlIGlzIGEgc3RhdGVTY2hlbWEgYnV0IG5vIHRvU3RhdGVPYmplY3QgcHJvdmlkZWRcclxuICAgICAgaWYgKCAhdG9TdGF0ZU9iamVjdFN1cHBsaWVkICYmIHN0YXRlU2NoZW1hU3VwcGxpZWQgJiYgdGhpcy5zdGF0ZVNjaGVtYSAmJiB0aGlzLnN0YXRlU2NoZW1hLmlzQ29tcG9zaXRlKCkgKSB7XHJcbiAgICAgICAgdG9TdGF0ZU9iamVjdCA9IHRoaXMuZGVmYXVsdFRvU3RhdGVPYmplY3QoIGNvcmVPYmplY3QgKTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICB0b1N0YXRlT2JqZWN0ID0gb3B0aW9ucy50b1N0YXRlT2JqZWN0KCBjb3JlT2JqZWN0ICk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFZhbGlkYXRlLCBidXQgb25seSBpZiB0aGlzIElPVHlwZSBpbnN0YW5jZSBoYXMgbW9yZSB0byB2YWxpZGF0ZSB0aGFuIHRoZSBzdXBlcnR5cGVcclxuICAgICAgaWYgKCB0b1N0YXRlT2JqZWN0U3VwcGxpZWQgfHwgc3RhdGVTY2hlbWFTdXBwbGllZCApIHtcclxuXHJcbiAgICAgICAgLy8gT25seSB2YWxpZGF0ZSB0aGUgc3RhdGVPYmplY3QgaWYgaXQgaXMgcGhldGlvU3RhdGU6dHJ1ZS5cclxuICAgICAgICAvLyBUaGlzIGlzIGFuIG4qbSBhbGdvcml0aG0gYmVjYXVzZSBmb3IgZWFjaCB0aW1lIHRvU3RhdGVPYmplY3QgaXMgY2FsbGVkIGFuZCBuZWVkcyB2YWxpZGF0aW9uLCB0aGlzLnZhbGlkYXRlU3RhdGVPYmplY3RcclxuICAgICAgICAvLyBsb29rcyBhbGwgdGhlIHdheSB1cCB0aGUgSU9UeXBlIGhpZXJhcmNoeS4gVGhpcyBpcyBub3QgZWZmaWNpZW50LCBidXQgZ2FpbnMgdXMgdGhlIGFiaWxpdHkgdG8gbWFrZSBzdXJlIHRoYXRcclxuICAgICAgICAvLyB0aGUgc3RhdGVPYmplY3QgZG9lc24ndCBoYXZlIGFueSBzdXBlcmZsdW91cywgdW5leHBlY3RlZCBrZXlzLiBUaGUgXCJtXCIgcG9ydGlvbiBpcyBiYXNlZCBvbiBob3cgbWFueSBzdWItcHJvcGVydGllc1xyXG4gICAgICAgIC8vIGluIGEgc3RhdGUgY2FsbCBgdG9TdGF0ZU9iamVjdGAsIGFuZCB0aGUgXCJuXCIgcG9ydGlvbiBpcyBiYXNlZCBvbiBob3cgbWFueSBJT1R5cGVzIGluIHRoZSBoaWVyYXJjaHkgZGVmaW5lIGFcclxuICAgICAgICAvLyB0b1N0YXRlT2JqZWN0IG9yIHN0YXRlU2NoZW1hLiBJbiB0aGUgZnV0dXJlIHdlIGNvdWxkIHBvdGVudGlhbGx5IGltcHJvdmUgcGVyZm9ybWFuY2UgYnkgaGF2aW5nIHZhbGlkYXRlU3RhdGVPYmplY3RcclxuICAgICAgICAvLyBvbmx5IGNoZWNrIGFnYWluc3QgdGhlIHNjaGVtYSBhdCB0aGlzIGxldmVsLCBidXQgdGhlbiBleHRyYSBrZXlzIGluIHRoZSBzdGF0ZU9iamVjdCB3b3VsZCBub3QgYmUgY2F1Z2h0LiBGcm9tIHdvcmsgZG9uZSBpbiBodHRwczovL2dpdGh1Yi5jb20vcGhldHNpbXMvcGhldC1pby9pc3N1ZXMvMTc3NFxyXG4gICAgICAgIGFzc2VydCAmJiB0aGlzLnZhbGlkYXRlU3RhdGVPYmplY3QoIHRvU3RhdGVPYmplY3QgKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdG9TdGF0ZU9iamVjdDtcclxuICAgIH07XHJcbiAgICB0aGlzLmZyb21TdGF0ZU9iamVjdCA9IG9wdGlvbnMuZnJvbVN0YXRlT2JqZWN0O1xyXG4gICAgdGhpcy5zdGF0ZU9iamVjdFRvQ3JlYXRlRWxlbWVudEFyZ3VtZW50cyA9IG9wdGlvbnMuc3RhdGVPYmplY3RUb0NyZWF0ZUVsZW1lbnRBcmd1bWVudHM7XHJcblxyXG4gICAgdGhpcy5hcHBseVN0YXRlID0gKCBjb3JlT2JqZWN0OiBULCBzdGF0ZU9iamVjdDogU3RhdGVUeXBlICkgPT4ge1xyXG4gICAgICB2YWxpZGF0ZSggY29yZU9iamVjdCwgdGhpcy52YWxpZGF0b3IsIFZBTElEQVRFX09QVElPTlNfRkFMU0UgKTtcclxuXHJcbiAgICAgIC8vIFZhbGlkYXRlLCBidXQgb25seSBpZiB0aGlzIElPVHlwZSBpbnN0YW5jZSBoYXMgbW9yZSB0byB2YWxpZGF0ZSB0aGFuIHRoZSBzdXBlcnR5cGVcclxuICAgICAgaWYgKCBhcHBseVN0YXRlU3VwcGxpZWQgfHwgc3RhdGVTY2hlbWFTdXBwbGllZCApIHtcclxuXHJcbiAgICAgICAgLy8gVmFsaWRhdGUgdGhhdCB0aGUgcHJvdmlkZWQgc3RhdGVPYmplY3QgaXMgb2YgdGhlIGV4cGVjdGVkIHNjaGVtYVxyXG4gICAgICAgIC8vIE5PVEU6IENhbm5vdCB1c2UgdGhpcy52YWxpZGF0ZVN0YXRlT2JqZWN0IGJlY2F1c2Ugb3B0aW9ucyBhZG9wdHMgc3VwZXJ0eXBlLmFwcGx5U3RhdGUsIHdoaWNoIGlzIGJvdW5kcyB0byB0aGVcclxuICAgICAgICAvLyBwYXJlbnQgSU9UeXBlLiBUaGlzIHByZXZlbnRzIGNvcnJlY3QgdmFsaWRhdGlvbiBiZWNhdXNlIHRoZSBzdXBlcnR5cGUgZG9lc24ndCBrbm93IGFib3V0IHRoZSBzdWJ0eXBlIHNjaGVtYXMuXHJcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciB3ZSBjYW5ub3QgdHlwZSBjaGVjayBhZ2FpbnN0IFBoZXRpb09iamVjdCBmcm9tIHRoaXMgZmlsZVxyXG4gICAgICAgIGFzc2VydCAmJiBjb3JlT2JqZWN0LnBoZXRpb1R5cGUgJiYgY29yZU9iamVjdC5waGV0aW9UeXBlLnZhbGlkYXRlU3RhdGVPYmplY3QoIHN0YXRlT2JqZWN0ICk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIE9ubHkgZG8gdGhpcyBub24tc3RhbmRhcmQgYXBwbHlTdGF0ZSBmdW5jdGlvbiBmcm9tIHN0YXRlU2NoZW1hIGlmIHRoZXJlIGlzIGEgc3RhdGVTY2hlbWEgYnV0IG5vIGFwcGx5U3RhdGUgcHJvdmlkZWRcclxuICAgICAgaWYgKCAhYXBwbHlTdGF0ZVN1cHBsaWVkICYmIHN0YXRlU2NoZW1hU3VwcGxpZWQgJiYgdGhpcy5zdGF0ZVNjaGVtYSAmJiB0aGlzLnN0YXRlU2NoZW1hLmlzQ29tcG9zaXRlKCkgKSB7XHJcbiAgICAgICAgdGhpcy5kZWZhdWx0QXBwbHlTdGF0ZSggY29yZU9iamVjdCwgc3RhdGVPYmplY3QgYXMgQ29tcG9zaXRlU3RhdGVPYmplY3RUeXBlICk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgb3B0aW9ucy5hcHBseVN0YXRlKCBjb3JlT2JqZWN0LCBzdGF0ZU9iamVjdCApO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuaXNGdW5jdGlvblR5cGUgPSBvcHRpb25zLmlzRnVuY3Rpb25UeXBlO1xyXG4gICAgdGhpcy5hZGRDaGlsZEVsZW1lbnQgPSBvcHRpb25zLmFkZENoaWxkRWxlbWVudDtcclxuXHJcbiAgICBpZiAoIGFzc2VydCApIHtcclxuXHJcbiAgICAgIGFzc2VydCAmJiBhc3NlcnQoIHN1cGVydHlwZSB8fCB0aGlzLnR5cGVOYW1lID09PSAnT2JqZWN0SU8nLCAnc3VwZXJ0eXBlIGlzIHJlcXVpcmVkJyApO1xyXG4gICAgICBhc3NlcnQgJiYgYXNzZXJ0KCAhdGhpcy50eXBlTmFtZS5pbmNsdWRlcyggJy4nICksICdEb3RzIHNob3VsZCBub3QgYXBwZWFyIGluIHR5cGUgbmFtZXMnICk7XHJcbiAgICAgIGFzc2VydCAmJiBhc3NlcnQoIHRoaXMudHlwZU5hbWUuc3BsaXQoIC9bPChdLyApWyAwIF0uZW5kc1dpdGgoIFBoZXRpb0NvbnN0YW50cy5JT19UWVBFX1NVRkZJWCApLCBgSU9UeXBlIG5hbWUgbXVzdCBlbmQgd2l0aCAke1BoZXRpb0NvbnN0YW50cy5JT19UWVBFX1NVRkZJWH1gICk7XHJcbiAgICAgIGFzc2VydCAmJiBhc3NlcnQoIHRoaXMuaGFzT3duUHJvcGVydHkoICd0eXBlTmFtZScgKSwgJ3RoaXMudHlwZU5hbWUgaXMgcmVxdWlyZWQnICk7XHJcblxyXG4gICAgICAvLyBhc3NlcnQgdGhhdCBlYWNoIHB1YmxpYyBtZXRob2QgYWRoZXJlcyB0byB0aGUgZXhwZWN0ZWQgc2NoZW1hXHJcbiAgICAgIHRoaXMubWV0aG9kcyAmJiBPYmplY3QudmFsdWVzKCB0aGlzLm1ldGhvZHMgKS5mb3JFYWNoKCAoIG1ldGhvZE9iamVjdDogSU9UeXBlTWV0aG9kICkgPT4ge1xyXG4gICAgICAgIGlmICggdHlwZW9mIG1ldGhvZE9iamVjdCA9PT0gJ29iamVjdCcgKSB7XHJcbiAgICAgICAgICBhc3NlcnQgJiYgbWV0aG9kT2JqZWN0Lmludm9jYWJsZUZvclJlYWRPbmx5RWxlbWVudHMgJiYgYXNzZXJ0KCB0eXBlb2YgbWV0aG9kT2JqZWN0Lmludm9jYWJsZUZvclJlYWRPbmx5RWxlbWVudHMgPT09ICdib29sZWFuJyxcclxuICAgICAgICAgICAgYGludm9jYWJsZUZvclJlYWRPbmx5RWxlbWVudHMgbXVzdCBiZSBvZiB0eXBlIGJvb2xlYW46ICR7bWV0aG9kT2JqZWN0Lmludm9jYWJsZUZvclJlYWRPbmx5RWxlbWVudHN9YCApO1xyXG4gICAgICAgIH1cclxuICAgICAgfSApO1xyXG4gICAgICBhc3NlcnQgJiYgYXNzZXJ0KCB0aGlzLmRvY3VtZW50YXRpb24ubGVuZ3RoID4gMCwgJ2RvY3VtZW50YXRpb24gbXVzdCBiZSBwcm92aWRlZCcgKTtcclxuXHJcbiAgICAgIHRoaXMubWV0aG9kcyAmJiB0aGlzLmhhc093blByb3BlcnR5KCAnbWV0aG9kT3JkZXInICkgJiYgdGhpcy5tZXRob2RPcmRlci5mb3JFYWNoKCBtZXRob2ROYW1lID0+IHtcclxuICAgICAgICBhc3NlcnQgJiYgYXNzZXJ0KCB0aGlzLm1ldGhvZHMhWyBtZXRob2ROYW1lIF0sIGBtZXRob2ROYW1lIG5vdCBpbiBwdWJsaWMgbWV0aG9kczogJHttZXRob2ROYW1lfWAgKTtcclxuICAgICAgfSApO1xyXG5cclxuICAgICAgaWYgKCBzdXBlcnR5cGUgKSB7XHJcbiAgICAgICAgY29uc3QgdHlwZUhpZXJhcmNoeSA9IHN1cGVydHlwZS5nZXRUeXBlSGllcmFyY2h5KCk7XHJcbiAgICAgICAgYXNzZXJ0ICYmIHRoaXMuZXZlbnRzICYmIHRoaXMuZXZlbnRzLmZvckVhY2goIGV2ZW50ID0+IHtcclxuXHJcbiAgICAgICAgICAvLyBNYWtlIHN1cmUgZXZlbnRzIGFyZSBub3QgbGlzdGVkIGFnYWluXHJcbiAgICAgICAgICBhc3NlcnQgJiYgYXNzZXJ0KCAhXy5zb21lKCB0eXBlSGllcmFyY2h5LCB0ID0+IHQuZXZlbnRzLmluY2x1ZGVzKCBldmVudCApICksIGBJT1R5cGUgc2hvdWxkIG5vdCBkZWNsYXJlIGV2ZW50IHRoYXQgcGFyZW50IGFsc28gaGFzOiAke2V2ZW50fWAgKTtcclxuICAgICAgICB9ICk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcblxyXG4gICAgICAgIC8vIFRoZSByb290IElPVHlwZSBtdXN0IHN1cHBseSBhbGwgNCBzdGF0ZSBtZXRob2RzLlxyXG4gICAgICAgIGFzc2VydCAmJiBhc3NlcnQoIHR5cGVvZiBvcHRpb25zLnRvU3RhdGVPYmplY3QgPT09ICdmdW5jdGlvbicsICd0b1N0YXRlT2JqZWN0IG11c3QgYmUgZGVmaW5lZCcgKTtcclxuICAgICAgICBhc3NlcnQgJiYgYXNzZXJ0KCB0eXBlb2Ygb3B0aW9ucy5mcm9tU3RhdGVPYmplY3QgPT09ICdmdW5jdGlvbicsICdmcm9tU3RhdGVPYmplY3QgbXVzdCBiZSBkZWZpbmVkJyApO1xyXG4gICAgICAgIGFzc2VydCAmJiBhc3NlcnQoIHR5cGVvZiBvcHRpb25zLnN0YXRlT2JqZWN0VG9DcmVhdGVFbGVtZW50QXJndW1lbnRzID09PSAnZnVuY3Rpb24nLCAnc3RhdGVPYmplY3RUb0NyZWF0ZUVsZW1lbnRBcmd1bWVudHMgbXVzdCBiZSBkZWZpbmVkJyApO1xyXG4gICAgICAgIGFzc2VydCAmJiBhc3NlcnQoIHR5cGVvZiBvcHRpb25zLmFwcGx5U3RhdGUgPT09ICdmdW5jdGlvbicsICdhcHBseVN0YXRlIG11c3QgYmUgZGVmaW5lZCcgKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gSW5jbHVkZSBzdGF0ZSBmcm9tIGFsbCBjb21wb3NpdGUgc3RhdGUgc2NoZW1hcyB1cCBhbmQgZG93biB0aGUgdHlwZSBoaWVyYXJjaHkgKGNoaWxkcmVuIG92ZXJyaWRpbmcgcGFyZW50cykuXHJcbiAgcHJpdmF0ZSBkZWZhdWx0VG9TdGF0ZU9iamVjdCggY29yZU9iamVjdDogVCApOiBTdGF0ZVR5cGUge1xyXG5cclxuICAgIGxldCBzdXBlclN0YXRlT2JqZWN0OiBQYXJ0aWFsPFN0YXRlVHlwZT4gPSB7fTtcclxuICAgIGlmICggdGhpcy5zdXBlcnR5cGUgKSB7XHJcbiAgICAgIHN1cGVyU3RhdGVPYmplY3QgPSB0aGlzLnN1cGVydHlwZS5kZWZhdWx0VG9TdGF0ZU9iamVjdCggY29yZU9iamVjdCApO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICggdGhpcy5zdGF0ZVNjaGVtYSAmJiB0aGlzLnN0YXRlU2NoZW1hLmlzQ29tcG9zaXRlKCkgKSB7XHJcbiAgICAgIHJldHVybiBfLm1lcmdlKCBzdXBlclN0YXRlT2JqZWN0LCB0aGlzLnN0YXRlU2NoZW1hLmRlZmF1bHRUb1N0YXRlT2JqZWN0KCBjb3JlT2JqZWN0ICkgKSBhcyBTdGF0ZVR5cGU7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgcmV0dXJuIHN1cGVyU3RhdGVPYmplY3QgYXMgU3RhdGVUeXBlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gSW5jbHVkZSBzdGF0ZSBmcm9tIGFsbCBjb21wb3NpdGUgc3RhdGUgc2NoZW1hcyB1cCBhbmQgZG93biB0aGUgdHlwZSBoaWVyYXJjaHkgKGNoaWxkcmVuIG92ZXJyaWRpbmcgcGFyZW50cykuXHJcbiAgcHJpdmF0ZSBkZWZhdWx0QXBwbHlTdGF0ZSggY29yZU9iamVjdDogVCwgc3RhdGVPYmplY3Q6IENvbXBvc2l0ZVN0YXRlT2JqZWN0VHlwZSApOiB2b2lkIHtcclxuXHJcbiAgICBpZiAoIHRoaXMuc3VwZXJ0eXBlICkge1xyXG4gICAgICB0aGlzLnN1cGVydHlwZS5kZWZhdWx0QXBwbHlTdGF0ZSggY29yZU9iamVjdCwgc3RhdGVPYmplY3QgKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIHRoaXMuc3RhdGVTY2hlbWEgJiYgdGhpcy5zdGF0ZVNjaGVtYS5pc0NvbXBvc2l0ZSgpICkge1xyXG4gICAgICB0aGlzLnN0YXRlU2NoZW1hLmRlZmF1bHRBcHBseVN0YXRlKCBjb3JlT2JqZWN0LCBzdGF0ZU9iamVjdCApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyBhbiBhcnJheSBvZiBJT1R5cGVzIG9mIHRoZSBzZWxmIHR5cGUgYW5kIGFsbCB0aGUgc3VwZXJ0eXBlIGFuY2VzdG9ycy5cclxuICAgKi9cclxuICBwcml2YXRlIGdldFR5cGVIaWVyYXJjaHkoKTogSU9UeXBlPEludGVudGlvbmFsQW55LCBJbnRlbnRpb25hbEFueSwgSW50ZW50aW9uYWxBbnk+W10ge1xyXG4gICAgY29uc3QgYXJyYXkgPSBbXTtcclxuXHJcbiAgICBsZXQgaW9UeXBlOiBJT1R5cGUgPSB0aGlzOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNvbnNpc3RlbnQtdGhpcywgQHR5cGVzY3JpcHQtZXNsaW50L25vLXRoaXMtYWxpYXNcclxuICAgIHdoaWxlICggaW9UeXBlICkge1xyXG4gICAgICBhcnJheS5wdXNoKCBpb1R5cGUgKTtcclxuICAgICAgaW9UeXBlID0gaW9UeXBlLnN1cGVydHlwZSE7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXJyYXk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBJT1R5cGUgaXMgYSBzdWJ0eXBlIG9mIHRoZSBwYXNzZWQtaW4gdHlwZSAob3IgaWYgdGhleSBhcmUgdGhlIHNhbWUpLlxyXG4gICAqL1xyXG4gIHB1YmxpYyBleHRlbmRzKCB0eXBlOiBJT1R5cGU8dW5rbm93biwgdW5rbm93bj4gKTogYm9vbGVhbiB7XHJcblxyXG4gICAgLy8gbWVtb3J5LWJhc2VkIGltcGxlbWVudGF0aW9uIE9LIHNpbmNlIHRoaXMgbWV0aG9kIGlzIG9ubHkgdXNlZCBpbiBhc3NlcnRpb25zXHJcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlSGllcmFyY2h5KCkuaW5jbHVkZXMoIHR5cGUgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybiBhbGwgdGhlIG1ldGFkYXRhIGRlZmF1bHRzIChmb3IgdGhlIGVudGlyZSBJT1R5cGUgaGllcmFyY2h5KVxyXG4gICAqL1xyXG4gIHB1YmxpYyBnZXRBbGxNZXRhZGF0YURlZmF1bHRzKCk6IFBhcnRpYWw8UGhldGlvRWxlbWVudE1ldGFkYXRhPiB7XHJcbiAgICByZXR1cm4gXy5tZXJnZSgge30sIHRoaXMuc3VwZXJ0eXBlID8gdGhpcy5zdXBlcnR5cGUuZ2V0QWxsTWV0YWRhdGFEZWZhdWx0cygpIDoge30sIHRoaXMubWV0YWRhdGFEZWZhdWx0cyApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJuIGFsbCB0aGUgZGF0YSBkZWZhdWx0cyAoZm9yIHRoZSBlbnRpcmUgSU9UeXBlIGhpZXJhcmNoeSlcclxuICAgKi9cclxuICBwdWJsaWMgZ2V0QWxsRGF0YURlZmF1bHRzKCk6IFJlY29yZDxzdHJpbmcsIHVua25vd24+IHtcclxuICAgIHJldHVybiBfLm1lcmdlKCB7fSwgdGhpcy5zdXBlcnR5cGUgPyB0aGlzLnN1cGVydHlwZS5nZXRBbGxEYXRhRGVmYXVsdHMoKSA6IHt9LCB0aGlzLmRhdGFEZWZhdWx0cyApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHN0YXRlT2JqZWN0IC0gdGhlIHN0YXRlT2JqZWN0IHRvIHZhbGlkYXRlIGFnYWluc3RcclxuICAgKiBAcGFyYW0gdG9Bc3NlcnQ9ZmFsc2UgLSB3aGV0aGVyIHRvIGFzc2VydCB3aGVuIGludmFsaWRcclxuICAgKiBAcGFyYW0gc2NoZW1hS2V5c1ByZXNlbnRJblN0YXRlT2JqZWN0PVtdXHJcbiAgICogQHJldHVybnMgaWYgdGhlIHN0YXRlT2JqZWN0IGlzIHZhbGlkIG9yIG5vdC5cclxuICAgKi9cclxuICBwdWJsaWMgaXNTdGF0ZU9iamVjdFZhbGlkKCBzdGF0ZU9iamVjdDogU3RhdGVUeXBlLCB0b0Fzc2VydCA9IGZhbHNlLCBzY2hlbWFLZXlzUHJlc2VudEluU3RhdGVPYmplY3Q6IHN0cmluZ1tdID0gW10gKTogYm9vbGVhbiB7XHJcblxyXG4gICAgLy8gU2V0IHRvIGZhbHNlIHdoZW4gaW52YWxpZFxyXG4gICAgbGV0IHZhbGlkID0gdHJ1ZTtcclxuXHJcbiAgICAvLyBtYWtlIHN1cmUgdGhlIHN0YXRlT2JqZWN0IGhhcyBldmVyeXRoaW5nIHRoZSBzY2hlbWEgcmVxdWlyZXMgYW5kIG5vdGhpbmcgbW9yZVxyXG4gICAgaWYgKCB0aGlzLnN0YXRlU2NoZW1hICkge1xyXG4gICAgICBjb25zdCB2YWxpZFNvRmFyID0gdGhpcy5zdGF0ZVNjaGVtYS5jaGVja1N0YXRlT2JqZWN0VmFsaWQoIHN0YXRlT2JqZWN0IGFzIFNlbGZTdGF0ZVR5cGUsIHRvQXNzZXJ0LCBzY2hlbWFLZXlzUHJlc2VudEluU3RhdGVPYmplY3QgKTtcclxuXHJcbiAgICAgIC8vIG51bGwgYXMgYSBtYXJrZXIgdG8ga2VlcCBjaGVja2luZyB1cCB0aGUgaGllcmFyY2h5LCBvdGhlcndpc2Ugd2UgcmVhY2hlZCBvdXIgYmFzZWQgY2FzZSBiZWNhdXNlIHRoZSBzdGF0ZVNjaGVtYSB3YXMgYSB2YWx1ZSwgbm90IGEgY29tcG9zaXRlXHJcbiAgICAgIGlmICggdmFsaWRTb0ZhciAhPT0gbnVsbCApIHtcclxuICAgICAgICByZXR1cm4gdmFsaWRTb0ZhcjtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmICggdGhpcy5zdXBlcnR5cGUgKSB7XHJcbiAgICAgIHJldHVybiB2YWxpZCAmJiB0aGlzLnN1cGVydHlwZS5pc1N0YXRlT2JqZWN0VmFsaWQoIHN0YXRlT2JqZWN0LCB0b0Fzc2VydCwgc2NoZW1hS2V5c1ByZXNlbnRJblN0YXRlT2JqZWN0ICk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gV2hlbiB3ZSByZWFjaCB0aGUgcm9vdCwgbWFrZSBzdXJlIHRoZXJlIGlzbid0IGFueXRoaW5nIGluIHRoZSBzdGF0ZU9iamVjdCB0aGF0IGlzbid0IGRlc2NyaWJlZCBieSBhIHNjaGVtYVxyXG4gICAgaWYgKCAhdGhpcy5zdXBlcnR5cGUgJiYgc3RhdGVPYmplY3QgJiYgdHlwZW9mIHN0YXRlT2JqZWN0ICE9PSAnc3RyaW5nJyAmJiAhQXJyYXkuaXNBcnJheSggc3RhdGVPYmplY3QgKSApIHtcclxuXHJcbiAgICAgIC8vIFZpc2l0IHRoZSBzdGF0ZVxyXG4gICAgICBPYmplY3Qua2V5cyggc3RhdGVPYmplY3QgKS5mb3JFYWNoKCBrZXkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGtleVZhbGlkID0gc2NoZW1hS2V5c1ByZXNlbnRJblN0YXRlT2JqZWN0LmluY2x1ZGVzKCBrZXkgKTtcclxuICAgICAgICBpZiAoICFrZXlWYWxpZCApIHtcclxuICAgICAgICAgIHZhbGlkID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFzc2VydCAmJiB0b0Fzc2VydCAmJiBhc3NlcnQoIGtleVZhbGlkLCBgc3RhdGVPYmplY3QgcHJvdmlkZWQgYSBrZXkgdGhhdCBpcyBub3QgaW4gdGhlIHNjaGVtYTogJHtrZXl9YCApO1xyXG4gICAgICB9ICk7XHJcblxyXG4gICAgICByZXR1cm4gdmFsaWQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFzc2VydCBpZiB0aGUgcHJvdmlkZWQgc3RhdGVPYmplY3QgaXMgbm90IHZhbGlkIHRvIHRoaXMgSU9UeXBlJ3Mgc3RhdGVTY2hlbWFcclxuICAgKi9cclxuICBwdWJsaWMgdmFsaWRhdGVTdGF0ZU9iamVjdCggc3RhdGVPYmplY3Q6IFN0YXRlVHlwZSApOiB2b2lkIHtcclxuICAgIHRoaXMuaXNTdGF0ZU9iamVjdFZhbGlkKCBzdGF0ZU9iamVjdCwgdHJ1ZSApO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIHRvU3RyaW5nKCk6IElPVHlwZU5hbWUge1xyXG4gICAgcmV0dXJuIHRoaXMudHlwZU5hbWU7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBkZWZhdWx0IHN0YXRlIHZhbHVlXHJcbmNvbnN0IERFRkFVTFRfU1RBVEUgPSBudWxsO1xyXG5cclxuLy8gVGhpcyBtdXN0IGJlIGRlY2xhcmVkIGFmdGVyIHRoZSBjbGFzcyBkZWNsYXJhdGlvbiB0byBhdm9pZCBhIGNpcmN1bGFyIGRlcGVuZGVuY3kgd2l0aCBQaGV0aW9PYmplY3QuXHJcbi8vIEByZWFkb25seVxyXG5JT1R5cGUuT2JqZWN0SU8gPSBuZXcgSU9UeXBlPFBoZXRpb09iamVjdCwgbnVsbD4oIFRhbmRlbUNvbnN0YW50cy5PQkpFQ1RfSU9fVFlQRV9OQU1FLCB7XHJcbiAgaXNWYWxpZFZhbHVlOiAoKSA9PiB0cnVlLFxyXG4gIHN1cGVydHlwZTogbnVsbCxcclxuICBkb2N1bWVudGF0aW9uOiAnVGhlIHJvb3Qgb2YgdGhlIFBoRVQtaU8gVHlwZSBoaWVyYXJjaHknLFxyXG4gIHRvU3RhdGVPYmplY3Q6ICggY29yZU9iamVjdDogUGhldGlvT2JqZWN0ICkgPT4ge1xyXG5cclxuICAgIGlmICggcGhldCAmJiBwaGV0LnRhbmRlbSAmJiBwaGV0LnRhbmRlbS5UYW5kZW0uVkFMSURBVElPTiApIHtcclxuXHJcbiAgICAgIGFzc2VydCAmJiBhc3NlcnQoIGNvcmVPYmplY3QudGFuZGVtLCAnY29yZU9iamVjdCBtdXN0IGJlIFBoRVQtaU8gb2JqZWN0JyApO1xyXG5cclxuICAgICAgYXNzZXJ0ICYmIGFzc2VydCggIWNvcmVPYmplY3QucGhldGlvU3RhdGUsXHJcbiAgICAgICAgYGZlbGwgYmFjayB0byByb290IHNlcmlhbGl6YXRpb24gc3RhdGUgZm9yICR7Y29yZU9iamVjdC50YW5kZW0ucGhldGlvSUR9LiBQb3RlbnRpYWwgc29sdXRpb25zOlxyXG4gICAgICAgICAqIG1hcmsgdGhlIHR5cGUgYXMgcGhldGlvU3RhdGU6IGZhbHNlXHJcbiAgICAgICAgICogY3JlYXRlIGEgY3VzdG9tIHRvU3RhdGVPYmplY3QgbWV0aG9kIGluIHlvdXIgSU9UeXBlXHJcbiAgICAgICAgICogcGVyaGFwcyB5b3UgaGF2ZSBldmVyeXRoaW5nIHJpZ2h0LCBidXQgZm9yZ290IHRvIHBhc3MgaW4gdGhlIElPVHlwZSB2aWEgcGhldGlvVHlwZSBpbiB0aGUgY29uc3RydWN0b3JgICk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gREVGQVVMVF9TVEFURTtcclxuICB9LFxyXG4gIGZyb21TdGF0ZU9iamVjdDogKCkgPT4ge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCAnT2JqZWN0SU8uZnJvbVN0YXRlT2JqZWN0IHNob3VsZCBub3QgYmUgY2FsbGVkJyApO1xyXG4gIH0sXHJcbiAgc3RhdGVPYmplY3RUb0NyZWF0ZUVsZW1lbnRBcmd1bWVudHM6ICgpID0+IFtdLFxyXG4gIGFwcGx5U3RhdGU6IF8ubm9vcCxcclxuICBtZXRhZGF0YURlZmF1bHRzOiBUYW5kZW1Db25zdGFudHMuUEhFVF9JT19PQkpFQ1RfTUVUQURBVEFfREVGQVVMVFMsXHJcbiAgZGF0YURlZmF1bHRzOiB7XHJcbiAgICBpbml0aWFsU3RhdGU6IERFRkFVTFRfU1RBVEVcclxuICB9LFxyXG4gIHN0YXRlU2NoZW1hOiBudWxsXHJcbn0gKTtcclxuXHJcbnRhbmRlbU5hbWVzcGFjZS5yZWdpc3RlciggJ0lPVHlwZScsIElPVHlwZSApOyJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBT0EsUUFBUSxNQUFNLDhCQUE4QjtBQUNuRCxPQUFPQyxVQUFVLE1BQXFCLGdDQUFnQztBQUN0RSxPQUFPQyxTQUFTLE1BQU0sb0NBQW9DO0FBQzFELE9BQU9DLGVBQWUsTUFBTSx1QkFBdUI7QUFDbkQsT0FBT0MsZUFBZSxNQUE2Qyx1QkFBdUI7QUFDMUYsT0FBT0MsZUFBZSxNQUFNLHVCQUF1QjtBQUNuRCxPQUFPQyxXQUFXLE1BQXFELGtCQUFrQjtBQUt6RjtBQUNBLE1BQU1DLHNCQUFzQixHQUFHO0VBQUVDLGlCQUFpQixFQUFFO0FBQU0sQ0FBQzs7QUFFM0Q7QUFDQTtBQUNBO0FBQ0EsTUFBTUMsZUFBZSxHQUFLQyxVQUFzQixJQUFjO0VBQzVELE1BQU1DLEtBQUssR0FBR0QsVUFBVSxDQUFDRSxPQUFPLENBQUVULGVBQWUsQ0FBQ1UsY0FBZSxDQUFDO0VBQ2xFQyxNQUFNLElBQUlBLE1BQU0sQ0FBRUgsS0FBSyxJQUFJLENBQUMsRUFBRSwrQkFBZ0MsQ0FBQztFQUMvRCxPQUFPRCxVQUFVLENBQUNLLFNBQVMsQ0FBRSxDQUFDLEVBQUVKLEtBQU0sQ0FBQztBQUN6QyxDQUFDO0FBdUhEO0FBQ0E7QUFDQSxlQUFlLE1BQU1LLE1BQU0sQ0FBNEU7RUFBRTtFQUN2Rzs7RUFXb0Y7O0VBT3BGOztFQUdBOztFQUdBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ1NDLFdBQVdBLENBQWtCQyxRQUFvQixFQUFFQyxlQUEyRCxFQUFH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