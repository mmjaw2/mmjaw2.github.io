// Copyright 2019-2024, University of Colorado Boulder

/**
 * A trait for subtypes of Node. Meant for Nodes with a value that "run" on a NumberProperty and handles formatting,
 * mapping, and aria-valuetext updating in the PDOM.
 *
 * Also implements the listeners that respond to accessible input, such as keydown, keyup, input, and change
 * events, which may come from a keyboard or other assistive device. Use getAccessibleValueHandlerInputListener() to get
 * these listeners to add to your Node with addInputListener().
 *
 * Browsers have limitations for the interaction of a slider when the range is not evenly divisible by the step size.
 * Rather than allow the browser to natively change the valueProperty with an input event, this trait implements a
 * totally custom interaction keeping the general slider behavior the same.
 *
 * @author Michael Kauzmann (PhET Interactive Simulations)
 * @author Jesse Greenberg (PhET Interactive Simulations)
 */

import Utils from '../../../dot/js/Utils.js';
import assertHasProperties from '../../../phet-core/js/assertHasProperties.js';
import Orientation from '../../../phet-core/js/Orientation.js';
import { animatedPanZoomSingleton, DelayedMutate, KeyboardUtils, PDOMUtils, Voicing } from '../../../scenery/js/imports.js';
import Utterance from '../../../utterance-queue/js/Utterance.js';
import sun from '../sun.js';
import optionize, { combineOptions } from '../../../phet-core/js/optionize.js';
import Multilink from '../../../axon/js/Multilink.js';
import DynamicProperty from '../../../axon/js/DynamicProperty.js';
import Property from '../../../axon/js/Property.js';
import platform from '../../../phet-core/js/platform.js';

// constants
const DEFAULT_TAG_NAME = 'input';
const toString = v => `${v}`;

// Options for the Voicing response that happens at the end of
const DEFAULT_VOICING_ON_END_RESPONSE_OPTIONS = {
  withNameResponse: false,
  // no need to repeat the name every change
  withObjectResponse: true,
  // response for the new value
  onlyOnValueChange: true // no response if value did not change
};

// Function signature for voicingOnEndResponse.

const ACCESSIBLE_VALUE_HANDLER_OPTIONS = ['startInput', 'endInput', 'onInput', 'constrainValue', 'keyboardStep', 'shiftKeyboardStep', 'pageKeyboardStep', 'ariaOrientation', 'panTargetNode', 'roundToStepSize', 'a11yMapPDOMValue', 'a11yMapValue', 'a11yRepeatEqualValueText', 'a11yCreateAriaValueText', 'a11yCreateContextResponseAlert', 'contextResponsePerValueChangeDelay', 'contextResponseMaxDelay', 'a11yDependencies', 'voicingOnEndResponseOptions'];

// do not use ParentOptions here!

/**
 * @param Type
 * @param optionsArgPosition - zero-indexed number that the options argument is provided at
 */
const AccessibleValueHandler = (Type, optionsArgPosition) => {
  const AccessibleValueHandlerClass = DelayedMutate('AccessibleValueHandler', ACCESSIBLE_VALUE_HANDLER_OPTIONS, class AccessibleValueHandler extends Voicing(Type) {
    _startInput = _.noop;
    _onInput = _.noop;
    _endInput = _.noop;
    _constrainValue = _.identity;
    _a11yMapValue = _.identity;
    _panTargetNode = null;
    // will be initialized based on the enabled range
    // will be initialized based on the enabled range

    // will be initialized based on the enabled range
    _ariaOrientation = Orientation.HORIZONTAL;
    _shiftKey = false;
    _a11yDependencies = [];

    // track previous values for callbacks outside of Property listeners
    _oldValue = null;
    _a11yCreateContextResponseAlert = null;

    // The Property value when an interaction starts, so it can be used as the "old" value
    // when generating a context response at the end of an interaction with a11yCreateContextResponseAlert.

    // The utterance sent to the utteranceQueue when the value changes, alert content generated by
    // optional a11yCreateContextResponseAlert. The alertStableDelay on this utterance will increase if the input
    // receives many interactions before the utterance can be announced so that VoiceOver has time to read the
    // aria-valuetext (object response) before the alert (context response).
    _contextResponseUtterance = new Utterance();

    // Number of times the input has changed in value before the utterance made was able to be spoken, only applicable
    // if using a11yCreateContextResponseAlert
    _timesValueTextChangedBeforeAlerting = 0;

    // in ms, see options for documentation.
    _contextResponsePerValueChangeDelay = 700;
    _contextResponseMaxDelay = 1500;

    // Whether an input event has been handled. If handled, we will not respond to the
    // change event. An AT (particularly VoiceOver) may send a change event (and not an input event) to the
    // browser in response to a user gesture. We need to handle that change event, without also handling the
    // input event in case a device sends both events to the browser.
    _a11yInputHandled = false;

    // Some browsers will receive `input` events when the user tabs away from the slider or
    // on some key presses - if we receive a keydown event for a tab key, do not allow input or change events
    _blockInput = false;

    // setting to enable/disable rounding to the step size
    _roundToStepSize = false;

    // key is the event.code for the range key, value is whether it is down
    _rangeKeysDown = {};
    _a11yMapPDOMValue = _.identity;
    _a11yCreateAriaValueText = toString; // by default make sure it returns a string
    _dependenciesMultilink = null;
    _a11yRepeatEqualValueText = true;

    // When context responses are supported, this counter is used to determine a mutable delay between hearing the
    // same response.
    _timesChangedBeforeAlerting = 0;

    // Options for the Voicing response at the end of interaction with this component.
    _voicingOnEndResponseOptions = DEFAULT_VOICING_ON_END_RESPONSE_OPTIONS;

    // At the start of input, a listener is attached to the PDOMPointer to prevent listeners closer to the
    // scene graph root from firing. A reference to the pointer is saved to support interrupt because
    // there is no SceneryEvent.
    _pdomPointer = null;
    constructor(...args) {
      const providedOptions = args[optionsArgPosition];
      assert && assert(providedOptions, 'providedOptions has required options');
      assert && assert(providedOptions.enabledRangeProperty, 'enabledRangeProperty is a required option');
      assert && assert(providedOptions.valueProperty, 'valueProperty is a required option');
      assert && providedOptions && assert(!providedOptions.hasOwnProperty('tagName') || providedOptions.tagName === null, 'AccessibleValueHandler sets its own tagName. Only provide tagName to clear accessible content from the PDOM');

      // cannot be set by client
      assert && providedOptions && assert(!providedOptions.hasOwnProperty('inputType'), 'AccessibleValueHandler sets its own inputType.');

      // if rounding to keyboard step, keyboardStep must be defined so values aren't skipped and the slider
      // doesn't get stuck while rounding to the nearest value, see https://github.com/phetsims/sun/issues/410
      if (assert && providedOptions && providedOptions.roundToStepSize) {
        assert(providedOptions.keyboardStep, 'rounding to keyboardStep, define appropriate keyboardStep to round to');
      }

      // Override options
      args[optionsArgPosition] = optionize()({
        // @ts-expect-error - TODO: we should be able to have the public API be just null, and internally set to string, Limitation (IV), see https://github.com/phetsims/phet-core/issues/128
        tagName: DEFAULT_TAG_NAME,
        // parent options that we must provide a default to use
        inputType: 'range'
      }, providedOptions);
      super(...args);

      // members of the Node API that are used by this trait
      assertHasProperties(this, ['inputValue', 'setPDOMAttribute']);
      const valueProperty = providedOptions.valueProperty;
      const enabledRangeProperty = providedOptions.enabledRangeProperty;
      if (providedOptions.reverseAlternativeInput) {
        // A DynamicProperty will invert the value before setting it to the actual valueProperty, and similarly
        // invert if the valueProperty changes externally.
        this._valueProperty = new DynamicProperty(new Property(valueProperty), {
          bidirectional: true,
          map: propertyValue => enabledRangeProperty.value.max - propertyValue,
          inverseMap: propertyValue => enabledRangeProperty.value.max - propertyValue
        });
      } else {
        this._valueProperty = valueProperty;
      }
      this._enabledRangeProperty = enabledRangeProperty;
      this._a11yValueTextUpdateListener = this.invalidateAriaValueText.bind(this);

      // initialized with setters that validate
      this.keyboardStep = (enabledRangeProperty.get().max - enabledRangeProperty.get().min) / 20;
      this.shiftKeyboardStep = (enabledRangeProperty.get().max - enabledRangeProperty.get().min) / 100;
      this.pageKeyboardStep = (enabledRangeProperty.get().max - enabledRangeProperty.get().min) / 10;
      this._valueOnStart = valueProperty.value;

      // be called last, after options have been set to `this`.
      this.invalidateA11yDependencies();

      // listeners, must be unlinked in dispose
      const enabledRangeObserver = this.invalidateEnabledRange.bind(this);
      this._enabledRangeProperty.link(enabledRangeObserver);

      // when the property changes, be sure to update the accessible input value and aria-valuetext which is read
      // by assistive technology when the value changes
      const valuePropertyListener = this.invalidateValueProperty.bind(this);
      this._valueProperty.link(valuePropertyListener);

      // A listener that will be attached to the pointer to prevent other listeners from attaching.
      this._pdomPointerListener = {
        interrupt: () => {
          this._onInteractionEnd(null);
        }
      };
      this._disposeAccessibleValueHandler = () => {
        this._enabledRangeProperty.unlink(enabledRangeObserver);
        this._valueProperty.unlink(valuePropertyListener);
        if (providedOptions.reverseAlternativeInput) {
          assert && assert(this._valueProperty instanceof DynamicProperty, 'Only a DynamicProperty can be disposed, otherwise this is disposing a Property that AccessibleValueHandler does not have ownership over.');
          this._valueProperty.dispose();
        }
        this._dependenciesMultilink && this._dependenciesMultilink.dispose();
        this._panTargetNode = null;
        this._a11yDependencies = [];
      };
    }
    set startInput(value) {
      this._startInput = value;
    }
    get startInput() {
      return this._startInput;
    }
    set onInput(value) {
      this._onInput = value;
    }
    get onInput() {
      return this._onInput;
    }
    set endInput(value) {
      this._endInput = value;
    }
    get endInput() {
      return this._endInput;
    }
    set constrainValue(value) {
      // NOTE: Not currently re-constraining the value on set, since hopefully other things are doing this action.
      // If that's not done, we should do something about it here.
      this._constrainValue = value;
    }
    get constrainValue() {
      return this._constrainValue;
    }
    set panTargetNode(value) {
      this._panTargetNode = value;
    }
    get panTargetNode() {
      return this._panTargetNode;
    }
    set roundToStepSize(value) {
      this._roundToStepSize = value;
    }
    get roundToStepSize() {
      return this._roundToStepSize;
    }
    set a11yMapPDOMValue(value) {
      this._a11yMapPDOMValue = value;
      this.invalidateEnabledRange(this._enabledRangeProperty.value);
      this.invalidateValueProperty();
      this.invalidateAriaValueText();
    }
    get a11yMapPDOMValue() {
      return this._a11yMapPDOMValue;
    }
    set a11yMapValue(value) {
      this._a11yMapValue = value;
    }
    get a11yMapValue() {
      return this._a11yMapValue;
    }
    set a11yRepeatEqualValueText(value) {
      this._a11yRepeatEqualValueText = value;
      this.invalidateAriaValueText();
    }
    get a11yRepeatEqualValueText() {
      return this._a11yRepeatEqualValueText;
    }
    set a11yCreateAriaValueText(value) {
      this._a11yCreateAriaValueText = value;
      this.invalidateAriaValueText();
    }
    get a11yCreateAriaValueText() {
      return this._a11yCreateAriaValueText;
    }
    set a11yCreateContextResponseAlert(value) {
      this._a11yCreateContextResponseAlert = value;
    }
    get a11yCreateContextResponseAlert() {
      return this._a11yCreateContextResponseAlert;
    }
    set contextResponsePerValueChangeDelay(value) {
      this._contextResponsePerValueChangeDelay = value;
    }
    get contextResponsePerValueChangeDelay() {
      return this._contextResponsePerValueChangeDelay;
    }
    set contextResponseMaxDelay(value) {
      this._contextResponseMaxDelay = value;
    }
    get contextResponseMaxDelay() {
      return this._contextResponseMaxDelay;
    }
    set voicingOnEndResponseOptions(value) {
      this._voicingOnEndResponseOptions = value;
    }
    get voicingOnEndResponseOptions() {
      return this._voicingOnEndResponseOptions;
    }
    invalidateAriaValueText() {
      this._updateAriaValueText(this._oldValue);
      this._oldValue = this._valueProperty.value;
    }
    invalidateEnabledRange(enabledRange) {
      const mappedMin = this._getMappedValue(enabledRange.min);
      const mappedMax = this._getMappedValue(enabledRange.max);

      // pdom - update enabled slider range for AT, required for screen reader events to behave correctly
      this.setPDOMAttribute('min', mappedMin);
      this.setPDOMAttribute('max', mappedMax);

      // update the step attribute slider element - this attribute is only added because it is required to
      // receive accessibility events on all browsers, and is totally separate from the step values above that
      // will modify the valueProperty. See function for more information.
      this._updateSiblingStepAttribute();
    }
    invalidateValueProperty() {
      const mappedValue = this._getMappedValue();

      // set the aria-valuenow attribute in case the AT requires it to read the value correctly, some may
      // fall back on this from aria-valuetext see
      // https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques/Using_the_aria-valuetext_attribute#Possible_effects_on_user_agents_and_assistive_technology
      this.setPDOMAttribute('aria-valuenow', mappedValue);

      // update the PDOM input value on Property change
      this.inputValue = mappedValue;
    }
    invalidateA11yDependencies() {
      // dispose the previous multilink, there is only one set of dependencies, though they can be overwritten.
      this._dependenciesMultilink && this._dependenciesMultilink.dispose();
      this._dependenciesMultilink = Multilink.multilinkAny(this._a11yDependencies.concat([this._valueProperty]), this._a11yValueTextUpdateListener);
    }

    /**
     * There are some features of AccessibleValueHandler that support updating when more than just the valueProperty
     * changes. Use this method to set the dependency Properties for this value handler. This will blow away the
     * previous list (like Node.children).
     */
    setA11yDependencies(dependencies) {
      assert && assert(!dependencies.includes(this._valueProperty), 'The value Property is already a dependency, and does not need to be added to this list');
      this._a11yDependencies = dependencies;
      this.invalidateA11yDependencies();
    }
    getA11yDependencies() {
      return this._a11yDependencies;
    }
    set a11yDependencies(value) {
      this.setA11yDependencies(value);
    }
    get a11yDependencies() {
      return this.getA11yDependencies();
    }
    _updateAriaValueText(oldPropertyValue) {
      const mappedValue = this._getMappedValue();

      // create the dynamic aria-valuetext from a11yCreateAriaValueText.
      const newAriaValueTextValueType = this._a11yCreateAriaValueText(mappedValue, this._valueProperty.value, oldPropertyValue);
      let newAriaValueText = PDOMUtils.unwrapStringProperty(newAriaValueTextValueType);

      // eslint-disable-next-line no-simple-type-checking-assertions
      assert && assert(typeof newAriaValueText === 'string');

      // Make sure that the new aria-valuetext is different from the previous one, so that if they are the same
      // the screen reader will still read the new text - adding a hairSpace registers as a new string, but the
      // screen reader won't read that character.
      const hairSpace = '\u200A';
      if (this._a11yRepeatEqualValueText && this.ariaValueText && newAriaValueText === this.ariaValueText.replace(new RegExp(hairSpace, 'g'), '')) {
        newAriaValueText = this.ariaValueText + hairSpace;
      }
      this.ariaValueText = newAriaValueText;
    }

    /**
     * If generating an alert when the user changes the slider value, create the alert content and send it
     * to the utteranceQueue. For VoiceOver, it is important that if the value is changed multiple times before
     * the alert can be spoken, we provide more time for the AT to finish speaking aria-valuetext. Otherwise, the
     * alert may be lost. See https://github.com/phetsims/gravity-force-lab-basics/issues/146.
     */
    alertContextResponse() {
      // Alerting will occur to each connected display's UtteranceQueue, but we should only increment delay once per
      // time this function is called.
      let timesChangedBeforeAlertingIncremented = false;
      if (this._a11yCreateContextResponseAlert) {
        const mappedValue = this._getMappedValue();
        const endInteractionAlert = this._a11yCreateContextResponseAlert(mappedValue, this._valueProperty.value, this._valueOnStart);

        // only if it returned an alert
        if (endInteractionAlert) {
          this._contextResponseUtterance.alert = endInteractionAlert;
          this.forEachUtteranceQueue(utteranceQueue => {
            // Only increment a single time, this has the constraint that if different utteranceQueues move this
            // alert through at a different time, the delay could be inconsistent, but in general it should work well.
            if (timesChangedBeforeAlertingIncremented) {
              // use the current value for this._timesChangedBeforeAlerting
            } else if (utteranceQueue.hasUtterance(this._contextResponseUtterance)) {
              timesChangedBeforeAlertingIncremented = true;
              this._timesChangedBeforeAlerting++;
            } else {
              this._timesChangedBeforeAlerting = 1;
            }

            // Adjust the delay of the utterance based on number of times it has been re-added to the queue. Each
            // time the aria-valuetext changes, this method is called, we want to make sure to give enough time for the
            // aria-valuetext to fully complete before alerting this context response.
            this._contextResponseUtterance.alertStableDelay = Math.min(this._contextResponseMaxDelay, this._timesChangedBeforeAlerting * this._contextResponsePerValueChangeDelay);
            utteranceQueue.addToBack(this._contextResponseUtterance);
          });
        }
      }
    }

    /**
     * Should be called after the model dependencies have been reset
     */
    reset() {
      // reset the aria-valuetext creator if it supports that
      this._a11yCreateAriaValueText.reset && this._a11yCreateAriaValueText.reset();
      this._a11yCreateContextResponseAlert && this._a11yCreateContextResponseAlert.reset && this._a11yCreateContextResponseAlert.reset();
      this._timesChangedBeforeAlerting = 0;
      // on reset, make sure that the PDOM descriptions are completely up to date.
      this._updateAriaValueText(null);
    }

    /**
     * get the formatted value based on the current value of the Property.
     * @param [value] - if not provided, will use the current value of the valueProperty
     */
    _getMappedValue(value = this._valueProperty.value) {
      return this._a11yMapPDOMValue(value);
    }

    /**
     * Return the input listener that could be attached to mixed in types of AccessibleValueHandler to support
     * interaction.
     */
    getAccessibleValueHandlerInputListener() {
      return {
        keydown: this.handleKeyDown.bind(this),
        keyup: this.handleKeyUp.bind(this),
        input: this.handleInput.bind(this),
        change: this.handleChange.bind(this),
        blur: this.handleBlur.bind(this)
      };
    }

    /**
     * Handle a keydown event so that the value handler behaves like a traditional input that modifies
     * a number. We expect the following:
     *   - Up Arrow/Right Arrow increments value by keyboardStep
     *   - Down Arrow/Left Arrow decrements value by step size
     *   - Page up/Page down will increment/decrement value pageKeyboardStep
     *   - Home/End will set value to min/max value for the range
     *   - Pressing shift with an arrow key will increment/decrement value by shiftKeyboardStep
     *
     * Add this as an input listener to the `keydown` event to the Node mixing in AccessibleValueHandler.
     */
    handleKeyDown(event) {
      const domEvent = event.domEvent;
      const key = KeyboardUtils.getEventCode(domEvent);
      if (!key) {
        return;
      }
      this._shiftKey = domEvent.shiftKey;

      // if we receive a 'tab' keydown event, do not allow the browser to react to this like a submission and
      // prevent responding to the `input` event
      if (KeyboardUtils.isKeyEvent(domEvent, KeyboardUtils.KEY_TAB)) {
        this._blockInput = true;
      }
      if (this.enabledProperty.get()) {
        // Prevent default so browser doesn't change input value automatically
        if (KeyboardUtils.isRangeKey(domEvent)) {
          // This should prevent any "change" and "input" events so we don't change the value twice, but it also
          // prevents a VoiceOver issue where pressing arrow keys both changes the slider value AND moves the
          // virtual cursor. This needs to be done every range key event so that we don't change the value with
          // an 'input' or 'change' event, even when the meta key is down.
          domEvent.preventDefault();

          // On Mac, we don't get a keyup event when the meta key is down so don't change the value or do
          // anything that assumes we will get a corresponding keyup event, see
          // https://stackoverflow.com/questions/11818637/why-does-javascript-drop-keyup-events-when-the-metakey-is-pressed-on-mac-browser
          if (!domEvent.metaKey) {
            // signify that this listener is reserved for dragging so that other listeners can change
            // their behavior during scenery event dispatch
            event.pointer.reserveForKeyboardDrag();

            // whether we will use constrainValue to modify the proposed value, see usages below
            let useConstrainValue = true;

            // if this is the first keydown this is the start of the drag interaction
            if (!this._anyKeysDown()) {
              this._onInteractionStart(event);
            }

            // track that a new key is being held down
            this._rangeKeysDown[key] = true;
            let newValue = this._valueProperty.get();
            if (KeyboardUtils.isAnyKeyEvent(domEvent, [KeyboardUtils.KEY_END, KeyboardUtils.KEY_HOME])) {
              // on 'end' and 'home' snap to max and min of enabled range respectively (this is typical browser
              // behavior for sliders)
              if (key === KeyboardUtils.KEY_END) {
                newValue = this._enabledRangeProperty.get().max;
              } else if (key === KeyboardUtils.KEY_HOME) {
                newValue = this._enabledRangeProperty.get().min;
              }
            } else {
              let stepSize;
              if (key === KeyboardUtils.KEY_PAGE_UP || key === KeyboardUtils.KEY_PAGE_DOWN) {
                // on page up and page down, the default step size is 1/10 of the range (this is typical browser behavior)
                stepSize = this.pageKeyboardStep;
                if (key === KeyboardUtils.KEY_PAGE_UP) {
                  newValue = this._valueProperty.get() + stepSize;
                } else if (key === KeyboardUtils.KEY_PAGE_DOWN) {
                  newValue = this._valueProperty.get() - stepSize;
                }
              } else if (KeyboardUtils.isArrowKey(domEvent)) {
                // if the shift key is pressed down, modify the step size (this is atypical browser behavior for sliders)
                stepSize = domEvent.shiftKey ? this.shiftKeyboardStep : this.keyboardStep;

                // Temporary workaround, if using shift key with arrow keys to use the shiftKeyboardStep, don't
                // use constrainValue because the constrainValue is often smaller than the values allowed by
                // constrainValue. See https://github.com/phetsims/sun/issues/698.
                useConstrainValue = !domEvent.shiftKey;
                if (key === KeyboardUtils.KEY_RIGHT_ARROW || key === KeyboardUtils.KEY_UP_ARROW) {
                  newValue = this._valueProperty.get() + stepSize;
                } else if (key === KeyboardUtils.KEY_LEFT_ARROW || key === KeyboardUtils.KEY_DOWN_ARROW) {
                  newValue = this._valueProperty.get() - stepSize;
                }
                if (this._roundToStepSize) {
                  newValue = roundValue(newValue, this._valueProperty.get(), stepSize);
                }
              }
            }

            // Map the value.
            const mappedValue = this._a11yMapValue(newValue, this._valueProperty.get());

            // Optionally constrain the value. Only constrain if modifying by shiftKeyboardStep because that step size
            // may allow finer precision than constrainValue. This is a workaround for
            // https://github.com/phetsims/sun/issues/698, and is actually a problem for all keyboard steps if they
            // are smaller than values allowed by constrainValue. In https://github.com/phetsims/sun/issues/703 we
            // will work to resolve this more generally.
            let constrainedValue = mappedValue;
            if (useConstrainValue) {
              constrainedValue = this._constrainValue(mappedValue);
            }

            // limit the value to the enabled range
            this._valueProperty.set(Utils.clamp(constrainedValue, this._enabledRangeProperty.get().min, this._enabledRangeProperty.get().max));

            // optional callback after the valueProperty is set (even if set to the same value) so that the listener
            // can use the new value.
            this._onInput(event);

            // after any keyboard input, make sure that the Node stays in view
            const panTargetNode = this._panTargetNode || this;
            animatedPanZoomSingleton.initialized && animatedPanZoomSingleton.listener.panToNode(panTargetNode, true, panTargetNode.limitPanDirection);
          }
        }
      }
    }

    /**
     * Handle key up event on this accessible slider, managing the shift key, and calling an optional endDrag
     * function on release. Add this as an input listener to the node mixing in AccessibleValueHandler.
     * @mixin-protected - made public for use in the mixin only
     */
    handleKeyUp(event) {
      const key = KeyboardUtils.getEventCode(event.domEvent);

      // handle case where user tabbed to this input while an arrow key might have been held down
      if (this._allKeysUp()) {
        return;
      }

      // reset shift key flag when we release it
      if (KeyboardUtils.SHIFT_KEYS.includes(key)) {
        this._shiftKey = false;
      }
      if (this.enabledProperty.get()) {
        if (KeyboardUtils.isRangeKey(event.domEvent)) {
          this._rangeKeysDown[key] = false;

          // when all range keys are released, we are done dragging
          if (this._allKeysUp()) {
            this._onInteractionEnd(event);
          }
        }
      }
    }

    /**
     * VoiceOver sends a "change" event to the slider (NOT an input event), so we need to handle the case when
     * a change event is sent but an input event ins't handled. Guarded against the case that BOTH change and
     * input are sent to the browser by the AT.
     *
     * Add this as a listener to the 'change' input event on the Node that is mixing in AccessibleValueHandler.
     * @mixin-protected - made public for use in the mixin only
     */
    handleChange(event) {
      if (!this._a11yInputHandled) {
        this.handleInput(event);
      }
      this._a11yInputHandled = false;
    }

    /**
     * Handle a direct 'input' event that might come from assistive technology. It is possible that the user agent
     * (particularly VoiceOver, or a switch device) will initiate an input event directly without going through
     * keydown. In that case, handle the change depending on which direction the user tried to go. We determine
     * this by detecting how the input value changed in response to the `input` event relative to the current
     * value of the valueProperty.
     *
     * Note that it is important to handle the "input" event, rather than the "change" event. The "input" will
     * fire when the value changes from a gesture, while the "change" will only happen on submission, like as
     * navigating away from the element.
     *
     * Add this as a listener to the `input` event on the Node that is mixing in AccessibleValueHandler.
     * @mixin-protected - made public for use in the mixin only
     */
    handleInput(event) {
      if (this.enabledProperty.get() && !this._blockInput) {
        // don't handle again on "change" event
        this._a11yInputHandled = true;
        let newValue = this._valueProperty.get();
        const inputValue = parseFloat(event.domEvent.target.value);
        const stepSize = this._shiftKey ? this.shiftKeyboardStep : this.keyboardStep;
        const mappedValue = this._getMappedValue();

        // start of change event is start of drag
        this._onInteractionStart(event);
        if (inputValue > mappedValue) {
          newValue = this._valueProperty.get() + stepSize;
        } else if (inputValue < mappedValue) {
          newValue = this._valueProperty.get() - stepSize;
        }
        if (this._roundToStepSize) {
          newValue = roundValue(newValue, this._valueProperty.get(), stepSize);
        }

        // limit to enabled range
        newValue = Utils.clamp(newValue, this._enabledRangeProperty.get().min, this._enabledRangeProperty.get().max);

        // optionally constrain value
        this._valueProperty.set(this._constrainValue(this._a11yMapValue(newValue, this._valueProperty.get())));

        // only one change per input, but still call optional onInput function - after valueProperty is set (even if
        // set to the same value) so listener can use new value.
        this._onInput(event);

        // end of change is the end of a drag
        this._onInteractionEnd(event);
      }

      // don't block the next input after receiving one, some AT may send either `keydown` or `input` events
      // depending on modifier keys so we need to be ready to receive either on next interaction
      this._blockInput = false;
    }

    /**
     * Fires when the accessible slider loses focus.
     *
     * Add this as a listener on the `blur` event to the Node that is mixing in AccessibleValueHandler.
     * @mixin-protected - made public for use in the mixin only
     */
    handleBlur(event) {
      // if any range keys are currently down, call end drag because user has stopped dragging to do something else
      if (this._anyKeysDown()) {
        this._onInteractionEnd(event);
      }

      // reset flag in case we shift-tabbed away from slider
      this._shiftKey = false;

      // when focus leaves this element stop blocking input events
      this._blockInput = false;

      // reset counter for range keys down
      this._rangeKeysDown = {};
    }

    /**
     * Interaction with this input has started, save the value on start so that it can be used as an "old" value
     * when generating the context response with option a11yCreateContextResponse.
     */
    _onInteractionStart(event) {
      assert && assert(!this._pdomPointer, 'Pointer should have been cleared and detached on end or interrupt.');
      this._pdomPointer = event.pointer;
      assert && assert(this._pdomPointer.attachedListener !== this._pdomPointerListener, 'This pointer listener was never removed!');
      this._pdomPointer.addInputListener(this._pdomPointerListener, true);
      this._valueOnStart = this._valueProperty.value;
      this._startInput(event);
    }

    /**
     * Interaction with this input has completed, generate an utterance describing changes if necessary and call
     * optional "end" function.
     *
     * @param [event] - Event is not guaranteed because we need to support interruption
     */
    _onInteractionEnd(event) {
      // It is possible that interaction already ended. This can happen if the pointer is interrupted just before
      // receiving a keyup event. This is a rare case and should only be possible while fuzzing.
      if (this._pdomPointer) {
        this.alertContextResponse();
        this.voicingOnEndResponse(this._valueOnStart);
        this._endInput(event);

        // detach the pointer listener that was attached on keydown
        assert && assert(this._pdomPointer.attachedListener === this._pdomPointerListener, 'pointer listener should be attached');
        this._pdomPointer.removeInputListener(this._pdomPointerListener);
        this._pdomPointer = null;
      }
    }

    /**
     * Set the delta for the value Property when using arrow keys to interact with the Node.
     */
    setKeyboardStep(keyboardStep) {
      assert && assert(keyboardStep >= 0, 'keyboard step must be non-negative');
      this._keyboardStep = keyboardStep;
    }
    set keyboardStep(keyboardStep) {
      this.setKeyboardStep(keyboardStep);
    }
    get keyboardStep() {
      return this.getKeyboardStep();
    }

    /**
     * Get the delta for value Property when using arrow keys.
     */
    getKeyboardStep() {
      return this._keyboardStep;
    }

    /**
     * Set the delta for value Property when using arrow keys with shift to interact with the Node.
     */
    setShiftKeyboardStep(shiftKeyboardStep) {
      assert && assert(shiftKeyboardStep >= 0, 'shift keyboard step must be non-negative');
      this._shiftKeyboardStep = shiftKeyboardStep;
    }
    set shiftKeyboardStep(shiftKeyboardStep) {
      this.setShiftKeyboardStep(shiftKeyboardStep);
    }
    get shiftKeyboardStep() {
      return this.getShiftKeyboardStep();
    }

    /**
     * Get the delta for value Property when using arrow keys with shift to interact with the Node.
     */
    getShiftKeyboardStep() {
      return this._shiftKeyboardStep;
    }

    /**
     * Returns whether the shift key is currently held down on this slider, changing the size of step.
     */
    getShiftKeyDown() {
      return this._shiftKey;
    }
    get shiftKeyDown() {
      return this.getShiftKeyDown();
    }

    /**
     * Set the delta for value Property when using page up/page down to interact with the Node.
     */
    setPageKeyboardStep(pageKeyboardStep) {
      assert && assert(pageKeyboardStep >= 0, 'page keyboard step must be non-negative');
      this._pageKeyboardStep = pageKeyboardStep;
    }
    set pageKeyboardStep(pageKeyboardStep) {
      this.setPageKeyboardStep(pageKeyboardStep);
    }
    get pageKeyboardStep() {
      return this.getPageKeyboardStep();
    }

    /**
     * Get the delta for value Property when using page up/page down to interact with the Node.
     */
    getPageKeyboardStep() {
      return this._pageKeyboardStep;
    }

    /**
     * Set the orientation for the slider as specified by https://www.w3.org/TR/wai-aria-1.1/#aria-orientation.
     * Depending on the value of this attribute, a screen reader will give different indications about which
     * arrow keys should be used
     */
    setAriaOrientation(orientation) {
      this._ariaOrientation = orientation;
      this.setPDOMAttribute('aria-orientation', orientation.ariaOrientation);
    }
    set ariaOrientation(orientation) {
      this.setAriaOrientation(orientation);
    }
    get ariaOrientation() {
      return this._ariaOrientation;
    }

    /**
     * Get the orientation of the accessible slider, see setAriaOrientation for information on the behavior of this
     * attribute.
     */
    getAriaOrientation() {
      return this._ariaOrientation;
    }

    /**
     * Returns true if all range keys are currently up (not held down).
     */
    _allKeysUp() {
      return _.every(this._rangeKeysDown, entry => !entry);
    }

    /**
     * Returns true if any range keys are currently down on this slider. Useful for determining when to call
     * startDrag or endDrag based on interaction.
     */
    _anyKeysDown() {
      return !!_.find(this._rangeKeysDown, entry => entry);
    }

    /**
     * Set the `step` attribute on accessible siblings for this Node. Usually, we can use the 'any' value,
     * which means that any value within the range is allowed. However, iOS VoiceOver does not support 'any'
     * so we have to calculate a valid step value for mobile Safari.
     *
     * The step attribute must be non-zero. Only values which are equal to min value plus
     * the basis of step are allowed. In other words, the following must always be true:
     * value = min + n * step where value <= max and n is an integer.
     *
     * If the input value is set to anything else, the result is confusing
     * keyboard behavior and the screen reader will say "Invalid" when the value changes.
     * See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/number#step
     *
     * This limitation is too restrictive for PhET as many sliders span physical ranges with keyboard steps that
     * are design to be convenient or pedagogically useful. For example, a slider that spans 0.01 to 15 requires
     * a step of 1, but DOM specification would only allow values 0.01, 1.01, 2.01, ...
     *
     * This restriction is why `step` attribute cannot equal keyboardStep of this trait.
     *
     * Also, if the step attribute is too small relative to the entire range of the slider VoiceOver doesn't allow
     * any input events because...VoiceOver is just interesting like that.
     *
     * Current workaround for all of this is to set the step size to support the precision of the value required
     * by the client so that all values are allowed. If we encounter the VoiceOver case described above we fall
     * back to setting the step size at 1/100th of the max value since the keyboard step generally evenly divides
     * the max value rather than the full range.
     *
     * See the following issues for history:
     * https://github.com/phetsims/sun/issues/413
     * https://github.com/phetsims/sun/issues/873
     */
    _updateSiblingStepAttribute() {
      let stepValue = 'any';

      // TODO: Remove when iOS Safari supports the 'any', see https://github.com/phetsims/a11y-research/issues/191
      if (platform.mobileSafari) {
        const smallestStep = Math.min(this.keyboardStep, this.shiftKeyboardStep, this.pageKeyboardStep);
        stepValue = Math.pow(10, -Utils.numberOfDecimalPlaces(smallestStep));
        const mappedMin = this._getMappedValue(this._enabledRangeProperty.get().min);
        const mappedMax = this._getMappedValue(this._enabledRangeProperty.get().max);
        const mappedLength = mappedMax - mappedMin;

        // If the step is too small relative to full range for VoiceOver to receive input, fall back to a portion of
        // the max value as a workaround.
        if (stepValue / mappedLength < 1e-5) {
          stepValue = mappedMax / 100;

          // Limit the precision of the calculated value.  This is necessary because otherwise floating point
          // inaccuracies can lead to problematic behaviors with screen readers,
          // see https://github.com/phetsims/greenhouse-effect/issues/388. The number of significant digits was chosen
          // somewhat arbitrarily.
          stepValue = Number(stepValue.toPrecision(8));
        }
      }
      this.setPDOMAttribute('step', stepValue);
    }

    /**
     * Call this to trigger the voicing response spoken when an interaction ends. Will speak the current
     * name and object responses (according to options). Set those responses of Voicing.ts to hear up-to-date
     * Voicing responses at the end of an interaction.
     *
     * @param valueOnStart - Property value at the start of the interaction.
     * @param providedOptions
     */
    voicingOnEndResponse(valueOnStart, providedOptions) {
      const options = combineOptions({}, this._voicingOnEndResponseOptions, providedOptions);
      const valueChanged = valueOnStart !== this._valueProperty.value;
      const valueAtMinMax = this._valueProperty.value === this._enabledRangeProperty.value.min || this._valueProperty.value === this._enabledRangeProperty.value.max;

      // content required to speak a response and add to back of UtteranceQueue.
      const responseContentExists = !!(options.withNameResponse && this.voicingNameResponse) || !!(options.withObjectResponse && this.voicingObjectResponse);
      const shouldSpeak = (!options.onlyOnValueChange ||
      // speak each time if onlyOnValueChange is false.
      valueAtMinMax ||
      // always speak at edges, for "go beyond" responses
      valueChanged) &&
      // If the value changed
      responseContentExists;
      shouldSpeak && this.voicingSpeakFullResponse({
        nameResponse: options.withNameResponse ? this.voicingNameResponse : null,
        objectResponse: options.withObjectResponse ? this.voicingObjectResponse : null,
        hintResponse: null // no hint, there was just a successful interaction
      });
    }
    dispose() {
      this._disposeAccessibleValueHandler();
      super.dispose();
    }
  });

  /**
   * {Array.<string>} - String keys for all the allowed options that will be set by Node.mutate( options ), in
   * the order they will be evaluated.
   *
   * NOTE: See Node's _mutatorKeys documentation for more information on how this operates, and potential special
   *       cases that may apply.
   */
  AccessibleValueHandlerClass.prototype._mutatorKeys = ACCESSIBLE_VALUE_HANDLER_OPTIONS.concat(AccessibleValueHandlerClass.prototype._mutatorKeys);
  assert && assert(AccessibleValueHandlerClass.prototype._mutatorKeys.length === _.uniq(AccessibleValueHandlerClass.prototype._mutatorKeys).length, 'duplicate mutator keys in AccessibleValueHandler');
  return AccessibleValueHandlerClass;
};
sun.register('AccessibleValueHandler', AccessibleValueHandler);

/**
 * Round the value to the nearest step size.
 *
 * @param newValue - value to be rounded
 * @param currentValue - current value of the Property associated with this slider
 * @param stepSize - the delta for this manipulation
 */
const roundValue = function (newValue, currentValue, stepSize) {
  let roundValue = newValue;
  if (stepSize !== 0) {
    // round the value to the nearest keyboard step
    roundValue = Utils.roundSymmetric(roundValue / stepSize) * stepSize;

    // go back a step if we went too far due to rounding
    roundValue = correctRounding(roundValue, currentValue, stepSize);
  }
  return roundValue;
};

/**
 * Helper function, it is possible due to rounding to go up or down a step if we have passed the nearest step during
 * keyboard interaction. This function corrects that.
 *
 */
const correctRounding = function (newValue, currentValue, stepSize) {
  let correctedValue = newValue;
  const proposedStep = Math.abs(newValue - currentValue);
  const stepToFar = proposedStep > stepSize;

  // it is possible that proposedStep will be larger than the stepSize but only because of precision
  // constraints with floating point values, don't correct if that is the cases
  const stepsAboutEqual = Utils.equalsEpsilon(proposedStep, stepSize, 1e-14);
  if (stepToFar && !stepsAboutEqual) {
    correctedValue += newValue > currentValue ? -stepSize : stepSize;
  }
  return correctedValue;
};
AccessibleValueHandler.DEFAULT_TAG_NAME = DEFAULT_TAG_NAME;
export default AccessibleValueHandler;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJVdGlscyIsImFzc2VydEhhc1Byb3BlcnRpZXMiLCJPcmllbnRhdGlvbiIsImFuaW1hdGVkUGFuWm9vbVNpbmdsZXRvbiIsIkRlbGF5ZWRNdXRhdGUiLCJLZXlib2FyZFV0aWxzIiwiUERPTVV0aWxzIiwiVm9pY2luZyIsIlV0dGVyYW5jZSIsInN1biIsIm9wdGlvbml6ZSIsImNvbWJpbmVPcHRpb25zIiwiTXVsdGlsaW5rIiwiRHluYW1pY1Byb3BlcnR5IiwiUHJvcGVydHkiLCJwbGF0Zm9ybSIsIkRFRkFVTFRfVEFHX05BTUUiLCJ0b1N0cmluZyIsInYiLCJERUZBVUxUX1ZPSUNJTkdfT05fRU5EX1JFU1BPTlNFX09QVElPTlMiLCJ3aXRoTmFtZVJlc3BvbnNlIiwid2l0aE9iamVjdFJlc3BvbnNlIiwib25seU9uVmFsdWVDaGFuZ2UiLCJBQ0NFU1NJQkxFX1ZBTFVFX0hBTkRMRVJfT1BUSU9OUyIsIkFjY2Vzc2libGVWYWx1ZUhhbmRsZXIiLCJUeXBlIiwib3B0aW9uc0FyZ1Bvc2l0aW9uIiwiQWNjZXNzaWJsZVZhbHVlSGFuZGxlckNsYXNzIiwiX3N0YXJ0SW5wdXQiLCJfIiwibm9vcCIsIl9vbklucHV0IiwiX2VuZElucHV0IiwiX2NvbnN0cmFpblZhbHVlIiwiaWRlbnRpdHkiLCJfYTExeU1hcFZhbHVlIiwiX3BhblRhcmdldE5vZGUiLCJfYXJpYU9yaWVudGF0aW9uIiwiSE9SSVpPTlRBTCIsIl9zaGlmdEtleSIsIl9hMTF5RGVwZW5kZW5jaWVzIiwiX29sZFZhbHVlIiwiX2ExMXlDcmVhdGVDb250ZXh0UmVzcG9uc2VBbGVydCIsIl9jb250ZXh0UmVzcG9uc2VVdHRlcmFuY2UiLCJfdGltZXNWYWx1ZVRleHRDaGFuZ2VkQmVmb3JlQWxlcnRpbmciLCJfY29udGV4dFJlc3BvbnNlUGVyVmFsdWVDaGFuZ2VEZWxheSIsIl9jb250ZXh0UmVzcG9uc2VNYXhEZWxheSIsIl9hMTF5SW5wdXRIYW5kbGVkIiwiX2Jsb2NrSW5wdXQiLCJfcm91bmRUb1N0ZXBTaXplIiwiX3JhbmdlS2V5c0Rvd24iLCJfYTExeU1hcFBET01WYWx1ZSIsIl9hMTF5Q3JlYXRlQXJpYVZhbHVlVGV4dCIsIl9kZXBlbmRlbmNpZXNNdWx0aWxpbmsiLCJfYTExeVJlcGVhdEVxdWFsVmFsdWVUZXh0IiwiX3RpbWVzQ2hhbmdlZEJlZm9yZUFsZXJ0aW5nIiwiX3ZvaWNpbmdPbkVuZFJlc3BvbnNlT3B0aW9ucyIsIl9wZG9tUG9pbnRlciIsImNvbnN0cnVjdG9yIiwiYXJncyIsInByb3ZpZGVkT3B0aW9ucyIsImFzc2VydCIsImVuYWJsZWRSYW5nZVByb3BlcnR5IiwidmFsdWVQcm9wZXJ0eSIsImhhc093blByb3BlcnR5IiwidGFnTmFtZSIsInJvdW5kVG9TdGVwU2l6ZSIsImtleWJvYXJkU3RlcCIsImlucHV0VHlwZSIsInJldmVyc2VBbHRlcm5hdGl2ZUlucHV0IiwiX3ZhbHVlUHJvcGVydHkiLCJiaWRpcmVjdGlvbmFsIiwibWFwIiwicHJvcGVydHlWYWx1ZSIsInZhbHVlIiwibWF4IiwiaW52ZXJzZU1hcCIsIl9lbmFibGVkUmFuZ2VQcm9wZXJ0eSIsIl9hMTF5VmFsdWVUZXh0VXBkYXRlTGlzdGVuZXIiLCJpbnZhbGlkYXRlQXJpYVZhbHVlVGV4dCIsImJpbmQiLCJnZXQiLCJtaW4iLCJzaGlmdEtleWJvYXJkU3RlcCIsInBhZ2VLZXlib2FyZFN0ZXAiLCJfdmFsdWVPblN0YXJ0IiwiaW52YWxpZGF0ZUExMXlEZXBlbmRlbmNpZXMiLCJlbmFibGVkUmFuZ2VPYnNlcnZlciIsImludmFsaWRhdGVFbmFibGVkUmFuZ2UiLCJsaW5rIiwidmFsdWVQcm9wZXJ0eUxpc3RlbmVyIiwiaW52YWxpZGF0ZVZhbHVlUHJvcGVydHkiLCJfcGRvbVBvaW50ZXJMaXN0ZW5lciIsImludGVycnVwdCIsIl9vbkludGVyYWN0aW9uRW5kIiwiX2Rpc3Bvc2VBY2Nlc3NpYmxlVmFsdWVIYW5kbGVyIiwidW5saW5rIiwiZGlzcG9zZSIsInN0YXJ0SW5wdXQiLCJvbklucHV0IiwiZW5kSW5wdXQiLCJjb25zdHJhaW5WYWx1ZSIsInBhblRhcmdldE5vZGUiLCJhMTF5TWFwUERPTVZhbHVlIiwiYTExeU1hcFZhbHVlIiwiYTExeVJlcGVhdEVxdWFsVmFsdWVUZXh0IiwiYTExeUNyZWF0ZUFyaWFWYWx1ZVRleHQiLCJhMTF5Q3JlYXRlQ29udGV4dFJlc3BvbnNlQWxlcnQiLCJjb250ZXh0UmVzcG9uc2VQZXJWYWx1ZUNoYW5nZURlbGF5IiwiY29udGV4dFJlc3BvbnNlTWF4RGVsYXkiLCJ2b2ljaW5nT25FbmRSZXNwb25zZU9wdGlvbnMiLCJfdXBkYXRlQXJpYVZhbHVlVGV4dCIsImVuYWJsZWRSYW5nZSIsIm1hcHBlZE1pbiIsIl9nZXRNYXBwZWRWYWx1ZSIsIm1hcHBlZE1heCIsInNldFBET01BdHRyaWJ1dGUiLCJfdXBkYXRlU2libGluZ1N0ZXBBdHRyaWJ1dGUiLCJtYXBwZWRWYWx1ZSIsImlucHV0VmFsdWUiLCJtdWx0aWxpbmtBbnkiLCJjb25jYXQiLCJzZXRBMTF5RGVwZW5kZW5jaWVzIiwiZGVwZW5kZW5jaWVzIiwiaW5jbHVkZXMiLCJnZXRBMTF5RGVwZW5kZW5jaWVzIiwiYTExeURlcGVuZGVuY2llcyIsIm9sZFByb3BlcnR5VmFsdWUiLCJuZXdBcmlhVmFsdWVUZXh0VmFsdWVUeXBlIiwibmV3QXJpYVZhbHVlVGV4dCIsInVud3JhcFN0cmluZ1Byb3BlcnR5IiwiaGFpclNwYWNlIiwiYXJpYVZhbHVlVGV4dCIsInJlcGxhY2UiLCJSZWdFeHAiLCJhbGVydENvbnRleHRSZXNwb25zZSIsInRpbWVzQ2hhbmdlZEJlZm9yZUFsZXJ0aW5nSW5jcmVtZW50ZWQiLCJlbmRJbnRlcmFjdGlvbkFsZXJ0IiwiYWxlcnQiLCJmb3JFYWNoVXR0ZXJhbmNlUXVldWUiLCJ1dHRlcmFuY2VRdWV1ZSIsImhhc1V0dGVyYW5jZSIsImFsZXJ0U3RhYmxlRGVsYXkiLCJNYXRoIiwiYWRkVG9CYWNrIiwicmVzZXQiLCJnZXRBY2Nlc3NpYmxlVmFsdWVIYW5kbGVySW5wdXRMaXN0ZW5lciIsImtleWRvd24iLCJoYW5kbGVLZXlEb3duIiwia2V5dXAiLCJoYW5kbGVLZXlVcCIsImlucHV0IiwiaGFuZGxlSW5wdXQiLCJjaGFuZ2UiLCJoYW5kbGVDaGFuZ2UiLCJibHVyIiwiaGFuZGxlQmx1ciIsImV2ZW50IiwiZG9tRXZlbnQiLCJrZXkiLCJnZXRFdmVudENvZGUiLCJzaGlmdEtleSIsImlzS2V5RXZlbnQiLCJLRVlfVEFCIiwiZW5hYmxlZFByb3BlcnR5IiwiaXNSYW5nZUtleSIsInByZXZlbnREZWZhdWx0IiwibWV0YUtleSIsInBvaW50ZXIiLCJyZXNlcnZlRm9yS2V5Ym9hcmREcmFnIiwidXNlQ29uc3RyYWluVmFsdWUiLCJfYW55S2V5c0Rvd24iLCJfb25JbnRlcmFjdGlvblN0YXJ0IiwibmV3VmFsdWUiLCJpc0FueUtleUV2ZW50IiwiS0VZX0VORCIsIktFWV9IT01FIiwic3RlcFNpemUiLCJLRVlfUEFHRV9VUCIsIktFWV9QQUdFX0RPV04iLCJpc0Fycm93S2V5IiwiS0VZX1JJR0hUX0FSUk9XIiwiS0VZX1VQX0FSUk9XIiwiS0VZX0xFRlRfQVJST1ciLCJLRVlfRE9XTl9BUlJPVyIsInJvdW5kVmFsdWUiLCJjb25zdHJhaW5lZFZhbHVlIiwic2V0IiwiY2xhbXAiLCJpbml0aWFsaXplZCIsImxpc3RlbmVyIiwicGFuVG9Ob2RlIiwibGltaXRQYW5EaXJlY3Rpb24iLCJfYWxsS2V5c1VwIiwiU0hJRlRfS0VZUyIsInBhcnNlRmxvYXQiLCJ0YXJnZXQiLCJhdHRhY2hlZExpc3RlbmVyIiwiYWRkSW5wdXRMaXN0ZW5lciIsInZvaWNpbmdPbkVuZFJlc3BvbnNlIiwicmVtb3ZlSW5wdXRMaXN0ZW5lciIsInNldEtleWJvYXJkU3RlcCIsIl9rZXlib2FyZFN0ZXAiLCJnZXRLZXlib2FyZFN0ZXAiLCJzZXRTaGlmdEtleWJvYXJkU3RlcCIsIl9zaGlmdEtleWJvYXJkU3RlcCIsImdldFNoaWZ0S2V5Ym9hcmRTdGVwIiwiZ2V0U2hpZnRLZXlEb3duIiwic2hpZnRLZXlEb3duIiwic2V0UGFnZUtleWJvYXJkU3RlcCIsIl9wYWdlS2V5Ym9hcmRTdGVwIiwiZ2V0UGFnZUtleWJvYXJkU3RlcCIsInNldEFyaWFPcmllbnRhdGlvbiIsIm9yaWVudGF0aW9uIiwiYXJpYU9yaWVudGF0aW9uIiwiZ2V0QXJpYU9yaWVudGF0aW9uIiwiZXZlcnkiLCJlbnRyeSIsImZpbmQiLCJzdGVwVmFsdWUiLCJtb2JpbGVTYWZhcmkiLCJzbWFsbGVzdFN0ZXAiLCJwb3ciLCJudW1iZXJPZkRlY2ltYWxQbGFjZXMiLCJtYXBwZWRMZW5ndGgiLCJOdW1iZXIiLCJ0b1ByZWNpc2lvbiIsInZhbHVlT25TdGFydCIsIm9wdGlvbnMiLCJ2YWx1ZUNoYW5nZWQiLCJ2YWx1ZUF0TWluTWF4IiwicmVzcG9uc2VDb250ZW50RXhpc3RzIiwidm9pY2luZ05hbWVSZXNwb25zZSIsInZvaWNpbmdPYmplY3RSZXNwb25zZSIsInNob3VsZFNwZWFrIiwidm9pY2luZ1NwZWFrRnVsbFJlc3BvbnNlIiwibmFtZVJlc3BvbnNlIiwib2JqZWN0UmVzcG9uc2UiLCJoaW50UmVzcG9uc2UiLCJwcm90b3R5cGUiLCJfbXV0YXRvcktleXMiLCJsZW5ndGgiLCJ1bmlxIiwicmVnaXN0ZXIiLCJjdXJyZW50VmFsdWUiLCJyb3VuZFN5bW1ldHJpYyIsImNvcnJlY3RSb3VuZGluZyIsImNvcnJlY3RlZFZhbHVlIiwicHJvcG9zZWRTdGVwIiwiYWJzIiwic3RlcFRvRmFyIiwic3RlcHNBYm91dEVxdWFsIiwiZXF1YWxzRXBzaWxvbiJdLCJzb3VyY2VzIjpbIkFjY2Vzc2libGVWYWx1ZUhhbmRsZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTktMjAyNCwgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXHJcblxyXG4vKipcclxuICogQSB0cmFpdCBmb3Igc3VidHlwZXMgb2YgTm9kZS4gTWVhbnQgZm9yIE5vZGVzIHdpdGggYSB2YWx1ZSB0aGF0IFwicnVuXCIgb24gYSBOdW1iZXJQcm9wZXJ0eSBhbmQgaGFuZGxlcyBmb3JtYXR0aW5nLFxyXG4gKiBtYXBwaW5nLCBhbmQgYXJpYS12YWx1ZXRleHQgdXBkYXRpbmcgaW4gdGhlIFBET00uXHJcbiAqXHJcbiAqIEFsc28gaW1wbGVtZW50cyB0aGUgbGlzdGVuZXJzIHRoYXQgcmVzcG9uZCB0byBhY2Nlc3NpYmxlIGlucHV0LCBzdWNoIGFzIGtleWRvd24sIGtleXVwLCBpbnB1dCwgYW5kIGNoYW5nZVxyXG4gKiBldmVudHMsIHdoaWNoIG1heSBjb21lIGZyb20gYSBrZXlib2FyZCBvciBvdGhlciBhc3Npc3RpdmUgZGV2aWNlLiBVc2UgZ2V0QWNjZXNzaWJsZVZhbHVlSGFuZGxlcklucHV0TGlzdGVuZXIoKSB0byBnZXRcclxuICogdGhlc2UgbGlzdGVuZXJzIHRvIGFkZCB0byB5b3VyIE5vZGUgd2l0aCBhZGRJbnB1dExpc3RlbmVyKCkuXHJcbiAqXHJcbiAqIEJyb3dzZXJzIGhhdmUgbGltaXRhdGlvbnMgZm9yIHRoZSBpbnRlcmFjdGlvbiBvZiBhIHNsaWRlciB3aGVuIHRoZSByYW5nZSBpcyBub3QgZXZlbmx5IGRpdmlzaWJsZSBieSB0aGUgc3RlcCBzaXplLlxyXG4gKiBSYXRoZXIgdGhhbiBhbGxvdyB0aGUgYnJvd3NlciB0byBuYXRpdmVseSBjaGFuZ2UgdGhlIHZhbHVlUHJvcGVydHkgd2l0aCBhbiBpbnB1dCBldmVudCwgdGhpcyB0cmFpdCBpbXBsZW1lbnRzIGFcclxuICogdG90YWxseSBjdXN0b20gaW50ZXJhY3Rpb24ga2VlcGluZyB0aGUgZ2VuZXJhbCBzbGlkZXIgYmVoYXZpb3IgdGhlIHNhbWUuXHJcbiAqXHJcbiAqIEBhdXRob3IgTWljaGFlbCBLYXV6bWFubiAoUGhFVCBJbnRlcmFjdGl2ZSBTaW11bGF0aW9ucylcclxuICogQGF1dGhvciBKZXNzZSBHcmVlbmJlcmcgKFBoRVQgSW50ZXJhY3RpdmUgU2ltdWxhdGlvbnMpXHJcbiAqL1xyXG5cclxuaW1wb3J0IFV0aWxzIGZyb20gJy4uLy4uLy4uL2RvdC9qcy9VdGlscy5qcyc7XHJcbmltcG9ydCBSYW5nZSBmcm9tICcuLi8uLi8uLi9kb3QvanMvUmFuZ2UuanMnO1xyXG5pbXBvcnQgYXNzZXJ0SGFzUHJvcGVydGllcyBmcm9tICcuLi8uLi8uLi9waGV0LWNvcmUvanMvYXNzZXJ0SGFzUHJvcGVydGllcy5qcyc7XHJcbmltcG9ydCBPcmllbnRhdGlvbiBmcm9tICcuLi8uLi8uLi9waGV0LWNvcmUvanMvT3JpZW50YXRpb24uanMnO1xyXG5pbXBvcnQgeyBhbmltYXRlZFBhblpvb21TaW5nbGV0b24sIERlbGF5ZWRNdXRhdGUsIEtleWJvYXJkVXRpbHMsIE5vZGUsIE5vZGVPcHRpb25zLCBQRE9NUG9pbnRlciwgUERPTVV0aWxzLCBQRE9NVmFsdWVUeXBlLCBTY2VuZXJ5RXZlbnQsIFNjZW5lcnlMaXN0ZW5lckZ1bmN0aW9uLCBUSW5wdXRMaXN0ZW5lciwgVFZvaWNpbmcsIFZvaWNpbmcsIFZvaWNpbmdPcHRpb25zIH0gZnJvbSAnLi4vLi4vLi4vc2NlbmVyeS9qcy9pbXBvcnRzLmpzJztcclxuaW1wb3J0IFV0dGVyYW5jZSBmcm9tICcuLi8uLi8uLi91dHRlcmFuY2UtcXVldWUvanMvVXR0ZXJhbmNlLmpzJztcclxuaW1wb3J0IHN1biBmcm9tICcuLi9zdW4uanMnO1xyXG5pbXBvcnQgb3B0aW9uaXplLCB7IGNvbWJpbmVPcHRpb25zIH0gZnJvbSAnLi4vLi4vLi4vcGhldC1jb3JlL2pzL29wdGlvbml6ZS5qcyc7XHJcbmltcG9ydCBNdWx0aWxpbmssIHsgVW5rbm93bk11bHRpbGluayB9IGZyb20gJy4uLy4uLy4uL2F4b24vanMvTXVsdGlsaW5rLmpzJztcclxuaW1wb3J0IFV0dGVyYW5jZVF1ZXVlIGZyb20gJy4uLy4uLy4uL3V0dGVyYW5jZS1xdWV1ZS9qcy9VdHRlcmFuY2VRdWV1ZS5qcyc7XHJcbmltcG9ydCBUUHJvcGVydHkgZnJvbSAnLi4vLi4vLi4vYXhvbi9qcy9UUHJvcGVydHkuanMnO1xyXG5pbXBvcnQgQ29uc3RydWN0b3IgZnJvbSAnLi4vLi4vLi4vcGhldC1jb3JlL2pzL3R5cGVzL0NvbnN0cnVjdG9yLmpzJztcclxuaW1wb3J0IEludGVudGlvbmFsQW55IGZyb20gJy4uLy4uLy4uL3BoZXQtY29yZS9qcy90eXBlcy9JbnRlbnRpb25hbEFueS5qcyc7XHJcbmltcG9ydCBUUmVhZE9ubHlQcm9wZXJ0eSBmcm9tICcuLi8uLi8uLi9heG9uL2pzL1RSZWFkT25seVByb3BlcnR5LmpzJztcclxuaW1wb3J0IER5bmFtaWNQcm9wZXJ0eSBmcm9tICcuLi8uLi8uLi9heG9uL2pzL0R5bmFtaWNQcm9wZXJ0eS5qcyc7XHJcbmltcG9ydCBQcm9wZXJ0eSBmcm9tICcuLi8uLi8uLi9heG9uL2pzL1Byb3BlcnR5LmpzJztcclxuaW1wb3J0IHBsYXRmb3JtIGZyb20gJy4uLy4uLy4uL3BoZXQtY29yZS9qcy9wbGF0Zm9ybS5qcyc7XHJcblxyXG4vLyBjb25zdGFudHNcclxuY29uc3QgREVGQVVMVF9UQUdfTkFNRSA9ICdpbnB1dCc7XHJcbmNvbnN0IHRvU3RyaW5nID0gKCB2OiBJbnRlbnRpb25hbEFueSApID0+IGAke3Z9YDtcclxuXHJcbi8vIE9wdGlvbnMgZm9yIHRoZSBWb2ljaW5nIHJlc3BvbnNlIHRoYXQgaGFwcGVucyBhdCB0aGUgZW5kIG9mXHJcbmNvbnN0IERFRkFVTFRfVk9JQ0lOR19PTl9FTkRfUkVTUE9OU0VfT1BUSU9OUyA9IHtcclxuICB3aXRoTmFtZVJlc3BvbnNlOiBmYWxzZSwgLy8gbm8gbmVlZCB0byByZXBlYXQgdGhlIG5hbWUgZXZlcnkgY2hhbmdlXHJcbiAgd2l0aE9iamVjdFJlc3BvbnNlOiB0cnVlLCAvLyByZXNwb25zZSBmb3IgdGhlIG5ldyB2YWx1ZVxyXG4gIG9ubHlPblZhbHVlQ2hhbmdlOiB0cnVlIC8vIG5vIHJlc3BvbnNlIGlmIHZhbHVlIGRpZCBub3QgY2hhbmdlXHJcbn07XHJcblxyXG50eXBlIENyZWF0ZVRleHRGdW5jdGlvbiA9IHtcclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHBkb21NYXBwZWRWYWx1ZSAtIHNlZVxyXG4gICAqIEBwYXJhbSBuZXdWYWx1ZSAtIHRoZSBuZXcgdmFsdWUsIHVuZm9ybWF0dGVkXHJcbiAgICogQHBhcmFtIHZhbHVlT25TdGFydCAtIHRoZSB2YWx1ZSBhdCB0aGUgc3RhcnQgb2YgdGhlIGludGVyYWN0aW9uLCB0aGUgdmFsdWUgb24ga2V5ZG93biBmb3IgcHJlc3MgYW5kIGhvbGRcclxuICAgKiBAcmV0dXJucyAtIHRleHQvcmVzcG9uc2Uvc3RyaW5nIHRvIGJlIHNldCB0byB0aGUgcHJpbWFyeVNpYmxpbmcsIG51bGwgbWVhbnMgbm90aGluZyB3aWxsIGhhcHBlblxyXG4gICAqICovXHJcbiAgKCBwZG9tTWFwcGVkVmFsdWU6IG51bWJlciwgbmV3VmFsdWU6IG51bWJlciwgdmFsdWVPblN0YXJ0OiBudW1iZXIgfCBudWxsICk6IFBET01WYWx1ZVR5cGUgfCBudWxsO1xyXG5cclxuICAvLyBpZiB0aGlzIGZ1bmN0aW9uIG5lZWRzIHJlc2V0dGluZywgaW5jbHVkZSBhIGByZXNldGAgZmllbGQgb24gdGhpcyBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2hlbiB0aGVcclxuICAvLyBBY2Nlc3NpYmxlVmFsdWVIYW5kbGVyIGlzIHJlc2V0LlxyXG4gIHJlc2V0PzogKCkgPT4gdm9pZDtcclxufTtcclxuXHJcbmV4cG9ydCB0eXBlIFZvaWNpbmdPbkVuZFJlc3BvbnNlT3B0aW9ucyA9IHtcclxuXHJcbiAgLy8gU2hvdWxkIHRoZSBWb2ljaW5nIHJlc3BvbnNlIGJlIHNwb2tlbiBpZiB0aGUgaW50ZXJhY3Rpb24gZG9lcyBub3QgY2hhbmdlIHRoZSB2YWx1ZT9cclxuICBvbmx5T25WYWx1ZUNoYW5nZT86IGJvb2xlYW47XHJcblxyXG4gIC8vIFNob3VsZCB0aGUgVm9pY2luZyByZXNwb25zZSBpbmNsdWRlIHRoZSBuYW1lIHJlc3BvbnNlP1xyXG4gIHdpdGhOYW1lUmVzcG9uc2U/OiBib29sZWFuO1xyXG5cclxuICAvLyBTaG91bGQgdGhlIFZvaWNpbmcgcmVzcG9uc2UgaW5jbHVkZSB0aGUgb2JqZWN0IHJlc3BvbnNlP1xyXG4gIHdpdGhPYmplY3RSZXNwb25zZT86IGJvb2xlYW47XHJcbn07XHJcblxyXG4vLyBGdW5jdGlvbiBzaWduYXR1cmUgZm9yIHZvaWNpbmdPbkVuZFJlc3BvbnNlLlxyXG5leHBvcnQgdHlwZSBWb2ljaW5nT25FbmRSZXNwb25zZSA9ICggdmFsdWVPblN0YXJ0OiBudW1iZXIsIHByb3ZpZGVkT3B0aW9ucz86IFZvaWNpbmdPbkVuZFJlc3BvbnNlT3B0aW9ucyApID0+IHZvaWQ7XHJcblxyXG5jb25zdCBBQ0NFU1NJQkxFX1ZBTFVFX0hBTkRMRVJfT1BUSU9OUzogc3RyaW5nW10gPSBbXHJcbiAgJ3N0YXJ0SW5wdXQnLFxyXG4gICdlbmRJbnB1dCcsXHJcbiAgJ29uSW5wdXQnLFxyXG4gICdjb25zdHJhaW5WYWx1ZScsXHJcbiAgJ2tleWJvYXJkU3RlcCcsXHJcbiAgJ3NoaWZ0S2V5Ym9hcmRTdGVwJyxcclxuICAncGFnZUtleWJvYXJkU3RlcCcsXHJcbiAgJ2FyaWFPcmllbnRhdGlvbicsXHJcbiAgJ3BhblRhcmdldE5vZGUnLFxyXG4gICdyb3VuZFRvU3RlcFNpemUnLFxyXG4gICdhMTF5TWFwUERPTVZhbHVlJyxcclxuICAnYTExeU1hcFZhbHVlJyxcclxuICAnYTExeVJlcGVhdEVxdWFsVmFsdWVUZXh0JyxcclxuICAnYTExeUNyZWF0ZUFyaWFWYWx1ZVRleHQnLFxyXG4gICdhMTF5Q3JlYXRlQ29udGV4dFJlc3BvbnNlQWxlcnQnLFxyXG4gICdjb250ZXh0UmVzcG9uc2VQZXJWYWx1ZUNoYW5nZURlbGF5JyxcclxuICAnY29udGV4dFJlc3BvbnNlTWF4RGVsYXknLFxyXG4gICdhMTF5RGVwZW5kZW5jaWVzJyxcclxuICAndm9pY2luZ09uRW5kUmVzcG9uc2VPcHRpb25zJ1xyXG5dO1xyXG5cclxudHlwZSBTZWxmT3B0aW9ucyA9IHtcclxuICB2YWx1ZVByb3BlcnR5OiBUUHJvcGVydHk8bnVtYmVyPjtcclxuICBlbmFibGVkUmFuZ2VQcm9wZXJ0eTogVFJlYWRPbmx5UHJvcGVydHk8UmFuZ2U+O1xyXG5cclxuICAvLyBjYWxsZWQgd2hlbiBpbnB1dCBiZWdpbnMgZnJvbSB1c2VyIGludGVyYWN0aW9uXHJcbiAgc3RhcnRJbnB1dD86ICggZXZlbnQ6IFNjZW5lcnlFdmVudCApID0+IHZvaWQ7XHJcblxyXG4gIC8vIGNhbGxlZCB3aGVuIGlucHV0IGVuZHMgZnJvbSB1c2VyIGludGVyYWN0aW9uXHJcbiAgZW5kSW5wdXQ/OiAoIGV2ZW50OiBTY2VuZXJ5RXZlbnQgfCBudWxsICkgPT4gdm9pZDtcclxuXHJcbiAgLy8gQ2FsbGVkIGFmdGVyIGFueSB1c2VyIGlucHV0IG9udG8gdGhpcyBjb21wb25lbnQuIFRoZSB2YWx1ZSB3aWxsIG1vc3QgbGlrZWx5IGNoYW5nZSBhcyBhIHJlc3VsdCBvZiB0aGlzIGlucHV0LFxyXG4gIC8vIGJ1dCBkb2Vzbid0IGhhdmUgdG8sIGxpa2Ugd2hlbiBhdCB0aGUgbWluL21heCBvZiB0aGUgdmFsdWUgcmFuZ2UuIFVzZWZ1bCBmb3IgaW5wdXQgZGV2aWNlcyB0aGF0IHN1cHBvcnQgXCJwcmVzc1xyXG4gIC8vIGFuZCBob2xkXCIgaW5wdXQuIEhvd2V2ZXIsIGJld2FyZSB0aGF0IHNvbWUgaW5wdXQgZGV2aWNlcywgc3VjaCBhcyBhIHN3aXRjaCwgaGF2ZSBubyBjb25jZXB0IG9mIFwicHJlc3MgYW5kIGhvbGRcIlxyXG4gIC8vIGFuZCB3aWxsIHRyaWdnZXIgb25jZSBwZXIgaW5wdXQuIEluIHRob3NlIGNhc2VzLCB0aGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIG9uY2UgcGVyIGlucHV0IChlYWNoIGlucHV0IHdpbGwgbG9va1xyXG4gIC8vIGxpa2Ugc3RhcnRJbnB1dC0+b25JbnB1dC0+ZW5kSW5wdXQgYWxsIGZyb20gb25lIGJyb3dzZXIgZXZlbnQpLlxyXG4gIG9uSW5wdXQ/OiAoIGV2ZW50OiBTY2VuZXJ5RXZlbnQgKSA9PiB2b2lkO1xyXG5cclxuICAvLyBDb25zdHJhaW5zIHRoZSB2YWx1ZSwgcmV0dXJuaW5nIGEgbmV3IHZhbHVlIGZvciB0aGUgdmFsdWVQcm9wZXJ0eSBpbnN0ZWFkLiBDYWxsZWQgYmVmb3JlIHRoZSB2YWx1ZVByb3BlcnR5IGlzIHNldC5cclxuICAvLyBTdWJ0eXBlcyBjYW4gdXNlIHRoaXMgZm9yIG90aGVyIGZvcm1zIG9mIGlucHV0IGFzIHdlbGwuXHJcbiAgLy8gRm9yIGtleWJvYXJkIGlucHV0LCB0aGlzIGlzIG9ubHkgY2FsbGVkIHdoZW4gdGhlIHNoaWZ0IGtleSBpcyBOT1QgZG93biBiZWNhdXNlIGl0IGlzIG9mdGVuIHRoZSBjYXNlIHRoYXRcclxuICAvLyBzaGlmdEtleWJvYXJkU3RlcCBpcyBhIHNtYWxsZXIgc3RlcCBzaXplIHRoZW4gd2hhdCBpcyBhbGxvd2VkIGJ5IGNvbnN0cmFpblZhbHVlLlxyXG4gIGNvbnN0cmFpblZhbHVlPzogKCB2YWx1ZTogbnVtYmVyICkgPT4gbnVtYmVyO1xyXG5cclxuICAvLyBkZWx0YSBmb3IgdGhlIHZhbHVlUHJvcGVydHkgZm9yIGVhY2ggcHJlc3Mgb2YgdGhlIGFycm93IGtleXNcclxuICBrZXlib2FyZFN0ZXA/OiBudW1iZXI7XHJcblxyXG4gIC8vIGRlbHRhIGZvciB0aGUgdmFsdWVQcm9wZXJ0eSBmb3IgZWFjaCBwcmVzcyBvZiB0aGUgYXJyb3cga2V5cyB3aGlsZSB0aGUgc2hpZnQgbW9kaWZpZXIgaXMgZG93blxyXG4gIHNoaWZ0S2V5Ym9hcmRTdGVwPzogbnVtYmVyO1xyXG5cclxuICAvLyBkZWx0YSBmb3IgdGhlIHZhbHVlUHJvcGVydHkgZm9yIGVhY2ggcHJlc3Mgb2YgXCJQYWdlIFVwXCIgYW5kIFwiUGFnZSBEb3duXCJcclxuICBwYWdlS2V5Ym9hcmRTdGVwPzogbnVtYmVyO1xyXG5cclxuICAvLyBJZiB0cnVlLCBhbHRlcm5hdGl2ZSBpbnB1dCB3aWxsIGJlICdyZXZlcnNlZCcgc28gdGhhdCBrZXlzIHRoYXQgbm9ybWFsbHkgaW5jcmVhc2UgdGhlIHZhbHVlIHdpbGwgZGVjcmVhc2UgaXQsXHJcbiAgLy8gYW5kIHZpY2UgdmVyc2EuIFRoaXMgaXMgdXNlZnVsIGZvciBjYXNlcyB3aGVyZSB0aGUgdmFsdWVQcm9wZXJ0eSBoYXMgYW4gaW52ZXJ0ZWQgYmVoYXZpb3IgZnJvbSB0eXBpY2FsIHNsaWRlclxyXG4gIC8vIGlucHV0LiBGb3IgZXhhbXBsZSwgYSBrbm9iIHRoYXQgbW92ZXMgdG8gdGhlIGxlZnQgdG8gaW5jcmVhc2UgdGhlIHZhbHVlUHJvcGVydHkuXHJcbiAgcmV2ZXJzZUFsdGVybmF0aXZlSW5wdXQ/OiBib29sZWFuO1xyXG5cclxuICAvLyBzcGVjaWZ5IG9yaWVudGF0aW9uLCByZWFkIGJ5IGFzc2lzdGl2ZSB0ZWNobm9sb2d5XHJcbiAgYXJpYU9yaWVudGF0aW9uPzogT3JpZW50YXRpb247XHJcblxyXG4gIC8vIFVwb24gYWNjZXNzaWJsZSBpbnB1dCwgd2Ugd2lsbCB0cnkgdG8ga2VlcCB0aGlzIE5vZGUgaW4gdmlldyBvZiB0aGUgYW5pbWF0ZWRQYW5ab29tU2luZ2xldG9uLlxyXG4gIC8vIElmIG51bGwsICd0aGlzJyBpcyB1c2VkICh0aGUgTm9kZSBtaXhpbmcgQWNjZXNzaWJsZVZhbHVlSGFuZGxlcilcclxuICBwYW5UYXJnZXROb2RlPzogbnVsbCB8IE5vZGU7XHJcblxyXG4gIC8vIFdoZW4gc2V0dGluZyB0aGUgUHJvcGVydHkgdmFsdWUgZnJvbSB0aGUgUERPTSBpbnB1dCwgdGhpcyBvcHRpb24gY29udHJvbHMgd2hldGhlciBvciBub3QgdG9cclxuICAvLyByb3VuZCB0aGUgdmFsdWUgdG8gYSBtdWx0aXBsZSBvZiB0aGUga2V5Ym9hcmRTdGVwLiBUaGlzIHdpbGwgb25seSByb3VuZCB0aGUgdmFsdWUgb24gbm9ybWFsIGtleSBwcmVzc2VzLFxyXG4gIC8vIHJvdW5kaW5nIHdpbGwgbm90IG9jY3VyIG9uIGxhcmdlIGp1bXBzIGxpa2UgcGFnZSB1cC9wYWdlIGRvd24vaG9tZS9lbmQuXHJcbiAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waGV0c2ltcy9ncmF2aXR5LWZvcmNlLWxhYi1iYXNpY3MvaXNzdWVzLzcyXHJcbiAgcm91bmRUb1N0ZXBTaXplPzogYm9vbGVhbjtcclxuXHJcbiAgLyoqXHJcbiAgICogTWFwIHRoZSB2YWx1ZVByb3BlcnR5IHZhbHVlIHRvIGFub3RoZXIgbnVtYmVyIHRoYXQgd2lsbCBiZSByZWFkIGJ5IGFzc2lzdGl2ZSBkZXZpY2VzIG9uXHJcbiAgICogdmFsdWVQcm9wZXJ0eSBjaGFuZ2VzIGZyb20gdGhlIFBET00gdmFsdWVzLiBUaGlzIGlzIHVzZWQgdG8gc2V0IHRoZSB2YWx1ZXMgZm9yIGFyaWEtdmFsdWV0ZXh0IGFuZCB0aGUgb25cclxuICAgKiBjaGFuZ2UgYWxlcnQsIGFzIHdlbGwgYXMgdGhlIGZvbGxvd2luZyBhdHRyaWJ1dGVzIG9uIHRoZSBQRE9NIGlucHV0OlxyXG4gICAqICAgIHZhbHVlXHJcbiAgICogICAgYXJpYS12YWx1ZW5vd1xyXG4gICAqICAgIG1pblxyXG4gICAqICAgIG1heFxyXG4gICAqICAgIHN0ZXBcclxuICAgKlxyXG4gICAqIEZvciB0aGlzIHJlYXNvbiwgaXQgaXMgaW1wb3J0YW50IHRoYXQgdGhlIG1hcHBlZCBcIm1pblwiIHdvdWxkIG5vdCBiZSBiaWdnZXIgdGhhbiB0aGUgbWFwcGVkIFwibWF4XCIgZnJvbSB0aGVcclxuICAgKiBlbmFibGVkUmFuZ2VQcm9wZXJ0eS5cclxuICAgKi9cclxuICBhMTF5TWFwUERPTVZhbHVlPzogKCB2YWx1ZTogbnVtYmVyICkgPT4gbnVtYmVyO1xyXG5cclxuICAvKipcclxuICAgKiBDYWxsZWQgYmVmb3JlIGNvbnN0cmFpbmluZyBhbmQgc2V0dGluZyB0aGUgUHJvcGVydHkuIFRoaXMgaXMgdXNlZnVsIGluIHJhcmUgY2FzZXMgd2hlcmUgdGhlIHZhbHVlIGJlaW5nIHNldFxyXG4gICAqIGJ5IEFjY2Vzc2libGVWYWx1ZUhhbmRsZXIgbWF5IGNoYW5nZSBiYXNlZCBvbiBvdXRzaWRlIGxvZ2ljLiBUaGlzIGlzIGZvciBtYXBwaW5nIHZhbHVlIGNoYW5nZXMgZnJvbSBpbnB1dCBsaXN0ZW5lcnNcclxuICAgKiBhc3NpZ25lZCBpbiB0aGlzIHR5cGUgKGtleWJvYXJkL2FsdC1pbnB1dCkgdG8gYSBuZXcgdmFsdWUgYmVmb3JlIHRoZSB2YWx1ZSBpcyBzZXQuXHJcbiAgICovXHJcbiAgYTExeU1hcFZhbHVlPzogKCBuZXdWYWx1ZTogbnVtYmVyLCBwcmV2aW91c1ZhbHVlOiBudW1iZXIgKSA9PiBudW1iZXI7XHJcblxyXG4gIC8qKlxyXG4gICAqIElmIHRydWUsIHRoZSBhcmlhLXZhbHVldGV4dCB3aWxsIGJlIHNwb2tlbiBldmVyeSB2YWx1ZSBjaGFuZ2UsIGV2ZW4gaWYgdGhlIGFyaWEtdmFsdWV0ZXh0IGRvZXNuJ3RcclxuICAgKiBhY3R1YWxseSBjaGFuZ2UuIEJ5IGRlZmF1bHQsIHNjcmVlbiByZWFkZXJzIHdvbid0IHNwZWFrIGFyaWEtdmFsdWV0ZXh0IGlmIGl0IHJlbWFpbnMgdGhlIHNhbWUgZm9yXHJcbiAgICogbXVsdGlwbGUgdmFsdWVzLlxyXG4gICAqL1xyXG4gIGExMXlSZXBlYXRFcXVhbFZhbHVlVGV4dD86IGJvb2xlYW47XHJcblxyXG4gIC8qKlxyXG4gICAqIGFyaWEtdmFsdWV0ZXh0IGNyZWF0aW9uIGZ1bmN0aW9uLCBjYWxsZWQgd2hlbiB0aGUgdmFsdWVQcm9wZXJ0eSBjaGFuZ2VzLlxyXG4gICAqIFRoaXMgc3RyaW5nIGlzIHJlYWQgYnkgQVQgZXZlcnkgdGltZSB0aGUgc2xpZGVyIHZhbHVlIGNoYW5nZXMuIFRoaXMgaXMgb2Z0ZW4gY2FsbGVkIHRoZSBcIm9iamVjdCByZXNwb25zZVwiXHJcbiAgICogZm9yIHRoaXMgaW50ZXJhY3Rpb24uXHJcbiAgICovXHJcbiAgYTExeUNyZWF0ZUFyaWFWYWx1ZVRleHQ/OiBDcmVhdGVUZXh0RnVuY3Rpb247XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBjb250ZW50IGZvciBhbiBhbGVydCB0aGF0IHdpbGwgYmUgc2VudCB0byB0aGUgdXR0ZXJhbmNlUXVldWUgd2hlbiB0aGUgdXNlciBmaW5pc2hlcyBpbnRlcmFjdGluZ1xyXG4gICAqIHdpdGggdGhlIGlucHV0LiBJcyBub3QgZ2VuZXJhdGVkIGV2ZXJ5IGNoYW5nZSwgYnV0IG9uIGV2ZXJ5IFwiZHJhZ1wiIGludGVyYWN0aW9uLCB0aGlzIGlzIGNhbGxlZCB3aXRoXHJcbiAgICogZW5kSW5wdXQuIFdpdGggYSBrZXlib2FyZCwgdGhpcyB3aWxsIGJlIGNhbGxlZCBldmVuIHdpdGggbm8gdmFsdWUgY2hhbmdlIChvbiB0aGUga2V5IHVwIGV2ZW50IGVuZGluZyB0aGVcclxuICAgKiBpbnRlcmFjdGlvbiksIE9uIGEgdG91Y2ggc3lzdGVtIGxpa2UgaU9TIHdpdGggVm9pY2UgT3ZlciBob3dldmVyLCBpbnB1dCBhbmQgY2hhbmdlIGV2ZW50cyB3aWxsIG9ubHkgZmlyZVxyXG4gICAqIHdoZW4gdGhlcmUgaXMgYSBQcm9wZXJ0eSB2YWx1ZSBjaGFuZ2UsIHNvIFwiZWRnZVwiIGFsZXJ0cyB3aWxsIG5vdCBmaXJlLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL2dyYXZpdHktZm9yY2UtbGFiLWJhc2ljcy9pc3N1ZXMvMTg1LlxyXG4gICAqIFRoaXMgYWxlcnQgaXMgb2Z0ZW4gY2FsbGVkIHRoZSBcImNvbnRleHQgcmVzcG9uc2VcIiBiZWNhdXNlIGl0IGlzIHRpbWVkIHRvIG9ubHkgYWxlcnQgYWZ0ZXIgYW4gaW50ZXJhY3Rpb25cclxuICAgKiBlbmQsIGluc3RlYWQgb2YgZWFjaCB0aW1lIHRoZSB2YWx1ZSBjaGFuZ2VzLlxyXG4gICAqXHJcbiAgICogSWYgZnVuY3Rpb24gcmV0dXJucyBudWxsLCB0aGVuIG5vIGFsZXJ0IHdpbGwgYmUgc2VudCB0byB1dHRlcmFuY2VRdWV1ZSBmb3IgYWxlcnRpbmcuXHJcbiAgICpcclxuICAgKiBUaGlzIGZ1bmN0aW9uIGNhbiBhbHNvIHN1cHBvcnQgYSBgcmVzZXRgIGZ1bmN0aW9uIG9uIGl0LCB0byBiZSBjYWxsZWQgd2hlbiB0aGUgQWNjZXNzaWJsZVZhbHVlSGFuZGxlciBpcyByZXNldFxyXG4gICAqL1xyXG4gIGExMXlDcmVhdGVDb250ZXh0UmVzcG9uc2VBbGVydD86IENyZWF0ZVRleHRGdW5jdGlvbiB8IG51bGw7XHJcblxyXG4gIC8vIFRoaXMgY29lZmZpY2llbnQgaXMgbXVsdGlwbGllZCBieSB0aGUgbnVtYmVyIG9mIHRpbWVzIHRoZSB2YWx1ZSBoYXMgYmVlbiBjaGFuZ2VkIHdpdGhvdXQgdGhlIGNvbnRleHQgcmVzcG9uc2VcclxuICAvLyBhbGVydGluZy4gVGhpcyBudW1iZXIgaXMgbWVhbnQgdG8gZ2l2ZSB0aGUgc2NyZWVuIHJlYWRlciBlbm91Z2ggY2hhbmNlIHRvIGZpbmlzaCByZWFkaW5nIHRoZSBhcmlhLXZhbHVldGV4dCxcclxuICAvLyB3aGljaCBjb3VsZCB0YWtlIGxvbmdlciB0aGUgbW9yZSB0aW1lIHRoZSB2YWx1ZSBjaGFuZ2VzLiBXZSB3YW50IHRvIGdpdmUgZW5vdWdoIHRpbWUgZm9yIFZPIHRvIHJlYWRcclxuICAvLyBhcmlhLXZhbHVldGV4dCBidXQgZG9uJ3Qgd2FudCB0byBoYXZlIHRvbyBtdWNoIHNpbGVuY2UgYmVmb3JlIHRoZSBhbGVydCBpcyBzcG9rZW4uXHJcbiAgY29udGV4dFJlc3BvbnNlUGVyVmFsdWVDaGFuZ2VEZWxheT86IG51bWJlcjtcclxuXHJcbiAgLy8gaW4gbXMsIFdoZW4gdGhlIHZhbHVlUHJvcGVydHkgY2hhbmdlcyByZXBlYXRlZGx5LCB3aGF0IGlzIHRoZSBtYXhpbXVtIHRpbWUgdG8gc2V0IHRoZVxyXG4gIC8vIGFsZXJ0U3RhYmxlRGVsYXkgZm9yIHRoZSBjb250ZXh0IHJlc3BvbnNlIHRvLiBUaGlzIHZhbHVlIHNob3VsZCBiZSBzbWFsbCBlbm91Z2ggdGhhdCBpdCBmZWVscyBsaWtlIHlvdSBhcmVcclxuICAvLyBhaXRpbmcgZm9yIHRoaXMgYWxlcnQgYWZ0ZXIgYW4gaW50ZXJhY3Rpb24uIFRoaXMgc2hvdWxkIGJlIGFsdGVyZWQgZGVwZW5kaW5nIG9uIGhvdyBxdWlja2x5IHlvdSBleHBlY3QgdGhlXHJcbiAgLy8gdmFsdWUgdG8gY2hhbmdlLiBXZSB3YW50IHRvIGdpdmUgZW5vdWdoIHRpbWUgZm9yIFZPIHRvIHJlYWQgYXJpYS12YWx1ZXRleHQgYnV0IGRvbid0IHdhbnQgdG8gaGF2ZSB0b28gbXVjaFxyXG4gIC8vIHNpbGVuY2UgYmVmb3JlIHRoZSBhbGVydCBpcyBzcG9rZW4uXHJcbiAgY29udGV4dFJlc3BvbnNlTWF4RGVsYXk/OiBudW1iZXI7XHJcblxyXG4gIC8qKlxyXG4gICAqIExpc3QgdGhlIGRlcGVuZGVuY2llcyB0aGlzIE5vZGUncyBQRE9NIGRlc2NyaXB0aW9ucyBoYXZlLiBUaGlzIHNob3VsZCBub3QgaW5jbHVkZSB0aGUgdmFsdWVQcm9wZXJ0eSwgYnV0XHJcbiAgICogc2hvdWxkIGxpc3QgYW55IFByb3BlcnRpZXMgd2hvc2UgY2hhbmdlIHNob3VsZCB0cmlnZ2VyIGEgZGVzY3JpcHRpb24gdXBkYXRlIGZvciB0aGlzIE5vZGUuXHJcbiAgICovXHJcbiAgYTExeURlcGVuZGVuY2llcz86IFRSZWFkT25seVByb3BlcnR5PEludGVudGlvbmFsQW55PltdO1xyXG5cclxuICAvLyBPbmx5IHByb3ZpZGUgdGFnTmFtZSB0byBBY2Nlc3NpYmxlVmFsdWVIYW5kbGVyIHRvIHJlbW92ZSBpdCBmcm9tIHRoZSBQRE9NLCBvdGhlcndpc2UsIEFjY2Vzc2libGVWYWx1ZUhhbmRsZXJcclxuICAvLyBzZXRzIGl0cyBvd24gdGFnTmFtZS5cclxuICB0YWdOYW1lPzogbnVsbDtcclxuXHJcbiAgLy8gQ3VzdG9taXphdGlvbnMgZm9yIHRoZSB2b2ljaW5nT25FbmRSZXNwb25zZSBmdW5jdGlvbiwgd2hpY2ggaXMgdXNlZCB0byB2b2ljZSBjb250ZW50IGF0IHRoZSBlbmRcclxuICAvLyBvZiBhbiBpbnRlcmFjdGlvbi5cclxuICB2b2ljaW5nT25FbmRSZXNwb25zZU9wdGlvbnM/OiBWb2ljaW5nT25FbmRSZXNwb25zZU9wdGlvbnM7XHJcbn07XHJcblxyXG50eXBlIFBhcmVudE9wdGlvbnMgPSBWb2ljaW5nT3B0aW9ucyAmIE5vZGVPcHRpb25zO1xyXG5cclxuZXhwb3J0IHR5cGUgQWNjZXNzaWJsZVZhbHVlSGFuZGxlck9wdGlvbnMgPSBTZWxmT3B0aW9ucyAmIFZvaWNpbmdPcHRpb25zOyAvLyBkbyBub3QgdXNlIFBhcmVudE9wdGlvbnMgaGVyZSFcclxuXHJcbmV4cG9ydCB0eXBlIFRBY2Nlc3NpYmxlVmFsdWVIYW5kbGVyID0ge1xyXG4gIHN0YXJ0SW5wdXQ6IFNjZW5lcnlMaXN0ZW5lckZ1bmN0aW9uO1xyXG4gIG9uSW5wdXQ6IFNjZW5lcnlMaXN0ZW5lckZ1bmN0aW9uO1xyXG4gIGVuZElucHV0OiAoIGV2ZW50OiBTY2VuZXJ5RXZlbnQgfCBudWxsICkgPT4gdm9pZDtcclxuICBjb25zdHJhaW5WYWx1ZTogKCAoIHZhbHVlOiBudW1iZXIgKSA9PiBudW1iZXIgKTtcclxuICBwYW5UYXJnZXROb2RlOiBOb2RlIHwgbnVsbDtcclxuICByb3VuZFRvU3RlcFNpemU6IGJvb2xlYW47XHJcbiAgYTExeU1hcFBET01WYWx1ZTogKCAoIHZhbHVlOiBudW1iZXIgKSA9PiBudW1iZXIgKTtcclxuICBhMTF5TWFwVmFsdWU6ICggKCBuZXdWYWx1ZTogbnVtYmVyLCBwcmV2aW91c1ZhbHVlOiBudW1iZXIgKSA9PiBudW1iZXIgKTtcclxuICBhMTF5UmVwZWF0RXF1YWxWYWx1ZVRleHQ6IGJvb2xlYW47XHJcbiAgYTExeUNyZWF0ZUFyaWFWYWx1ZVRleHQ6IENyZWF0ZVRleHRGdW5jdGlvbjtcclxuICBhMTF5Q3JlYXRlQ29udGV4dFJlc3BvbnNlQWxlcnQ6IENyZWF0ZVRleHRGdW5jdGlvbiB8IG51bGw7XHJcbiAgY29udGV4dFJlc3BvbnNlUGVyVmFsdWVDaGFuZ2VEZWxheTogbnVtYmVyO1xyXG4gIGNvbnRleHRSZXNwb25zZU1heERlbGF5OiBudW1iZXI7XHJcbiAgdm9pY2luZ09uRW5kUmVzcG9uc2VPcHRpb25zOiBWb2ljaW5nT25FbmRSZXNwb25zZU9wdGlvbnM7XHJcbiAgc2V0QTExeURlcGVuZGVuY2llcyggZGVwZW5kZW5jaWVzOiBUUmVhZE9ubHlQcm9wZXJ0eTxJbnRlbnRpb25hbEFueT5bXSApOiB2b2lkO1xyXG4gIGdldEExMXlEZXBlbmRlbmNpZXMoKTogVFJlYWRPbmx5UHJvcGVydHk8SW50ZW50aW9uYWxBbnk+W107XHJcbiAgYTExeURlcGVuZGVuY2llczogVFJlYWRPbmx5UHJvcGVydHk8SW50ZW50aW9uYWxBbnk+W107XHJcbiAgYWxlcnRDb250ZXh0UmVzcG9uc2UoKTogdm9pZDtcclxuICByZXNldCgpOiB2b2lkO1xyXG4gIGdldEFjY2Vzc2libGVWYWx1ZUhhbmRsZXJJbnB1dExpc3RlbmVyKCk6IFRJbnB1dExpc3RlbmVyO1xyXG4gIGhhbmRsZUtleURvd24oIGV2ZW50OiBTY2VuZXJ5RXZlbnQ8S2V5Ym9hcmRFdmVudD4gKTogdm9pZDtcclxuXHJcbiAgLy8gQG1peGluLXByb3RlY3RlZCAtIG1hZGUgcHVibGljIGZvciB1c2UgaW4gdGhlIG1peGluIG9ubHlcclxuICBoYW5kbGVLZXlVcCggZXZlbnQ6IFNjZW5lcnlFdmVudDxLZXlib2FyZEV2ZW50PiApOiB2b2lkO1xyXG4gIC8vIEBtaXhpbi1wcm90ZWN0ZWQgLSBtYWRlIHB1YmxpYyBmb3IgdXNlIGluIHRoZSBtaXhpbiBvbmx5XHJcbiAgaGFuZGxlQ2hhbmdlKCBldmVudDogU2NlbmVyeUV2ZW50ICk6IHZvaWQ7XHJcbiAgLy8gQG1peGluLXByb3RlY3RlZCAtIG1hZGUgcHVibGljIGZvciB1c2UgaW4gdGhlIG1peGluIG9ubHlcclxuICBoYW5kbGVJbnB1dCggZXZlbnQ6IFNjZW5lcnlFdmVudCApOiB2b2lkO1xyXG4gIC8vIEBtaXhpbi1wcm90ZWN0ZWQgLSBtYWRlIHB1YmxpYyBmb3IgdXNlIGluIHRoZSBtaXhpbiBvbmx5XHJcbiAgaGFuZGxlQmx1ciggZXZlbnQ6IFNjZW5lcnlFdmVudDxGb2N1c0V2ZW50PiApOiB2b2lkO1xyXG4gIHNldEtleWJvYXJkU3RlcCgga2V5Ym9hcmRTdGVwOiBudW1iZXIgKTogdm9pZDtcclxuICBrZXlib2FyZFN0ZXA6IG51bWJlcjtcclxuICBnZXRLZXlib2FyZFN0ZXAoKTogbnVtYmVyO1xyXG4gIHNldFNoaWZ0S2V5Ym9hcmRTdGVwKCBzaGlmdEtleWJvYXJkU3RlcDogbnVtYmVyICk6IHZvaWQ7XHJcbiAgc2hpZnRLZXlib2FyZFN0ZXA6IG51bWJlcjtcclxuICBnZXRTaGlmdEtleWJvYXJkU3RlcCgpOiBudW1iZXI7XHJcbiAgZ2V0U2hpZnRLZXlEb3duKCk6IGJvb2xlYW47XHJcbiAgZ2V0IHNoaWZ0S2V5RG93bigpOiBib29sZWFuO1xyXG4gIHNldFBhZ2VLZXlib2FyZFN0ZXAoIHBhZ2VLZXlib2FyZFN0ZXA6IG51bWJlciApOiB2b2lkO1xyXG4gIHBhZ2VLZXlib2FyZFN0ZXA6IG51bWJlcjtcclxuICBnZXRQYWdlS2V5Ym9hcmRTdGVwKCk6IG51bWJlcjtcclxuICBzZXRBcmlhT3JpZW50YXRpb24oIG9yaWVudGF0aW9uOiBPcmllbnRhdGlvbiApOiB2b2lkO1xyXG4gIGFyaWFPcmllbnRhdGlvbjogT3JpZW50YXRpb247XHJcbiAgZ2V0QXJpYU9yaWVudGF0aW9uKCk6IE9yaWVudGF0aW9uO1xyXG4gIHZvaWNpbmdPbkVuZFJlc3BvbnNlKCB2YWx1ZU9uU3RhcnQ6IG51bWJlciwgcHJvdmlkZWRPcHRpb25zPzogVm9pY2luZ09uRW5kUmVzcG9uc2VPcHRpb25zICk6IHZvaWQ7XHJcbn0gJiBUVm9pY2luZztcclxuXHJcblxyXG4vKipcclxuICogQHBhcmFtIFR5cGVcclxuICogQHBhcmFtIG9wdGlvbnNBcmdQb3NpdGlvbiAtIHplcm8taW5kZXhlZCBudW1iZXIgdGhhdCB0aGUgb3B0aW9ucyBhcmd1bWVudCBpcyBwcm92aWRlZCBhdFxyXG4gKi9cclxuY29uc3QgQWNjZXNzaWJsZVZhbHVlSGFuZGxlciA9IDxTdXBlclR5cGUgZXh0ZW5kcyBDb25zdHJ1Y3RvcjxOb2RlPj4oIFR5cGU6IFN1cGVyVHlwZSwgb3B0aW9uc0FyZ1Bvc2l0aW9uOiBudW1iZXIgKTogU3VwZXJUeXBlICYgQ29uc3RydWN0b3I8VEFjY2Vzc2libGVWYWx1ZUhhbmRsZXI+ID0+IHtcclxuICBjb25zdCBBY2Nlc3NpYmxlVmFsdWVIYW5kbGVyQ2xhc3MgPSBEZWxheWVkTXV0YXRlKCAnQWNjZXNzaWJsZVZhbHVlSGFuZGxlcicsIEFDQ0VTU0lCTEVfVkFMVUVfSEFORExFUl9PUFRJT05TLFxyXG4gICAgY2xhc3MgQWNjZXNzaWJsZVZhbHVlSGFuZGxlciBleHRlbmRzIFZvaWNpbmcoIFR5cGUgKSBpbXBsZW1lbnRzIFRBY2Nlc3NpYmxlVmFsdWVIYW5kbGVyIHtcclxuICAgICAgcHJpdmF0ZSByZWFkb25seSBfdmFsdWVQcm9wZXJ0eTogVFByb3BlcnR5PG51bWJlcj47XHJcbiAgICAgIHByaXZhdGUgX2VuYWJsZWRSYW5nZVByb3BlcnR5OiBUUmVhZE9ubHlQcm9wZXJ0eTxSYW5nZT47XHJcbiAgICAgIHByaXZhdGUgX3N0YXJ0SW5wdXQ6IFNjZW5lcnlMaXN0ZW5lckZ1bmN0aW9uID0gXy5ub29wO1xyXG4gICAgICBwcml2YXRlIF9vbklucHV0OiBTY2VuZXJ5TGlzdGVuZXJGdW5jdGlvbiA9IF8ubm9vcDtcclxuICAgICAgcHJpdmF0ZSBfZW5kSW5wdXQ6ICggKCBldmVudDogU2NlbmVyeUV2ZW50IHwgbnVsbCApID0+IHZvaWQgKSA9IF8ubm9vcDtcclxuICAgICAgcHJpdmF0ZSBfY29uc3RyYWluVmFsdWU6ICggKCB2YWx1ZTogbnVtYmVyICkgPT4gbnVtYmVyICkgPSBfLmlkZW50aXR5O1xyXG4gICAgICBwcml2YXRlIF9hMTF5TWFwVmFsdWU6ICggKCBuZXdWYWx1ZTogbnVtYmVyLCBwcmV2aW91c1ZhbHVlOiBudW1iZXIgKSA9PiBudW1iZXIgKSA9IF8uaWRlbnRpdHk7XHJcbiAgICAgIHByaXZhdGUgX3BhblRhcmdldE5vZGU6IE5vZGUgfCBudWxsID0gbnVsbDtcclxuICAgICAgcHJpdmF0ZSBfa2V5Ym9hcmRTdGVwITogbnVtYmVyOyAvLyB3aWxsIGJlIGluaXRpYWxpemVkIGJhc2VkIG9uIHRoZSBlbmFibGVkIHJhbmdlXHJcbiAgICAgIHByaXZhdGUgX3NoaWZ0S2V5Ym9hcmRTdGVwITogbnVtYmVyOyAvLyB3aWxsIGJlIGluaXRpYWxpemVkIGJhc2VkIG9uIHRoZSBlbmFibGVkIHJhbmdlXHJcbiAgICAgIHByaXZhdGUgX3BhZ2VLZXlib2FyZFN0ZXAhOiBudW1iZXI7IC8vIHdpbGwgYmUgaW5pdGlhbGl6ZWQgYmFzZWQgb24gdGhlIGVuYWJsZWQgcmFuZ2VcclxuICAgICAgcHJpdmF0ZSBfYXJpYU9yaWVudGF0aW9uOiBPcmllbnRhdGlvbiA9IE9yaWVudGF0aW9uLkhPUklaT05UQUw7XHJcbiAgICAgIHByaXZhdGUgX3NoaWZ0S2V5ID0gZmFsc2U7XHJcblxyXG4gICAgICBwcml2YXRlIF9hMTF5RGVwZW5kZW5jaWVzOiBUUmVhZE9ubHlQcm9wZXJ0eTxJbnRlbnRpb25hbEFueT5bXSA9IFtdO1xyXG5cclxuICAgICAgLy8gdHJhY2sgcHJldmlvdXMgdmFsdWVzIGZvciBjYWxsYmFja3Mgb3V0c2lkZSBvZiBQcm9wZXJ0eSBsaXN0ZW5lcnNcclxuICAgICAgcHJpdmF0ZSBfb2xkVmFsdWU6IG51bWJlciB8IG51bGwgPSBudWxsO1xyXG5cclxuICAgICAgcHJpdmF0ZSBfYTExeUNyZWF0ZUNvbnRleHRSZXNwb25zZUFsZXJ0OiBDcmVhdGVUZXh0RnVuY3Rpb24gfCBudWxsID0gbnVsbDtcclxuXHJcbiAgICAgIC8vIFRoZSBQcm9wZXJ0eSB2YWx1ZSB3aGVuIGFuIGludGVyYWN0aW9uIHN0YXJ0cywgc28gaXQgY2FuIGJlIHVzZWQgYXMgdGhlIFwib2xkXCIgdmFsdWVcclxuICAgICAgLy8gd2hlbiBnZW5lcmF0aW5nIGEgY29udGV4dCByZXNwb25zZSBhdCB0aGUgZW5kIG9mIGFuIGludGVyYWN0aW9uIHdpdGggYTExeUNyZWF0ZUNvbnRleHRSZXNwb25zZUFsZXJ0LlxyXG4gICAgICBwcml2YXRlIF92YWx1ZU9uU3RhcnQ6IG51bWJlcjtcclxuXHJcbiAgICAgIC8vIFRoZSB1dHRlcmFuY2Ugc2VudCB0byB0aGUgdXR0ZXJhbmNlUXVldWUgd2hlbiB0aGUgdmFsdWUgY2hhbmdlcywgYWxlcnQgY29udGVudCBnZW5lcmF0ZWQgYnlcclxuICAgICAgLy8gb3B0aW9uYWwgYTExeUNyZWF0ZUNvbnRleHRSZXNwb25zZUFsZXJ0LiBUaGUgYWxlcnRTdGFibGVEZWxheSBvbiB0aGlzIHV0dGVyYW5jZSB3aWxsIGluY3JlYXNlIGlmIHRoZSBpbnB1dFxyXG4gICAgICAvLyByZWNlaXZlcyBtYW55IGludGVyYWN0aW9ucyBiZWZvcmUgdGhlIHV0dGVyYW5jZSBjYW4gYmUgYW5ub3VuY2VkIHNvIHRoYXQgVm9pY2VPdmVyIGhhcyB0aW1lIHRvIHJlYWQgdGhlXHJcbiAgICAgIC8vIGFyaWEtdmFsdWV0ZXh0IChvYmplY3QgcmVzcG9uc2UpIGJlZm9yZSB0aGUgYWxlcnQgKGNvbnRleHQgcmVzcG9uc2UpLlxyXG4gICAgICBwcml2YXRlIHJlYWRvbmx5IF9jb250ZXh0UmVzcG9uc2VVdHRlcmFuY2U6IFV0dGVyYW5jZSA9IG5ldyBVdHRlcmFuY2UoKTtcclxuXHJcbiAgICAgIC8vIE51bWJlciBvZiB0aW1lcyB0aGUgaW5wdXQgaGFzIGNoYW5nZWQgaW4gdmFsdWUgYmVmb3JlIHRoZSB1dHRlcmFuY2UgbWFkZSB3YXMgYWJsZSB0byBiZSBzcG9rZW4sIG9ubHkgYXBwbGljYWJsZVxyXG4gICAgICAvLyBpZiB1c2luZyBhMTF5Q3JlYXRlQ29udGV4dFJlc3BvbnNlQWxlcnRcclxuICAgICAgcHJpdmF0ZSBfdGltZXNWYWx1ZVRleHRDaGFuZ2VkQmVmb3JlQWxlcnRpbmcgPSAwO1xyXG5cclxuICAgICAgLy8gaW4gbXMsIHNlZSBvcHRpb25zIGZvciBkb2N1bWVudGF0aW9uLlxyXG4gICAgICBwcml2YXRlIF9jb250ZXh0UmVzcG9uc2VQZXJWYWx1ZUNoYW5nZURlbGF5ID0gNzAwO1xyXG4gICAgICBwcml2YXRlIF9jb250ZXh0UmVzcG9uc2VNYXhEZWxheSA9IDE1MDA7XHJcblxyXG4gICAgICAvLyBXaGV0aGVyIGFuIGlucHV0IGV2ZW50IGhhcyBiZWVuIGhhbmRsZWQuIElmIGhhbmRsZWQsIHdlIHdpbGwgbm90IHJlc3BvbmQgdG8gdGhlXHJcbiAgICAgIC8vIGNoYW5nZSBldmVudC4gQW4gQVQgKHBhcnRpY3VsYXJseSBWb2ljZU92ZXIpIG1heSBzZW5kIGEgY2hhbmdlIGV2ZW50IChhbmQgbm90IGFuIGlucHV0IGV2ZW50KSB0byB0aGVcclxuICAgICAgLy8gYnJvd3NlciBpbiByZXNwb25zZSB0byBhIHVzZXIgZ2VzdHVyZS4gV2UgbmVlZCB0byBoYW5kbGUgdGhhdCBjaGFuZ2UgZXZlbnQsIHdpdGhvdXQgYWxzbyBoYW5kbGluZyB0aGVcclxuICAgICAgLy8gaW5wdXQgZXZlbnQgaW4gY2FzZSBhIGRldmljZSBzZW5kcyBib3RoIGV2ZW50cyB0byB0aGUgYnJvd3Nlci5cclxuICAgICAgcHJpdmF0ZSBfYTExeUlucHV0SGFuZGxlZCA9IGZhbHNlO1xyXG5cclxuICAgICAgLy8gU29tZSBicm93c2VycyB3aWxsIHJlY2VpdmUgYGlucHV0YCBldmVudHMgd2hlbiB0aGUgdXNlciB0YWJzIGF3YXkgZnJvbSB0aGUgc2xpZGVyIG9yXHJcbiAgICAgIC8vIG9uIHNvbWUga2V5IHByZXNzZXMgLSBpZiB3ZSByZWNlaXZlIGEga2V5ZG93biBldmVudCBmb3IgYSB0YWIga2V5LCBkbyBub3QgYWxsb3cgaW5wdXQgb3IgY2hhbmdlIGV2ZW50c1xyXG4gICAgICBwcml2YXRlIF9ibG9ja0lucHV0ID0gZmFsc2U7XHJcblxyXG4gICAgICAvLyBzZXR0aW5nIHRvIGVuYWJsZS9kaXNhYmxlIHJvdW5kaW5nIHRvIHRoZSBzdGVwIHNpemVcclxuICAgICAgcHJpdmF0ZSBfcm91bmRUb1N0ZXBTaXplID0gZmFsc2U7XHJcblxyXG4gICAgICAvLyBrZXkgaXMgdGhlIGV2ZW50LmNvZGUgZm9yIHRoZSByYW5nZSBrZXksIHZhbHVlIGlzIHdoZXRoZXIgaXQgaXMgZG93blxyXG4gICAgICBwcml2YXRlIF9yYW5nZUtleXNEb3duOiBSZWNvcmQ8c3RyaW5nLCBib29sZWFuPiA9IHt9O1xyXG4gICAgICBwcml2YXRlIF9hMTF5TWFwUERPTVZhbHVlOiAoICggdmFsdWU6IG51bWJlciApID0+IG51bWJlciApID0gXy5pZGVudGl0eTtcclxuICAgICAgcHJpdmF0ZSBfYTExeUNyZWF0ZUFyaWFWYWx1ZVRleHQ6IENyZWF0ZVRleHRGdW5jdGlvbiA9IHRvU3RyaW5nOyAvLyBieSBkZWZhdWx0IG1ha2Ugc3VyZSBpdCByZXR1cm5zIGEgc3RyaW5nXHJcbiAgICAgIHByaXZhdGUgX2RlcGVuZGVuY2llc011bHRpbGluazogVW5rbm93bk11bHRpbGluayB8IG51bGwgPSBudWxsO1xyXG4gICAgICBwcml2YXRlIF9hMTF5UmVwZWF0RXF1YWxWYWx1ZVRleHQgPSB0cnVlO1xyXG5cclxuICAgICAgLy8gV2hlbiBjb250ZXh0IHJlc3BvbnNlcyBhcmUgc3VwcG9ydGVkLCB0aGlzIGNvdW50ZXIgaXMgdXNlZCB0byBkZXRlcm1pbmUgYSBtdXRhYmxlIGRlbGF5IGJldHdlZW4gaGVhcmluZyB0aGVcclxuICAgICAgLy8gc2FtZSByZXNwb25zZS5cclxuICAgICAgcHJpdmF0ZSBfdGltZXNDaGFuZ2VkQmVmb3JlQWxlcnRpbmcgPSAwO1xyXG5cclxuICAgICAgLy8gT3B0aW9ucyBmb3IgdGhlIFZvaWNpbmcgcmVzcG9uc2UgYXQgdGhlIGVuZCBvZiBpbnRlcmFjdGlvbiB3aXRoIHRoaXMgY29tcG9uZW50LlxyXG4gICAgICBwcml2YXRlIF92b2ljaW5nT25FbmRSZXNwb25zZU9wdGlvbnM6IFZvaWNpbmdPbkVuZFJlc3BvbnNlT3B0aW9ucyA9IERFRkFVTFRfVk9JQ0lOR19PTl9FTkRfUkVTUE9OU0VfT1BUSU9OUztcclxuXHJcbiAgICAgIC8vIEF0IHRoZSBzdGFydCBvZiBpbnB1dCwgYSBsaXN0ZW5lciBpcyBhdHRhY2hlZCB0byB0aGUgUERPTVBvaW50ZXIgdG8gcHJldmVudCBsaXN0ZW5lcnMgY2xvc2VyIHRvIHRoZVxyXG4gICAgICAvLyBzY2VuZSBncmFwaCByb290IGZyb20gZmlyaW5nLiBBIHJlZmVyZW5jZSB0byB0aGUgcG9pbnRlciBpcyBzYXZlZCB0byBzdXBwb3J0IGludGVycnVwdCBiZWNhdXNlXHJcbiAgICAgIC8vIHRoZXJlIGlzIG5vIFNjZW5lcnlFdmVudC5cclxuICAgICAgcHJpdmF0ZSBfcGRvbVBvaW50ZXI6IFBET01Qb2ludGVyIHwgbnVsbCA9IG51bGw7XHJcbiAgICAgIHByaXZhdGUgX3Bkb21Qb2ludGVyTGlzdGVuZXI6IFRJbnB1dExpc3RlbmVyO1xyXG5cclxuICAgICAgcHJpdmF0ZSByZWFkb25seSBfYTExeVZhbHVlVGV4dFVwZGF0ZUxpc3RlbmVyOiAoKSA9PiB2b2lkO1xyXG4gICAgICBwcml2YXRlIHJlYWRvbmx5IF9kaXNwb3NlQWNjZXNzaWJsZVZhbHVlSGFuZGxlcjogKCkgPT4gdm9pZDtcclxuXHJcbiAgICAgIHB1YmxpYyBjb25zdHJ1Y3RvciggLi4uYXJnczogSW50ZW50aW9uYWxBbnlbXSApIHtcclxuXHJcbiAgICAgICAgY29uc3QgcHJvdmlkZWRPcHRpb25zID0gYXJnc1sgb3B0aW9uc0FyZ1Bvc2l0aW9uIF0gYXMgQWNjZXNzaWJsZVZhbHVlSGFuZGxlck9wdGlvbnM7XHJcblxyXG4gICAgICAgIGFzc2VydCAmJiBhc3NlcnQoIHByb3ZpZGVkT3B0aW9ucywgJ3Byb3ZpZGVkT3B0aW9ucyBoYXMgcmVxdWlyZWQgb3B0aW9ucycgKTtcclxuICAgICAgICBhc3NlcnQgJiYgYXNzZXJ0KCBwcm92aWRlZE9wdGlvbnMuZW5hYmxlZFJhbmdlUHJvcGVydHksICdlbmFibGVkUmFuZ2VQcm9wZXJ0eSBpcyBhIHJlcXVpcmVkIG9wdGlvbicgKTtcclxuICAgICAgICBhc3NlcnQgJiYgYXNzZXJ0KCBwcm92aWRlZE9wdGlvbnMudmFsdWVQcm9wZXJ0eSwgJ3ZhbHVlUHJvcGVydHkgaXMgYSByZXF1aXJlZCBvcHRpb24nICk7XHJcblxyXG4gICAgICAgIGFzc2VydCAmJiBwcm92aWRlZE9wdGlvbnMgJiYgYXNzZXJ0KCAhcHJvdmlkZWRPcHRpb25zLmhhc093blByb3BlcnR5KCAndGFnTmFtZScgKSB8fCBwcm92aWRlZE9wdGlvbnMudGFnTmFtZSA9PT0gbnVsbCxcclxuICAgICAgICAgICdBY2Nlc3NpYmxlVmFsdWVIYW5kbGVyIHNldHMgaXRzIG93biB0YWdOYW1lLiBPbmx5IHByb3ZpZGUgdGFnTmFtZSB0byBjbGVhciBhY2Nlc3NpYmxlIGNvbnRlbnQgZnJvbSB0aGUgUERPTScgKTtcclxuXHJcbiAgICAgICAgLy8gY2Fubm90IGJlIHNldCBieSBjbGllbnRcclxuICAgICAgICBhc3NlcnQgJiYgcHJvdmlkZWRPcHRpb25zICYmIGFzc2VydCggIXByb3ZpZGVkT3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSggJ2lucHV0VHlwZScgKSwgJ0FjY2Vzc2libGVWYWx1ZUhhbmRsZXIgc2V0cyBpdHMgb3duIGlucHV0VHlwZS4nICk7XHJcblxyXG4gICAgICAgIC8vIGlmIHJvdW5kaW5nIHRvIGtleWJvYXJkIHN0ZXAsIGtleWJvYXJkU3RlcCBtdXN0IGJlIGRlZmluZWQgc28gdmFsdWVzIGFyZW4ndCBza2lwcGVkIGFuZCB0aGUgc2xpZGVyXHJcbiAgICAgICAgLy8gZG9lc24ndCBnZXQgc3R1Y2sgd2hpbGUgcm91bmRpbmcgdG8gdGhlIG5lYXJlc3QgdmFsdWUsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vcGhldHNpbXMvc3VuL2lzc3Vlcy80MTBcclxuICAgICAgICBpZiAoIGFzc2VydCAmJiBwcm92aWRlZE9wdGlvbnMgJiYgcHJvdmlkZWRPcHRpb25zLnJvdW5kVG9TdGVwU2l6ZSApIHtcclxuICAgICAgICAgIGFzc2VydCggcHJvdmlkZWRPcHRpb25zLmtleWJvYXJkU3RlcCwgJ3JvdW5kaW5nIHRvIGtleWJvYXJkU3RlcCwgZGVmaW5lIGFwcHJvcHJpYXRlIGtleWJvYXJkU3RlcCB0byByb3VuZCB0bycgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIE92ZXJyaWRlIG9wdGlvbnNcclxuICAgICAgICBhcmdzWyBvcHRpb25zQXJnUG9zaXRpb24gXSA9IG9wdGlvbml6ZTxBY2Nlc3NpYmxlVmFsdWVIYW5kbGVyT3B0aW9ucywgU2VsZk9wdGlvbnMsIFBhcmVudE9wdGlvbnM+KCkoIHtcclxuICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLSBUT0RPOiB3ZSBzaG91bGQgYmUgYWJsZSB0byBoYXZlIHRoZSBwdWJsaWMgQVBJIGJlIGp1c3QgbnVsbCwgYW5kIGludGVybmFsbHkgc2V0IHRvIHN0cmluZywgTGltaXRhdGlvbiAoSVYpLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL3BoZXQtY29yZS9pc3N1ZXMvMTI4XHJcbiAgICAgICAgICB0YWdOYW1lOiBERUZBVUxUX1RBR19OQU1FLFxyXG5cclxuICAgICAgICAgIC8vIHBhcmVudCBvcHRpb25zIHRoYXQgd2UgbXVzdCBwcm92aWRlIGEgZGVmYXVsdCB0byB1c2VcclxuICAgICAgICAgIGlucHV0VHlwZTogJ3JhbmdlJ1xyXG4gICAgICAgIH0sIHByb3ZpZGVkT3B0aW9ucyApO1xyXG4gICAgICAgIHN1cGVyKCAuLi5hcmdzICk7XHJcblxyXG4gICAgICAgIC8vIG1lbWJlcnMgb2YgdGhlIE5vZGUgQVBJIHRoYXQgYXJlIHVzZWQgYnkgdGhpcyB0cmFpdFxyXG4gICAgICAgIGFzc2VydEhhc1Byb3BlcnRpZXMoIHRoaXMsIFsgJ2lucHV0VmFsdWUnLCAnc2V0UERPTUF0dHJpYnV0ZScgXSApO1xyXG5cclxuICAgICAgICBjb25zdCB2YWx1ZVByb3BlcnR5ID0gcHJvdmlkZWRPcHRpb25zLnZhbHVlUHJvcGVydHk7XHJcbiAgICAgICAgY29uc3QgZW5hYmxlZFJhbmdlUHJvcGVydHkgPSBwcm92aWRlZE9wdGlvbnMuZW5hYmxlZFJhbmdlUHJvcGVydHk7XHJcblxyXG4gICAgICAgIGlmICggcHJvdmlkZWRPcHRpb25zLnJldmVyc2VBbHRlcm5hdGl2ZUlucHV0ICkge1xyXG5cclxuICAgICAgICAgIC8vIEEgRHluYW1pY1Byb3BlcnR5IHdpbGwgaW52ZXJ0IHRoZSB2YWx1ZSBiZWZvcmUgc2V0dGluZyBpdCB0byB0aGUgYWN0dWFsIHZhbHVlUHJvcGVydHksIGFuZCBzaW1pbGFybHlcclxuICAgICAgICAgIC8vIGludmVydCBpZiB0aGUgdmFsdWVQcm9wZXJ0eSBjaGFuZ2VzIGV4dGVybmFsbHkuXHJcbiAgICAgICAgICB0aGlzLl92YWx1ZVByb3BlcnR5ID0gbmV3IER5bmFtaWNQcm9wZXJ0eSggbmV3IFByb3BlcnR5KCB2YWx1ZVByb3BlcnR5ICksIHtcclxuICAgICAgICAgICAgYmlkaXJlY3Rpb25hbDogdHJ1ZSxcclxuICAgICAgICAgICAgbWFwOiAoIHByb3BlcnR5VmFsdWU6IG51bWJlciApID0+IGVuYWJsZWRSYW5nZVByb3BlcnR5LnZhbHVlLm1heCAtIHByb3BlcnR5VmFsdWUsXHJcbiAgICAgICAgICAgIGludmVyc2VNYXA6ICggcHJvcGVydHlWYWx1ZTogbnVtYmVyICkgPT4gZW5hYmxlZFJhbmdlUHJvcGVydHkudmFsdWUubWF4IC0gcHJvcGVydHlWYWx1ZVxyXG4gICAgICAgICAgfSApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgIHRoaXMuX3ZhbHVlUHJvcGVydHkgPSB2YWx1ZVByb3BlcnR5O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5fZW5hYmxlZFJhbmdlUHJvcGVydHkgPSBlbmFibGVkUmFuZ2VQcm9wZXJ0eTtcclxuXHJcbiAgICAgICAgdGhpcy5fYTExeVZhbHVlVGV4dFVwZGF0ZUxpc3RlbmVyID0gdGhpcy5pbnZhbGlkYXRlQXJpYVZhbHVlVGV4dC5iaW5kKCB0aGlzICk7XHJcblxyXG4gICAgICAgIC8vIGluaXRpYWxpemVkIHdpdGggc2V0dGVycyB0aGF0IHZhbGlkYXRlXHJcbiAgICAgICAgdGhpcy5rZXlib2FyZFN0ZXAgPSAoIGVuYWJsZWRSYW5nZVByb3BlcnR5LmdldCgpLm1heCAtIGVuYWJsZWRSYW5nZVByb3BlcnR5LmdldCgpLm1pbiApIC8gMjA7XHJcbiAgICAgICAgdGhpcy5zaGlmdEtleWJvYXJkU3RlcCA9ICggZW5hYmxlZFJhbmdlUHJvcGVydHkuZ2V0KCkubWF4IC0gZW5hYmxlZFJhbmdlUHJvcGVydHkuZ2V0KCkubWluICkgLyAxMDA7XHJcbiAgICAgICAgdGhpcy5wYWdlS2V5Ym9hcmRTdGVwID0gKCBlbmFibGVkUmFuZ2VQcm9wZXJ0eS5nZXQoKS5tYXggLSBlbmFibGVkUmFuZ2VQcm9wZXJ0eS5nZXQoKS5taW4gKSAvIDEwO1xyXG5cclxuICAgICAgICB0aGlzLl92YWx1ZU9uU3RhcnQgPSB2YWx1ZVByb3BlcnR5LnZhbHVlO1xyXG5cclxuICAgICAgICAvLyBiZSBjYWxsZWQgbGFzdCwgYWZ0ZXIgb3B0aW9ucyBoYXZlIGJlZW4gc2V0IHRvIGB0aGlzYC5cclxuICAgICAgICB0aGlzLmludmFsaWRhdGVBMTF5RGVwZW5kZW5jaWVzKCk7XHJcblxyXG4gICAgICAgIC8vIGxpc3RlbmVycywgbXVzdCBiZSB1bmxpbmtlZCBpbiBkaXNwb3NlXHJcbiAgICAgICAgY29uc3QgZW5hYmxlZFJhbmdlT2JzZXJ2ZXIgPSB0aGlzLmludmFsaWRhdGVFbmFibGVkUmFuZ2UuYmluZCggdGhpcyApO1xyXG4gICAgICAgIHRoaXMuX2VuYWJsZWRSYW5nZVByb3BlcnR5LmxpbmsoIGVuYWJsZWRSYW5nZU9ic2VydmVyICk7XHJcblxyXG4gICAgICAgIC8vIHdoZW4gdGhlIHByb3BlcnR5IGNoYW5nZXMsIGJlIHN1cmUgdG8gdXBkYXRlIHRoZSBhY2Nlc3NpYmxlIGlucHV0IHZhbHVlIGFuZCBhcmlhLXZhbHVldGV4dCB3aGljaCBpcyByZWFkXHJcbiAgICAgICAgLy8gYnkgYXNzaXN0aXZlIHRlY2hub2xvZ3kgd2hlbiB0aGUgdmFsdWUgY2hhbmdlc1xyXG4gICAgICAgIGNvbnN0IHZhbHVlUHJvcGVydHlMaXN0ZW5lciA9IHRoaXMuaW52YWxpZGF0ZVZhbHVlUHJvcGVydHkuYmluZCggdGhpcyApO1xyXG4gICAgICAgIHRoaXMuX3ZhbHVlUHJvcGVydHkubGluayggdmFsdWVQcm9wZXJ0eUxpc3RlbmVyICk7XHJcblxyXG4gICAgICAgIC8vIEEgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGF0dGFjaGVkIHRvIHRoZSBwb2ludGVyIHRvIHByZXZlbnQgb3RoZXIgbGlzdGVuZXJzIGZyb20gYXR0YWNoaW5nLlxyXG4gICAgICAgIHRoaXMuX3Bkb21Qb2ludGVyTGlzdGVuZXIgPSB7XHJcbiAgICAgICAgICBpbnRlcnJ1cHQ6ICgpOiB2b2lkID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fb25JbnRlcmFjdGlvbkVuZCggbnVsbCApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHRoaXMuX2Rpc3Bvc2VBY2Nlc3NpYmxlVmFsdWVIYW5kbGVyID0gKCkgPT4ge1xyXG4gICAgICAgICAgdGhpcy5fZW5hYmxlZFJhbmdlUHJvcGVydHkudW5saW5rKCBlbmFibGVkUmFuZ2VPYnNlcnZlciApO1xyXG4gICAgICAgICAgdGhpcy5fdmFsdWVQcm9wZXJ0eS51bmxpbmsoIHZhbHVlUHJvcGVydHlMaXN0ZW5lciApO1xyXG5cclxuICAgICAgICAgIGlmICggcHJvdmlkZWRPcHRpb25zLnJldmVyc2VBbHRlcm5hdGl2ZUlucHV0ICkge1xyXG4gICAgICAgICAgICBhc3NlcnQgJiYgYXNzZXJ0KFxyXG4gICAgICAgICAgICAgIHRoaXMuX3ZhbHVlUHJvcGVydHkgaW5zdGFuY2VvZiBEeW5hbWljUHJvcGVydHksXHJcbiAgICAgICAgICAgICAgJ09ubHkgYSBEeW5hbWljUHJvcGVydHkgY2FuIGJlIGRpc3Bvc2VkLCBvdGhlcndpc2UgdGhpcyBpcyBkaXNwb3NpbmcgYSBQcm9wZXJ0eSB0aGF0IEFjY2Vzc2libGVWYWx1ZUhhbmRsZXIgZG9lcyBub3QgaGF2ZSBvd25lcnNoaXAgb3Zlci4nXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlUHJvcGVydHkuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHRoaXMuX2RlcGVuZGVuY2llc011bHRpbGluayAmJiB0aGlzLl9kZXBlbmRlbmNpZXNNdWx0aWxpbmsuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgdGhpcy5fcGFuVGFyZ2V0Tm9kZSA9IG51bGw7XHJcbiAgICAgICAgICB0aGlzLl9hMTF5RGVwZW5kZW5jaWVzID0gW107XHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcHVibGljIHNldCBzdGFydElucHV0KCB2YWx1ZTogU2NlbmVyeUxpc3RlbmVyRnVuY3Rpb24gKSB7XHJcbiAgICAgICAgdGhpcy5fc3RhcnRJbnB1dCA9IHZhbHVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBwdWJsaWMgZ2V0IHN0YXJ0SW5wdXQoKTogU2NlbmVyeUxpc3RlbmVyRnVuY3Rpb24ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zdGFydElucHV0O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBwdWJsaWMgc2V0IG9uSW5wdXQoIHZhbHVlOiBTY2VuZXJ5TGlzdGVuZXJGdW5jdGlvbiApIHtcclxuICAgICAgICB0aGlzLl9vbklucHV0ID0gdmFsdWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHB1YmxpYyBnZXQgb25JbnB1dCgpOiBTY2VuZXJ5TGlzdGVuZXJGdW5jdGlvbiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX29uSW5wdXQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHB1YmxpYyBzZXQgZW5kSW5wdXQoIHZhbHVlOiAoICggZXZlbnQ6IFNjZW5lcnlFdmVudCB8IG51bGwgKSA9PiB2b2lkICkgKSB7XHJcbiAgICAgICAgdGhpcy5fZW5kSW5wdXQgPSB2YWx1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcHVibGljIGdldCBlbmRJbnB1dCgpOiAoIGV2ZW50OiBTY2VuZXJ5RXZlbnQgfCBudWxsICkgPT4gdm9pZCB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuZElucHV0O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBwdWJsaWMgc2V0IGNvbnN0cmFpblZhbHVlKCB2YWx1ZTogKCAoIHZhbHVlOiBudW1iZXIgKSA9PiBudW1iZXIgKSApIHtcclxuICAgICAgICAvLyBOT1RFOiBOb3QgY3VycmVudGx5IHJlLWNvbnN0cmFpbmluZyB0aGUgdmFsdWUgb24gc2V0LCBzaW5jZSBob3BlZnVsbHkgb3RoZXIgdGhpbmdzIGFyZSBkb2luZyB0aGlzIGFjdGlvbi5cclxuICAgICAgICAvLyBJZiB0aGF0J3Mgbm90IGRvbmUsIHdlIHNob3VsZCBkbyBzb21ldGhpbmcgYWJvdXQgaXQgaGVyZS5cclxuICAgICAgICB0aGlzLl9jb25zdHJhaW5WYWx1ZSA9IHZhbHVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBwdWJsaWMgZ2V0IGNvbnN0cmFpblZhbHVlKCk6ICggKCB2YWx1ZTogbnVtYmVyICkgPT4gbnVtYmVyICkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jb25zdHJhaW5WYWx1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcHVibGljIHNldCBwYW5UYXJnZXROb2RlKCB2YWx1ZTogTm9kZSB8IG51bGwgKSB7XHJcbiAgICAgICAgdGhpcy5fcGFuVGFyZ2V0Tm9kZSA9IHZhbHVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBwdWJsaWMgZ2V0IHBhblRhcmdldE5vZGUoKTogTm9kZSB8IG51bGwge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9wYW5UYXJnZXROb2RlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBwdWJsaWMgc2V0IHJvdW5kVG9TdGVwU2l6ZSggdmFsdWU6IGJvb2xlYW4gKSB7XHJcbiAgICAgICAgdGhpcy5fcm91bmRUb1N0ZXBTaXplID0gdmFsdWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHB1YmxpYyBnZXQgcm91bmRUb1N0ZXBTaXplKCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9yb3VuZFRvU3RlcFNpemU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHB1YmxpYyBzZXQgYTExeU1hcFBET01WYWx1ZSggdmFsdWU6ICggKCB2YWx1ZTogbnVtYmVyICkgPT4gbnVtYmVyICkgKSB7XHJcbiAgICAgICAgdGhpcy5fYTExeU1hcFBET01WYWx1ZSA9IHZhbHVlO1xyXG5cclxuICAgICAgICB0aGlzLmludmFsaWRhdGVFbmFibGVkUmFuZ2UoIHRoaXMuX2VuYWJsZWRSYW5nZVByb3BlcnR5LnZhbHVlICk7XHJcbiAgICAgICAgdGhpcy5pbnZhbGlkYXRlVmFsdWVQcm9wZXJ0eSgpO1xyXG4gICAgICAgIHRoaXMuaW52YWxpZGF0ZUFyaWFWYWx1ZVRleHQoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcHVibGljIGdldCBhMTF5TWFwUERPTVZhbHVlKCk6ICggKCB2YWx1ZTogbnVtYmVyICkgPT4gbnVtYmVyICkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hMTF5TWFwUERPTVZhbHVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBwdWJsaWMgc2V0IGExMXlNYXBWYWx1ZSggdmFsdWU6ICggKCBuZXdWYWx1ZTogbnVtYmVyLCBwcmV2aW91c1ZhbHVlOiBudW1iZXIgKSA9PiBudW1iZXIgKSApIHtcclxuICAgICAgICB0aGlzLl9hMTF5TWFwVmFsdWUgPSB2YWx1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcHVibGljIGdldCBhMTF5TWFwVmFsdWUoKTogKCAoIG5ld1ZhbHVlOiBudW1iZXIsIHByZXZpb3VzVmFsdWU6IG51bWJlciApID0+IG51bWJlciApIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYTExeU1hcFZhbHVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBwdWJsaWMgc2V0IGExMXlSZXBlYXRFcXVhbFZhbHVlVGV4dCggdmFsdWU6IGJvb2xlYW4gKSB7XHJcbiAgICAgICAgdGhpcy5fYTExeVJlcGVhdEVxdWFsVmFsdWVUZXh0ID0gdmFsdWU7XHJcblxyXG4gICAgICAgIHRoaXMuaW52YWxpZGF0ZUFyaWFWYWx1ZVRleHQoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcHVibGljIGdldCBhMTF5UmVwZWF0RXF1YWxWYWx1ZVRleHQoKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ExMXlSZXBlYXRFcXVhbFZhbHVlVGV4dDtcclxuICAgICAgfVxyXG5cclxuICAgICAgcHVibGljIHNldCBhMTF5Q3JlYXRlQXJpYVZhbHVlVGV4dCggdmFsdWU6IENyZWF0ZVRleHRGdW5jdGlvbiApIHtcclxuICAgICAgICB0aGlzLl9hMTF5Q3JlYXRlQXJpYVZhbHVlVGV4dCA9IHZhbHVlO1xyXG5cclxuICAgICAgICB0aGlzLmludmFsaWRhdGVBcmlhVmFsdWVUZXh0KCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHB1YmxpYyBnZXQgYTExeUNyZWF0ZUFyaWFWYWx1ZVRleHQoKTogQ3JlYXRlVGV4dEZ1bmN0aW9uIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYTExeUNyZWF0ZUFyaWFWYWx1ZVRleHQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHB1YmxpYyBzZXQgYTExeUNyZWF0ZUNvbnRleHRSZXNwb25zZUFsZXJ0KCB2YWx1ZTogQ3JlYXRlVGV4dEZ1bmN0aW9uIHwgbnVsbCApIHtcclxuICAgICAgICB0aGlzLl9hMTF5Q3JlYXRlQ29udGV4dFJlc3BvbnNlQWxlcnQgPSB2YWx1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcHVibGljIGdldCBhMTF5Q3JlYXRlQ29udGV4dFJlc3BvbnNlQWxlcnQoKTogQ3JlYXRlVGV4dEZ1bmN0aW9uIHwgbnVsbCB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ExMXlDcmVhdGVDb250ZXh0UmVzcG9uc2VBbGVydDtcclxuICAgICAgfVxyXG5cclxuICAgICAgcHVibGljIHNldCBjb250ZXh0UmVzcG9uc2VQZXJWYWx1ZUNoYW5nZURlbGF5KCB2YWx1ZTogbnVtYmVyICkge1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHRSZXNwb25zZVBlclZhbHVlQ2hhbmdlRGVsYXkgPSB2YWx1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcHVibGljIGdldCBjb250ZXh0UmVzcG9uc2VQZXJWYWx1ZUNoYW5nZURlbGF5KCk6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRleHRSZXNwb25zZVBlclZhbHVlQ2hhbmdlRGVsYXk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHB1YmxpYyBzZXQgY29udGV4dFJlc3BvbnNlTWF4RGVsYXkoIHZhbHVlOiBudW1iZXIgKSB7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dFJlc3BvbnNlTWF4RGVsYXkgPSB2YWx1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcHVibGljIGdldCBjb250ZXh0UmVzcG9uc2VNYXhEZWxheSgpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jb250ZXh0UmVzcG9uc2VNYXhEZWxheTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcHVibGljIHNldCB2b2ljaW5nT25FbmRSZXNwb25zZU9wdGlvbnMoIHZhbHVlOiBWb2ljaW5nT25FbmRSZXNwb25zZU9wdGlvbnMgKSB7XHJcbiAgICAgICAgdGhpcy5fdm9pY2luZ09uRW5kUmVzcG9uc2VPcHRpb25zID0gdmFsdWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHB1YmxpYyBnZXQgdm9pY2luZ09uRW5kUmVzcG9uc2VPcHRpb25zKCk6IFZvaWNpbmdPbkVuZFJlc3BvbnNlT3B0aW9ucyB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZvaWNpbmdPbkVuZFJlc3BvbnNlT3B0aW9ucztcclxuICAgICAgfVxyXG5cclxuICAgICAgcHJpdmF0ZSBpbnZhbGlkYXRlQXJpYVZhbHVlVGV4dCgpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLl91cGRhdGVBcmlhVmFsdWVUZXh0KCB0aGlzLl9vbGRWYWx1ZSApO1xyXG5cclxuICAgICAgICB0aGlzLl9vbGRWYWx1ZSA9IHRoaXMuX3ZhbHVlUHJvcGVydHkudmFsdWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHByaXZhdGUgaW52YWxpZGF0ZUVuYWJsZWRSYW5nZSggZW5hYmxlZFJhbmdlOiBSYW5nZSApOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBtYXBwZWRNaW4gPSB0aGlzLl9nZXRNYXBwZWRWYWx1ZSggZW5hYmxlZFJhbmdlLm1pbiApO1xyXG4gICAgICAgIGNvbnN0IG1hcHBlZE1heCA9IHRoaXMuX2dldE1hcHBlZFZhbHVlKCBlbmFibGVkUmFuZ2UubWF4ICk7XHJcblxyXG4gICAgICAgIC8vIHBkb20gLSB1cGRhdGUgZW5hYmxlZCBzbGlkZXIgcmFuZ2UgZm9yIEFULCByZXF1aXJlZCBmb3Igc2NyZWVuIHJlYWRlciBldmVudHMgdG8gYmVoYXZlIGNvcnJlY3RseVxyXG4gICAgICAgIHRoaXMuc2V0UERPTUF0dHJpYnV0ZSggJ21pbicsIG1hcHBlZE1pbiApO1xyXG4gICAgICAgIHRoaXMuc2V0UERPTUF0dHJpYnV0ZSggJ21heCcsIG1hcHBlZE1heCApO1xyXG5cclxuICAgICAgICAvLyB1cGRhdGUgdGhlIHN0ZXAgYXR0cmlidXRlIHNsaWRlciBlbGVtZW50IC0gdGhpcyBhdHRyaWJ1dGUgaXMgb25seSBhZGRlZCBiZWNhdXNlIGl0IGlzIHJlcXVpcmVkIHRvXHJcbiAgICAgICAgLy8gcmVjZWl2ZSBhY2Nlc3NpYmlsaXR5IGV2ZW50cyBvbiBhbGwgYnJvd3NlcnMsIGFuZCBpcyB0b3RhbGx5IHNlcGFyYXRlIGZyb20gdGhlIHN0ZXAgdmFsdWVzIGFib3ZlIHRoYXRcclxuICAgICAgICAvLyB3aWxsIG1vZGlmeSB0aGUgdmFsdWVQcm9wZXJ0eS4gU2VlIGZ1bmN0aW9uIGZvciBtb3JlIGluZm9ybWF0aW9uLlxyXG4gICAgICAgIHRoaXMuX3VwZGF0ZVNpYmxpbmdTdGVwQXR0cmlidXRlKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHByaXZhdGUgaW52YWxpZGF0ZVZhbHVlUHJvcGVydHkoKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3QgbWFwcGVkVmFsdWUgPSB0aGlzLl9nZXRNYXBwZWRWYWx1ZSgpO1xyXG5cclxuICAgICAgICAvLyBzZXQgdGhlIGFyaWEtdmFsdWVub3cgYXR0cmlidXRlIGluIGNhc2UgdGhlIEFUIHJlcXVpcmVzIGl0IHRvIHJlYWQgdGhlIHZhbHVlIGNvcnJlY3RseSwgc29tZSBtYXlcclxuICAgICAgICAvLyBmYWxsIGJhY2sgb24gdGhpcyBmcm9tIGFyaWEtdmFsdWV0ZXh0IHNlZVxyXG4gICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FjY2Vzc2liaWxpdHkvQVJJQS9BUklBX1RlY2huaXF1ZXMvVXNpbmdfdGhlX2FyaWEtdmFsdWV0ZXh0X2F0dHJpYnV0ZSNQb3NzaWJsZV9lZmZlY3RzX29uX3VzZXJfYWdlbnRzX2FuZF9hc3Npc3RpdmVfdGVjaG5vbG9neVxyXG4gICAgICAgIHRoaXMuc2V0UERPTUF0dHJpYnV0ZSggJ2FyaWEtdmFsdWVub3cnLCBtYXBwZWRWYWx1ZSApO1xyXG5cclxuICAgICAgICAvLyB1cGRhdGUgdGhlIFBET00gaW5wdXQgdmFsdWUgb24gUHJvcGVydHkgY2hhbmdlXHJcbiAgICAgICAgdGhpcy5pbnB1dFZhbHVlID0gbWFwcGVkVmFsdWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHByaXZhdGUgaW52YWxpZGF0ZUExMXlEZXBlbmRlbmNpZXMoKTogdm9pZCB7XHJcblxyXG4gICAgICAgIC8vIGRpc3Bvc2UgdGhlIHByZXZpb3VzIG11bHRpbGluaywgdGhlcmUgaXMgb25seSBvbmUgc2V0IG9mIGRlcGVuZGVuY2llcywgdGhvdWdoIHRoZXkgY2FuIGJlIG92ZXJ3cml0dGVuLlxyXG4gICAgICAgIHRoaXMuX2RlcGVuZGVuY2llc011bHRpbGluayAmJiB0aGlzLl9kZXBlbmRlbmNpZXNNdWx0aWxpbmsuZGlzcG9zZSgpO1xyXG5cclxuICAgICAgICB0aGlzLl9kZXBlbmRlbmNpZXNNdWx0aWxpbmsgPSBNdWx0aWxpbmsubXVsdGlsaW5rQW55KCB0aGlzLl9hMTF5RGVwZW5kZW5jaWVzLmNvbmNhdCggWyB0aGlzLl92YWx1ZVByb3BlcnR5IF0gKSwgdGhpcy5fYTExeVZhbHVlVGV4dFVwZGF0ZUxpc3RlbmVyICk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBUaGVyZSBhcmUgc29tZSBmZWF0dXJlcyBvZiBBY2Nlc3NpYmxlVmFsdWVIYW5kbGVyIHRoYXQgc3VwcG9ydCB1cGRhdGluZyB3aGVuIG1vcmUgdGhhbiBqdXN0IHRoZSB2YWx1ZVByb3BlcnR5XHJcbiAgICAgICAqIGNoYW5nZXMuIFVzZSB0aGlzIG1ldGhvZCB0byBzZXQgdGhlIGRlcGVuZGVuY3kgUHJvcGVydGllcyBmb3IgdGhpcyB2YWx1ZSBoYW5kbGVyLiBUaGlzIHdpbGwgYmxvdyBhd2F5IHRoZVxyXG4gICAgICAgKiBwcmV2aW91cyBsaXN0IChsaWtlIE5vZGUuY2hpbGRyZW4pLlxyXG4gICAgICAgKi9cclxuICAgICAgcHVibGljIHNldEExMXlEZXBlbmRlbmNpZXMoIGRlcGVuZGVuY2llczogVFJlYWRPbmx5UHJvcGVydHk8SW50ZW50aW9uYWxBbnk+W10gKTogdm9pZCB7XHJcbiAgICAgICAgYXNzZXJ0ICYmIGFzc2VydCggIWRlcGVuZGVuY2llcy5pbmNsdWRlcyggdGhpcy5fdmFsdWVQcm9wZXJ0eSApLFxyXG4gICAgICAgICAgJ1RoZSB2YWx1ZSBQcm9wZXJ0eSBpcyBhbHJlYWR5IGEgZGVwZW5kZW5jeSwgYW5kIGRvZXMgbm90IG5lZWQgdG8gYmUgYWRkZWQgdG8gdGhpcyBsaXN0JyApO1xyXG5cclxuICAgICAgICB0aGlzLl9hMTF5RGVwZW5kZW5jaWVzID0gZGVwZW5kZW5jaWVzO1xyXG5cclxuICAgICAgICB0aGlzLmludmFsaWRhdGVBMTF5RGVwZW5kZW5jaWVzKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHB1YmxpYyBnZXRBMTF5RGVwZW5kZW5jaWVzKCk6IFRSZWFkT25seVByb3BlcnR5PEludGVudGlvbmFsQW55PltdIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYTExeURlcGVuZGVuY2llcztcclxuICAgICAgfVxyXG5cclxuICAgICAgcHVibGljIHNldCBhMTF5RGVwZW5kZW5jaWVzKCB2YWx1ZTogVFJlYWRPbmx5UHJvcGVydHk8SW50ZW50aW9uYWxBbnk+W10gKSB7XHJcbiAgICAgICAgdGhpcy5zZXRBMTF5RGVwZW5kZW5jaWVzKCB2YWx1ZSApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBwdWJsaWMgZ2V0IGExMXlEZXBlbmRlbmNpZXMoKTogVFJlYWRPbmx5UHJvcGVydHk8SW50ZW50aW9uYWxBbnk+W10ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldEExMXlEZXBlbmRlbmNpZXMoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcHJpdmF0ZSBfdXBkYXRlQXJpYVZhbHVlVGV4dCggb2xkUHJvcGVydHlWYWx1ZTogbnVtYmVyIHwgbnVsbCApOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBtYXBwZWRWYWx1ZSA9IHRoaXMuX2dldE1hcHBlZFZhbHVlKCk7XHJcblxyXG4gICAgICAgIC8vIGNyZWF0ZSB0aGUgZHluYW1pYyBhcmlhLXZhbHVldGV4dCBmcm9tIGExMXlDcmVhdGVBcmlhVmFsdWVUZXh0LlxyXG4gICAgICAgIGNvbnN0IG5ld0FyaWFWYWx1ZVRleHRWYWx1ZVR5cGUgPSB0aGlzLl9hMTF5Q3JlYXRlQXJpYVZhbHVlVGV4dCggbWFwcGVkVmFsdWUsIHRoaXMuX3ZhbHVlUHJvcGVydHkudmFsdWUsIG9sZFByb3BlcnR5VmFsdWUgKTtcclxuICAgICAgICBsZXQgbmV3QXJpYVZhbHVlVGV4dCA9IFBET01VdGlscy51bndyYXBTdHJpbmdQcm9wZXJ0eSggbmV3QXJpYVZhbHVlVGV4dFZhbHVlVHlwZSApITtcclxuXHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNpbXBsZS10eXBlLWNoZWNraW5nLWFzc2VydGlvbnNcclxuICAgICAgICBhc3NlcnQgJiYgYXNzZXJ0KCB0eXBlb2YgbmV3QXJpYVZhbHVlVGV4dCA9PT0gJ3N0cmluZycgKTtcclxuXHJcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgdGhlIG5ldyBhcmlhLXZhbHVldGV4dCBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgcHJldmlvdXMgb25lLCBzbyB0aGF0IGlmIHRoZXkgYXJlIHRoZSBzYW1lXHJcbiAgICAgICAgLy8gdGhlIHNjcmVlbiByZWFkZXIgd2lsbCBzdGlsbCByZWFkIHRoZSBuZXcgdGV4dCAtIGFkZGluZyBhIGhhaXJTcGFjZSByZWdpc3RlcnMgYXMgYSBuZXcgc3RyaW5nLCBidXQgdGhlXHJcbiAgICAgICAgLy8gc2NyZWVuIHJlYWRlciB3b24ndCByZWFkIHRoYXQgY2hhcmFjdGVyLlxyXG4gICAgICAgIGNvbnN0IGhhaXJTcGFjZSA9ICdcXHUyMDBBJztcclxuICAgICAgICBpZiAoIHRoaXMuX2ExMXlSZXBlYXRFcXVhbFZhbHVlVGV4dCAmJiB0aGlzLmFyaWFWYWx1ZVRleHQgJiYgbmV3QXJpYVZhbHVlVGV4dCA9PT0gdGhpcy5hcmlhVmFsdWVUZXh0LnJlcGxhY2UoIG5ldyBSZWdFeHAoIGhhaXJTcGFjZSwgJ2cnICksICcnICkgKSB7XHJcbiAgICAgICAgICBuZXdBcmlhVmFsdWVUZXh0ID0gdGhpcy5hcmlhVmFsdWVUZXh0ICsgaGFpclNwYWNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5hcmlhVmFsdWVUZXh0ID0gbmV3QXJpYVZhbHVlVGV4dDtcclxuICAgICAgfVxyXG5cclxuICAgICAgLyoqXHJcbiAgICAgICAqIElmIGdlbmVyYXRpbmcgYW4gYWxlcnQgd2hlbiB0aGUgdXNlciBjaGFuZ2VzIHRoZSBzbGlkZXIgdmFsdWUsIGNyZWF0ZSB0aGUgYWxlcnQgY29udGVudCBhbmQgc2VuZCBpdFxyXG4gICAgICAgKiB0byB0aGUgdXR0ZXJhbmNlUXVldWUuIEZvciBWb2ljZU92ZXIsIGl0IGlzIGltcG9ydGFudCB0aGF0IGlmIHRoZSB2YWx1ZSBpcyBjaGFuZ2VkIG11bHRpcGxlIHRpbWVzIGJlZm9yZVxyXG4gICAgICAgKiB0aGUgYWxlcnQgY2FuIGJlIHNwb2tlbiwgd2UgcHJvdmlkZSBtb3JlIHRpbWUgZm9yIHRoZSBBVCB0byBmaW5pc2ggc3BlYWtpbmcgYXJpYS12YWx1ZXRleHQuIE90aGVyd2lzZSwgdGhlXHJcbiAgICAgICAqIGFsZXJ0IG1heSBiZSBsb3N0LiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL2dyYXZpdHktZm9yY2UtbGFiLWJhc2ljcy9pc3N1ZXMvMTQ2LlxyXG4gICAgICAgKi9cclxuICAgICAgcHVibGljIGFsZXJ0Q29udGV4dFJlc3BvbnNlKCk6IHZvaWQge1xyXG5cclxuICAgICAgICAvLyBBbGVydGluZyB3aWxsIG9jY3VyIHRvIGVhY2ggY29ubmVjdGVkIGRpc3BsYXkncyBVdHRlcmFuY2VRdWV1ZSwgYnV0IHdlIHNob3VsZCBvbmx5IGluY3JlbWVudCBkZWxheSBvbmNlIHBlclxyXG4gICAgICAgIC8vIHRpbWUgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQuXHJcbiAgICAgICAgbGV0IHRpbWVzQ2hhbmdlZEJlZm9yZUFsZXJ0aW5nSW5jcmVtZW50ZWQgPSBmYWxzZTtcclxuICAgICAgICBpZiAoIHRoaXMuX2ExMXlDcmVhdGVDb250ZXh0UmVzcG9uc2VBbGVydCApIHtcclxuXHJcbiAgICAgICAgICBjb25zdCBtYXBwZWRWYWx1ZSA9IHRoaXMuX2dldE1hcHBlZFZhbHVlKCk7XHJcbiAgICAgICAgICBjb25zdCBlbmRJbnRlcmFjdGlvbkFsZXJ0ID0gdGhpcy5fYTExeUNyZWF0ZUNvbnRleHRSZXNwb25zZUFsZXJ0KCBtYXBwZWRWYWx1ZSwgdGhpcy5fdmFsdWVQcm9wZXJ0eS52YWx1ZSwgdGhpcy5fdmFsdWVPblN0YXJ0ICk7XHJcblxyXG4gICAgICAgICAgLy8gb25seSBpZiBpdCByZXR1cm5lZCBhbiBhbGVydFxyXG4gICAgICAgICAgaWYgKCBlbmRJbnRlcmFjdGlvbkFsZXJ0ICkge1xyXG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0UmVzcG9uc2VVdHRlcmFuY2UuYWxlcnQgPSBlbmRJbnRlcmFjdGlvbkFsZXJ0O1xyXG4gICAgICAgICAgICB0aGlzLmZvckVhY2hVdHRlcmFuY2VRdWV1ZSggKCB1dHRlcmFuY2VRdWV1ZTogVXR0ZXJhbmNlUXVldWUgKSA9PiB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIE9ubHkgaW5jcmVtZW50IGEgc2luZ2xlIHRpbWUsIHRoaXMgaGFzIHRoZSBjb25zdHJhaW50IHRoYXQgaWYgZGlmZmVyZW50IHV0dGVyYW5jZVF1ZXVlcyBtb3ZlIHRoaXNcclxuICAgICAgICAgICAgICAvLyBhbGVydCB0aHJvdWdoIGF0IGEgZGlmZmVyZW50IHRpbWUsIHRoZSBkZWxheSBjb3VsZCBiZSBpbmNvbnNpc3RlbnQsIGJ1dCBpbiBnZW5lcmFsIGl0IHNob3VsZCB3b3JrIHdlbGwuXHJcbiAgICAgICAgICAgICAgaWYgKCB0aW1lc0NoYW5nZWRCZWZvcmVBbGVydGluZ0luY3JlbWVudGVkICkge1xyXG4gICAgICAgICAgICAgICAgLy8gdXNlIHRoZSBjdXJyZW50IHZhbHVlIGZvciB0aGlzLl90aW1lc0NoYW5nZWRCZWZvcmVBbGVydGluZ1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBlbHNlIGlmICggdXR0ZXJhbmNlUXVldWUuaGFzVXR0ZXJhbmNlKCB0aGlzLl9jb250ZXh0UmVzcG9uc2VVdHRlcmFuY2UgKSApIHtcclxuICAgICAgICAgICAgICAgIHRpbWVzQ2hhbmdlZEJlZm9yZUFsZXJ0aW5nSW5jcmVtZW50ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdGltZXNDaGFuZ2VkQmVmb3JlQWxlcnRpbmcrKztcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90aW1lc0NoYW5nZWRCZWZvcmVBbGVydGluZyA9IDE7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAvLyBBZGp1c3QgdGhlIGRlbGF5IG9mIHRoZSB1dHRlcmFuY2UgYmFzZWQgb24gbnVtYmVyIG9mIHRpbWVzIGl0IGhhcyBiZWVuIHJlLWFkZGVkIHRvIHRoZSBxdWV1ZS4gRWFjaFxyXG4gICAgICAgICAgICAgIC8vIHRpbWUgdGhlIGFyaWEtdmFsdWV0ZXh0IGNoYW5nZXMsIHRoaXMgbWV0aG9kIGlzIGNhbGxlZCwgd2Ugd2FudCB0byBtYWtlIHN1cmUgdG8gZ2l2ZSBlbm91Z2ggdGltZSBmb3IgdGhlXHJcbiAgICAgICAgICAgICAgLy8gYXJpYS12YWx1ZXRleHQgdG8gZnVsbHkgY29tcGxldGUgYmVmb3JlIGFsZXJ0aW5nIHRoaXMgY29udGV4dCByZXNwb25zZS5cclxuICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0UmVzcG9uc2VVdHRlcmFuY2UuYWxlcnRTdGFibGVEZWxheSA9IE1hdGgubWluKCB0aGlzLl9jb250ZXh0UmVzcG9uc2VNYXhEZWxheSxcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RpbWVzQ2hhbmdlZEJlZm9yZUFsZXJ0aW5nICogdGhpcy5fY29udGV4dFJlc3BvbnNlUGVyVmFsdWVDaGFuZ2VEZWxheSApO1xyXG5cclxuICAgICAgICAgICAgICB1dHRlcmFuY2VRdWV1ZS5hZGRUb0JhY2soIHRoaXMuX2NvbnRleHRSZXNwb25zZVV0dGVyYW5jZSApO1xyXG4gICAgICAgICAgICB9ICk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogU2hvdWxkIGJlIGNhbGxlZCBhZnRlciB0aGUgbW9kZWwgZGVwZW5kZW5jaWVzIGhhdmUgYmVlbiByZXNldFxyXG4gICAgICAgKi9cclxuICAgICAgcHVibGljIHJlc2V0KCk6IHZvaWQge1xyXG5cclxuICAgICAgICAvLyByZXNldCB0aGUgYXJpYS12YWx1ZXRleHQgY3JlYXRvciBpZiBpdCBzdXBwb3J0cyB0aGF0XHJcbiAgICAgICAgdGhpcy5fYTExeUNyZWF0ZUFyaWFWYWx1ZVRleHQucmVzZXQgJiYgdGhpcy5fYTExeUNyZWF0ZUFyaWFWYWx1ZVRleHQucmVzZXQoKTtcclxuICAgICAgICB0aGlzLl9hMTF5Q3JlYXRlQ29udGV4dFJlc3BvbnNlQWxlcnQgJiYgdGhpcy5fYTExeUNyZWF0ZUNvbnRleHRSZXNwb25zZUFsZXJ0LnJlc2V0ICYmIHRoaXMuX2ExMXlDcmVhdGVDb250ZXh0UmVzcG9uc2VBbGVydC5yZXNldCgpO1xyXG5cclxuICAgICAgICB0aGlzLl90aW1lc0NoYW5nZWRCZWZvcmVBbGVydGluZyA9IDA7XHJcbiAgICAgICAgLy8gb24gcmVzZXQsIG1ha2Ugc3VyZSB0aGF0IHRoZSBQRE9NIGRlc2NyaXB0aW9ucyBhcmUgY29tcGxldGVseSB1cCB0byBkYXRlLlxyXG4gICAgICAgIHRoaXMuX3VwZGF0ZUFyaWFWYWx1ZVRleHQoIG51bGwgKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLyoqXHJcbiAgICAgICAqIGdldCB0aGUgZm9ybWF0dGVkIHZhbHVlIGJhc2VkIG9uIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBQcm9wZXJ0eS5cclxuICAgICAgICogQHBhcmFtIFt2YWx1ZV0gLSBpZiBub3QgcHJvdmlkZWQsIHdpbGwgdXNlIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSB2YWx1ZVByb3BlcnR5XHJcbiAgICAgICAqL1xyXG4gICAgICBwcml2YXRlIF9nZXRNYXBwZWRWYWx1ZSggdmFsdWU6IG51bWJlciA9IHRoaXMuX3ZhbHVlUHJvcGVydHkudmFsdWUgKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYTExeU1hcFBET01WYWx1ZSggdmFsdWUgKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLyoqXHJcbiAgICAgICAqIFJldHVybiB0aGUgaW5wdXQgbGlzdGVuZXIgdGhhdCBjb3VsZCBiZSBhdHRhY2hlZCB0byBtaXhlZCBpbiB0eXBlcyBvZiBBY2Nlc3NpYmxlVmFsdWVIYW5kbGVyIHRvIHN1cHBvcnRcclxuICAgICAgICogaW50ZXJhY3Rpb24uXHJcbiAgICAgICAqL1xyXG4gICAgICBwdWJsaWMgZ2V0QWNjZXNzaWJsZVZhbHVlSGFuZGxlcklucHV0TGlzdGVuZXIoKTogVElucHV0TGlzdGVuZXIge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBrZXlkb3duOiB0aGlzLmhhbmRsZUtleURvd24uYmluZCggdGhpcyApLFxyXG4gICAgICAgICAga2V5dXA6IHRoaXMuaGFuZGxlS2V5VXAuYmluZCggdGhpcyApLFxyXG4gICAgICAgICAgaW5wdXQ6IHRoaXMuaGFuZGxlSW5wdXQuYmluZCggdGhpcyApLFxyXG4gICAgICAgICAgY2hhbmdlOiB0aGlzLmhhbmRsZUNoYW5nZS5iaW5kKCB0aGlzICksXHJcbiAgICAgICAgICBibHVyOiB0aGlzLmhhbmRsZUJsdXIuYmluZCggdGhpcyApXHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLyoqXHJcbiAgICAgICAqIEhhbmRsZSBhIGtleWRvd24gZXZlbnQgc28gdGhhdCB0aGUgdmFsdWUgaGFuZGxlciBiZWhhdmVzIGxpa2UgYSB0cmFkaXRpb25hbCBpbnB1dCB0aGF0IG1vZGlmaWVzXHJcbiAgICAgICAqIGEgbnVtYmVyLiBXZSBleHBlY3QgdGhlIGZvbGxvd2luZzpcclxuICAgICAgICogICAtIFVwIEFycm93L1JpZ2h0IEFycm93IGluY3JlbWVudHMgdmFsdWUgYnkga2V5Ym9hcmRTdGVwXHJcbiAgICAgICAqICAgLSBEb3duIEFycm93L0xlZnQgQXJyb3cgZGVjcmVtZW50cyB2YWx1ZSBieSBzdGVwIHNpemVcclxuICAgICAgICogICAtIFBhZ2UgdXAvUGFnZSBkb3duIHdpbGwgaW5jcmVtZW50L2RlY3JlbWVudCB2YWx1ZSBwYWdlS2V5Ym9hcmRTdGVwXHJcbiAgICAgICAqICAgLSBIb21lL0VuZCB3aWxsIHNldCB2YWx1ZSB0byBtaW4vbWF4IHZhbHVlIGZvciB0aGUgcmFuZ2VcclxuICAgICAgICogICAtIFByZXNzaW5nIHNoaWZ0IHdpdGggYW4gYXJyb3cga2V5IHdpbGwgaW5jcmVtZW50L2RlY3JlbWVudCB2YWx1ZSBieSBzaGlmdEtleWJvYXJkU3RlcFxyXG4gICAgICAgKlxyXG4gICAgICAgKiBBZGQgdGhpcyBhcyBhbiBpbnB1dCBsaXN0ZW5lciB0byB0aGUgYGtleWRvd25gIGV2ZW50IHRvIHRoZSBOb2RlIG1peGluZyBpbiBBY2Nlc3NpYmxlVmFsdWVIYW5kbGVyLlxyXG4gICAgICAgKi9cclxuICAgICAgcHVibGljIGhhbmRsZUtleURvd24oIGV2ZW50OiBTY2VuZXJ5RXZlbnQ8S2V5Ym9hcmRFdmVudD4gKTogdm9pZCB7XHJcblxyXG4gICAgICAgIGNvbnN0IGRvbUV2ZW50ID0gZXZlbnQuZG9tRXZlbnQhO1xyXG5cclxuICAgICAgICBjb25zdCBrZXkgPSBLZXlib2FyZFV0aWxzLmdldEV2ZW50Q29kZSggZG9tRXZlbnQgKTtcclxuXHJcbiAgICAgICAgaWYgKCAha2V5ICkge1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5fc2hpZnRLZXkgPSBkb21FdmVudC5zaGlmdEtleTtcclxuXHJcblxyXG4gICAgICAgIC8vIGlmIHdlIHJlY2VpdmUgYSAndGFiJyBrZXlkb3duIGV2ZW50LCBkbyBub3QgYWxsb3cgdGhlIGJyb3dzZXIgdG8gcmVhY3QgdG8gdGhpcyBsaWtlIGEgc3VibWlzc2lvbiBhbmRcclxuICAgICAgICAvLyBwcmV2ZW50IHJlc3BvbmRpbmcgdG8gdGhlIGBpbnB1dGAgZXZlbnRcclxuICAgICAgICBpZiAoIEtleWJvYXJkVXRpbHMuaXNLZXlFdmVudCggZG9tRXZlbnQsIEtleWJvYXJkVXRpbHMuS0VZX1RBQiApICkge1xyXG4gICAgICAgICAgdGhpcy5fYmxvY2tJbnB1dCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIHRoaXMuZW5hYmxlZFByb3BlcnR5LmdldCgpICkge1xyXG5cclxuICAgICAgICAgIC8vIFByZXZlbnQgZGVmYXVsdCBzbyBicm93c2VyIGRvZXNuJ3QgY2hhbmdlIGlucHV0IHZhbHVlIGF1dG9tYXRpY2FsbHlcclxuICAgICAgICAgIGlmICggS2V5Ym9hcmRVdGlscy5pc1JhbmdlS2V5KCBkb21FdmVudCApICkge1xyXG5cclxuICAgICAgICAgICAgLy8gVGhpcyBzaG91bGQgcHJldmVudCBhbnkgXCJjaGFuZ2VcIiBhbmQgXCJpbnB1dFwiIGV2ZW50cyBzbyB3ZSBkb24ndCBjaGFuZ2UgdGhlIHZhbHVlIHR3aWNlLCBidXQgaXQgYWxzb1xyXG4gICAgICAgICAgICAvLyBwcmV2ZW50cyBhIFZvaWNlT3ZlciBpc3N1ZSB3aGVyZSBwcmVzc2luZyBhcnJvdyBrZXlzIGJvdGggY2hhbmdlcyB0aGUgc2xpZGVyIHZhbHVlIEFORCBtb3ZlcyB0aGVcclxuICAgICAgICAgICAgLy8gdmlydHVhbCBjdXJzb3IuIFRoaXMgbmVlZHMgdG8gYmUgZG9uZSBldmVyeSByYW5nZSBrZXkgZXZlbnQgc28gdGhhdCB3ZSBkb24ndCBjaGFuZ2UgdGhlIHZhbHVlIHdpdGhcclxuICAgICAgICAgICAgLy8gYW4gJ2lucHV0JyBvciAnY2hhbmdlJyBldmVudCwgZXZlbiB3aGVuIHRoZSBtZXRhIGtleSBpcyBkb3duLlxyXG4gICAgICAgICAgICBkb21FdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgICAgICAgICAgLy8gT24gTWFjLCB3ZSBkb24ndCBnZXQgYSBrZXl1cCBldmVudCB3aGVuIHRoZSBtZXRhIGtleSBpcyBkb3duIHNvIGRvbid0IGNoYW5nZSB0aGUgdmFsdWUgb3IgZG9cclxuICAgICAgICAgICAgLy8gYW55dGhpbmcgdGhhdCBhc3N1bWVzIHdlIHdpbGwgZ2V0IGEgY29ycmVzcG9uZGluZyBrZXl1cCBldmVudCwgc2VlXHJcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzExODE4NjM3L3doeS1kb2VzLWphdmFzY3JpcHQtZHJvcC1rZXl1cC1ldmVudHMtd2hlbi10aGUtbWV0YWtleS1pcy1wcmVzc2VkLW9uLW1hYy1icm93c2VyXHJcbiAgICAgICAgICAgIGlmICggIWRvbUV2ZW50Lm1ldGFLZXkgKSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIHNpZ25pZnkgdGhhdCB0aGlzIGxpc3RlbmVyIGlzIHJlc2VydmVkIGZvciBkcmFnZ2luZyBzbyB0aGF0IG90aGVyIGxpc3RlbmVycyBjYW4gY2hhbmdlXHJcbiAgICAgICAgICAgICAgLy8gdGhlaXIgYmVoYXZpb3IgZHVyaW5nIHNjZW5lcnkgZXZlbnQgZGlzcGF0Y2hcclxuICAgICAgICAgICAgICBldmVudC5wb2ludGVyLnJlc2VydmVGb3JLZXlib2FyZERyYWcoKTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gd2hldGhlciB3ZSB3aWxsIHVzZSBjb25zdHJhaW5WYWx1ZSB0byBtb2RpZnkgdGhlIHByb3Bvc2VkIHZhbHVlLCBzZWUgdXNhZ2VzIGJlbG93XHJcbiAgICAgICAgICAgICAgbGV0IHVzZUNvbnN0cmFpblZhbHVlID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gaWYgdGhpcyBpcyB0aGUgZmlyc3Qga2V5ZG93biB0aGlzIGlzIHRoZSBzdGFydCBvZiB0aGUgZHJhZyBpbnRlcmFjdGlvblxyXG4gICAgICAgICAgICAgIGlmICggIXRoaXMuX2FueUtleXNEb3duKCkgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9vbkludGVyYWN0aW9uU3RhcnQoIGV2ZW50ICk7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAvLyB0cmFjayB0aGF0IGEgbmV3IGtleSBpcyBiZWluZyBoZWxkIGRvd25cclxuICAgICAgICAgICAgICB0aGlzLl9yYW5nZUtleXNEb3duWyBrZXkgXSA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICAgIGxldCBuZXdWYWx1ZSA9IHRoaXMuX3ZhbHVlUHJvcGVydHkuZ2V0KCk7XHJcbiAgICAgICAgICAgICAgaWYgKCBLZXlib2FyZFV0aWxzLmlzQW55S2V5RXZlbnQoIGRvbUV2ZW50LCBbIEtleWJvYXJkVXRpbHMuS0VZX0VORCwgS2V5Ym9hcmRVdGlscy5LRVlfSE9NRSBdICkgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gb24gJ2VuZCcgYW5kICdob21lJyBzbmFwIHRvIG1heCBhbmQgbWluIG9mIGVuYWJsZWQgcmFuZ2UgcmVzcGVjdGl2ZWx5ICh0aGlzIGlzIHR5cGljYWwgYnJvd3NlclxyXG4gICAgICAgICAgICAgICAgLy8gYmVoYXZpb3IgZm9yIHNsaWRlcnMpXHJcbiAgICAgICAgICAgICAgICBpZiAoIGtleSA9PT0gS2V5Ym9hcmRVdGlscy5LRVlfRU5EICkge1xyXG4gICAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IHRoaXMuX2VuYWJsZWRSYW5nZVByb3BlcnR5LmdldCgpLm1heDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCBrZXkgPT09IEtleWJvYXJkVXRpbHMuS0VZX0hPTUUgKSB7XHJcbiAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlID0gdGhpcy5fZW5hYmxlZFJhbmdlUHJvcGVydHkuZ2V0KCkubWluO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGxldCBzdGVwU2l6ZTtcclxuICAgICAgICAgICAgICAgIGlmICgga2V5ID09PSBLZXlib2FyZFV0aWxzLktFWV9QQUdFX1VQIHx8IGtleSA9PT0gS2V5Ym9hcmRVdGlscy5LRVlfUEFHRV9ET1dOICkge1xyXG4gICAgICAgICAgICAgICAgICAvLyBvbiBwYWdlIHVwIGFuZCBwYWdlIGRvd24sIHRoZSBkZWZhdWx0IHN0ZXAgc2l6ZSBpcyAxLzEwIG9mIHRoZSByYW5nZSAodGhpcyBpcyB0eXBpY2FsIGJyb3dzZXIgYmVoYXZpb3IpXHJcbiAgICAgICAgICAgICAgICAgIHN0ZXBTaXplID0gdGhpcy5wYWdlS2V5Ym9hcmRTdGVwO1xyXG5cclxuICAgICAgICAgICAgICAgICAgaWYgKCBrZXkgPT09IEtleWJvYXJkVXRpbHMuS0VZX1BBR0VfVVAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUgPSB0aGlzLl92YWx1ZVByb3BlcnR5LmdldCgpICsgc3RlcFNpemU7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIGtleSA9PT0gS2V5Ym9hcmRVdGlscy5LRVlfUEFHRV9ET1dOICkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlID0gdGhpcy5fdmFsdWVQcm9wZXJ0eS5nZXQoKSAtIHN0ZXBTaXplO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICggS2V5Ym9hcmRVdGlscy5pc0Fycm93S2V5KCBkb21FdmVudCApICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIHNoaWZ0IGtleSBpcyBwcmVzc2VkIGRvd24sIG1vZGlmeSB0aGUgc3RlcCBzaXplICh0aGlzIGlzIGF0eXBpY2FsIGJyb3dzZXIgYmVoYXZpb3IgZm9yIHNsaWRlcnMpXHJcbiAgICAgICAgICAgICAgICAgIHN0ZXBTaXplID0gZG9tRXZlbnQuc2hpZnRLZXkgPyB0aGlzLnNoaWZ0S2V5Ym9hcmRTdGVwIDogdGhpcy5rZXlib2FyZFN0ZXA7XHJcblxyXG4gICAgICAgICAgICAgICAgICAvLyBUZW1wb3Jhcnkgd29ya2Fyb3VuZCwgaWYgdXNpbmcgc2hpZnQga2V5IHdpdGggYXJyb3cga2V5cyB0byB1c2UgdGhlIHNoaWZ0S2V5Ym9hcmRTdGVwLCBkb24ndFxyXG4gICAgICAgICAgICAgICAgICAvLyB1c2UgY29uc3RyYWluVmFsdWUgYmVjYXVzZSB0aGUgY29uc3RyYWluVmFsdWUgaXMgb2Z0ZW4gc21hbGxlciB0aGFuIHRoZSB2YWx1ZXMgYWxsb3dlZCBieVxyXG4gICAgICAgICAgICAgICAgICAvLyBjb25zdHJhaW5WYWx1ZS4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waGV0c2ltcy9zdW4vaXNzdWVzLzY5OC5cclxuICAgICAgICAgICAgICAgICAgdXNlQ29uc3RyYWluVmFsdWUgPSAhZG9tRXZlbnQuc2hpZnRLZXk7XHJcblxyXG4gICAgICAgICAgICAgICAgICBpZiAoIGtleSA9PT0gS2V5Ym9hcmRVdGlscy5LRVlfUklHSFRfQVJST1cgfHwga2V5ID09PSBLZXlib2FyZFV0aWxzLktFWV9VUF9BUlJPVyApIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IHRoaXMuX3ZhbHVlUHJvcGVydHkuZ2V0KCkgKyBzdGVwU2l6ZTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICBlbHNlIGlmICgga2V5ID09PSBLZXlib2FyZFV0aWxzLktFWV9MRUZUX0FSUk9XIHx8IGtleSA9PT0gS2V5Ym9hcmRVdGlscy5LRVlfRE9XTl9BUlJPVyApIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IHRoaXMuX3ZhbHVlUHJvcGVydHkuZ2V0KCkgLSBzdGVwU2l6ZTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgaWYgKCB0aGlzLl9yb3VuZFRvU3RlcFNpemUgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUgPSByb3VuZFZhbHVlKCBuZXdWYWx1ZSwgdGhpcy5fdmFsdWVQcm9wZXJ0eS5nZXQoKSwgc3RlcFNpemUgKTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgLy8gTWFwIHRoZSB2YWx1ZS5cclxuICAgICAgICAgICAgICBjb25zdCBtYXBwZWRWYWx1ZSA9IHRoaXMuX2ExMXlNYXBWYWx1ZSggbmV3VmFsdWUsIHRoaXMuX3ZhbHVlUHJvcGVydHkuZ2V0KCkgKTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gT3B0aW9uYWxseSBjb25zdHJhaW4gdGhlIHZhbHVlLiBPbmx5IGNvbnN0cmFpbiBpZiBtb2RpZnlpbmcgYnkgc2hpZnRLZXlib2FyZFN0ZXAgYmVjYXVzZSB0aGF0IHN0ZXAgc2l6ZVxyXG4gICAgICAgICAgICAgIC8vIG1heSBhbGxvdyBmaW5lciBwcmVjaXNpb24gdGhhbiBjb25zdHJhaW5WYWx1ZS4gVGhpcyBpcyBhIHdvcmthcm91bmQgZm9yXHJcbiAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL3N1bi9pc3N1ZXMvNjk4LCBhbmQgaXMgYWN0dWFsbHkgYSBwcm9ibGVtIGZvciBhbGwga2V5Ym9hcmQgc3RlcHMgaWYgdGhleVxyXG4gICAgICAgICAgICAgIC8vIGFyZSBzbWFsbGVyIHRoYW4gdmFsdWVzIGFsbG93ZWQgYnkgY29uc3RyYWluVmFsdWUuIEluIGh0dHBzOi8vZ2l0aHViLmNvbS9waGV0c2ltcy9zdW4vaXNzdWVzLzcwMyB3ZVxyXG4gICAgICAgICAgICAgIC8vIHdpbGwgd29yayB0byByZXNvbHZlIHRoaXMgbW9yZSBnZW5lcmFsbHkuXHJcbiAgICAgICAgICAgICAgbGV0IGNvbnN0cmFpbmVkVmFsdWUgPSBtYXBwZWRWYWx1ZTtcclxuICAgICAgICAgICAgICBpZiAoIHVzZUNvbnN0cmFpblZhbHVlICkge1xyXG4gICAgICAgICAgICAgICAgY29uc3RyYWluZWRWYWx1ZSA9IHRoaXMuX2NvbnN0cmFpblZhbHVlKCBtYXBwZWRWYWx1ZSApO1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgLy8gbGltaXQgdGhlIHZhbHVlIHRvIHRoZSBlbmFibGVkIHJhbmdlXHJcbiAgICAgICAgICAgICAgdGhpcy5fdmFsdWVQcm9wZXJ0eS5zZXQoIFV0aWxzLmNsYW1wKCBjb25zdHJhaW5lZFZhbHVlLCB0aGlzLl9lbmFibGVkUmFuZ2VQcm9wZXJ0eS5nZXQoKS5taW4sIHRoaXMuX2VuYWJsZWRSYW5nZVByb3BlcnR5LmdldCgpLm1heCApICk7XHJcblxyXG4gICAgICAgICAgICAgIC8vIG9wdGlvbmFsIGNhbGxiYWNrIGFmdGVyIHRoZSB2YWx1ZVByb3BlcnR5IGlzIHNldCAoZXZlbiBpZiBzZXQgdG8gdGhlIHNhbWUgdmFsdWUpIHNvIHRoYXQgdGhlIGxpc3RlbmVyXHJcbiAgICAgICAgICAgICAgLy8gY2FuIHVzZSB0aGUgbmV3IHZhbHVlLlxyXG4gICAgICAgICAgICAgIHRoaXMuX29uSW5wdXQoIGV2ZW50ICk7XHJcblxyXG4gICAgICAgICAgICAgIC8vIGFmdGVyIGFueSBrZXlib2FyZCBpbnB1dCwgbWFrZSBzdXJlIHRoYXQgdGhlIE5vZGUgc3RheXMgaW4gdmlld1xyXG4gICAgICAgICAgICAgIGNvbnN0IHBhblRhcmdldE5vZGUgPSB0aGlzLl9wYW5UYXJnZXROb2RlIHx8IHRoaXM7XHJcbiAgICAgICAgICAgICAgYW5pbWF0ZWRQYW5ab29tU2luZ2xldG9uLmluaXRpYWxpemVkICYmIGFuaW1hdGVkUGFuWm9vbVNpbmdsZXRvbi5saXN0ZW5lci5wYW5Ub05vZGUoIHBhblRhcmdldE5vZGUsIHRydWUsIHBhblRhcmdldE5vZGUubGltaXRQYW5EaXJlY3Rpb24gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLyoqXHJcbiAgICAgICAqIEhhbmRsZSBrZXkgdXAgZXZlbnQgb24gdGhpcyBhY2Nlc3NpYmxlIHNsaWRlciwgbWFuYWdpbmcgdGhlIHNoaWZ0IGtleSwgYW5kIGNhbGxpbmcgYW4gb3B0aW9uYWwgZW5kRHJhZ1xyXG4gICAgICAgKiBmdW5jdGlvbiBvbiByZWxlYXNlLiBBZGQgdGhpcyBhcyBhbiBpbnB1dCBsaXN0ZW5lciB0byB0aGUgbm9kZSBtaXhpbmcgaW4gQWNjZXNzaWJsZVZhbHVlSGFuZGxlci5cclxuICAgICAgICogQG1peGluLXByb3RlY3RlZCAtIG1hZGUgcHVibGljIGZvciB1c2UgaW4gdGhlIG1peGluIG9ubHlcclxuICAgICAgICovXHJcbiAgICAgIHB1YmxpYyBoYW5kbGVLZXlVcCggZXZlbnQ6IFNjZW5lcnlFdmVudDxLZXlib2FyZEV2ZW50PiApOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBrZXkgPSBLZXlib2FyZFV0aWxzLmdldEV2ZW50Q29kZSggZXZlbnQuZG9tRXZlbnQgKSE7XHJcblxyXG4gICAgICAgIC8vIGhhbmRsZSBjYXNlIHdoZXJlIHVzZXIgdGFiYmVkIHRvIHRoaXMgaW5wdXQgd2hpbGUgYW4gYXJyb3cga2V5IG1pZ2h0IGhhdmUgYmVlbiBoZWxkIGRvd25cclxuICAgICAgICBpZiAoIHRoaXMuX2FsbEtleXNVcCgpICkge1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gcmVzZXQgc2hpZnQga2V5IGZsYWcgd2hlbiB3ZSByZWxlYXNlIGl0XHJcbiAgICAgICAgaWYgKCBLZXlib2FyZFV0aWxzLlNISUZUX0tFWVMuaW5jbHVkZXMoIGtleSApICkge1xyXG4gICAgICAgICAgdGhpcy5fc2hpZnRLZXkgPSBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICggdGhpcy5lbmFibGVkUHJvcGVydHkuZ2V0KCkgKSB7XHJcbiAgICAgICAgICBpZiAoIEtleWJvYXJkVXRpbHMuaXNSYW5nZUtleSggZXZlbnQuZG9tRXZlbnQgKSApIHtcclxuICAgICAgICAgICAgdGhpcy5fcmFuZ2VLZXlzRG93blsga2V5IF0gPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIC8vIHdoZW4gYWxsIHJhbmdlIGtleXMgYXJlIHJlbGVhc2VkLCB3ZSBhcmUgZG9uZSBkcmFnZ2luZ1xyXG4gICAgICAgICAgICBpZiAoIHRoaXMuX2FsbEtleXNVcCgpICkge1xyXG4gICAgICAgICAgICAgIHRoaXMuX29uSW50ZXJhY3Rpb25FbmQoIGV2ZW50ICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBWb2ljZU92ZXIgc2VuZHMgYSBcImNoYW5nZVwiIGV2ZW50IHRvIHRoZSBzbGlkZXIgKE5PVCBhbiBpbnB1dCBldmVudCksIHNvIHdlIG5lZWQgdG8gaGFuZGxlIHRoZSBjYXNlIHdoZW5cclxuICAgICAgICogYSBjaGFuZ2UgZXZlbnQgaXMgc2VudCBidXQgYW4gaW5wdXQgZXZlbnQgaW5zJ3QgaGFuZGxlZC4gR3VhcmRlZCBhZ2FpbnN0IHRoZSBjYXNlIHRoYXQgQk9USCBjaGFuZ2UgYW5kXHJcbiAgICAgICAqIGlucHV0IGFyZSBzZW50IHRvIHRoZSBicm93c2VyIGJ5IHRoZSBBVC5cclxuICAgICAgICpcclxuICAgICAgICogQWRkIHRoaXMgYXMgYSBsaXN0ZW5lciB0byB0aGUgJ2NoYW5nZScgaW5wdXQgZXZlbnQgb24gdGhlIE5vZGUgdGhhdCBpcyBtaXhpbmcgaW4gQWNjZXNzaWJsZVZhbHVlSGFuZGxlci5cclxuICAgICAgICogQG1peGluLXByb3RlY3RlZCAtIG1hZGUgcHVibGljIGZvciB1c2UgaW4gdGhlIG1peGluIG9ubHlcclxuICAgICAgICovXHJcbiAgICAgIHB1YmxpYyBoYW5kbGVDaGFuZ2UoIGV2ZW50OiBTY2VuZXJ5RXZlbnQgKTogdm9pZCB7XHJcblxyXG4gICAgICAgIGlmICggIXRoaXMuX2ExMXlJbnB1dEhhbmRsZWQgKSB7XHJcbiAgICAgICAgICB0aGlzLmhhbmRsZUlucHV0KCBldmVudCApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5fYTExeUlucHV0SGFuZGxlZCA9IGZhbHNlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogSGFuZGxlIGEgZGlyZWN0ICdpbnB1dCcgZXZlbnQgdGhhdCBtaWdodCBjb21lIGZyb20gYXNzaXN0aXZlIHRlY2hub2xvZ3kuIEl0IGlzIHBvc3NpYmxlIHRoYXQgdGhlIHVzZXIgYWdlbnRcclxuICAgICAgICogKHBhcnRpY3VsYXJseSBWb2ljZU92ZXIsIG9yIGEgc3dpdGNoIGRldmljZSkgd2lsbCBpbml0aWF0ZSBhbiBpbnB1dCBldmVudCBkaXJlY3RseSB3aXRob3V0IGdvaW5nIHRocm91Z2hcclxuICAgICAgICoga2V5ZG93bi4gSW4gdGhhdCBjYXNlLCBoYW5kbGUgdGhlIGNoYW5nZSBkZXBlbmRpbmcgb24gd2hpY2ggZGlyZWN0aW9uIHRoZSB1c2VyIHRyaWVkIHRvIGdvLiBXZSBkZXRlcm1pbmVcclxuICAgICAgICogdGhpcyBieSBkZXRlY3RpbmcgaG93IHRoZSBpbnB1dCB2YWx1ZSBjaGFuZ2VkIGluIHJlc3BvbnNlIHRvIHRoZSBgaW5wdXRgIGV2ZW50IHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50XHJcbiAgICAgICAqIHZhbHVlIG9mIHRoZSB2YWx1ZVByb3BlcnR5LlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBOb3RlIHRoYXQgaXQgaXMgaW1wb3J0YW50IHRvIGhhbmRsZSB0aGUgXCJpbnB1dFwiIGV2ZW50LCByYXRoZXIgdGhhbiB0aGUgXCJjaGFuZ2VcIiBldmVudC4gVGhlIFwiaW5wdXRcIiB3aWxsXHJcbiAgICAgICAqIGZpcmUgd2hlbiB0aGUgdmFsdWUgY2hhbmdlcyBmcm9tIGEgZ2VzdHVyZSwgd2hpbGUgdGhlIFwiY2hhbmdlXCIgd2lsbCBvbmx5IGhhcHBlbiBvbiBzdWJtaXNzaW9uLCBsaWtlIGFzXHJcbiAgICAgICAqIG5hdmlnYXRpbmcgYXdheSBmcm9tIHRoZSBlbGVtZW50LlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBBZGQgdGhpcyBhcyBhIGxpc3RlbmVyIHRvIHRoZSBgaW5wdXRgIGV2ZW50IG9uIHRoZSBOb2RlIHRoYXQgaXMgbWl4aW5nIGluIEFjY2Vzc2libGVWYWx1ZUhhbmRsZXIuXHJcbiAgICAgICAqIEBtaXhpbi1wcm90ZWN0ZWQgLSBtYWRlIHB1YmxpYyBmb3IgdXNlIGluIHRoZSBtaXhpbiBvbmx5XHJcbiAgICAgICAqL1xyXG4gICAgICBwdWJsaWMgaGFuZGxlSW5wdXQoIGV2ZW50OiBTY2VuZXJ5RXZlbnQgKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKCB0aGlzLmVuYWJsZWRQcm9wZXJ0eS5nZXQoKSAmJiAhdGhpcy5fYmxvY2tJbnB1dCApIHtcclxuXHJcbiAgICAgICAgICAvLyBkb24ndCBoYW5kbGUgYWdhaW4gb24gXCJjaGFuZ2VcIiBldmVudFxyXG4gICAgICAgICAgdGhpcy5fYTExeUlucHV0SGFuZGxlZCA9IHRydWU7XHJcblxyXG4gICAgICAgICAgbGV0IG5ld1ZhbHVlID0gdGhpcy5fdmFsdWVQcm9wZXJ0eS5nZXQoKTtcclxuXHJcbiAgICAgICAgICBjb25zdCBpbnB1dFZhbHVlID0gcGFyc2VGbG9hdCggKCBldmVudC5kb21FdmVudCEudGFyZ2V0IGFzIEhUTUxJbnB1dEVsZW1lbnQgKS52YWx1ZSApO1xyXG4gICAgICAgICAgY29uc3Qgc3RlcFNpemUgPSB0aGlzLl9zaGlmdEtleSA/IHRoaXMuc2hpZnRLZXlib2FyZFN0ZXAgOiB0aGlzLmtleWJvYXJkU3RlcDtcclxuICAgICAgICAgIGNvbnN0IG1hcHBlZFZhbHVlID0gdGhpcy5fZ2V0TWFwcGVkVmFsdWUoKTtcclxuXHJcbiAgICAgICAgICAvLyBzdGFydCBvZiBjaGFuZ2UgZXZlbnQgaXMgc3RhcnQgb2YgZHJhZ1xyXG4gICAgICAgICAgdGhpcy5fb25JbnRlcmFjdGlvblN0YXJ0KCBldmVudCApO1xyXG5cclxuICAgICAgICAgIGlmICggaW5wdXRWYWx1ZSA+IG1hcHBlZFZhbHVlICkge1xyXG4gICAgICAgICAgICBuZXdWYWx1ZSA9IHRoaXMuX3ZhbHVlUHJvcGVydHkuZ2V0KCkgKyBzdGVwU2l6ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGVsc2UgaWYgKCBpbnB1dFZhbHVlIDwgbWFwcGVkVmFsdWUgKSB7XHJcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gdGhpcy5fdmFsdWVQcm9wZXJ0eS5nZXQoKSAtIHN0ZXBTaXplO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGlmICggdGhpcy5fcm91bmRUb1N0ZXBTaXplICkge1xyXG4gICAgICAgICAgICBuZXdWYWx1ZSA9IHJvdW5kVmFsdWUoIG5ld1ZhbHVlLCB0aGlzLl92YWx1ZVByb3BlcnR5LmdldCgpLCBzdGVwU2l6ZSApO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIGxpbWl0IHRvIGVuYWJsZWQgcmFuZ2VcclxuICAgICAgICAgIG5ld1ZhbHVlID0gVXRpbHMuY2xhbXAoIG5ld1ZhbHVlLCB0aGlzLl9lbmFibGVkUmFuZ2VQcm9wZXJ0eS5nZXQoKS5taW4sIHRoaXMuX2VuYWJsZWRSYW5nZVByb3BlcnR5LmdldCgpLm1heCApO1xyXG5cclxuICAgICAgICAgIC8vIG9wdGlvbmFsbHkgY29uc3RyYWluIHZhbHVlXHJcbiAgICAgICAgICB0aGlzLl92YWx1ZVByb3BlcnR5LnNldCggdGhpcy5fY29uc3RyYWluVmFsdWUoIHRoaXMuX2ExMXlNYXBWYWx1ZSggbmV3VmFsdWUsIHRoaXMuX3ZhbHVlUHJvcGVydHkuZ2V0KCkgKSApICk7XHJcblxyXG4gICAgICAgICAgLy8gb25seSBvbmUgY2hhbmdlIHBlciBpbnB1dCwgYnV0IHN0aWxsIGNhbGwgb3B0aW9uYWwgb25JbnB1dCBmdW5jdGlvbiAtIGFmdGVyIHZhbHVlUHJvcGVydHkgaXMgc2V0IChldmVuIGlmXHJcbiAgICAgICAgICAvLyBzZXQgdG8gdGhlIHNhbWUgdmFsdWUpIHNvIGxpc3RlbmVyIGNhbiB1c2UgbmV3IHZhbHVlLlxyXG4gICAgICAgICAgdGhpcy5fb25JbnB1dCggZXZlbnQgKTtcclxuXHJcbiAgICAgICAgICAvLyBlbmQgb2YgY2hhbmdlIGlzIHRoZSBlbmQgb2YgYSBkcmFnXHJcbiAgICAgICAgICB0aGlzLl9vbkludGVyYWN0aW9uRW5kKCBldmVudCApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gZG9uJ3QgYmxvY2sgdGhlIG5leHQgaW5wdXQgYWZ0ZXIgcmVjZWl2aW5nIG9uZSwgc29tZSBBVCBtYXkgc2VuZCBlaXRoZXIgYGtleWRvd25gIG9yIGBpbnB1dGAgZXZlbnRzXHJcbiAgICAgICAgLy8gZGVwZW5kaW5nIG9uIG1vZGlmaWVyIGtleXMgc28gd2UgbmVlZCB0byBiZSByZWFkeSB0byByZWNlaXZlIGVpdGhlciBvbiBuZXh0IGludGVyYWN0aW9uXHJcbiAgICAgICAgdGhpcy5fYmxvY2tJbnB1dCA9IGZhbHNlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogRmlyZXMgd2hlbiB0aGUgYWNjZXNzaWJsZSBzbGlkZXIgbG9zZXMgZm9jdXMuXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEFkZCB0aGlzIGFzIGEgbGlzdGVuZXIgb24gdGhlIGBibHVyYCBldmVudCB0byB0aGUgTm9kZSB0aGF0IGlzIG1peGluZyBpbiBBY2Nlc3NpYmxlVmFsdWVIYW5kbGVyLlxyXG4gICAgICAgKiBAbWl4aW4tcHJvdGVjdGVkIC0gbWFkZSBwdWJsaWMgZm9yIHVzZSBpbiB0aGUgbWl4aW4gb25seVxyXG4gICAgICAgKi9cclxuICAgICAgcHVibGljIGhhbmRsZUJsdXIoIGV2ZW50OiBTY2VuZXJ5RXZlbnQ8Rm9jdXNFdmVudD4gKTogdm9pZCB7XHJcblxyXG4gICAgICAgIC8vIGlmIGFueSByYW5nZSBrZXlzIGFyZSBjdXJyZW50bHkgZG93biwgY2FsbCBlbmQgZHJhZyBiZWNhdXNlIHVzZXIgaGFzIHN0b3BwZWQgZHJhZ2dpbmcgdG8gZG8gc29tZXRoaW5nIGVsc2VcclxuICAgICAgICBpZiAoIHRoaXMuX2FueUtleXNEb3duKCkgKSB7XHJcbiAgICAgICAgICB0aGlzLl9vbkludGVyYWN0aW9uRW5kKCBldmVudCApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gcmVzZXQgZmxhZyBpbiBjYXNlIHdlIHNoaWZ0LXRhYmJlZCBhd2F5IGZyb20gc2xpZGVyXHJcbiAgICAgICAgdGhpcy5fc2hpZnRLZXkgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgLy8gd2hlbiBmb2N1cyBsZWF2ZXMgdGhpcyBlbGVtZW50IHN0b3AgYmxvY2tpbmcgaW5wdXQgZXZlbnRzXHJcbiAgICAgICAgdGhpcy5fYmxvY2tJbnB1dCA9IGZhbHNlO1xyXG5cclxuICAgICAgICAvLyByZXNldCBjb3VudGVyIGZvciByYW5nZSBrZXlzIGRvd25cclxuICAgICAgICB0aGlzLl9yYW5nZUtleXNEb3duID0ge307XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBJbnRlcmFjdGlvbiB3aXRoIHRoaXMgaW5wdXQgaGFzIHN0YXJ0ZWQsIHNhdmUgdGhlIHZhbHVlIG9uIHN0YXJ0IHNvIHRoYXQgaXQgY2FuIGJlIHVzZWQgYXMgYW4gXCJvbGRcIiB2YWx1ZVxyXG4gICAgICAgKiB3aGVuIGdlbmVyYXRpbmcgdGhlIGNvbnRleHQgcmVzcG9uc2Ugd2l0aCBvcHRpb24gYTExeUNyZWF0ZUNvbnRleHRSZXNwb25zZS5cclxuICAgICAgICovXHJcbiAgICAgIHByaXZhdGUgX29uSW50ZXJhY3Rpb25TdGFydCggZXZlbnQ6IFNjZW5lcnlFdmVudCApOiB2b2lkIHtcclxuXHJcbiAgICAgICAgYXNzZXJ0ICYmIGFzc2VydCggIXRoaXMuX3Bkb21Qb2ludGVyLCAnUG9pbnRlciBzaG91bGQgaGF2ZSBiZWVuIGNsZWFyZWQgYW5kIGRldGFjaGVkIG9uIGVuZCBvciBpbnRlcnJ1cHQuJyApO1xyXG4gICAgICAgIHRoaXMuX3Bkb21Qb2ludGVyID0gZXZlbnQucG9pbnRlciBhcyBQRE9NUG9pbnRlcjtcclxuXHJcbiAgICAgICAgYXNzZXJ0ICYmIGFzc2VydCggdGhpcy5fcGRvbVBvaW50ZXIuYXR0YWNoZWRMaXN0ZW5lciAhPT0gdGhpcy5fcGRvbVBvaW50ZXJMaXN0ZW5lciwgJ1RoaXMgcG9pbnRlciBsaXN0ZW5lciB3YXMgbmV2ZXIgcmVtb3ZlZCEnICk7XHJcbiAgICAgICAgdGhpcy5fcGRvbVBvaW50ZXIuYWRkSW5wdXRMaXN0ZW5lciggdGhpcy5fcGRvbVBvaW50ZXJMaXN0ZW5lciwgdHJ1ZSApO1xyXG5cclxuICAgICAgICB0aGlzLl92YWx1ZU9uU3RhcnQgPSB0aGlzLl92YWx1ZVByb3BlcnR5LnZhbHVlO1xyXG4gICAgICAgIHRoaXMuX3N0YXJ0SW5wdXQoIGV2ZW50ICk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBJbnRlcmFjdGlvbiB3aXRoIHRoaXMgaW5wdXQgaGFzIGNvbXBsZXRlZCwgZ2VuZXJhdGUgYW4gdXR0ZXJhbmNlIGRlc2NyaWJpbmcgY2hhbmdlcyBpZiBuZWNlc3NhcnkgYW5kIGNhbGxcclxuICAgICAgICogb3B0aW9uYWwgXCJlbmRcIiBmdW5jdGlvbi5cclxuICAgICAgICpcclxuICAgICAgICogQHBhcmFtIFtldmVudF0gLSBFdmVudCBpcyBub3QgZ3VhcmFudGVlZCBiZWNhdXNlIHdlIG5lZWQgdG8gc3VwcG9ydCBpbnRlcnJ1cHRpb25cclxuICAgICAgICovXHJcbiAgICAgIHByaXZhdGUgX29uSW50ZXJhY3Rpb25FbmQoIGV2ZW50OiBTY2VuZXJ5RXZlbnQgfCBudWxsICk6IHZvaWQge1xyXG5cclxuICAgICAgICAvLyBJdCBpcyBwb3NzaWJsZSB0aGF0IGludGVyYWN0aW9uIGFscmVhZHkgZW5kZWQuIFRoaXMgY2FuIGhhcHBlbiBpZiB0aGUgcG9pbnRlciBpcyBpbnRlcnJ1cHRlZCBqdXN0IGJlZm9yZVxyXG4gICAgICAgIC8vIHJlY2VpdmluZyBhIGtleXVwIGV2ZW50LiBUaGlzIGlzIGEgcmFyZSBjYXNlIGFuZCBzaG91bGQgb25seSBiZSBwb3NzaWJsZSB3aGlsZSBmdXp6aW5nLlxyXG4gICAgICAgIGlmICggdGhpcy5fcGRvbVBvaW50ZXIgKSB7XHJcblxyXG4gICAgICAgICAgdGhpcy5hbGVydENvbnRleHRSZXNwb25zZSgpO1xyXG4gICAgICAgICAgdGhpcy52b2ljaW5nT25FbmRSZXNwb25zZSggdGhpcy5fdmFsdWVPblN0YXJ0ICk7XHJcbiAgICAgICAgICB0aGlzLl9lbmRJbnB1dCggZXZlbnQgKTtcclxuXHJcbiAgICAgICAgICAvLyBkZXRhY2ggdGhlIHBvaW50ZXIgbGlzdGVuZXIgdGhhdCB3YXMgYXR0YWNoZWQgb24ga2V5ZG93blxyXG4gICAgICAgICAgYXNzZXJ0ICYmIGFzc2VydCggdGhpcy5fcGRvbVBvaW50ZXIuYXR0YWNoZWRMaXN0ZW5lciA9PT0gdGhpcy5fcGRvbVBvaW50ZXJMaXN0ZW5lciwgJ3BvaW50ZXIgbGlzdGVuZXIgc2hvdWxkIGJlIGF0dGFjaGVkJyApO1xyXG4gICAgICAgICAgdGhpcy5fcGRvbVBvaW50ZXIucmVtb3ZlSW5wdXRMaXN0ZW5lciggdGhpcy5fcGRvbVBvaW50ZXJMaXN0ZW5lciApO1xyXG4gICAgICAgICAgdGhpcy5fcGRvbVBvaW50ZXIgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLyoqXHJcbiAgICAgICAqIFNldCB0aGUgZGVsdGEgZm9yIHRoZSB2YWx1ZSBQcm9wZXJ0eSB3aGVuIHVzaW5nIGFycm93IGtleXMgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgTm9kZS5cclxuICAgICAgICovXHJcbiAgICAgIHB1YmxpYyBzZXRLZXlib2FyZFN0ZXAoIGtleWJvYXJkU3RlcDogbnVtYmVyICk6IHZvaWQge1xyXG4gICAgICAgIGFzc2VydCAmJiBhc3NlcnQoIGtleWJvYXJkU3RlcCA+PSAwLCAna2V5Ym9hcmQgc3RlcCBtdXN0IGJlIG5vbi1uZWdhdGl2ZScgKTtcclxuXHJcbiAgICAgICAgdGhpcy5fa2V5Ym9hcmRTdGVwID0ga2V5Ym9hcmRTdGVwO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBwdWJsaWMgc2V0IGtleWJvYXJkU3RlcCgga2V5Ym9hcmRTdGVwOiBudW1iZXIgKSB7IHRoaXMuc2V0S2V5Ym9hcmRTdGVwKCBrZXlib2FyZFN0ZXAgKTsgfVxyXG5cclxuICAgICAgcHVibGljIGdldCBrZXlib2FyZFN0ZXAoKTogbnVtYmVyIHsgcmV0dXJuIHRoaXMuZ2V0S2V5Ym9hcmRTdGVwKCk7IH1cclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBHZXQgdGhlIGRlbHRhIGZvciB2YWx1ZSBQcm9wZXJ0eSB3aGVuIHVzaW5nIGFycm93IGtleXMuXHJcbiAgICAgICAqL1xyXG4gICAgICBwdWJsaWMgZ2V0S2V5Ym9hcmRTdGVwKCk6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2tleWJvYXJkU3RlcDtcclxuICAgICAgfVxyXG5cclxuICAgICAgLyoqXHJcbiAgICAgICAqIFNldCB0aGUgZGVsdGEgZm9yIHZhbHVlIFByb3BlcnR5IHdoZW4gdXNpbmcgYXJyb3cga2V5cyB3aXRoIHNoaWZ0IHRvIGludGVyYWN0IHdpdGggdGhlIE5vZGUuXHJcbiAgICAgICAqL1xyXG4gICAgICBwdWJsaWMgc2V0U2hpZnRLZXlib2FyZFN0ZXAoIHNoaWZ0S2V5Ym9hcmRTdGVwOiBudW1iZXIgKTogdm9pZCB7XHJcbiAgICAgICAgYXNzZXJ0ICYmIGFzc2VydCggc2hpZnRLZXlib2FyZFN0ZXAgPj0gMCwgJ3NoaWZ0IGtleWJvYXJkIHN0ZXAgbXVzdCBiZSBub24tbmVnYXRpdmUnICk7XHJcblxyXG4gICAgICAgIHRoaXMuX3NoaWZ0S2V5Ym9hcmRTdGVwID0gc2hpZnRLZXlib2FyZFN0ZXA7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHB1YmxpYyBzZXQgc2hpZnRLZXlib2FyZFN0ZXAoIHNoaWZ0S2V5Ym9hcmRTdGVwOiBudW1iZXIgKSB7IHRoaXMuc2V0U2hpZnRLZXlib2FyZFN0ZXAoIHNoaWZ0S2V5Ym9hcmRTdGVwICk7IH1cclxuXHJcbiAgICAgIHB1YmxpYyBnZXQgc2hpZnRLZXlib2FyZFN0ZXAoKTogbnVtYmVyIHsgcmV0dXJuIHRoaXMuZ2V0U2hpZnRLZXlib2FyZFN0ZXAoKTsgfVxyXG5cclxuICAgICAgLyoqXHJcbiAgICAgICAqIEdldCB0aGUgZGVsdGEgZm9yIHZhbHVlIFByb3BlcnR5IHdoZW4gdXNpbmcgYXJyb3cga2V5cyB3aXRoIHNoaWZ0IHRvIGludGVyYWN0IHdpdGggdGhlIE5vZGUuXHJcbiAgICAgICAqL1xyXG4gICAgICBwdWJsaWMgZ2V0U2hpZnRLZXlib2FyZFN0ZXAoKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc2hpZnRLZXlib2FyZFN0ZXA7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHNoaWZ0IGtleSBpcyBjdXJyZW50bHkgaGVsZCBkb3duIG9uIHRoaXMgc2xpZGVyLCBjaGFuZ2luZyB0aGUgc2l6ZSBvZiBzdGVwLlxyXG4gICAgICAgKi9cclxuICAgICAgcHVibGljIGdldFNoaWZ0S2V5RG93bigpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc2hpZnRLZXk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHB1YmxpYyBnZXQgc2hpZnRLZXlEb3duKCk6IGJvb2xlYW4geyByZXR1cm4gdGhpcy5nZXRTaGlmdEtleURvd24oKTsgfVxyXG5cclxuICAgICAgLyoqXHJcbiAgICAgICAqIFNldCB0aGUgZGVsdGEgZm9yIHZhbHVlIFByb3BlcnR5IHdoZW4gdXNpbmcgcGFnZSB1cC9wYWdlIGRvd24gdG8gaW50ZXJhY3Qgd2l0aCB0aGUgTm9kZS5cclxuICAgICAgICovXHJcbiAgICAgIHB1YmxpYyBzZXRQYWdlS2V5Ym9hcmRTdGVwKCBwYWdlS2V5Ym9hcmRTdGVwOiBudW1iZXIgKTogdm9pZCB7XHJcbiAgICAgICAgYXNzZXJ0ICYmIGFzc2VydCggcGFnZUtleWJvYXJkU3RlcCA+PSAwLCAncGFnZSBrZXlib2FyZCBzdGVwIG11c3QgYmUgbm9uLW5lZ2F0aXZlJyApO1xyXG5cclxuICAgICAgICB0aGlzLl9wYWdlS2V5Ym9hcmRTdGVwID0gcGFnZUtleWJvYXJkU3RlcDtcclxuICAgICAgfVxyXG5cclxuICAgICAgcHVibGljIHNldCBwYWdlS2V5Ym9hcmRTdGVwKCBwYWdlS2V5Ym9hcmRTdGVwOiBudW1iZXIgKSB7IHRoaXMuc2V0UGFnZUtleWJvYXJkU3RlcCggcGFnZUtleWJvYXJkU3RlcCApOyB9XHJcblxyXG4gICAgICBwdWJsaWMgZ2V0IHBhZ2VLZXlib2FyZFN0ZXAoKTogbnVtYmVyIHsgcmV0dXJuIHRoaXMuZ2V0UGFnZUtleWJvYXJkU3RlcCgpOyB9XHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogR2V0IHRoZSBkZWx0YSBmb3IgdmFsdWUgUHJvcGVydHkgd2hlbiB1c2luZyBwYWdlIHVwL3BhZ2UgZG93biB0byBpbnRlcmFjdCB3aXRoIHRoZSBOb2RlLlxyXG4gICAgICAgKi9cclxuICAgICAgcHVibGljIGdldFBhZ2VLZXlib2FyZFN0ZXAoKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcGFnZUtleWJvYXJkU3RlcDtcclxuICAgICAgfVxyXG5cclxuICAgICAgLyoqXHJcbiAgICAgICAqIFNldCB0aGUgb3JpZW50YXRpb24gZm9yIHRoZSBzbGlkZXIgYXMgc3BlY2lmaWVkIGJ5IGh0dHBzOi8vd3d3LnczLm9yZy9UUi93YWktYXJpYS0xLjEvI2FyaWEtb3JpZW50YXRpb24uXHJcbiAgICAgICAqIERlcGVuZGluZyBvbiB0aGUgdmFsdWUgb2YgdGhpcyBhdHRyaWJ1dGUsIGEgc2NyZWVuIHJlYWRlciB3aWxsIGdpdmUgZGlmZmVyZW50IGluZGljYXRpb25zIGFib3V0IHdoaWNoXHJcbiAgICAgICAqIGFycm93IGtleXMgc2hvdWxkIGJlIHVzZWRcclxuICAgICAgICovXHJcbiAgICAgIHB1YmxpYyBzZXRBcmlhT3JpZW50YXRpb24oIG9yaWVudGF0aW9uOiBPcmllbnRhdGlvbiApOiB2b2lkIHtcclxuXHJcbiAgICAgICAgdGhpcy5fYXJpYU9yaWVudGF0aW9uID0gb3JpZW50YXRpb247XHJcbiAgICAgICAgdGhpcy5zZXRQRE9NQXR0cmlidXRlKCAnYXJpYS1vcmllbnRhdGlvbicsIG9yaWVudGF0aW9uLmFyaWFPcmllbnRhdGlvbiApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBwdWJsaWMgc2V0IGFyaWFPcmllbnRhdGlvbiggb3JpZW50YXRpb246IE9yaWVudGF0aW9uICkgeyB0aGlzLnNldEFyaWFPcmllbnRhdGlvbiggb3JpZW50YXRpb24gKTsgfVxyXG5cclxuICAgICAgcHVibGljIGdldCBhcmlhT3JpZW50YXRpb24oKTogT3JpZW50YXRpb24geyByZXR1cm4gdGhpcy5fYXJpYU9yaWVudGF0aW9uOyB9XHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogR2V0IHRoZSBvcmllbnRhdGlvbiBvZiB0aGUgYWNjZXNzaWJsZSBzbGlkZXIsIHNlZSBzZXRBcmlhT3JpZW50YXRpb24gZm9yIGluZm9ybWF0aW9uIG9uIHRoZSBiZWhhdmlvciBvZiB0aGlzXHJcbiAgICAgICAqIGF0dHJpYnV0ZS5cclxuICAgICAgICovXHJcbiAgICAgIHB1YmxpYyBnZXRBcmlhT3JpZW50YXRpb24oKTogT3JpZW50YXRpb24ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hcmlhT3JpZW50YXRpb247XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBSZXR1cm5zIHRydWUgaWYgYWxsIHJhbmdlIGtleXMgYXJlIGN1cnJlbnRseSB1cCAobm90IGhlbGQgZG93bikuXHJcbiAgICAgICAqL1xyXG4gICAgICBwcml2YXRlIF9hbGxLZXlzVXAoKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIF8uZXZlcnkoIHRoaXMuX3JhbmdlS2V5c0Rvd24sIGVudHJ5ID0+ICFlbnRyeSApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogUmV0dXJucyB0cnVlIGlmIGFueSByYW5nZSBrZXlzIGFyZSBjdXJyZW50bHkgZG93biBvbiB0aGlzIHNsaWRlci4gVXNlZnVsIGZvciBkZXRlcm1pbmluZyB3aGVuIHRvIGNhbGxcclxuICAgICAgICogc3RhcnREcmFnIG9yIGVuZERyYWcgYmFzZWQgb24gaW50ZXJhY3Rpb24uXHJcbiAgICAgICAqL1xyXG4gICAgICBwcml2YXRlIF9hbnlLZXlzRG93bigpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gISFfLmZpbmQoIHRoaXMuX3JhbmdlS2V5c0Rvd24sIGVudHJ5ID0+IGVudHJ5ICk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBTZXQgdGhlIGBzdGVwYCBhdHRyaWJ1dGUgb24gYWNjZXNzaWJsZSBzaWJsaW5ncyBmb3IgdGhpcyBOb2RlLiBVc3VhbGx5LCB3ZSBjYW4gdXNlIHRoZSAnYW55JyB2YWx1ZSxcclxuICAgICAgICogd2hpY2ggbWVhbnMgdGhhdCBhbnkgdmFsdWUgd2l0aGluIHRoZSByYW5nZSBpcyBhbGxvd2VkLiBIb3dldmVyLCBpT1MgVm9pY2VPdmVyIGRvZXMgbm90IHN1cHBvcnQgJ2FueSdcclxuICAgICAgICogc28gd2UgaGF2ZSB0byBjYWxjdWxhdGUgYSB2YWxpZCBzdGVwIHZhbHVlIGZvciBtb2JpbGUgU2FmYXJpLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBUaGUgc3RlcCBhdHRyaWJ1dGUgbXVzdCBiZSBub24temVyby4gT25seSB2YWx1ZXMgd2hpY2ggYXJlIGVxdWFsIHRvIG1pbiB2YWx1ZSBwbHVzXHJcbiAgICAgICAqIHRoZSBiYXNpcyBvZiBzdGVwIGFyZSBhbGxvd2VkLiBJbiBvdGhlciB3b3JkcywgdGhlIGZvbGxvd2luZyBtdXN0IGFsd2F5cyBiZSB0cnVlOlxyXG4gICAgICAgKiB2YWx1ZSA9IG1pbiArIG4gKiBzdGVwIHdoZXJlIHZhbHVlIDw9IG1heCBhbmQgbiBpcyBhbiBpbnRlZ2VyLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBJZiB0aGUgaW5wdXQgdmFsdWUgaXMgc2V0IHRvIGFueXRoaW5nIGVsc2UsIHRoZSByZXN1bHQgaXMgY29uZnVzaW5nXHJcbiAgICAgICAqIGtleWJvYXJkIGJlaGF2aW9yIGFuZCB0aGUgc2NyZWVuIHJlYWRlciB3aWxsIHNheSBcIkludmFsaWRcIiB3aGVuIHRoZSB2YWx1ZSBjaGFuZ2VzLlxyXG4gICAgICAgKiBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9FbGVtZW50L2lucHV0L251bWJlciNzdGVwXHJcbiAgICAgICAqXHJcbiAgICAgICAqIFRoaXMgbGltaXRhdGlvbiBpcyB0b28gcmVzdHJpY3RpdmUgZm9yIFBoRVQgYXMgbWFueSBzbGlkZXJzIHNwYW4gcGh5c2ljYWwgcmFuZ2VzIHdpdGgga2V5Ym9hcmQgc3RlcHMgdGhhdFxyXG4gICAgICAgKiBhcmUgZGVzaWduIHRvIGJlIGNvbnZlbmllbnQgb3IgcGVkYWdvZ2ljYWxseSB1c2VmdWwuIEZvciBleGFtcGxlLCBhIHNsaWRlciB0aGF0IHNwYW5zIDAuMDEgdG8gMTUgcmVxdWlyZXNcclxuICAgICAgICogYSBzdGVwIG9mIDEsIGJ1dCBET00gc3BlY2lmaWNhdGlvbiB3b3VsZCBvbmx5IGFsbG93IHZhbHVlcyAwLjAxLCAxLjAxLCAyLjAxLCAuLi5cclxuICAgICAgICpcclxuICAgICAgICogVGhpcyByZXN0cmljdGlvbiBpcyB3aHkgYHN0ZXBgIGF0dHJpYnV0ZSBjYW5ub3QgZXF1YWwga2V5Ym9hcmRTdGVwIG9mIHRoaXMgdHJhaXQuXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEFsc28sIGlmIHRoZSBzdGVwIGF0dHJpYnV0ZSBpcyB0b28gc21hbGwgcmVsYXRpdmUgdG8gdGhlIGVudGlyZSByYW5nZSBvZiB0aGUgc2xpZGVyIFZvaWNlT3ZlciBkb2Vzbid0IGFsbG93XHJcbiAgICAgICAqIGFueSBpbnB1dCBldmVudHMgYmVjYXVzZS4uLlZvaWNlT3ZlciBpcyBqdXN0IGludGVyZXN0aW5nIGxpa2UgdGhhdC5cclxuICAgICAgICpcclxuICAgICAgICogQ3VycmVudCB3b3JrYXJvdW5kIGZvciBhbGwgb2YgdGhpcyBpcyB0byBzZXQgdGhlIHN0ZXAgc2l6ZSB0byBzdXBwb3J0IHRoZSBwcmVjaXNpb24gb2YgdGhlIHZhbHVlIHJlcXVpcmVkXHJcbiAgICAgICAqIGJ5IHRoZSBjbGllbnQgc28gdGhhdCBhbGwgdmFsdWVzIGFyZSBhbGxvd2VkLiBJZiB3ZSBlbmNvdW50ZXIgdGhlIFZvaWNlT3ZlciBjYXNlIGRlc2NyaWJlZCBhYm92ZSB3ZSBmYWxsXHJcbiAgICAgICAqIGJhY2sgdG8gc2V0dGluZyB0aGUgc3RlcCBzaXplIGF0IDEvMTAwdGggb2YgdGhlIG1heCB2YWx1ZSBzaW5jZSB0aGUga2V5Ym9hcmQgc3RlcCBnZW5lcmFsbHkgZXZlbmx5IGRpdmlkZXNcclxuICAgICAgICogdGhlIG1heCB2YWx1ZSByYXRoZXIgdGhhbiB0aGUgZnVsbCByYW5nZS5cclxuICAgICAgICpcclxuICAgICAgICogU2VlIHRoZSBmb2xsb3dpbmcgaXNzdWVzIGZvciBoaXN0b3J5OlxyXG4gICAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vcGhldHNpbXMvc3VuL2lzc3Vlcy80MTNcclxuICAgICAgICogaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL3N1bi9pc3N1ZXMvODczXHJcbiAgICAgICAqL1xyXG4gICAgICBwcml2YXRlIF91cGRhdGVTaWJsaW5nU3RlcEF0dHJpYnV0ZSgpOiB2b2lkIHtcclxuICAgICAgICBsZXQgc3RlcFZhbHVlOiBudW1iZXIgfCBzdHJpbmcgPSAnYW55JztcclxuXHJcbiAgICAgICAgLy8gVE9ETzogUmVtb3ZlIHdoZW4gaU9TIFNhZmFyaSBzdXBwb3J0cyB0aGUgJ2FueScsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vcGhldHNpbXMvYTExeS1yZXNlYXJjaC9pc3N1ZXMvMTkxXHJcbiAgICAgICAgaWYgKCBwbGF0Zm9ybS5tb2JpbGVTYWZhcmkgKSB7XHJcblxyXG4gICAgICAgICAgY29uc3Qgc21hbGxlc3RTdGVwID0gTWF0aC5taW4oIHRoaXMua2V5Ym9hcmRTdGVwLCB0aGlzLnNoaWZ0S2V5Ym9hcmRTdGVwLCB0aGlzLnBhZ2VLZXlib2FyZFN0ZXAgKTtcclxuICAgICAgICAgIHN0ZXBWYWx1ZSA9IE1hdGgucG93KCAxMCwgLVV0aWxzLm51bWJlck9mRGVjaW1hbFBsYWNlcyggc21hbGxlc3RTdGVwICkgKTtcclxuXHJcbiAgICAgICAgICBjb25zdCBtYXBwZWRNaW4gPSB0aGlzLl9nZXRNYXBwZWRWYWx1ZSggdGhpcy5fZW5hYmxlZFJhbmdlUHJvcGVydHkuZ2V0KCkubWluICk7XHJcbiAgICAgICAgICBjb25zdCBtYXBwZWRNYXggPSB0aGlzLl9nZXRNYXBwZWRWYWx1ZSggdGhpcy5fZW5hYmxlZFJhbmdlUHJvcGVydHkuZ2V0KCkubWF4ICk7XHJcbiAgICAgICAgICBjb25zdCBtYXBwZWRMZW5ndGggPSBtYXBwZWRNYXggLSBtYXBwZWRNaW47XHJcblxyXG4gICAgICAgICAgLy8gSWYgdGhlIHN0ZXAgaXMgdG9vIHNtYWxsIHJlbGF0aXZlIHRvIGZ1bGwgcmFuZ2UgZm9yIFZvaWNlT3ZlciB0byByZWNlaXZlIGlucHV0LCBmYWxsIGJhY2sgdG8gYSBwb3J0aW9uIG9mXHJcbiAgICAgICAgICAvLyB0aGUgbWF4IHZhbHVlIGFzIGEgd29ya2Fyb3VuZC5cclxuICAgICAgICAgIGlmICggc3RlcFZhbHVlIC8gbWFwcGVkTGVuZ3RoIDwgMWUtNSApIHtcclxuICAgICAgICAgICAgc3RlcFZhbHVlID0gbWFwcGVkTWF4IC8gMTAwO1xyXG5cclxuICAgICAgICAgICAgLy8gTGltaXQgdGhlIHByZWNpc2lvbiBvZiB0aGUgY2FsY3VsYXRlZCB2YWx1ZS4gIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugb3RoZXJ3aXNlIGZsb2F0aW5nIHBvaW50XHJcbiAgICAgICAgICAgIC8vIGluYWNjdXJhY2llcyBjYW4gbGVhZCB0byBwcm9ibGVtYXRpYyBiZWhhdmlvcnMgd2l0aCBzY3JlZW4gcmVhZGVycyxcclxuICAgICAgICAgICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waGV0c2ltcy9ncmVlbmhvdXNlLWVmZmVjdC9pc3N1ZXMvMzg4LiBUaGUgbnVtYmVyIG9mIHNpZ25pZmljYW50IGRpZ2l0cyB3YXMgY2hvc2VuXHJcbiAgICAgICAgICAgIC8vIHNvbWV3aGF0IGFyYml0cmFyaWx5LlxyXG4gICAgICAgICAgICBzdGVwVmFsdWUgPSBOdW1iZXIoIHN0ZXBWYWx1ZS50b1ByZWNpc2lvbiggOCApICk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnNldFBET01BdHRyaWJ1dGUoICdzdGVwJywgc3RlcFZhbHVlICk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBDYWxsIHRoaXMgdG8gdHJpZ2dlciB0aGUgdm9pY2luZyByZXNwb25zZSBzcG9rZW4gd2hlbiBhbiBpbnRlcmFjdGlvbiBlbmRzLiBXaWxsIHNwZWFrIHRoZSBjdXJyZW50XHJcbiAgICAgICAqIG5hbWUgYW5kIG9iamVjdCByZXNwb25zZXMgKGFjY29yZGluZyB0byBvcHRpb25zKS4gU2V0IHRob3NlIHJlc3BvbnNlcyBvZiBWb2ljaW5nLnRzIHRvIGhlYXIgdXAtdG8tZGF0ZVxyXG4gICAgICAgKiBWb2ljaW5nIHJlc3BvbnNlcyBhdCB0aGUgZW5kIG9mIGFuIGludGVyYWN0aW9uLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAcGFyYW0gdmFsdWVPblN0YXJ0IC0gUHJvcGVydHkgdmFsdWUgYXQgdGhlIHN0YXJ0IG9mIHRoZSBpbnRlcmFjdGlvbi5cclxuICAgICAgICogQHBhcmFtIHByb3ZpZGVkT3B0aW9uc1xyXG4gICAgICAgKi9cclxuICAgICAgcHVibGljIHZvaWNpbmdPbkVuZFJlc3BvbnNlKCB2YWx1ZU9uU3RhcnQ6IG51bWJlciwgcHJvdmlkZWRPcHRpb25zPzogVm9pY2luZ09uRW5kUmVzcG9uc2VPcHRpb25zICk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBjb21iaW5lT3B0aW9uczxWb2ljaW5nT25FbmRSZXNwb25zZU9wdGlvbnM+KCB7fSwgdGhpcy5fdm9pY2luZ09uRW5kUmVzcG9uc2VPcHRpb25zLCBwcm92aWRlZE9wdGlvbnMgKTtcclxuXHJcbiAgICAgICAgY29uc3QgdmFsdWVDaGFuZ2VkID0gdmFsdWVPblN0YXJ0ICE9PSB0aGlzLl92YWx1ZVByb3BlcnR5LnZhbHVlO1xyXG4gICAgICAgIGNvbnN0IHZhbHVlQXRNaW5NYXggPSB0aGlzLl92YWx1ZVByb3BlcnR5LnZhbHVlID09PSB0aGlzLl9lbmFibGVkUmFuZ2VQcm9wZXJ0eS52YWx1ZS5taW4gfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmFsdWVQcm9wZXJ0eS52YWx1ZSA9PT0gdGhpcy5fZW5hYmxlZFJhbmdlUHJvcGVydHkudmFsdWUubWF4O1xyXG5cclxuICAgICAgICAvLyBjb250ZW50IHJlcXVpcmVkIHRvIHNwZWFrIGEgcmVzcG9uc2UgYW5kIGFkZCB0byBiYWNrIG9mIFV0dGVyYW5jZVF1ZXVlLlxyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlQ29udGVudEV4aXN0cyA9ICEhKCBvcHRpb25zLndpdGhOYW1lUmVzcG9uc2UgJiYgdGhpcy52b2ljaW5nTmFtZVJlc3BvbnNlICkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhISggb3B0aW9ucy53aXRoT2JqZWN0UmVzcG9uc2UgJiYgdGhpcy52b2ljaW5nT2JqZWN0UmVzcG9uc2UgKTtcclxuICAgICAgICBjb25zdCBzaG91bGRTcGVhayA9ICggIW9wdGlvbnMub25seU9uVmFsdWVDaGFuZ2UgfHwgLy8gc3BlYWsgZWFjaCB0aW1lIGlmIG9ubHlPblZhbHVlQ2hhbmdlIGlzIGZhbHNlLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZUF0TWluTWF4IHx8IC8vIGFsd2F5cyBzcGVhayBhdCBlZGdlcywgZm9yIFwiZ28gYmV5b25kXCIgcmVzcG9uc2VzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlQ2hhbmdlZCApICYmIC8vIElmIHRoZSB2YWx1ZSBjaGFuZ2VkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZUNvbnRlbnRFeGlzdHM7XHJcblxyXG4gICAgICAgIHNob3VsZFNwZWFrICYmIHRoaXMudm9pY2luZ1NwZWFrRnVsbFJlc3BvbnNlKCB7XHJcbiAgICAgICAgICBuYW1lUmVzcG9uc2U6IG9wdGlvbnMud2l0aE5hbWVSZXNwb25zZSA/IHRoaXMudm9pY2luZ05hbWVSZXNwb25zZSA6IG51bGwsXHJcbiAgICAgICAgICBvYmplY3RSZXNwb25zZTogb3B0aW9ucy53aXRoT2JqZWN0UmVzcG9uc2UgPyB0aGlzLnZvaWNpbmdPYmplY3RSZXNwb25zZSA6IG51bGwsXHJcbiAgICAgICAgICBoaW50UmVzcG9uc2U6IG51bGwgLy8gbm8gaGludCwgdGhlcmUgd2FzIGp1c3QgYSBzdWNjZXNzZnVsIGludGVyYWN0aW9uXHJcbiAgICAgICAgfSApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBwdWJsaWMgb3ZlcnJpZGUgZGlzcG9zZSgpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLl9kaXNwb3NlQWNjZXNzaWJsZVZhbHVlSGFuZGxlcigpO1xyXG5cclxuICAgICAgICBzdXBlci5kaXNwb3NlKCk7XHJcbiAgICAgIH1cclxuICAgIH0gKTtcclxuXHJcbiAgLyoqXHJcbiAgICoge0FycmF5LjxzdHJpbmc+fSAtIFN0cmluZyBrZXlzIGZvciBhbGwgdGhlIGFsbG93ZWQgb3B0aW9ucyB0aGF0IHdpbGwgYmUgc2V0IGJ5IE5vZGUubXV0YXRlKCBvcHRpb25zICksIGluXHJcbiAgICogdGhlIG9yZGVyIHRoZXkgd2lsbCBiZSBldmFsdWF0ZWQuXHJcbiAgICpcclxuICAgKiBOT1RFOiBTZWUgTm9kZSdzIF9tdXRhdG9yS2V5cyBkb2N1bWVudGF0aW9uIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIGhvdyB0aGlzIG9wZXJhdGVzLCBhbmQgcG90ZW50aWFsIHNwZWNpYWxcclxuICAgKiAgICAgICBjYXNlcyB0aGF0IG1heSBhcHBseS5cclxuICAgKi9cclxuICBBY2Nlc3NpYmxlVmFsdWVIYW5kbGVyQ2xhc3MucHJvdG90eXBlLl9tdXRhdG9yS2V5cyA9IEFDQ0VTU0lCTEVfVkFMVUVfSEFORExFUl9PUFRJT05TLmNvbmNhdCggQWNjZXNzaWJsZVZhbHVlSGFuZGxlckNsYXNzLnByb3RvdHlwZS5fbXV0YXRvcktleXMgKTtcclxuXHJcbiAgYXNzZXJ0ICYmIGFzc2VydCggQWNjZXNzaWJsZVZhbHVlSGFuZGxlckNsYXNzLnByb3RvdHlwZS5fbXV0YXRvcktleXMubGVuZ3RoID09PSBfLnVuaXEoIEFjY2Vzc2libGVWYWx1ZUhhbmRsZXJDbGFzcy5wcm90b3R5cGUuX211dGF0b3JLZXlzICkubGVuZ3RoLCAnZHVwbGljYXRlIG11dGF0b3Iga2V5cyBpbiBBY2Nlc3NpYmxlVmFsdWVIYW5kbGVyJyApO1xyXG5cclxuICByZXR1cm4gQWNjZXNzaWJsZVZhbHVlSGFuZGxlckNsYXNzO1xyXG59O1xyXG5cclxuc3VuLnJlZ2lzdGVyKCAnQWNjZXNzaWJsZVZhbHVlSGFuZGxlcicsIEFjY2Vzc2libGVWYWx1ZUhhbmRsZXIgKTtcclxuXHJcbi8qKlxyXG4gKiBSb3VuZCB0aGUgdmFsdWUgdG8gdGhlIG5lYXJlc3Qgc3RlcCBzaXplLlxyXG4gKlxyXG4gKiBAcGFyYW0gbmV3VmFsdWUgLSB2YWx1ZSB0byBiZSByb3VuZGVkXHJcbiAqIEBwYXJhbSBjdXJyZW50VmFsdWUgLSBjdXJyZW50IHZhbHVlIG9mIHRoZSBQcm9wZXJ0eSBhc3NvY2lhdGVkIHdpdGggdGhpcyBzbGlkZXJcclxuICogQHBhcmFtIHN0ZXBTaXplIC0gdGhlIGRlbHRhIGZvciB0aGlzIG1hbmlwdWxhdGlvblxyXG4gKi9cclxuY29uc3Qgcm91bmRWYWx1ZSA9IGZ1bmN0aW9uKCBuZXdWYWx1ZTogbnVtYmVyLCBjdXJyZW50VmFsdWU6IG51bWJlciwgc3RlcFNpemU6IG51bWJlciApOiBudW1iZXIge1xyXG4gIGxldCByb3VuZFZhbHVlID0gbmV3VmFsdWU7XHJcbiAgaWYgKCBzdGVwU2l6ZSAhPT0gMCApIHtcclxuXHJcbiAgICAvLyByb3VuZCB0aGUgdmFsdWUgdG8gdGhlIG5lYXJlc3Qga2V5Ym9hcmQgc3RlcFxyXG4gICAgcm91bmRWYWx1ZSA9IFV0aWxzLnJvdW5kU3ltbWV0cmljKCByb3VuZFZhbHVlIC8gc3RlcFNpemUgKSAqIHN0ZXBTaXplO1xyXG5cclxuICAgIC8vIGdvIGJhY2sgYSBzdGVwIGlmIHdlIHdlbnQgdG9vIGZhciBkdWUgdG8gcm91bmRpbmdcclxuICAgIHJvdW5kVmFsdWUgPSBjb3JyZWN0Um91bmRpbmcoIHJvdW5kVmFsdWUsIGN1cnJlbnRWYWx1ZSwgc3RlcFNpemUgKTtcclxuICB9XHJcbiAgcmV0dXJuIHJvdW5kVmFsdWU7XHJcbn07XHJcblxyXG4vKipcclxuICogSGVscGVyIGZ1bmN0aW9uLCBpdCBpcyBwb3NzaWJsZSBkdWUgdG8gcm91bmRpbmcgdG8gZ28gdXAgb3IgZG93biBhIHN0ZXAgaWYgd2UgaGF2ZSBwYXNzZWQgdGhlIG5lYXJlc3Qgc3RlcCBkdXJpbmdcclxuICoga2V5Ym9hcmQgaW50ZXJhY3Rpb24uIFRoaXMgZnVuY3Rpb24gY29ycmVjdHMgdGhhdC5cclxuICpcclxuICovXHJcbmNvbnN0IGNvcnJlY3RSb3VuZGluZyA9IGZ1bmN0aW9uKCBuZXdWYWx1ZTogbnVtYmVyLCBjdXJyZW50VmFsdWU6IG51bWJlciwgc3RlcFNpemU6IG51bWJlciApOiBudW1iZXIge1xyXG4gIGxldCBjb3JyZWN0ZWRWYWx1ZSA9IG5ld1ZhbHVlO1xyXG5cclxuICBjb25zdCBwcm9wb3NlZFN0ZXAgPSBNYXRoLmFicyggbmV3VmFsdWUgLSBjdXJyZW50VmFsdWUgKTtcclxuICBjb25zdCBzdGVwVG9GYXIgPSBwcm9wb3NlZFN0ZXAgPiBzdGVwU2l6ZTtcclxuXHJcbiAgLy8gaXQgaXMgcG9zc2libGUgdGhhdCBwcm9wb3NlZFN0ZXAgd2lsbCBiZSBsYXJnZXIgdGhhbiB0aGUgc3RlcFNpemUgYnV0IG9ubHkgYmVjYXVzZSBvZiBwcmVjaXNpb25cclxuICAvLyBjb25zdHJhaW50cyB3aXRoIGZsb2F0aW5nIHBvaW50IHZhbHVlcywgZG9uJ3QgY29ycmVjdCBpZiB0aGF0IGlzIHRoZSBjYXNlc1xyXG4gIGNvbnN0IHN0ZXBzQWJvdXRFcXVhbCA9IFV0aWxzLmVxdWFsc0Vwc2lsb24oIHByb3Bvc2VkU3RlcCwgc3RlcFNpemUsIDFlLTE0ICk7XHJcbiAgaWYgKCBzdGVwVG9GYXIgJiYgIXN0ZXBzQWJvdXRFcXVhbCApIHtcclxuICAgIGNvcnJlY3RlZFZhbHVlICs9ICggbmV3VmFsdWUgPiBjdXJyZW50VmFsdWUgKSA/ICggLXN0ZXBTaXplICkgOiBzdGVwU2l6ZTtcclxuICB9XHJcbiAgcmV0dXJuIGNvcnJlY3RlZFZhbHVlO1xyXG59O1xyXG5cclxuQWNjZXNzaWJsZVZhbHVlSGFuZGxlci5ERUZBVUxUX1RBR19OQU1FID0gREVGQVVMVF9UQUdfTkFNRTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IEFjY2Vzc2libGVWYWx1ZUhhbmRsZXI7Il0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBT0EsS0FBSyxNQUFNLDBCQUEwQjtBQUU1QyxPQUFPQyxtQkFBbUIsTUFBTSw4Q0FBOEM7QUFDOUUsT0FBT0MsV0FBVyxNQUFNLHNDQUFzQztBQUM5RCxTQUFTQyx3QkFBd0IsRUFBRUMsYUFBYSxFQUFFQyxhQUFhLEVBQWtDQyxTQUFTLEVBQWtGQyxPQUFPLFFBQXdCLGdDQUFnQztBQUMzUCxPQUFPQyxTQUFTLE1BQU0sMENBQTBDO0FBQ2hFLE9BQU9DLEdBQUcsTUFBTSxXQUFXO0FBQzNCLE9BQU9DLFNBQVMsSUFBSUMsY0FBYyxRQUFRLG9DQUFvQztBQUM5RSxPQUFPQyxTQUFTLE1BQTRCLCtCQUErQjtBQU0zRSxPQUFPQyxlQUFlLE1BQU0scUNBQXFDO0FBQ2pFLE9BQU9DLFFBQVEsTUFBTSw4QkFBOEI7QUFDbkQsT0FBT0MsUUFBUSxNQUFNLG1DQUFtQzs7QUFFeEQ7QUFDQSxNQUFNQyxnQkFBZ0IsR0FBRyxPQUFPO0FBQ2hDLE1BQU1DLFFBQVEsR0FBS0MsQ0FBaUIsSUFBTyxHQUFFQSxDQUFFLEVBQUM7O0FBRWhEO0FBQ0EsTUFBTUMsdUNBQXVDLEdBQUc7RUFDOUNDLGdCQUFnQixFQUFFLEtBQUs7RUFBRTtFQUN6QkMsa0JBQWtCLEVBQUUsSUFBSTtF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