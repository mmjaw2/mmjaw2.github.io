// Copyright 2013-2024, University of Colorado Boulder

/**
 * Dimension3 is a basic width, height, and depth, like a Bounds3 but without the position defined.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 * @author Chris Malley (PixelZoom, Inc.)
 */

import dot from './dot.js';
import InfiniteNumberIO from '../../tandem/js/types/InfiniteNumberIO.js';
import IOType from '../../tandem/js/types/IOType.js';
import Bounds3 from './Bounds3.js';
const STATE_SCHEMA = {
  width: InfiniteNumberIO,
  height: InfiniteNumberIO,
  depth: InfiniteNumberIO
};
export default class Dimension3 {
  constructor(width, height, depth) {
    this.width = width;
    this.height = height;
    this.depth = depth;
  }

  /**
   * Debugging string for the dimension.
   */
  toString() {
    return `[${this.width}w, ${this.height}h, ${this.depth}d]`;
  }

  /**
   * Sets this dimension to be a copy of another dimension.
   * This is the mutable form of the function copy(). This will mutate (change) this dimension, in addition to returning
   * this dimension itself.
   */
  set(dimension) {
    this.width = dimension.width;
    this.height = dimension.height;
    this.depth = dimension.depth;
    return this;
  }

  /**
   * Sets the width of the dimension, returning this.
   */
  setWidth(width) {
    this.width = width;
    return this;
  }

  /**
   * Sets the height of the dimension, returning this.
   */
  setHeight(height) {
    this.height = height;
    return this;
  }

  /**
   * Sets the depth of the dimension, returning this.
   */
  setDepth(depth) {
    this.depth = depth;
    return this;
  }

  /**
   * Creates a copy of this dimension, or if a dimension is passed in, set that dimension's values to ours.
   * This is the immutable form of the function set(), if a dimension is provided. This will return a new dimension,
   * and will not modify this dimension.
   *
   * @param [dimension] - If not provided, creates a new Dimension3 with filled in values. Otherwise, fills
   *                      in the values of the provided dimension so that it equals this dimension.
   */
  copy(dimension) {
    if (dimension) {
      return dimension.set(this);
    } else {
      return new Dimension3(this.width, this.height, this.depth);
    }
  }

  /**
   * Creates a Bounds2 from this dimension based on passing in the minimum (top-left) corner as (x,y).
   * @param [x] - Minimum x coordinate of the bounds, or 0 if not provided.
   * @param [y] - Minimum y coordinate of the bounds, or 0 if not provided.
   * @param [z] - Minimum z coordinate of the bounds, or 0 if not provided.
   */
  toBounds(x, y, z) {
    x = x !== undefined ? x : 0;
    y = y !== undefined ? y : 0;
    z = z !== undefined ? z : 0;
    return new Bounds3(x, y, z, this.width + x, this.height + y, this.depth + z);
  }

  /**
   * Exact equality comparison between this dimension and another dimension.
   */
  equals(that) {
    return this.width === that.width && this.height === that.height && this.depth === that.depth;
  }
  toStateObject() {
    return {
      width: InfiniteNumberIO.toStateObject(this.width),
      height: InfiniteNumberIO.toStateObject(this.height),
      depth: InfiniteNumberIO.toStateObject(this.depth)
    };
  }
  static fromStateObject(stateObject) {
    return new Dimension3(InfiniteNumberIO.fromStateObject(stateObject.width), InfiniteNumberIO.fromStateObject(stateObject.height), InfiniteNumberIO.fromStateObject(stateObject.depth));
  }
  static Dimension3IO = new IOType('Dimension3IO', {
    valueType: Dimension3,
    documentation: 'A dimension with "width", "height", and "depth" members.',
    stateSchema: STATE_SCHEMA,
    toStateObject: range => range.toStateObject(),
    fromStateObject: stateObject => Dimension3.fromStateObject(stateObject)
  });
}
dot.register('Dimension3', Dimension3);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJkb3QiLCJJbmZpbml0ZU51bWJlcklPIiwiSU9UeXBlIiwiQm91bmRzMyIsIlNUQVRFX1NDSEVNQSIsIndpZHRoIiwiaGVpZ2h0IiwiZGVwdGgiLCJEaW1lbnNpb24zIiwiY29uc3RydWN0b3IiLCJ0b1N0cmluZyIsInNldCIsImRpbWVuc2lvbiIsInNldFdpZHRoIiwic2V0SGVpZ2h0Iiwic2V0RGVwdGgiLCJjb3B5IiwidG9Cb3VuZHMiLCJ4IiwieSIsInoiLCJ1bmRlZmluZWQiLCJlcXVhbHMiLCJ0aGF0IiwidG9TdGF0ZU9iamVjdCIsImZyb21TdGF0ZU9iamVjdCIsInN0YXRlT2JqZWN0IiwiRGltZW5zaW9uM0lPIiwidmFsdWVUeXBlIiwiZG9jdW1lbnRhdGlvbiIsInN0YXRlU2NoZW1hIiwicmFuZ2UiLCJyZWdpc3RlciJdLCJzb3VyY2VzIjpbIkRpbWVuc2lvbjMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTMtMjAyNCwgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXHJcblxyXG4vKipcclxuICogRGltZW5zaW9uMyBpcyBhIGJhc2ljIHdpZHRoLCBoZWlnaHQsIGFuZCBkZXB0aCwgbGlrZSBhIEJvdW5kczMgYnV0IHdpdGhvdXQgdGhlIHBvc2l0aW9uIGRlZmluZWQuXHJcbiAqXHJcbiAqIEBhdXRob3IgSm9uYXRoYW4gT2xzb24gPGpvbmF0aGFuLm9sc29uQGNvbG9yYWRvLmVkdT5cclxuICogQGF1dGhvciBDaHJpcyBNYWxsZXkgKFBpeGVsWm9vbSwgSW5jLilcclxuICovXHJcblxyXG5pbXBvcnQgZG90IGZyb20gJy4vZG90LmpzJztcclxuaW1wb3J0IEluZmluaXRlTnVtYmVySU8gZnJvbSAnLi4vLi4vdGFuZGVtL2pzL3R5cGVzL0luZmluaXRlTnVtYmVySU8uanMnO1xyXG5pbXBvcnQgeyBTdGF0ZU9iamVjdCB9IGZyb20gJy4uLy4uL3RhbmRlbS9qcy90eXBlcy9TdGF0ZVNjaGVtYS5qcyc7XHJcbmltcG9ydCBJT1R5cGUgZnJvbSAnLi4vLi4vdGFuZGVtL2pzL3R5cGVzL0lPVHlwZS5qcyc7XHJcbmltcG9ydCBCb3VuZHMzIGZyb20gJy4vQm91bmRzMy5qcyc7XHJcblxyXG5jb25zdCBTVEFURV9TQ0hFTUEgPSB7XHJcbiAgd2lkdGg6IEluZmluaXRlTnVtYmVySU8sXHJcbiAgaGVpZ2h0OiBJbmZpbml0ZU51bWJlcklPLFxyXG4gIGRlcHRoOiBJbmZpbml0ZU51bWJlcklPXHJcbn07XHJcbmV4cG9ydCB0eXBlIERpbWVuc2lvbjNTdGF0ZU9iamVjdCA9IFN0YXRlT2JqZWN0PHR5cGVvZiBTVEFURV9TQ0hFTUE+O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGltZW5zaW9uMyB7XHJcblxyXG4gIHB1YmxpYyB3aWR0aDogbnVtYmVyO1xyXG4gIHB1YmxpYyBoZWlnaHQ6IG51bWJlcjtcclxuICBwdWJsaWMgZGVwdGg6IG51bWJlcjtcclxuXHJcbiAgcHVibGljIGNvbnN0cnVjdG9yKCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlciwgZGVwdGg6IG51bWJlciApIHtcclxuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcclxuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgdGhpcy5kZXB0aCA9IGRlcHRoO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGVidWdnaW5nIHN0cmluZyBmb3IgdGhlIGRpbWVuc2lvbi5cclxuICAgKi9cclxuICBwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHtcclxuICAgIHJldHVybiBgWyR7dGhpcy53aWR0aH13LCAke3RoaXMuaGVpZ2h0fWgsICR7dGhpcy5kZXB0aH1kXWA7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXRzIHRoaXMgZGltZW5zaW9uIHRvIGJlIGEgY29weSBvZiBhbm90aGVyIGRpbWVuc2lvbi5cclxuICAgKiBUaGlzIGlzIHRoZSBtdXRhYmxlIGZvcm0gb2YgdGhlIGZ1bmN0aW9uIGNvcHkoKS4gVGhpcyB3aWxsIG11dGF0ZSAoY2hhbmdlKSB0aGlzIGRpbWVuc2lvbiwgaW4gYWRkaXRpb24gdG8gcmV0dXJuaW5nXHJcbiAgICogdGhpcyBkaW1lbnNpb24gaXRzZWxmLlxyXG4gICAqL1xyXG4gIHB1YmxpYyBzZXQoIGRpbWVuc2lvbjogRGltZW5zaW9uMyApOiBEaW1lbnNpb24zIHtcclxuICAgIHRoaXMud2lkdGggPSBkaW1lbnNpb24ud2lkdGg7XHJcbiAgICB0aGlzLmhlaWdodCA9IGRpbWVuc2lvbi5oZWlnaHQ7XHJcbiAgICB0aGlzLmRlcHRoID0gZGltZW5zaW9uLmRlcHRoO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXRzIHRoZSB3aWR0aCBvZiB0aGUgZGltZW5zaW9uLCByZXR1cm5pbmcgdGhpcy5cclxuICAgKi9cclxuICBwdWJsaWMgc2V0V2lkdGgoIHdpZHRoOiBudW1iZXIgKTogRGltZW5zaW9uMyB7XHJcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgdGhlIGhlaWdodCBvZiB0aGUgZGltZW5zaW9uLCByZXR1cm5pbmcgdGhpcy5cclxuICAgKi9cclxuICBwdWJsaWMgc2V0SGVpZ2h0KCBoZWlnaHQ6IG51bWJlciApOiBEaW1lbnNpb24zIHtcclxuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXRzIHRoZSBkZXB0aCBvZiB0aGUgZGltZW5zaW9uLCByZXR1cm5pbmcgdGhpcy5cclxuICAgKi9cclxuICBwdWJsaWMgc2V0RGVwdGgoIGRlcHRoOiBudW1iZXIgKTogRGltZW5zaW9uMyB7XHJcbiAgICB0aGlzLmRlcHRoID0gZGVwdGg7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYSBjb3B5IG9mIHRoaXMgZGltZW5zaW9uLCBvciBpZiBhIGRpbWVuc2lvbiBpcyBwYXNzZWQgaW4sIHNldCB0aGF0IGRpbWVuc2lvbidzIHZhbHVlcyB0byBvdXJzLlxyXG4gICAqIFRoaXMgaXMgdGhlIGltbXV0YWJsZSBmb3JtIG9mIHRoZSBmdW5jdGlvbiBzZXQoKSwgaWYgYSBkaW1lbnNpb24gaXMgcHJvdmlkZWQuIFRoaXMgd2lsbCByZXR1cm4gYSBuZXcgZGltZW5zaW9uLFxyXG4gICAqIGFuZCB3aWxsIG5vdCBtb2RpZnkgdGhpcyBkaW1lbnNpb24uXHJcbiAgICpcclxuICAgKiBAcGFyYW0gW2RpbWVuc2lvbl0gLSBJZiBub3QgcHJvdmlkZWQsIGNyZWF0ZXMgYSBuZXcgRGltZW5zaW9uMyB3aXRoIGZpbGxlZCBpbiB2YWx1ZXMuIE90aGVyd2lzZSwgZmlsbHNcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICBpbiB0aGUgdmFsdWVzIG9mIHRoZSBwcm92aWRlZCBkaW1lbnNpb24gc28gdGhhdCBpdCBlcXVhbHMgdGhpcyBkaW1lbnNpb24uXHJcbiAgICovXHJcbiAgcHVibGljIGNvcHkoIGRpbWVuc2lvbj86IERpbWVuc2lvbjMgKTogRGltZW5zaW9uMyB7XHJcbiAgICBpZiAoIGRpbWVuc2lvbiApIHtcclxuICAgICAgcmV0dXJuIGRpbWVuc2lvbi5zZXQoIHRoaXMgKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICByZXR1cm4gbmV3IERpbWVuc2lvbjMoIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCB0aGlzLmRlcHRoICk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIGEgQm91bmRzMiBmcm9tIHRoaXMgZGltZW5zaW9uIGJhc2VkIG9uIHBhc3NpbmcgaW4gdGhlIG1pbmltdW0gKHRvcC1sZWZ0KSBjb3JuZXIgYXMgKHgseSkuXHJcbiAgICogQHBhcmFtIFt4XSAtIE1pbmltdW0geCBjb29yZGluYXRlIG9mIHRoZSBib3VuZHMsIG9yIDAgaWYgbm90IHByb3ZpZGVkLlxyXG4gICAqIEBwYXJhbSBbeV0gLSBNaW5pbXVtIHkgY29vcmRpbmF0ZSBvZiB0aGUgYm91bmRzLCBvciAwIGlmIG5vdCBwcm92aWRlZC5cclxuICAgKiBAcGFyYW0gW3pdIC0gTWluaW11bSB6IGNvb3JkaW5hdGUgb2YgdGhlIGJvdW5kcywgb3IgMCBpZiBub3QgcHJvdmlkZWQuXHJcbiAgICovXHJcbiAgcHVibGljIHRvQm91bmRzKCB4PzogbnVtYmVyLCB5PzogbnVtYmVyLCB6PzogbnVtYmVyICk6IEJvdW5kczMge1xyXG4gICAgeCA9IHggIT09IHVuZGVmaW5lZCA/IHggOiAwO1xyXG4gICAgeSA9IHkgIT09IHVuZGVmaW5lZCA/IHkgOiAwO1xyXG4gICAgeiA9IHogIT09IHVuZGVmaW5lZCA/IHogOiAwO1xyXG4gICAgcmV0dXJuIG5ldyBCb3VuZHMzKCB4LCB5LCB6LCB0aGlzLndpZHRoICsgeCwgdGhpcy5oZWlnaHQgKyB5LCB0aGlzLmRlcHRoICsgeiApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRXhhY3QgZXF1YWxpdHkgY29tcGFyaXNvbiBiZXR3ZWVuIHRoaXMgZGltZW5zaW9uIGFuZCBhbm90aGVyIGRpbWVuc2lvbi5cclxuICAgKi9cclxuICBwdWJsaWMgZXF1YWxzKCB0aGF0OiBEaW1lbnNpb24zICk6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuIHRoaXMud2lkdGggPT09IHRoYXQud2lkdGggJiYgdGhpcy5oZWlnaHQgPT09IHRoYXQuaGVpZ2h0ICYmIHRoaXMuZGVwdGggPT09IHRoYXQuZGVwdGg7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgdG9TdGF0ZU9iamVjdCgpOiBEaW1lbnNpb24zU3RhdGVPYmplY3Qge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgd2lkdGg6IEluZmluaXRlTnVtYmVySU8udG9TdGF0ZU9iamVjdCggdGhpcy53aWR0aCApLFxyXG4gICAgICBoZWlnaHQ6IEluZmluaXRlTnVtYmVySU8udG9TdGF0ZU9iamVjdCggdGhpcy5oZWlnaHQgKSxcclxuICAgICAgZGVwdGg6IEluZmluaXRlTnVtYmVySU8udG9TdGF0ZU9iamVjdCggdGhpcy5kZXB0aCApXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgcHVibGljIHN0YXRpYyBmcm9tU3RhdGVPYmplY3QoIHN0YXRlT2JqZWN0OiBEaW1lbnNpb24zU3RhdGVPYmplY3QgKTogRGltZW5zaW9uMyB7XHJcbiAgICByZXR1cm4gbmV3IERpbWVuc2lvbjMoXHJcbiAgICAgIEluZmluaXRlTnVtYmVySU8uZnJvbVN0YXRlT2JqZWN0KCBzdGF0ZU9iamVjdC53aWR0aCApLFxyXG4gICAgICBJbmZpbml0ZU51bWJlcklPLmZyb21TdGF0ZU9iamVjdCggc3RhdGVPYmplY3QuaGVpZ2h0ICksXHJcbiAgICAgIEluZmluaXRlTnVtYmVySU8uZnJvbVN0YXRlT2JqZWN0KCBzdGF0ZU9iamVjdC5kZXB0aCApXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIHN0YXRpYyBEaW1lbnNpb24zSU8gPSBuZXcgSU9UeXBlPERpbWVuc2lvbjMsIERpbWVuc2lvbjNTdGF0ZU9iamVjdD4oICdEaW1lbnNpb24zSU8nLCB7XHJcbiAgICB2YWx1ZVR5cGU6IERpbWVuc2lvbjMsXHJcbiAgICBkb2N1bWVudGF0aW9uOiAnQSBkaW1lbnNpb24gd2l0aCBcIndpZHRoXCIsIFwiaGVpZ2h0XCIsIGFuZCBcImRlcHRoXCIgbWVtYmVycy4nLFxyXG4gICAgc3RhdGVTY2hlbWE6IFNUQVRFX1NDSEVNQSxcclxuICAgIHRvU3RhdGVPYmplY3Q6ICggcmFuZ2U6IERpbWVuc2lvbjMgKSA9PiByYW5nZS50b1N0YXRlT2JqZWN0KCksXHJcbiAgICBmcm9tU3RhdGVPYmplY3Q6ICggc3RhdGVPYmplY3Q6IERpbWVuc2lvbjNTdGF0ZU9iamVjdCApID0+IERpbWVuc2lvbjMuZnJvbVN0YXRlT2JqZWN0KCBzdGF0ZU9iamVjdCApXHJcbiAgfSApO1xyXG59XHJcblxyXG5kb3QucmVnaXN0ZXIoICdEaW1lbnNpb24zJywgRGltZW5zaW9u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