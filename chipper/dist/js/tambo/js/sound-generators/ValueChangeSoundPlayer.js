// Copyright 2022-2024, University of Colorado Boulder

/**
 * ValueChangeSoundPlayer plays sounds based on changes to a numerical value.  It was initially created for supporting
 * sound generation in PhET's Slider class and variations thereof, but it may have other applications.
 *
 * This class does not extend SoundGenerator and is not itself added to the sound manager.  It is instead a player of
 * a set of sounds, each of which should be registered with the sound manager elsewhere.
 *
 * Because the sounds should only be produced when users directly change a value, and not in side-effect-ish situations
 * (such as a reset), this class does not monitor a Property.  Instead, it provides methods that can be used to evaluate
 * changes in a value and potentially play sounds (or not, if the change doesn't warrant sound generation), and it is
 * the client's responsibility to know the situations in which these methods should be called.  Often these methods will
 * be called in drag handlers and other code that handles user input.
 *
 * @author John Blanco (PhET Interactive Simulations)
 */

import Range from '../../../dot/js/Range.js';
import Utils from '../../../dot/js/Utils.js';
import optionize from '../../../phet-core/js/optionize.js';
import generalBoundaryBoop_mp3 from '../../sounds/generalBoundaryBoop_mp3.js';
import generalSoftClick_mp3 from '../../sounds/generalSoftClick_mp3.js';
import phetAudioContext from '../phetAudioContext.js';
import generalBoundaryBoopSoundPlayer from '../shared-sound-players/generalBoundaryBoopSoundPlayer.js';
import generalSoftClickSoundPlayer from '../shared-sound-players/generalSoftClickSoundPlayer.js';
import nullSoundPlayer from '../shared-sound-players/nullSoundPlayer.js';
import tambo from '../tambo.js';
import SoundClip from './SoundClip.js';
import SoundClipPlayer from './SoundClipPlayer.js';
import Disposable from '../../../axon/js/Disposable.js';
import TinyProperty from '../../../axon/js/TinyProperty.js';

// constants
const DEFAULT_NUMBER_OF_MIDDLE_THRESHOLDS = 5; // fairly arbitrary
const DEFAULT_MIN_SOUND_PLAYER = new SoundClipPlayer(generalBoundaryBoop_mp3, {
  soundClipOptions: {
    initialOutputLevel: 0.2,
    initialPlaybackRate: 1 / Math.pow(2, 1 / 6) // a major second lower
  },
  soundManagerOptions: {
    categoryName: 'user-interface'
  }
});
const DEFAULT_MIDDLE_MOVING_DOWN_SOUND_PLAYER = new SoundClipPlayer(generalSoftClick_mp3, {
  soundClipOptions: {
    initialOutputLevel: 0.2,
    initialPlaybackRate: 1 / Math.pow(2, 1 / 6) // a major second lower
  },
  soundManagerOptions: {
    categoryName: 'user-interface'
  }
});

// Define a default constraint function.  See the docs for the associated option for more info.  The interval value used
// here was empirically determined.
const DEFAULT_VALUE_CONSTRAINT = value => Utils.roundToInterval(value, 0.000000001);

// A "no-op" function for mapping pitch values.  Always returns one, which signifies no change to the playback rate.
const NO_PLAYBACK_RATE_CHANGE = () => 1;

// A function for a stubbed sound player, see usage.
const STUB_SOUND_PLAYER_FUNCTION = () => {
  assert && assert(false, 'Code error: This is a stubbed function and should never be invoked.');
};
class ValueChangeSoundPlayer extends Disposable {
  // The distance between the threshold values at which sounds will be played.
  interThresholdDistance = DEFAULT_NUMBER_OF_MIDDLE_THRESHOLDS;

  // range of values that this should expect to handle

  // sound player for movement in the middle of the range (i.e. not at min or max) and moving up

  // sound player for movement in the middle of the range (i.e. not at min or max) and moving down

  // playback rate mapper for middle sounds and upward value changes

  // playback rate mapper for middle sounds and downward value changes

  // Sound players for the min and max values.  If nothing is provided a default will be used.  If the flag
  // USE_MIDDLE_SOUND is provided, the sound player for the middle range will be used.

  // min time between playing one middle sound and the next

  // function to constrain the values used for thresholds and comparisons

  // time of most recently played middle sound, used to moderate the rate at which these sounds are played

  /**
   * @param valueRange - the range of values expected and over which sounds will be played
   * @param [providedOptions]
   */
  constructor(valueRange, providedOptions) {
    const options = optionize()({
      middleMovingUpSoundPlayer: generalSoftClickSoundPlayer,
      middleMovingDownSoundPlayer: DEFAULT_MIDDLE_MOVING_DOWN_SOUND_PLAYER,
      middleMovingUpPlaybackRateMapper: NO_PLAYBACK_RATE_CHANGE,
      middleMovingDownPlaybackRateMapper: NO_PLAYBACK_RATE_CHANGE,
      numberOfMiddleThresholds: null,
      interThresholdDelta: null,
      constrainValue: DEFAULT_VALUE_CONSTRAINT,
      minSoundPlayer: DEFAULT_MIN_SOUND_PLAYER,
      maxSoundPlayer: generalBoundaryBoopSoundPlayer,
      minimumInterMiddleSoundTime: 0.035 // empirically determined
    }, providedOptions);

    // option validity checks
    assert && assert(options.minimumInterMiddleSoundTime >= 0 && options.minimumInterMiddleSoundTime < 1, `unreasonable value for minimumInterMiddleSoundTime: ${options.minimumInterMiddleSoundTime}`);
    assert && assert(options.numberOfMiddleThresholds === null || options.interThresholdDelta === null, 'cannot specify both the number of middle thresholds and the inter-threshold delta');
    assert && assert(options.numberOfMiddleThresholds === null || Number.isInteger(options.numberOfMiddleThresholds), 'numberOfMiddleThresholds must be an integer if specified');

    // If a playback rate mapper is provided for a middle threshold sound, the provided sound player must support
    // setting a different playback rate.  It should NOT be a SoundClipPlayer, since those are designed to be shared, so
    // the playback rate should never be changed.  The following assertions are intended to verify that these options
    // are set in a compatible way.
    assert && assert(options.middleMovingUpPlaybackRateMapper === NO_PLAYBACK_RATE_CHANGE || options.middleMovingUpSoundPlayer instanceof SoundClip, 'a sound player that supports playback rate changes is required when a playback rate mapper is used');
    assert && assert(options.middleMovingDownPlaybackRateMapper === NO_PLAYBACK_RATE_CHANGE || options.middleMovingDownSoundPlayer instanceof SoundClip, 'a sound player that supports playback rate changes is required when a playback rate mapper is used');

    // Set default number of middle thresholds if necessary.
    if (options.numberOfMiddleThresholds === null && options.interThresholdDelta === null) {
      options.numberOfMiddleThresholds = DEFAULT_NUMBER_OF_MIDDLE_THRESHOLDS;
    }
    super(options);
    this.valueRangeProperty = valueRange instanceof Range ? new TinyProperty(valueRange) : valueRange;
    this.middleMovingUpSoundPlayer = options.middleMovingUpSoundPlayer;
    this.middleMovingDownSoundPlayer = options.middleMovingDownSoundPlayer;
    this.middleMovingUpPlaybackRateMapper = options.middleMovingUpPlaybackRateMapper;
    this.middleMovingDownPlaybackRateMapper = options.middleMovingDownPlaybackRateMapper;
    this.minSoundPlayer = options.minSoundPlayer;
    this.maxSoundPlayer = options.maxSoundPlayer;
    this.minimumInterMiddleSoundTime = options.minimumInterMiddleSoundTime;
    this.timeOfMostRecentMiddleSound = 0;
    this.constrainValue = options.constrainValue;
    const rangeChangeListener = valueRange => {
      if (options.numberOfMiddleThresholds !== null) {
        this.interThresholdDistance = valueRange.getLength() / (options.numberOfMiddleThresholds + 1);
      } else if (options.interThresholdDelta !== null) {
        this.interThresholdDistance = options.interThresholdDelta;
      } else {
        assert && assert(false, 'should never get here, it is a logic error if we do');
        this.interThresholdDistance = valueRange.getLength() / 2; // avoid uninitialized compile-time error
      }
    };
    this.valueRangeProperty.link(rangeChangeListener);
    this.disposeEmitter.addListener(() => {
      this.valueRangeProperty.unlink(rangeChangeListener);
    });
  }

  /**
   * Check if the new value has reached or crossed a threshold and, if so, play the appropriate sound.  If no threshold
   * has been reached or crossed and the new value is not at the min or max, no sound will be played.
   */
  playSoundIfThresholdReached(newValue, oldValue) {
    if (newValue !== oldValue) {
      const constrainedNewValue = this.constrainValue(newValue);
      const constrainedOldValue = this.constrainValue(oldValue);
      const oldValueSurroundingThresholds = this.getSurroundingThresholds(constrainedOldValue);
      const newValueSurroundingThresholds = this.getSurroundingThresholds(constrainedNewValue);
      const thresholdCrossed = oldValueSurroundingThresholds.length === 1 && newValueSurroundingThresholds.length === 1 && Math.abs(oldValueSurroundingThresholds[0] - newValueSurroundingThresholds[0]) > this.interThresholdDistance || oldValueSurroundingThresholds.length === 1 && newValueSurroundingThresholds.length === 2 && oldValueSurroundingThresholds[0] !== newValueSurroundingThresholds[0] && oldValueSurroundingThresholds[0] !== newValueSurroundingThresholds[1] || oldValueSurroundingThresholds.length === 2 && newValueSurroundingThresholds.length === 1 && newValueSurroundingThresholds[0] !== oldValueSurroundingThresholds[0] && newValueSurroundingThresholds[0] !== oldValueSurroundingThresholds[1] || oldValueSurroundingThresholds.length === 2 && newValueSurroundingThresholds.length === 2 && newValueSurroundingThresholds[0] !== oldValueSurroundingThresholds[0];
      const thresholdReached = newValueSurroundingThresholds.length === 1 && (oldValueSurroundingThresholds.length === 2 || oldValueSurroundingThresholds[0] !== newValueSurroundingThresholds[0]);
      if (thresholdCrossed || thresholdReached || constrainedNewValue === this.valueRangeProperty.value.min || constrainedNewValue === this.valueRangeProperty.value.max) {
        this.playSoundForValueChange(newValue, oldValue);
      }
    }
  }

  /**
   * Play the appropriate sound for the change in value indicated by the provided new and old values.  This will almost
   * always play a sound, but there are some exceptions.  See the code and comments for details.
   */
  playSoundForValueChange(newValue, oldValue) {
    const constrainedNewValue = this.constrainValue(newValue);
    const constrainedOldValue = this.constrainValue(oldValue);
    if (constrainedNewValue !== constrainedOldValue || oldValue !== newValue && (newValue === this.valueRangeProperty.value.min || newValue === this.valueRangeProperty.value.max)) {
      if (newValue === this.valueRangeProperty.value.min && this.minSoundPlayer !== ValueChangeSoundPlayer.USE_MIDDLE_SOUND) {
        this.minSoundPlayer.play();
      } else if (newValue === this.valueRangeProperty.value.max && this.maxSoundPlayer !== ValueChangeSoundPlayer.USE_MIDDLE_SOUND) {
        this.maxSoundPlayer.play();
      } else {
        // Play a middle-range sound, but only if enough time has passed since the last one was played.
        const now = phetAudioContext.currentTime;
        if (now - this.timeOfMostRecentMiddleSound > this.minimumInterMiddleSoundTime) {
          let playbackRateMapper;
          let soundPlayer;
          if (constrainedNewValue > constrainedOldValue) {
            playbackRateMapper = this.middleMovingUpPlaybackRateMapper;
            soundPlayer = this.middleMovingUpSoundPlayer;
          } else {
            playbackRateMapper = this.middleMovingUpPlaybackRateMapper;
            soundPlayer = this.middleMovingDownSoundPlayer;
          }
          if (playbackRateMapper !== NO_PLAYBACK_RATE_CHANGE) {
            // Adjust the playback rate based on the provided new value.  It should be safe to cast this here because of
            // the assertion checks that occur during construction.
            soundPlayer.setPlaybackRate(playbackRateMapper(newValue));
          }
          soundPlayer.play();
          this.timeOfMostRecentMiddleSound = now;
        }
      }
    }
  }

  /**
   * Get an array that contains the next lowest and next highest thresholds for the provided value.  If the provided
   * value is exactly equal to a threshold, only the single threshold value is returned in the array.
   */
  getSurroundingThresholds(value) {
    // A note to future maintainers: JavaScript's floating point implementation was causing all manner of problems with
    // this method.  For instance, when the inter-threshold distance was 0.1 and the provided value was 0.3, JS says
    // that 0.3/0.1 is 2.9999999999999996, so it was tricky to tell that the value was at a threshold and not below it.
    // Therefore, the code below does rounding to intervals that were empirically determined to correct for the floating
    // point problems.  This worked in all test cases, but may not stand the test of time if some unusual slider
    // configurations are needed.  One idea might be to make the rounding interval for this calculation an option to the
    // class, but that felt like overkill at the time of this writing.
    const roundingInterval = 1E-7;
    const segment = Math.floor(Utils.roundToInterval((value - this.valueRangeProperty.value.min) / this.interThresholdDistance, roundingInterval));
    const lowerThreshold = Utils.roundToInterval(segment * this.interThresholdDistance + this.valueRangeProperty.value.min, roundingInterval);
    const thresholdArray = [lowerThreshold];
    if (lowerThreshold !== value) {
      // The provided value wasn't exactly at a threshold.  Since the preceding calculation provided the lower
      // threshold, add the upper one now.
      const upperThreshold = Math.min(Utils.roundToInterval(lowerThreshold + this.interThresholdDistance, roundingInterval), this.valueRangeProperty.value.max);

      // This may seem like an odd test, so here's the story: There are some rare but possible cases where the
      // calculation above doesn't actually yield a higher value due to floating point errors.  When testing in Dec
      // 2022, this was only seen on the Wave Packet Center slider in Fourier Making Waves.  So, only add the upper
      // threshold if it's actually higher than the lower one.  If the upper threshold isn't added, this essentially
      // says that the lower threshold was an exact match for one of the crossing thresholds, which is approximately
      // true and has worked fine in all test cases thus far.
      if (upperThreshold > lowerThreshold) {
        thresholdArray.push(upperThreshold);
      }
    }
    return thresholdArray;
  }

  /**
   * A static instance that makes no sound.  This is generally used as an option value to turn off sound generation.
   */
  static NO_SOUND = new ValueChangeSoundPlayer(new Range(0, 1), {
    middleMovingUpSoundPlayer: nullSoundPlayer,
    minSoundPlayer: nullSoundPlayer,
    maxSoundPlayer: nullSoundPlayer
  });

  /**
   * A static TSoundPlayer instance that is intended to be used as a flag for the min and max sound players to
   * indicate that the middle sound player should be used.
   */
  static USE_MIDDLE_SOUND = {
    play: STUB_SOUND_PLAYER_FUNCTION,
    stop: STUB_SOUND_PLAYER_FUNCTION
  };
}
tambo.register('ValueChangeSoundPlayer', ValueChangeSoundPlayer);
export default ValueChangeSoundPlayer;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJSYW5nZSIsIlV0aWxzIiwib3B0aW9uaXplIiwiZ2VuZXJhbEJvdW5kYXJ5Qm9vcF9tcDMiLCJnZW5lcmFsU29mdENsaWNrX21wMyIsInBoZXRBdWRpb0NvbnRleHQiLCJnZW5lcmFsQm91bmRhcnlCb29wU291bmRQbGF5ZXIiLCJnZW5lcmFsU29mdENsaWNrU291bmRQbGF5ZXIiLCJudWxsU291bmRQbGF5ZXIiLCJ0YW1ibyIsIlNvdW5kQ2xpcCIsIlNvdW5kQ2xpcFBsYXllciIsIkRpc3Bvc2FibGUiLCJUaW55UHJvcGVydHkiLCJERUZBVUxUX05VTUJFUl9PRl9NSURETEVfVEhSRVNIT0xEUyIsIkRFRkFVTFRfTUlOX1NPVU5EX1BMQVlFUiIsInNvdW5kQ2xpcE9wdGlvbnMiLCJpbml0aWFsT3V0cHV0TGV2ZWwiLCJpbml0aWFsUGxheWJhY2tSYXRlIiwiTWF0aCIsInBvdyIsInNvdW5kTWFuYWdlck9wdGlvbnMiLCJjYXRlZ29yeU5hbWUiLCJERUZBVUxUX01JRERMRV9NT1ZJTkdfRE9XTl9TT1VORF9QTEFZRVIiLCJERUZBVUxUX1ZBTFVFX0NPTlNUUkFJTlQiLCJ2YWx1ZSIsInJvdW5kVG9JbnRlcnZhbCIsIk5PX1BMQVlCQUNLX1JBVEVfQ0hBTkdFIiwiU1RVQl9TT1VORF9QTEFZRVJfRlVOQ1RJT04iLCJhc3NlcnQiLCJWYWx1ZUNoYW5nZVNvdW5kUGxheWVyIiwiaW50ZXJUaHJlc2hvbGREaXN0YW5jZSIsImNvbnN0cnVjdG9yIiwidmFsdWVSYW5nZSIsInByb3ZpZGVkT3B0aW9ucyIsIm9wdGlvbnMiLCJtaWRkbGVNb3ZpbmdVcFNvdW5kUGxheWVyIiwibWlkZGxlTW92aW5nRG93blNvdW5kUGxheWVyIiwibWlkZGxlTW92aW5nVXBQbGF5YmFja1JhdGVNYXBwZXIiLCJtaWRkbGVNb3ZpbmdEb3duUGxheWJhY2tSYXRlTWFwcGVyIiwibnVtYmVyT2ZNaWRkbGVUaHJlc2hvbGRzIiwiaW50ZXJUaHJlc2hvbGREZWx0YSIsImNvbnN0cmFpblZhbHVlIiwibWluU291bmRQbGF5ZXIiLCJtYXhTb3VuZFBsYXllciIsIm1pbmltdW1JbnRlck1pZGRsZVNvdW5kVGltZSIsIk51bWJlciIsImlzSW50ZWdlciIsInZhbHVlUmFuZ2VQcm9wZXJ0eSIsInRpbWVPZk1vc3RSZWNlbnRNaWRkbGVTb3VuZCIsInJhbmdlQ2hhbmdlTGlzdGVuZXIiLCJnZXRMZW5ndGgiLCJsaW5rIiwiZGlzcG9zZUVtaXR0ZXIiLCJhZGRMaXN0ZW5lciIsInVubGluayIsInBsYXlTb3VuZElmVGhyZXNob2xkUmVhY2hlZCIsIm5ld1ZhbHVlIiwib2xkVmFsdWUiLCJjb25zdHJhaW5lZE5ld1ZhbHVlIiwiY29uc3RyYWluZWRPbGRWYWx1ZSIsIm9sZFZhbHVlU3Vycm91bmRpbmdUaHJlc2hvbGRzIiwiZ2V0U3Vycm91bmRpbmdUaHJlc2hvbGRzIiwibmV3VmFsdWVTdXJyb3VuZGluZ1RocmVzaG9sZHMiLCJ0aHJlc2hvbGRDcm9zc2VkIiwibGVuZ3RoIiwiYWJzIiwidGhyZXNob2xkUmVhY2hlZCIsIm1pbiIsIm1heCIsInBsYXlTb3VuZEZvclZhbHVlQ2hhbmdlIiwiVVNFX01JRERMRV9TT1VORCIsInBsYXkiLCJub3ciLCJjdXJyZW50VGltZSIsInBsYXliYWNrUmF0ZU1hcHBlciIsInNvdW5kUGxheWVyIiwic2V0UGxheWJhY2tSYXRlIiwicm91bmRpbmdJbnRlcnZhbCIsInNlZ21lbnQiLCJmbG9vciIsImxvd2VyVGhyZXNob2xkIiwidGhyZXNob2xkQXJyYXkiLCJ1cHBlclRocmVzaG9sZCIsInB1c2giLCJOT19TT1VORCIsInN0b3AiLCJyZWdpc3RlciJdLCJzb3VyY2VzIjpbIlZhbHVlQ2hhbmdlU291bmRQbGF5ZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMjItMjAyNCwgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXHJcblxyXG4vKipcclxuICogVmFsdWVDaGFuZ2VTb3VuZFBsYXllciBwbGF5cyBzb3VuZHMgYmFzZWQgb24gY2hhbmdlcyB0byBhIG51bWVyaWNhbCB2YWx1ZS4gIEl0IHdhcyBpbml0aWFsbHkgY3JlYXRlZCBmb3Igc3VwcG9ydGluZ1xyXG4gKiBzb3VuZCBnZW5lcmF0aW9uIGluIFBoRVQncyBTbGlkZXIgY2xhc3MgYW5kIHZhcmlhdGlvbnMgdGhlcmVvZiwgYnV0IGl0IG1heSBoYXZlIG90aGVyIGFwcGxpY2F0aW9ucy5cclxuICpcclxuICogVGhpcyBjbGFzcyBkb2VzIG5vdCBleHRlbmQgU291bmRHZW5lcmF0b3IgYW5kIGlzIG5vdCBpdHNlbGYgYWRkZWQgdG8gdGhlIHNvdW5kIG1hbmFnZXIuICBJdCBpcyBpbnN0ZWFkIGEgcGxheWVyIG9mXHJcbiAqIGEgc2V0IG9mIHNvdW5kcywgZWFjaCBvZiB3aGljaCBzaG91bGQgYmUgcmVnaXN0ZXJlZCB3aXRoIHRoZSBzb3VuZCBtYW5hZ2VyIGVsc2V3aGVyZS5cclxuICpcclxuICogQmVjYXVzZSB0aGUgc291bmRzIHNob3VsZCBvbmx5IGJlIHByb2R1Y2VkIHdoZW4gdXNlcnMgZGlyZWN0bHkgY2hhbmdlIGEgdmFsdWUsIGFuZCBub3QgaW4gc2lkZS1lZmZlY3QtaXNoIHNpdHVhdGlvbnNcclxuICogKHN1Y2ggYXMgYSByZXNldCksIHRoaXMgY2xhc3MgZG9lcyBub3QgbW9uaXRvciBhIFByb3BlcnR5LiAgSW5zdGVhZCwgaXQgcHJvdmlkZXMgbWV0aG9kcyB0aGF0IGNhbiBiZSB1c2VkIHRvIGV2YWx1YXRlXHJcbiAqIGNoYW5nZXMgaW4gYSB2YWx1ZSBhbmQgcG90ZW50aWFsbHkgcGxheSBzb3VuZHMgKG9yIG5vdCwgaWYgdGhlIGNoYW5nZSBkb2Vzbid0IHdhcnJhbnQgc291bmQgZ2VuZXJhdGlvbiksIGFuZCBpdCBpc1xyXG4gKiB0aGUgY2xpZW50J3MgcmVzcG9uc2liaWxpdHkgdG8ga25vdyB0aGUgc2l0dWF0aW9ucyBpbiB3aGljaCB0aGVzZSBtZXRob2RzIHNob3VsZCBiZSBjYWxsZWQuICBPZnRlbiB0aGVzZSBtZXRob2RzIHdpbGxcclxuICogYmUgY2FsbGVkIGluIGRyYWcgaGFuZGxlcnMgYW5kIG90aGVyIGNvZGUgdGhhdCBoYW5kbGVzIHVzZXIgaW5wdXQuXHJcbiAqXHJcbiAqIEBhdXRob3IgSm9obiBCbGFuY28gKFBoRVQgSW50ZXJhY3RpdmUgU2ltdWxhdGlvbnMpXHJcbiAqL1xyXG5cclxuaW1wb3J0IFJhbmdlIGZyb20gJy4uLy4uLy4uL2RvdC9qcy9SYW5nZS5qcyc7XHJcbmltcG9ydCBVdGlscyBmcm9tICcuLi8uLi8uLi9kb3QvanMvVXRpbHMuanMnO1xyXG5pbXBvcnQgb3B0aW9uaXplIGZyb20gJy4uLy4uLy4uL3BoZXQtY29yZS9qcy9vcHRpb25pemUuanMnO1xyXG5pbXBvcnQgZ2VuZXJhbEJvdW5kYXJ5Qm9vcF9tcDMgZnJvbSAnLi4vLi4vc291bmRzL2dlbmVyYWxCb3VuZGFyeUJvb3BfbXAzLmpzJztcclxuaW1wb3J0IGdlbmVyYWxTb2Z0Q2xpY2tfbXAzIGZyb20gJy4uLy4uL3NvdW5kcy9nZW5lcmFsU29mdENsaWNrX21wMy5qcyc7XHJcbmltcG9ydCBUU291bmRQbGF5ZXIgZnJvbSAnLi4vVFNvdW5kUGxheWVyLmpzJztcclxuaW1wb3J0IHBoZXRBdWRpb0NvbnRleHQgZnJvbSAnLi4vcGhldEF1ZGlvQ29udGV4dC5qcyc7XHJcbmltcG9ydCBnZW5lcmFsQm91bmRhcnlCb29wU291bmRQbGF5ZXIgZnJvbSAnLi4vc2hhcmVkLXNvdW5kLXBsYXllcnMvZ2VuZXJhbEJvdW5kYXJ5Qm9vcFNvdW5kUGxheWVyLmpzJztcclxuaW1wb3J0IGdlbmVyYWxTb2Z0Q2xpY2tTb3VuZFBsYXllciBmcm9tICcuLi9zaGFyZWQtc291bmQtcGxheWVycy9nZW5lcmFsU29mdENsaWNrU291bmRQbGF5ZXIuanMnO1xyXG5pbXBvcnQgbnVsbFNvdW5kUGxheWVyIGZyb20gJy4uL3NoYXJlZC1zb3VuZC1wbGF5ZXJzL251bGxTb3VuZFBsYXllci5qcyc7XHJcbmltcG9ydCB0YW1ibyBmcm9tICcuLi90YW1iby5qcyc7XHJcbmltcG9ydCBTb3VuZENsaXAgZnJvbSAnLi9Tb3VuZENsaXAuanMnO1xyXG5pbXBvcnQgU291bmRDbGlwUGxheWVyIGZyb20gJy4vU291bmRDbGlwUGxheWVyLmpzJztcclxuaW1wb3J0IERpc3Bvc2FibGUsIHsgRGlzcG9zYWJsZU9wdGlvbnMgfSBmcm9tICcuLi8uLi8uLi9heG9uL2pzL0Rpc3Bvc2FibGUuanMnO1xyXG5pbXBvcnQgVFJlYWRPbmx5UHJvcGVydHkgZnJvbSAnLi4vLi4vLi4vYXhvbi9qcy9UUmVhZE9ubHlQcm9wZXJ0eS5qcyc7XHJcbmltcG9ydCBUaW55UHJvcGVydHkgZnJvbSAnLi4vLi4vLi4vYXhvbi9qcy9UaW55UHJvcGVydHkuanMnO1xyXG5cclxuLy8gY29uc3RhbnRzXHJcbmNvbnN0IERFRkFVTFRfTlVNQkVSX09GX01JRERMRV9USFJFU0hPTERTID0gNTsgLy8gZmFpcmx5IGFyYml0cmFyeVxyXG5jb25zdCBERUZBVUxUX01JTl9TT1VORF9QTEFZRVIgPSBuZXcgU291bmRDbGlwUGxheWVyKCBnZW5lcmFsQm91bmRhcnlCb29wX21wMywge1xyXG4gIHNvdW5kQ2xpcE9wdGlvbnM6IHtcclxuICAgIGluaXRpYWxPdXRwdXRMZXZlbDogMC4yLFxyXG4gICAgaW5pdGlhbFBsYXliYWNrUmF0ZTogMSAvIE1hdGgucG93KCAyLCAxIC8gNiApIC8vIGEgbWFqb3Igc2Vjb25kIGxvd2VyXHJcbiAgfSxcclxuICBzb3VuZE1hbmFnZXJPcHRpb25zOiB7IGNhdGVnb3J5TmFtZTogJ3VzZXItaW50ZXJmYWNlJyB9XHJcbn0gKTtcclxuY29uc3QgREVGQVVMVF9NSURETEVfTU9WSU5HX0RPV05fU09VTkRfUExBWUVSID0gbmV3IFNvdW5kQ2xpcFBsYXllciggZ2VuZXJhbFNvZnRDbGlja19tcDMsIHtcclxuICBzb3VuZENsaXBPcHRpb25zOiB7XHJcbiAgICBpbml0aWFsT3V0cHV0TGV2ZWw6IDAuMixcclxuICAgIGluaXRpYWxQbGF5YmFja1JhdGU6IDEgLyBNYXRoLnBvdyggMiwgMSAvIDYgKSAvLyBhIG1ham9yIHNlY29uZCBsb3dlclxyXG4gIH0sXHJcbiAgc291bmRNYW5hZ2VyT3B0aW9uczogeyBjYXRlZ29yeU5hbWU6ICd1c2VyLWludGVyZmFjZScgfVxyXG59ICk7XHJcblxyXG4vLyBEZWZpbmUgYSBkZWZhdWx0IGNvbnN0cmFpbnQgZnVuY3Rpb24uICBTZWUgdGhlIGRvY3MgZm9yIHRoZSBhc3NvY2lhdGVkIG9wdGlvbiBmb3IgbW9yZSBpbmZvLiAgVGhlIGludGVydmFsIHZhbHVlIHVzZWRcclxuLy8gaGVyZSB3YXMgZW1waXJpY2FsbHkgZGV0ZXJtaW5lZC5cclxuY29uc3QgREVGQVVMVF9WQUxVRV9DT05TVFJBSU5UID0gKCB2YWx1ZTogbnVtYmVyICkgPT4gVXRpbHMucm91bmRUb0ludGVydmFsKCB2YWx1ZSwgMC4wMDAwMDAwMDEgKTtcclxuXHJcbi8vIEEgXCJuby1vcFwiIGZ1bmN0aW9uIGZvciBtYXBwaW5nIHBpdGNoIHZhbHVlcy4gIEFsd2F5cyByZXR1cm5zIG9uZSwgd2hpY2ggc2lnbmlmaWVzIG5vIGNoYW5nZSB0byB0aGUgcGxheWJhY2sgcmF0ZS5cclxuY29uc3QgTk9fUExBWUJBQ0tfUkFURV9DSEFOR0UgPSAoKSA9PiAxO1xyXG5cclxuLy8gQSBmdW5jdGlvbiBmb3IgYSBzdHViYmVkIHNvdW5kIHBsYXllciwgc2VlIHVzYWdlLlxyXG5jb25zdCBTVFVCX1NPVU5EX1BMQVlFUl9GVU5DVElPTiA9ICgpOiB2b2lkID0+IHtcclxuICBhc3NlcnQgJiYgYXNzZXJ0KCBmYWxzZSwgJ0NvZGUgZXJyb3I6IFRoaXMgaXMgYSBzdHViYmVkIGZ1bmN0aW9uIGFuZCBzaG91bGQgbmV2ZXIgYmUgaW52b2tlZC4nICk7XHJcbn07XHJcblxyXG50eXBlIFNlbGZPcHRpb25zID0ge1xyXG5cclxuICAvLyBUaGUgc291bmQgcGxheWVyIGZvciBtb3ZlbWVudCBpbiB0aGUgbWlkZGxlIG9mIHRoZSByYW5nZSBpbiB0aGUgdXAgZGlyZWN0aW9uLlxyXG4gIG1pZGRsZU1vdmluZ1VwU291bmRQbGF5ZXI/OiBUU291bmRQbGF5ZXIgfCBTb3VuZENsaXA7XHJcblxyXG4gIC8vIFRoZSBzb3VuZCBwbGF5ZXIgZm9yIG1vdmVtZW50IGluIHRoZSBtaWRkbGUgb2YgdGhlIHJhbmdlIGluIHRoZSBkb3duIGRpcmVjdGlvbi5cclxuICBtaWRkbGVNb3ZpbmdEb3duU291bmRQbGF5ZXI/OiBUU291bmRQbGF5ZXIgfCBTb3VuZENsaXA7XHJcblxyXG4gIC8vIEZ1bmN0aW9ucyB0aGF0LCBpZiBwcm92aWRlZCwgd2lsbCBhbHRlciB0aGUgcGxheWJhY2sgcmF0ZXMgb2YgdGhlIG1pZGRsZSBzb3VuZHMgYmFzZWQgb24gdGhlIHByb3ZpZGVkIHZhbHVlLlxyXG4gIG1pZGRsZU1vdmluZ1VwUGxheWJhY2tSYXRlTWFwcGVyPzogKCB2YWx1ZTogbnVtYmVyICkgPT4gbnVtYmVyO1xyXG4gIG1pZGRsZU1vdmluZ0Rvd25QbGF5YmFja1JhdGVNYXBwZXI/OiAoIHZhbHVlOiBudW1iZXIgKSA9PiBudW1iZXI7XHJcblxyXG4gIC8vIFRoZSBudW1iZXIgb2YgdGhyZXNob2xkcyB0aGF0LCB3aGVuIHJlYWNoZWQgb3IgY3Jvc3NlZCwgd2lsbCBjYXVzZSBhIHNvdW5kIHRvIGJlIHBsYXllZCB3aGVuIGNoZWNraW5nIHZhbHVlIGNoYW5nZXNcclxuICAvLyBhZ2FpbnN0IHRocmVzaG9sZHMuICBJbiBvdGhlciB3b3JkcywgdGhpcyBpcyB0aGUgbnVtYmVyIG9mIHRocmVzaG9sZHMgdGhhdCBleGlzdCBiZXR3ZWVuIHRoZSBtaW4gYW5kIG1heCB2YWx1ZXMuXHJcbiAgLy8gVGhpcyBhc3N1bWVzIHN5bW1ldHJpYyBzcGFjaW5nIG9mIHRoZSB0aHJlc2hvbGRzLCBhbmQgaXMgbm90IGNvbXBhdGlibGUgd2l0aCBleHBsaWNpdGx5IHNldHRpbmcgb2YgdGhlICdkZWx0YSdcclxuICAvLyB2YWx1ZS5cclxuICBudW1iZXJPZk1pZGRsZVRocmVzaG9sZHM/OiBudW1iZXIgfCBudWxsO1xyXG5cclxuICAvLyBUaGUgZGVsdGEgdmFsdWUgYmV0d2VlbiB0aHJlc2hvbGRzIHRoYXQgYXJlIHVzZWQgdG8gZGV0ZXJtaW5lIHdoZW4gc291bmRzIGFyZSBwbGF5ZWQuICBUaGlzIGlzIGFuIGFsdGVybmF0aXZlIHdheVxyXG4gIC8vIHRvIHNwZWNpZnkgdGhlIHRocmVzaG9sZHMgYW5kIHNob3VsZCBvbmx5IGJlIHVzZWQgd2hlbiBudW1iZXJPZk1pZGRsZVRocmVzaG9sZHMgY2FuJ3QsIHdoaWNoIGlzIGdlbmVyYWxseSB3aGVuIGFcclxuICAvLyB2ZXJ5IHNwZWNpZmljIGRlbHRhIGlzIHJlcXVpcmVkIGFuZCBoYXZpbmcgcGVyZmVjdGx5IGV2ZW4gdGhyZXNob2xkcyBpc24ndCBjb21wbGV0ZWx5IGRlc2lyYWJsZS4gIE5vdGUgdGhhdCB0aGlzXHJcbiAgLy8gYXBwcm9hY2ggd2lsbCBvZnRlbiBsZWFkIHRvIGEgc2l0dWF0aW9uIHdoZXJlIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBsYXN0IHRocmVzaG9sZCBhbmQgdGhlIGVuZCBvZiB0aGUgcmFuZ2VcclxuICAvLyBpc24ndCB0aGUgc2FtZSBhcyB0aGUgZGlzdGFuY2UgYmV0d2VlbiBhbGwgdGhlIG90aGVyIHRocmVzaG9sZHMuICBUaGlzIHdhcyBpbml0aWFsbHkgYWRkZWQgdG8gc3VwcG9ydFxyXG4gIC8vIE51bWJlckNvbnRyb2wsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vcGhldHNpbXMvc3VuL2lzc3Vlcy82OTcuICBUaGlzIGlzIGluY29tcGF0aWJsZSB3aXRoIHNwZWNpZnlpbmdcclxuICAvLyBudW1iZXJPZk1pZGRsZVRocmVzaG9sZHMuXHJcbiAgaW50ZXJUaHJlc2hvbGREZWx0YT86IG51bWJlciB8IG51bGw7XHJcblxyXG4gIC8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBjb25zdHJhaW4gdGhlIHZhbHVlcyB1c2VkIGZvciB0aHJlc2hvbGRzIGFuZCB2YWx1ZSBjb21wYXJpc29ucy4gIFdpdGhvdXQgdGhpcywgdGhlcmUgY2FuXHJcbiAgLy8gc29tZXRpbWVzIGJlIGNhc2VzIHdoZXJlIHNsaWdodCB2YWx1ZSBkaWZmZXJlbmNlcywgc3VjaCBhcyB0aG9zZSBjYXVzZWQgYnkgZmxvYXRpbmcgcG9pbnQgaW5hY2N1cmFjaWVzLCBjYW4gY2F1c2VcclxuICAvLyBzb3VuZHMgbm90IHRvIGJlIGdlbmVyYXRlZCB3aGVuIHRoZXkgc2hvdWxkLiAgVXNlIF8uaWRlbnRpdHkgZm9yIGEgXCJuby1vcFwiIGlmIG5vIGNvbnN0cmFpbnQgaXMgbmVlZGVkLiAgVGhpcyBpc1xyXG4gIC8vIHVzZWQgZm9yIG11bHRpcGxlIHZhbHVlcywgYnV0IGlzIGNhbGxlZCBcImNvbnN0cmFpblZhbHVlXCIgcmF0aGVyIHRoYW4gXCJjb25zdHJhaW5WYWx1ZXNcIiB0byBtYXRjaCB0aGUgcHJlLWV4aXN0aW5nXHJcbiAgLy8gb3B0aW9uIG5hbWUgaW4gdGhlIFNsaWRlciBjbGFzcy4gIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcGhldHNpbXMvc3VuL2lzc3Vlcy82OTcjaXNzdWVjb21tZW50LTEwNjY4NTAxODEuXHJcbiAgY29uc3RyYWluVmFsdWU/OiAoIG46IG51bWJlciApID0+IG51bWJlcjtcclxuXHJcbiAgLy8gVGhlIHNvdW5kIHBsYXllciB0aGF0IGlzIHVzZWQgdG8gaW5kaWNhdGUgdGhlIG1pbmltdW0gdmFsdWUuXHJcbiAgbWluU291bmRQbGF5ZXI/OiBUU291bmRQbGF5ZXI7XHJcblxyXG4gIC8vIFRoZSBzb3VuZCBwbGF5ZXIgdGhhdCBpcyB1c2VkIHRvIGluZGljYXRlIHRoZSBtYXhpbXVtIHZhbHVlLlxyXG4gIG1heFNvdW5kUGxheWVyPzogVFNvdW5kUGxheWVyO1xyXG5cclxuICAvLyBUaGUgbWluaW11bSBhbW91bnQgb2YgdGltZSB0aGF0IG11c3QgcGFzcyBhZnRlciBhIG1pZGRsZSBzb3VuZCBpcyBwbGF5ZWQgYmVmb3JlIGFub3RoZXIgY2FuIGJlIHBsYXllZC4gIFRoaXMgaXNcclxuICAvLyBoZWxwZnVsIHdoZW4gYSBsb3Qgb2YgdmFsdWUgY2hhbmdlcyBjYW4gb2NjdXIgcmFwaWRseSBhbmQgdGh1cyBjcmVhdGUgYW4gb3ZlcndoZWxtaW5nIGFtb3VudCBvZiBzb3VuZC5cclxuICBtaW5pbXVtSW50ZXJNaWRkbGVTb3VuZFRpbWU/OiBudW1iZXI7XHJcbn07XHJcblxyXG5leHBvcnQgdHlwZSBWYWx1ZUNoYW5nZVNvdW5kUGxheWVyT3B0aW9ucyA9IFNlbGZPcHRpb25zICYgRGlzcG9zYWJsZU9wdGlvbnM7XHJcblxyXG5jbGFzcyBWYWx1ZUNoYW5nZVNvdW5kUGxheWVyIGV4dGVuZHMgRGlzcG9zYWJsZSB7XHJcblxyXG4gIC8vIFRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSB0aHJlc2hvbGQgdmFsdWVzIGF0IHdoaWNoIHNvdW5kcyB3aWxsIGJlIHBsYXllZC5cclxuICBwcml2YXRlIGludGVyVGhyZXNob2xkRGlzdGFuY2U6IG51bWJlciA9IERFRkFVTFRfTlVNQkVSX09GX01JRERMRV9USFJFU0hPTERTO1xyXG5cclxuICAvLyByYW5nZSBvZiB2YWx1ZXMgdGhhdCB0aGlzIHNob3VsZCBleHBlY3QgdG8gaGFuZGxlXHJcbiAgcHJpdmF0ZSByZWFkb25seSB2YWx1ZVJhbmdlUHJvcGVydHk6IFRSZWFkT25seVByb3BlcnR5PFJhbmdlPjtcclxuXHJcbiAgLy8gc291bmQgcGxheWVyIGZvciBtb3ZlbWVudCBpbiB0aGUgbWlkZGxlIG9mIHRoZSByYW5nZSAoaS5lLiBub3QgYXQgbWluIG9yIG1heCkgYW5kIG1vdmluZyB1cFxyXG4gIHByaXZhdGUgcmVhZG9ubHkgbWlkZGxlTW92aW5nVXBTb3VuZFBsYXllcjogVFNvdW5kUGxheWVyIHwgU291bmRDbGlwO1xyXG5cclxuICAvLyBzb3VuZCBwbGF5ZXIgZm9yIG1vdmVtZW50IGluIHRoZSBtaWRkbGUgb2YgdGhlIHJhbmdlIChpLmUuIG5vdCBhdCBtaW4gb3IgbWF4KSBhbmQgbW92aW5nIGRvd25cclxuICBwcml2YXRlIHJlYWRvbmx5IG1pZGRsZU1vdmluZ0Rvd25Tb3VuZFBsYXllcjogVFNvdW5kUGxheWVyIHwgU291bmRDbGlwO1xyXG5cclxuICAvLyBwbGF5YmFjayByYXRlIG1hcHBlciBmb3IgbWlkZGxlIHNvdW5kcyBhbmQgdXB3YXJkIHZhbHVlIGNoYW5nZXNcclxuICBwcml2YXRlIHJlYWRvbmx5IG1pZGRsZU1vdmluZ1VwUGxheWJhY2tSYXRlTWFwcGVyOiAoIHZhbHVlOiBudW1iZXIgKSA9PiBudW1iZXI7XHJcblxyXG4gIC8vIHBsYXliYWNrIHJhdGUgbWFwcGVyIGZvciBtaWRkbGUgc291bmRzIGFuZCBkb3dud2FyZCB2YWx1ZSBjaGFuZ2VzXHJcbiAgcHJpdmF0ZSByZWFkb25seSBtaWRkbGVNb3ZpbmdEb3duUGxheWJhY2tSYXRlTWFwcGVyOiAoIHZhbHVlOiBudW1iZXIgKSA9PiBudW1iZXI7XHJcblxyXG4gIC8vIFNvdW5kIHBsYXllcnMgZm9yIHRoZSBtaW4gYW5kIG1heCB2YWx1ZXMuICBJZiBub3RoaW5nIGlzIHByb3ZpZGVkIGEgZGVmYXVsdCB3aWxsIGJlIHVzZWQuICBJZiB0aGUgZmxhZ1xyXG4gIC8vIFVTRV9NSURETEVfU09VTkQgaXMgcHJvdmlkZWQsIHRoZSBzb3VuZCBwbGF5ZXIgZm9yIHRoZSBtaWRkbGUgcmFuZ2Ugd2lsbCBiZSB1c2VkLlxyXG4gIHByaXZhdGUgcmVhZG9ubHkgbWluU291bmRQbGF5ZXI6IFRTb3VuZFBsYXllcjtcclxuICBwcml2YXRlIHJlYWRvbmx5IG1heFNvdW5kUGxheWVyOiBUU291bmRQbGF5ZXI7XHJcblxyXG4gIC8vIG1pbiB0aW1lIGJldHdlZW4gcGxheWluZyBvbmUgbWlkZGxlIHNvdW5kIGFuZCB0aGUgbmV4dFxyXG4gIHByaXZhdGUgcmVhZG9ubHkgbWluaW11bUludGVyTWlkZGxlU291bmRUaW1lOiBudW1iZXI7XHJcblxyXG4gIC8vIGZ1bmN0aW9uIHRvIGNvbnN0cmFpbiB0aGUgdmFsdWVzIHVzZWQgZm9yIHRocmVzaG9sZHMgYW5kIGNvbXBhcmlzb25zXHJcbiAgcHJpdmF0ZSByZWFkb25seSBjb25zdHJhaW5WYWx1ZTogKCBuOiBudW1iZXIgKSA9PiBudW1iZXI7XHJcblxyXG4gIC8vIHRpbWUgb2YgbW9zdCByZWNlbnRseSBwbGF5ZWQgbWlkZGxlIHNvdW5kLCB1c2VkIHRvIG1vZGVyYXRlIHRoZSByYXRlIGF0IHdoaWNoIHRoZXNlIHNvdW5kcyBhcmUgcGxheWVkXHJcbiAgcHJpdmF0ZSB0aW1lT2ZNb3N0UmVjZW50TWlkZGxlU291bmQ6IG51bWJlcjtcclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHZhbHVlUmFuZ2UgLSB0aGUgcmFuZ2Ugb2YgdmFsdWVzIGV4cGVjdGVkIGFuZCBvdmVyIHdoaWNoIHNvdW5kcyB3aWxsIGJlIHBsYXllZFxyXG4gICAqIEBwYXJhbSBbcHJvdmlkZWRPcHRpb25zXVxyXG4gICAqL1xyXG4gIHB1YmxpYyBjb25zdHJ1Y3RvciggdmFsdWVSYW5nZTogUmFuZ2UgfCBUUmVhZE9ubHlQcm9wZXJ0eTxSYW5nZT4sIHByb3ZpZGVkT3B0aW9ucz86IFZhbHVlQ2hhbmdlU291bmRQbGF5ZXJPcHRpb25zICkge1xyXG5cclxuICAgIGNvbnN0IG9wdGlvbnMgPSBvcHRpb25pemU8VmFsdWVDaGFuZ2VTb3VuZFBsYXllck9wdGlvbnMsIFNlbGZPcHRpb25zLCBEaXNwb3NhYmxlT3B0aW9ucz4oKSgge1xyXG4gICAgICBtaWRkbGVNb3ZpbmdVcFNvdW5kUGxheWVyOiBnZW5lcmFsU29mdENsaWNrU291bmRQbGF5ZXIsXHJcbiAgICAgIG1pZGRsZU1vdmluZ0Rvd25Tb3VuZFBsYXllcjogREVGQVVMVF9NSURETEVfTU9WSU5HX0RPV05fU09VTkRfUExBWUVSLFxyXG4gICAgICBtaWRkbGVNb3ZpbmdVcFBsYXliYWNrUmF0ZU1hcHBlcjogTk9fUExBWUJBQ0tfUkFURV9DSEFOR0UsXHJcbiAgICAgIG1pZGRsZU1vdmluZ0Rvd25QbGF5YmFja1JhdGVNYXBwZXI6IE5PX1BMQVlCQUNLX1JBVEVfQ0hBTkdFLFxyXG4gICAgICBudW1iZXJPZk1pZGRsZVRocmVzaG9sZHM6IG51bGwsXHJcbiAgICAgIGludGVyVGhyZXNob2xkRGVsdGE6IG51bGwsXHJcbiAgICAgIGNvbnN0cmFpblZhbHVlOiBERUZBVUxUX1ZBTFVFX0NPTlNUUkFJTlQsXHJcbiAgICAgIG1pblNvdW5kUGxheWVyOiBERUZBVUxUX01JTl9TT1VORF9QTEFZRVIsXHJcbiAgICAgIG1heFNvdW5kUGxheWVyOiBnZW5lcmFsQm91bmRhcnlCb29wU291bmRQbGF5ZXIsXHJcbiAgICAgIG1pbmltdW1JbnRlck1pZGRsZVNvdW5kVGltZTogMC4wMzUgLy8gZW1waXJpY2FsbHkgZGV0ZXJtaW5lZFxyXG4gICAgfSwgcHJvdmlkZWRPcHRpb25zICk7XHJcblxyXG4gICAgLy8gb3B0aW9uIHZhbGlkaXR5IGNoZWNrc1xyXG4gICAgYXNzZXJ0ICYmIGFzc2VydChcclxuICAgIG9wdGlvbnMubWluaW11bUludGVyTWlkZGxlU291bmRUaW1lID49IDAgJiYgb3B0aW9ucy5taW5pbXVtSW50ZXJNaWRkbGVTb3VuZFRpbWUgPCAxLFxyXG4gICAgICBgdW5yZWFzb25hYmxlIHZhbHVlIGZvciBtaW5pbXVtSW50ZXJNaWRkbGVTb3VuZFRpbWU6ICR7b3B0aW9ucy5taW5pbXVtSW50ZXJNaWRkbGVTb3VuZFRpbWV9YFxyXG4gICAgKTtcclxuICAgIGFzc2VydCAmJiBhc3NlcnQoXHJcbiAgICAgIG9wdGlvbnMubnVtYmVyT2ZNaWRkbGVUaHJlc2hvbGRzID09PSBudWxsIHx8IG9wdGlvbnMuaW50ZXJUaHJlc2hvbGREZWx0YSA9PT0gbnVsbCxcclxuICAgICAgJ2Nhbm5vdCBzcGVjaWZ5IGJvdGggdGhlIG51bWJlciBvZiBtaWRkbGUgdGhyZXNob2xkcyBhbmQgdGhlIGludGVyLXRocmVzaG9sZCBkZWx0YSdcclxuICAgICk7XHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KFxyXG4gICAgICBvcHRpb25zLm51bWJlck9mTWlkZGxlVGhyZXNob2xkcyA9PT0gbnVsbCB8fCBOdW1iZXIuaXNJbnRlZ2VyKCBvcHRpb25zLm51bWJlck9mTWlkZGxlVGhyZXNob2xkcyApLFxyXG4gICAgICAnbnVtYmVyT2ZNaWRkbGVUaHJlc2hvbGRzIG11c3QgYmUgYW4gaW50ZWdlciBpZiBzcGVjaWZpZWQnXHJcbiAgICApO1xyXG5cclxuICAgIC8vIElmIGEgcGxheWJhY2sgcmF0ZSBtYXBwZXIgaXMgcHJvdmlkZWQgZm9yIGEgbWlkZGxlIHRocmVzaG9sZCBzb3VuZCwgdGhlIHByb3ZpZGVkIHNvdW5kIHBsYXllciBtdXN0IHN1cHBvcnRcclxuICAgIC8vIHNldHRpbmcgYSBkaWZmZXJlbnQgcGxheWJhY2sgcmF0ZS4gIEl0IHNob3VsZCBOT1QgYmUgYSBTb3VuZENsaXBQbGF5ZXIsIHNpbmNlIHRob3NlIGFyZSBkZXNpZ25lZCB0byBiZSBzaGFyZWQsIHNvXHJcbiAgICAvLyB0aGUgcGxheWJhY2sgcmF0ZSBzaG91bGQgbmV2ZXIgYmUgY2hhbmdlZC4gIFRoZSBmb2xsb3dpbmcgYXNzZXJ0aW9ucyBhcmUgaW50ZW5kZWQgdG8gdmVyaWZ5IHRoYXQgdGhlc2Ugb3B0aW9uc1xyXG4gICAgLy8gYXJlIHNldCBpbiBhIGNvbXBhdGlibGUgd2F5LlxyXG4gICAgYXNzZXJ0ICYmIGFzc2VydChcclxuICAgICAgb3B0aW9ucy5taWRkbGVNb3ZpbmdVcFBsYXliYWNrUmF0ZU1hcHBlciA9PT0gTk9fUExBWUJBQ0tfUkFURV9DSEFOR0UgfHxcclxuICAgICAgb3B0aW9ucy5taWRkbGVNb3ZpbmdVcFNvdW5kUGxheWVyIGluc3RhbmNlb2YgU291bmRDbGlwLFxyXG4gICAgICAnYSBzb3VuZCBwbGF5ZXIgdGhhdCBzdXBwb3J0cyBwbGF5YmFjayByYXRlIGNoYW5nZXMgaXMgcmVxdWlyZWQgd2hlbiBhIHBsYXliYWNrIHJhdGUgbWFwcGVyIGlzIHVzZWQnXHJcbiAgICApO1xyXG4gICAgYXNzZXJ0ICYmIGFzc2VydChcclxuICAgICAgb3B0aW9ucy5taWRkbGVNb3ZpbmdEb3duUGxheWJhY2tSYXRlTWFwcGVyID09PSBOT19QTEFZQkFDS19SQVRFX0NIQU5HRSB8fFxyXG4gICAgICBvcHRpb25zLm1pZGRsZU1vdmluZ0Rvd25Tb3VuZFBsYXllciBpbnN0YW5jZW9mIFNvdW5kQ2xpcCxcclxuICAgICAgJ2Egc291bmQgcGxheWVyIHRoYXQgc3VwcG9ydHMgcGxheWJhY2sgcmF0ZSBjaGFuZ2VzIGlzIHJlcXVpcmVkIHdoZW4gYSBwbGF5YmFjayByYXRlIG1hcHBlciBpcyB1c2VkJ1xyXG4gICAgKTtcclxuXHJcbiAgICAvLyBTZXQgZGVmYXVsdCBudW1iZXIgb2YgbWlkZGxlIHRocmVzaG9sZHMgaWYgbmVjZXNzYXJ5LlxyXG4gICAgaWYgKCBvcHRpb25zLm51bWJlck9mTWlkZGxlVGhyZXNob2xkcyA9PT0gbnVsbCAmJiBvcHRpb25zLmludGVyVGhyZXNob2xkRGVsdGEgPT09IG51bGwgKSB7XHJcbiAgICAgIG9wdGlvbnMubnVtYmVyT2ZNaWRkbGVUaHJlc2hvbGRzID0gREVGQVVMVF9OVU1CRVJfT0ZfTUlERExFX1RIUkVTSE9MRFM7XHJcbiAgICB9XHJcblxyXG4gICAgc3VwZXIoIG9wdGlvbnMgKTtcclxuXHJcbiAgICB0aGlzLnZhbHVlUmFuZ2VQcm9wZXJ0eSA9IHZhbHVlUmFuZ2UgaW5zdGFuY2VvZiBSYW5nZSA/IG5ldyBUaW55UHJvcGVydHkoIHZhbHVlUmFuZ2UgKSA6IHZhbHVlUmFuZ2U7XHJcbiAgICB0aGlzLm1pZGRsZU1vdmluZ1VwU291bmRQbGF5ZXIgPSBvcHRpb25zLm1pZGRsZU1vdmluZ1VwU291bmRQbGF5ZXI7XHJcbiAgICB0aGlzLm1pZGRsZU1vdmluZ0Rvd25Tb3VuZFBsYXllciA9IG9wdGlvbnMubWlkZGxlTW92aW5nRG93blNvdW5kUGxheWVyO1xyXG4gICAgdGhpcy5taWRkbGVNb3ZpbmdVcFBsYXliYWNrUmF0ZU1hcHBlciA9IG9wdGlvbnMubWlkZGxlTW92aW5nVXBQbGF5YmFja1JhdGVNYXBwZXI7XHJcbiAgICB0aGlzLm1pZGRsZU1vdmluZ0Rvd25QbGF5YmFja1JhdGVNYXBwZXIgPSBvcHRpb25zLm1pZGRsZU1vdmluZ0Rvd25QbGF5YmFja1JhdGVNYXBwZXI7XHJcbiAgICB0aGlzLm1pblNvdW5kUGxheWVyID0gb3B0aW9ucy5taW5Tb3VuZFBsYXllcjtcclxuICAgIHRoaXMubWF4U291bmRQbGF5ZXIgPSBvcHRpb25zLm1heFNvdW5kUGxheWVyO1xyXG4gICAgdGhpcy5taW5pbXVtSW50ZXJNaWRkbGVTb3VuZFRpbWUgPSBvcHRpb25zLm1pbmltdW1JbnRlck1pZGRsZVNvdW5kVGltZTtcclxuICAgIHRoaXMudGltZU9mTW9zdFJlY2VudE1pZGRsZVNvdW5kID0gMDtcclxuICAgIHRoaXMuY29uc3RyYWluVmFsdWUgPSBvcHRpb25zLmNvbnN0cmFpblZhbHVlO1xyXG5cclxuICAgIGNvbnN0IHJhbmdlQ2hhbmdlTGlzdGVuZXIgPSAoIHZhbHVlUmFuZ2U6IFJhbmdlICkgPT4ge1xyXG4gICAgICBpZiAoIG9wdGlvbnMubnVtYmVyT2ZNaWRkbGVUaHJlc2hvbGRzICE9PSBudWxsICkge1xyXG4gICAgICAgIHRoaXMuaW50ZXJUaHJlc2hvbGREaXN0YW5jZSA9IHZhbHVlUmFuZ2UuZ2V0TGVuZ3RoKCkgLyAoIG9wdGlvbnMubnVtYmVyT2ZNaWRkbGVUaHJlc2hvbGRzICsgMSApO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2UgaWYgKCBvcHRpb25zLmludGVyVGhyZXNob2xkRGVsdGEgIT09IG51bGwgKSB7XHJcbiAgICAgICAgdGhpcy5pbnRlclRocmVzaG9sZERpc3RhbmNlID0gb3B0aW9ucy5pbnRlclRocmVzaG9sZERlbHRhO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIGFzc2VydCAmJiBhc3NlcnQoIGZhbHNlLCAnc2hvdWxkIG5ldmVyIGdldCBoZXJlLCBpdCBpcyBhIGxvZ2ljIGVycm9yIGlmIHdlIGRvJyApO1xyXG4gICAgICAgIHRoaXMuaW50ZXJUaHJlc2hvbGREaXN0YW5jZSA9IHZhbHVlUmFuZ2UuZ2V0TGVuZ3RoKCkgLyAyOyAvLyBhdm9pZCB1bmluaXRpYWxpemVkIGNvbXBpbGUtdGltZSBlcnJvclxyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgdGhpcy52YWx1ZVJhbmdlUHJvcGVydHkubGluayggcmFuZ2VDaGFuZ2VMaXN0ZW5lciApO1xyXG5cclxuICAgIHRoaXMuZGlzcG9zZUVtaXR0ZXIuYWRkTGlzdGVuZXIoICgpID0+IHtcclxuICAgICAgdGhpcy52YWx1ZVJhbmdlUHJvcGVydHkudW5saW5rKCByYW5nZUNoYW5nZUxpc3RlbmVyICk7XHJcbiAgICB9ICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDaGVjayBpZiB0aGUgbmV3IHZhbHVlIGhhcyByZWFjaGVkIG9yIGNyb3NzZWQgYSB0aHJlc2hvbGQgYW5kLCBpZiBzbywgcGxheSB0aGUgYXBwcm9wcmlhdGUgc291bmQuICBJZiBubyB0aHJlc2hvbGRcclxuICAgKiBoYXMgYmVlbiByZWFjaGVkIG9yIGNyb3NzZWQgYW5kIHRoZSBuZXcgdmFsdWUgaXMgbm90IGF0IHRoZSBtaW4gb3IgbWF4LCBubyBzb3VuZCB3aWxsIGJlIHBsYXllZC5cclxuICAgKi9cclxuICBwdWJsaWMgcGxheVNvdW5kSWZUaHJlc2hvbGRSZWFjaGVkKCBuZXdWYWx1ZTogbnVtYmVyLCBvbGRWYWx1ZTogbnVtYmVyICk6IHZvaWQge1xyXG5cclxuICAgIGlmICggbmV3VmFsdWUgIT09IG9sZFZhbHVlICkge1xyXG5cclxuICAgICAgY29uc3QgY29uc3RyYWluZWROZXdWYWx1ZSA9IHRoaXMuY29uc3RyYWluVmFsdWUoIG5ld1ZhbHVlICk7XHJcbiAgICAgIGNvbnN0IGNvbnN0cmFpbmVkT2xkVmFsdWUgPSB0aGlzLmNvbnN0cmFpblZhbHVlKCBvbGRWYWx1ZSApO1xyXG5cclxuICAgICAgY29uc3Qgb2xkVmFsdWVTdXJyb3VuZGluZ1RocmVzaG9sZHMgPSB0aGlzLmdldFN1cnJvdW5kaW5nVGhyZXNob2xkcyggY29uc3RyYWluZWRPbGRWYWx1ZSApO1xyXG4gICAgICBjb25zdCBuZXdWYWx1ZVN1cnJvdW5kaW5nVGhyZXNob2xkcyA9IHRoaXMuZ2V0U3Vycm91bmRpbmdUaHJlc2hvbGRzKCBjb25zdHJhaW5lZE5ld1ZhbHVlICk7XHJcblxyXG4gICAgICBjb25zdCB0aHJlc2hvbGRDcm9zc2VkID0gKCBvbGRWYWx1ZVN1cnJvdW5kaW5nVGhyZXNob2xkcy5sZW5ndGggPT09IDEgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWVTdXJyb3VuZGluZ1RocmVzaG9sZHMubGVuZ3RoID09PSAxICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguYWJzKCBvbGRWYWx1ZVN1cnJvdW5kaW5nVGhyZXNob2xkc1sgMCBdIC0gbmV3VmFsdWVTdXJyb3VuZGluZ1RocmVzaG9sZHNbIDAgXSApID4gdGhpcy5pbnRlclRocmVzaG9sZERpc3RhbmNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIG9sZFZhbHVlU3Vycm91bmRpbmdUaHJlc2hvbGRzLmxlbmd0aCA9PT0gMSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZVN1cnJvdW5kaW5nVGhyZXNob2xkcy5sZW5ndGggPT09IDIgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkVmFsdWVTdXJyb3VuZGluZ1RocmVzaG9sZHNbIDAgXSAhPT0gbmV3VmFsdWVTdXJyb3VuZGluZ1RocmVzaG9sZHNbIDAgXSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGRWYWx1ZVN1cnJvdW5kaW5nVGhyZXNob2xkc1sgMCBdICE9PSBuZXdWYWx1ZVN1cnJvdW5kaW5nVGhyZXNob2xkc1sgMSBdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9sZFZhbHVlU3Vycm91bmRpbmdUaHJlc2hvbGRzLmxlbmd0aCA9PT0gMiAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZVN1cnJvdW5kaW5nVGhyZXNob2xkcy5sZW5ndGggPT09IDEgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWVTdXJyb3VuZGluZ1RocmVzaG9sZHNbIDAgXSAhPT0gb2xkVmFsdWVTdXJyb3VuZGluZ1RocmVzaG9sZHNbIDAgXSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZVN1cnJvdW5kaW5nVGhyZXNob2xkc1sgMCBdICE9PSBvbGRWYWx1ZVN1cnJvdW5kaW5nVGhyZXNob2xkc1sgMSBdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9sZFZhbHVlU3Vycm91bmRpbmdUaHJlc2hvbGRzLmxlbmd0aCA9PT0gMiAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZVN1cnJvdW5kaW5nVGhyZXNob2xkcy5sZW5ndGggPT09IDIgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWVTdXJyb3VuZGluZ1RocmVzaG9sZHNbIDAgXSAhPT0gb2xkVmFsdWVTdXJyb3VuZGluZ1RocmVzaG9sZHNbIDAgXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgY29uc3QgdGhyZXNob2xkUmVhY2hlZCA9IG5ld1ZhbHVlU3Vycm91bmRpbmdUaHJlc2hvbGRzLmxlbmd0aCA9PT0gMSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBvbGRWYWx1ZVN1cnJvdW5kaW5nVGhyZXNob2xkcy5sZW5ndGggPT09IDIgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkVmFsdWVTdXJyb3VuZGluZ1RocmVzaG9sZHNbIDAgXSAhPT0gbmV3VmFsdWVTdXJyb3VuZGluZ1RocmVzaG9sZHNbIDAgXSApO1xyXG5cclxuICAgICAgaWYgKCB0aHJlc2hvbGRDcm9zc2VkIHx8XHJcbiAgICAgICAgICAgdGhyZXNob2xkUmVhY2hlZCB8fFxyXG4gICAgICAgICAgIGNvbnN0cmFpbmVkTmV3VmFsdWUgPT09IHRoaXMudmFsdWVSYW5nZVByb3BlcnR5LnZhbHVlLm1pbiB8fFxyXG4gICAgICAgICAgIGNvbnN0cmFpbmVkTmV3VmFsdWUgPT09IHRoaXMudmFsdWVSYW5nZVByb3BlcnR5LnZhbHVlLm1heFxyXG4gICAgICApIHtcclxuICAgICAgICB0aGlzLnBsYXlTb3VuZEZvclZhbHVlQ2hhbmdlKCBuZXdWYWx1ZSwgb2xkVmFsdWUgKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUGxheSB0aGUgYXBwcm9wcmlhdGUgc291bmQgZm9yIHRoZSBjaGFuZ2UgaW4gdmFsdWUgaW5kaWNhdGVkIGJ5IHRoZSBwcm92aWRlZCBuZXcgYW5kIG9sZCB2YWx1ZXMuICBUaGlzIHdpbGwgYWxtb3N0XHJcbiAgICogYWx3YXlzIHBsYXkgYSBzb3VuZCwgYnV0IHRoZXJlIGFyZSBzb21lIGV4Y2VwdGlvbnMuICBTZWUgdGhlIGNvZGUgYW5kIGNvbW1lbnRzIGZvciBkZXRhaWxzLlxyXG4gICAqL1xyXG4gIHB1YmxpYyBwbGF5U291bmRGb3JWYWx1ZUNoYW5nZSggbmV3VmFsdWU6IG51bWJlciwgb2xkVmFsdWU6IG51bWJlciApOiB2b2lkIHtcclxuICAgIGNvbnN0IGNvbnN0cmFpbmVkTmV3VmFsdWUgPSB0aGlzLmNvbnN0cmFpblZhbHVlKCBuZXdWYWx1ZSApO1xyXG4gICAgY29uc3QgY29uc3RyYWluZWRPbGRWYWx1ZSA9IHRoaXMuY29uc3RyYWluVmFsdWUoIG9sZFZhbHVlICk7XHJcbiAgICBpZiAoIGNvbnN0cmFpbmVkTmV3VmFsdWUgIT09IGNvbnN0cmFpbmVkT2xkVmFsdWUgfHxcclxuICAgICAgICAgKCBvbGRWYWx1ZSAhPT0gbmV3VmFsdWUgJiYgKCBuZXdWYWx1ZSA9PT0gdGhpcy52YWx1ZVJhbmdlUHJvcGVydHkudmFsdWUubWluIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUgPT09IHRoaXMudmFsdWVSYW5nZVByb3BlcnR5LnZhbHVlLm1heCApICkgKSB7XHJcblxyXG4gICAgICBpZiAoIG5ld1ZhbHVlID09PSB0aGlzLnZhbHVlUmFuZ2VQcm9wZXJ0eS52YWx1ZS5taW4gJiZcclxuICAgICAgICAgICB0aGlzLm1pblNvdW5kUGxheWVyICE9PSBWYWx1ZUNoYW5nZVNvdW5kUGxheWVyLlVTRV9NSURETEVfU09VTkQgKSB7XHJcbiAgICAgICAgdGhpcy5taW5Tb3VuZFBsYXllci5wbGF5KCk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSBpZiAoIG5ld1ZhbHVlID09PSB0aGlzLnZhbHVlUmFuZ2VQcm9wZXJ0eS52YWx1ZS5tYXggJiZcclxuICAgICAgICAgICAgICAgIHRoaXMubWF4U291bmRQbGF5ZXIgIT09IFZhbHVlQ2hhbmdlU291bmRQbGF5ZXIuVVNFX01JRERMRV9TT1VORCApIHtcclxuICAgICAgICB0aGlzLm1heFNvdW5kUGxheWVyLnBsYXkoKTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuXHJcbiAgICAgICAgLy8gUGxheSBhIG1pZGRsZS1yYW5nZSBzb3VuZCwgYnV0IG9ubHkgaWYgZW5vdWdoIHRpbWUgaGFzIHBhc3NlZCBzaW5jZSB0aGUgbGFzdCBvbmUgd2FzIHBsYXllZC5cclxuICAgICAgICBjb25zdCBub3cgPSBwaGV0QXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lO1xyXG4gICAgICAgIGlmICggbm93IC0gdGhpcy50aW1lT2ZNb3N0UmVjZW50TWlkZGxlU291bmQgPiB0aGlzLm1pbmltdW1JbnRlck1pZGRsZVNvdW5kVGltZSApIHtcclxuICAgICAgICAgIGxldCBwbGF5YmFja1JhdGVNYXBwZXI7XHJcbiAgICAgICAgICBsZXQgc291bmRQbGF5ZXI7XHJcbiAgICAgICAgICBpZiAoIGNvbnN0cmFpbmVkTmV3VmFsdWUgPiBjb25zdHJhaW5lZE9sZFZhbHVlICkge1xyXG4gICAgICAgICAgICBwbGF5YmFja1JhdGVNYXBwZXIgPSB0aGlzLm1pZGRsZU1vdmluZ1VwUGxheWJhY2tSYXRlTWFwcGVyO1xyXG4gICAgICAgICAgICBzb3VuZFBsYXllciA9IHRoaXMubWlkZGxlTW92aW5nVXBTb3VuZFBsYXllcjtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwbGF5YmFja1JhdGVNYXBwZXIgPSB0aGlzLm1pZGRsZU1vdmluZ1VwUGxheWJhY2tSYXRlTWFwcGVyO1xyXG4gICAgICAgICAgICBzb3VuZFBsYXllciA9IHRoaXMubWlkZGxlTW92aW5nRG93blNvdW5kUGxheWVyO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGlmICggcGxheWJhY2tSYXRlTWFwcGVyICE9PSBOT19QTEFZQkFDS19SQVRFX0NIQU5HRSApIHtcclxuXHJcbiAgICAgICAgICAgIC8vIEFkanVzdCB0aGUgcGxheWJhY2sgcmF0ZSBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgbmV3IHZhbHVlLiAgSXQgc2hvdWxkIGJlIHNhZmUgdG8gY2FzdCB0aGlzIGhlcmUgYmVjYXVzZSBvZlxyXG4gICAgICAgICAgICAvLyB0aGUgYXNzZXJ0aW9uIGNoZWNrcyB0aGF0IG9jY3VyIGR1cmluZyBjb25zdHJ1Y3Rpb24uXHJcbiAgICAgICAgICAgICggc291bmRQbGF5ZXIgYXMgU291bmRDbGlwICkuc2V0UGxheWJhY2tSYXRlKCBwbGF5YmFja1JhdGVNYXBwZXIoIG5ld1ZhbHVlICkgKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHNvdW5kUGxheWVyLnBsYXkoKTtcclxuICAgICAgICAgIHRoaXMudGltZU9mTW9zdFJlY2VudE1pZGRsZVNvdW5kID0gbm93O1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IGFuIGFycmF5IHRoYXQgY29udGFpbnMgdGhlIG5leHQgbG93ZXN0IGFuZCBuZXh0IGhpZ2hlc3QgdGhyZXNob2xkcyBmb3IgdGhlIHByb3ZpZGVkIHZhbHVlLiAgSWYgdGhlIHByb3ZpZGVkXHJcbiAgICogdmFsdWUgaXMgZXhhY3RseSBlcXVhbCB0byBhIHRocmVzaG9sZCwgb25seSB0aGUgc2luZ2xlIHRocmVzaG9sZCB2YWx1ZSBpcyByZXR1cm5lZCBpbiB0aGUgYXJyYXkuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBnZXRTdXJyb3VuZGluZ1RocmVzaG9sZHMoIHZhbHVlOiBudW1iZXIgKTogbnVtYmVyW10ge1xyXG5cclxuICAgIC8vIEEgbm90ZSB0byBmdXR1cmUgbWFpbnRhaW5lcnM6IEphdmFTY3JpcHQncyBmbG9hdGluZyBwb2ludCBpbXBsZW1lbnRhdGlvbiB3YXMgY2F1c2luZyBhbGwgbWFubmVyIG9mIHByb2JsZW1zIHdpdGhcclxuICAgIC8vIHRoaXMgbWV0aG9kLiAgRm9yIGluc3RhbmNlLCB3aGVuIHRoZSBpbnRlci10aHJlc2hvbGQgZGlzdGFuY2Ugd2FzIDAuMSBhbmQgdGhlIHByb3ZpZGVkIHZhbHVlIHdhcyAwLjMsIEpTIHNheXNcclxuICAgIC8vIHRoYXQgMC4zLzAuMSBpcyAyLjk5OTk5OTk5OTk5OTk5OTYsIHNvIGl0IHdhcyB0cmlja3kgdG8gdGVsbCB0aGF0IHRoZSB2YWx1ZSB3YXMgYXQgYSB0aHJlc2hvbGQgYW5kIG5vdCBiZWxvdyBpdC5cclxuICAgIC8vIFRoZXJlZm9yZSwgdGhlIGNvZGUgYmVsb3cgZG9lcyByb3VuZGluZyB0byBpbnRlcnZhbHMgdGhhdCB3ZXJlIGVtcGlyaWNhbGx5IGRldGVybWluZWQgdG8gY29ycmVjdCBmb3IgdGhlIGZsb2F0aW5nXHJcbiAgICAvLyBwb2ludCBwcm9ibGVtcy4gIFRoaXMgd29ya2VkIGluIGFsbCB0ZXN0IGNhc2VzLCBidXQgbWF5IG5vdCBzdGFuZCB0aGUgdGVzdCBvZiB0aW1lIGlmIHNvbWUgdW51c3VhbCBzbGlkZXJcclxuICAgIC8vIGNvbmZpZ3VyYXRpb25zIGFyZSBuZWVkZWQuICBPbmUgaWRlYSBtaWdodCBiZSB0byBtYWtlIHRoZSByb3VuZGluZyBpbnRlcnZhbCBmb3IgdGhpcyBjYWxjdWxhdGlvbiBhbiBvcHRpb24gdG8gdGhlXHJcbiAgICAvLyBjbGFzcywgYnV0IHRoYXQgZmVsdCBsaWtlIG92ZXJraWxsIGF0IHRoZSB0aW1lIG9mIHRoaXMgd3JpdGluZy5cclxuICAgIGNvbnN0IHJvdW5kaW5nSW50ZXJ2YWwgPSAxRS03O1xyXG5cclxuICAgIGNvbnN0IHNlZ21lbnQgPSBNYXRoLmZsb29yKFxyXG4gICAgICBVdGlscy5yb3VuZFRvSW50ZXJ2YWwoICggdmFsdWUgLSB0aGlzLnZhbHVlUmFuZ2VQcm9wZXJ0eS52YWx1ZS5taW4gKSAvIHRoaXMuaW50ZXJUaHJlc2hvbGREaXN0YW5jZSxcclxuICAgICAgICByb3VuZGluZ0ludGVydmFsIClcclxuICAgICk7XHJcblxyXG4gICAgY29uc3QgbG93ZXJUaHJlc2hvbGQgPSBVdGlscy5yb3VuZFRvSW50ZXJ2YWwoXHJcbiAgICAgIHNlZ21lbnQgKiB0aGlzLmludGVyVGhyZXNob2xkRGlzdGFuY2UgKyB0aGlzLnZhbHVlUmFuZ2VQcm9wZXJ0eS52YWx1ZS5taW4sXHJcbiAgICAgIHJvdW5kaW5nSW50ZXJ2YWxcclxuICAgICk7XHJcbiAgICBjb25zdCB0aHJlc2hvbGRBcnJheSA9IFsgbG93ZXJUaHJlc2hvbGQgXTtcclxuICAgIGlmICggbG93ZXJUaHJlc2hvbGQgIT09IHZhbHVlICkge1xyXG5cclxuICAgICAgLy8gVGhlIHByb3ZpZGVkIHZhbHVlIHdhc24ndCBleGFjdGx5IGF0IGEgdGhyZXNob2xkLiAgU2luY2UgdGhlIHByZWNlZGluZyBjYWxjdWxhdGlvbiBwcm92aWRlZCB0aGUgbG93ZXJcclxuICAgICAgLy8gdGhyZXNob2xkLCBhZGQgdGhlIHVwcGVyIG9uZSBub3cuXHJcbiAgICAgIGNvbnN0IHVwcGVyVGhyZXNob2xkID0gTWF0aC5taW4oXHJcbiAgICAgICAgVXRpbHMucm91bmRUb0ludGVydmFsKCBsb3dlclRocmVzaG9sZCArIHRoaXMuaW50ZXJUaHJlc2hvbGREaXN0YW5jZSwgcm91bmRpbmdJbnRlcnZhbCApLFxyXG4gICAgICAgIHRoaXMudmFsdWVSYW5nZVByb3BlcnR5LnZhbHVlLm1heFxyXG4gICAgICApO1xyXG5cclxuICAgICAgLy8gVGhpcyBtYXkgc2VlbSBsaWtlIGFuIG9kZCB0ZXN0LCBzbyBoZXJlJ3MgdGhlIHN0b3J5OiBUaGVyZSBhcmUgc29tZSByYXJlIGJ1dCBwb3NzaWJsZSBjYXNlcyB3aGVyZSB0aGVcclxuICAgICAgLy8gY2FsY3VsYXRpb24gYWJvdmUgZG9lc24ndCBhY3R1YWxseSB5aWVsZCBhIGhpZ2hlciB2YWx1ZSBkdWUgdG8gZmxvYXRpbmcgcG9pbnQgZXJyb3JzLiAgV2hlbiB0ZXN0aW5nIGluIERlY1xyXG4gICAgICAvLyAyMDIyLCB0aGlzIHdhcyBvbmx5IHNlZW4gb24gdGhlIFdhdmUgUGFja2V0IENlbnRlciBzbGlkZXIgaW4gRm91cmllciBNYWtpbmcgV2F2ZXMuICBTbywgb25seSBhZGQgdGhlIHVwcGVyXHJcbiAgICAgIC8vIHRocmVzaG9sZCBpZiBpdCdzIGFjdHVhbGx5IGhpZ2hlciB0aGFuIHRoZSBsb3dlciBvbmUuICBJZiB0aGUgdXBwZXIgdGhyZXNob2xkIGlzbid0IGFkZGVkLCB0aGlzIGVzc2VudGlhbGx5XHJcbiAgICAgIC8vIHNheXMgdGhhdCB0aGUgbG93ZXIgdGhyZXNob2xkIHdhcyBhbiBleGFjdCBtYXRjaCBmb3Igb25lIG9mIHRoZSBjcm9zc2luZyB0aHJlc2hvbGRzLCB3aGljaCBpcyBhcHByb3hpbWF0ZWx5XHJcbiAgICAgIC8vIHRydWUgYW5kIGhhcyB3b3JrZWQgZmluZSBpbiBhbGwgdGVzdCBjYXNlcyB0aHVzIGZhci5cclxuICAgICAgaWYgKCB1cHBlclRocmVzaG9sZCA+IGxvd2VyVGhyZXNob2xkICkge1xyXG4gICAgICAgIHRocmVzaG9sZEFycmF5LnB1c2goIHVwcGVyVGhyZXNob2xkICk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0aHJlc2hvbGRBcnJheTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEEgc3RhdGljIGluc3RhbmNlIHRoYXQgbWFrZXMgbm8gc291bmQuICBUaGlzIGlzIGdlbmVyYWxseSB1c2VkIGFzIGFuIG9wdGlvbiB2YWx1ZSB0byB0dXJuIG9mZiBzb3VuZCBnZW5lcmF0aW9uLlxyXG4gICAqL1xyXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgTk9fU09VTkQgPSBuZXcgVmFsdWVDaGFuZ2VTb3VuZFBsYXllciggbmV3IFJhbmdlKCAwLCAxICksIHtcclxuICAgIG1pZGRsZU1vdmluZ1VwU291bmRQbGF5ZXI6IG51bGxTb3VuZFBsYXllcixcclxuICAgIG1pblNvdW5kUGxheWVyOiBudWxsU291bmRQbGF5ZXIsXHJcbiAgICBtYXhTb3VuZFBsYXllcjogbnVsbFNvdW5kUGxheWVyXHJcbiAgfSApO1xyXG5cclxuICAvKipcclxuICAgKiBBIHN0YXRpYyBUU291bmRQbGF5ZXIgaW5zdGFuY2UgdGhhdCBpcyBpbnRlbmRlZCB0byBiZSB1c2VkIGFzIGEgZmxhZyBmb3IgdGhlIG1pbiBhbmQgbWF4IHNvdW5kIHBsYXllcnMgdG9cclxuICAgKiBpbmRpY2F0ZSB0aGF0IHRoZSBtaWRkbGUgc291bmQgcGxheWVyIHNob3VsZCBiZSB1c2VkLlxyXG4gICAqL1xyXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgVVNFX01JRERMRV9TT1VORDogVFNvdW5kUGxheWVyID0ge1xyXG4gICAgcGxheTogU1RVQl9TT1VORF9QTEFZRVJfRlVOQ1RJT04sXHJcbiAgICBzdG9wOiBTVFVCX1NPVU5EX1BMQVlFUl9GVU5DVElPTlxyXG4gIH07XHJcbn1cclxuXHJcbnRhbWJvLnJlZ2lzdGVyKCAnVmFsdWVDaGFuZ2VTb3VuZFBsYXllcicsIFZhbHVlQ2hhbmdlU291bmRQbGF5ZXIgKTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFZhbHVlQ2hhbmdlU291bmRQbGF5ZXI7Il0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBT0EsS0FBSyxNQUFNLDBCQUEwQjtBQUM1QyxPQUFPQyxLQUFLLE1BQU0sMEJBQTBCO0FBQzVDLE9BQU9DLFNBQVMsTUFBTSxvQ0FBb0M7QUFDMUQsT0FBT0MsdUJBQXVCLE1BQU0seUNBQXlDO0FBQzdFLE9BQU9DLG9CQUFvQixNQUFNLHNDQUFzQztBQUV2RSxPQUFPQyxnQkFBZ0IsTUFBTSx3QkFBd0I7QUFDckQsT0FBT0MsOEJBQThCLE1BQU0sMkRBQTJEO0FBQ3RHLE9BQU9DLDJCQUEyQixNQUFNLHdEQUF3RDtBQUNoRyxPQUFPQyxlQUFlLE1BQU0sNENBQTRDO0FBQ3hFLE9BQU9DLEtBQUssTUFBTSxhQUFhO0FBQy9CLE9BQU9DLFNBQVMsTUFBTSxnQkFBZ0I7QUFDdEMsT0FBT0MsZUFBZSxNQUFNLHNCQUFzQjtBQUNsRCxPQUFPQyxVQUFVLE1BQTZCLGdDQUFnQztBQUU5RSxPQUFPQyxZQUFZLE1BQU0sa0NBQWtDOztBQUUzRDtBQUNBLE1BQU1DLG1DQUFtQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0FBQy9DLE1BQU1DLHdCQUF3QixHQUFHLElBQUlKLGVBQWUsQ0FBRVIsdUJBQXVCLEVBQUU7RUFDN0VhLGdCQUFnQixFQUFFO0lBQ2hCQyxrQkFBa0IsRUFBRSxHQUFHO0lBQ3ZCQyxtQkFBbUIsRUFBRSxDQUFDLEdBQUdDLElBQUksQ0FBQ0MsR0FBRyxDQUFFLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBRSxDQUFDLENBQUM7RUFDaEQsQ0FBQztFQUNEQyxtQkFBbUIsRUFBRTtJQUFFQyxZQUFZLEVB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