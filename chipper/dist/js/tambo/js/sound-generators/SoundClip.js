// Copyright 2018-2024, University of Colorado Boulder

/**
 * A sound generator that plays pre-recorded sounds, either as a one-shot or as a loop.
 *
 * @author John Blanco (PhET Interactive Simulations)
 */

import BooleanProperty from '../../../axon/js/BooleanProperty.js';
import audioContextStateChangeMonitor from '../audioContextStateChangeMonitor.js';
import soundConstants from '../soundConstants.js';
import SoundUtils from '../SoundUtils.js';
import tambo from '../tambo.js';
import SoundGenerator from './SoundGenerator.js';
import optionize from '../../../phet-core/js/optionize.js';
// constants
const MAX_PLAY_DEFER_TIME = 0.2; // seconds, max time to defer a play request while waiting for audio context state change
const DEFAULT_TC = soundConstants.DEFAULT_PARAM_CHANGE_TIME_CONSTANT;
const DEFAULT_STOP_DELAY = 0.1;
class SoundClip extends SoundGenerator {
  // an object containing the audio buffer and flag that indicates readiness, i.e. whether it is fully loaded

  // flag that controls whether this is a one-shot or loop sound

  // flag that controls whether changes to the playback rate affects in-progress sounds

  // Controls whether this clip can be initiated when it is disabled, see description in options type definition above.
  // This is part of the API and can be changed if needed, though such a need is generally quite rare.

  // start point for playback of the sound data

  // stop or wrap around point for playback of the sound data

  // A list of active source buffer nodes, used so that this clip can be played multiple times without each initiation
  // interfering with the other.

  // a gain node that is used to prevent clicks when stopping the sound

  // The rate at which clip is being played back, 1 is normal, above 1 is faster, below 1 is slower.  See online docs
  // for AudioBufferSourceNode.playbackRate for more information.

  // indicates whether the sound is being played

  // time at which a deferred play request occurred, in milliseconds since epoch

  // callback for when audio context isn't in 'running' state, see usage

  constructor(wrappedAudioBuffer, providedOptions) {
    const options = optionize()({
      loop: false,
      trimSilence: true,
      initialPlaybackRate: 1,
      initiateWhenDisabled: false,
      rateChangesAffectPlayingSounds: true
    }, providedOptions);
    super(options);

    // initialize local state
    this.wrappedAudioBuffer = wrappedAudioBuffer;
    this.loop = options.loop;
    this.rateChangesAffectPlayingSounds = options.rateChangesAffectPlayingSounds;
    this.initiateWhenDisabled = options.initiateWhenDisabled;
    this.soundStart = 0;
    this.soundEnd = null;
    if (options.trimSilence) {
      // For sounds that are created statically during the module load phase, this listener will interpret the audio
      // data once the load of that data has completed.  For all sounds constructed after the module load phase has
      // completed, this will process right away.
      const setStartAndEndPoints = audioBuffer => {
        if (audioBuffer) {
          const loopBoundsInfo = SoundUtils.detectSoundBounds(audioBuffer);
          this.soundStart = loopBoundsInfo.soundStart;
          this.soundEnd = loopBoundsInfo.soundEnd;
          this.wrappedAudioBuffer.audioBufferProperty.unlink(setStartAndEndPoints);
        }
      };
      this.wrappedAudioBuffer.audioBufferProperty.link(setStartAndEndPoints);
    }
    this.activeBufferSources = [];
    this.localGainNode = this.audioContext.createGain();
    this.localGainNode.connect(this.soundSourceDestination);
    this._playbackRate = options.initialPlaybackRate;
    this.isPlayingProperty = new BooleanProperty(false);
    this.timeOfDeferredPlayRequest = Number.NEGATIVE_INFINITY;

    // callback for when audio context isn't in 'running' state, see usage
    this.audioContextStateChangeListener = state => {
      if (state === 'running') {
        // initiate deferred play if this is a loop or if it hasn't been too long since the request was made
        if (this.loop || (Date.now() - this.timeOfDeferredPlayRequest) / 1000 < MAX_PLAY_DEFER_TIME) {
          // Play the sound, but with a little bit of delay.  The delay was found to be needed because otherwise on
          // some browsers the sound would be somewhat muted, probably due to some sort of fade in of the audio levels
          // that the browser does automatically to avoid having the web page's sound start too abruptly.  The amount of
          // delay was empirically determined by testing on multiple browsers.
          this.play(0.1);
        }

        // automatically remove after firing
        audioContextStateChangeMonitor.removeStateChangeListener(this.audioContext, this.audioContextStateChangeListener);
      }
    };

    // Listen to the Property that indicates whether we are fully enabled and stop one-shot sounds when it goes false.
    this.fullyEnabledProperty.lazyLink(fullyEnabled => {
      if (!this.loop && !fullyEnabled) {
        this.stop();
      }
    });

    // Clean up memory references when this object is disposed to avoid memory leaks.
    this.disposeEmitter.addListener(() => {
      if (audioContextStateChangeMonitor.hasListener(this.audioContext, this.audioContextStateChangeListener)) {
        audioContextStateChangeMonitor.removeStateChangeListener(this.audioContext, this.audioContextStateChangeListener);
      }
    });
  }

  /**
   * Start playing the sound.
   */
  play(delay = 0) {
    if (this.audioContext.state === 'running' && this.wrappedAudioBuffer.audioBufferProperty.value) {
      const now = this.audioContext.currentTime;
      if (this.loop && !this.isPlayingProperty.get() || !this.loop && (this.fullyEnabled || this.initiateWhenDisabled)) {
        // create an audio buffer source node that uses the previously decoded audio data
        const bufferSource = this.audioContext.createBufferSource();
        bufferSource.buffer = this.wrappedAudioBuffer.audioBufferProperty.value;
        bufferSource.loop = this.loop;
        bufferSource.loopStart = this.soundStart;
        if (this.soundEnd) {
          bufferSource.loopEnd = this.soundEnd;
        }

        // make sure the local gain is set to unity value
        this.localGainNode.gain.cancelScheduledValues(now);
        this.localGainNode.gain.setValueAtTime(1, now);
        bufferSource.connect(this.soundSourceDestination);

        // add this to the list of active sources so that it can be stopped if necessary
        this.activeBufferSources.push(bufferSource);
        if (!this.loop) {
          // add a handler for when the sound finishes playing
          bufferSource.onended = () => {
            // remove the source from the list of active sources
            const indexOfSource = this.activeBufferSources.indexOf(bufferSource);
            if (indexOfSource > -1) {
              this.activeBufferSources.splice(indexOfSource, 1);
            }
            this.isPlayingProperty.value = this.activeBufferSources.length > 0;
          };
        }

        // set the playback rate and start playback
        bufferSource.playbackRate.setValueAtTime(this._playbackRate, now);
        bufferSource.start(now + delay, this.soundStart);
        this.isPlayingProperty.value = true;
      }
    } else if (this.audioContext.state === 'suspended') {
      // The play method was called when the audio context was not yet running, so add a listener to play if and when
      // the audio context state changes.  This will start any loops, and will also play a one-shot sound if the time
      // between the request and the state change isn't too great.  Note that this does NOT queue up more than one
      // individual sound to be played.
      this.timeOfDeferredPlayRequest = Date.now();
      if (!audioContextStateChangeMonitor.hasListener(this.audioContext, this.audioContextStateChangeListener)) {
        audioContextStateChangeMonitor.addStateChangeListener(this.audioContext, this.audioContextStateChangeListener);
      }
    }
  }

  /**
   * Stop playing the sound.
   *
   * Note: Doing rapid stops and starts of a loop using this method can cause sound glitches.  If you have a need to
   * do that, use volume fades combined with zero delay stops.
   *
   * @param [delay] - The amount of time to wait before stopping, generally used to prevent sudden stops, which can
   * cause audible clicks.  If greater than zero, which it is by default, this method will try to fade out the sound
   * fully prior to stopping the audio playback.
   */
  stop(delay = DEFAULT_STOP_DELAY) {
    // Calculate a time constant to fade output level by 99% by the stop time, see Web Audio time constant information
    // to understand this calculation.
    const fadeTimeConstant = delay > 0 ? delay / 4.61 : soundConstants.DEFAULT_PARAM_CHANGE_TIME_CONSTANT;

    // Simply calling stop() on the buffer source frequently causes an audible click, so we use a gain node and turn
    // down the gain, effectively doing a fade out, and then stopping playback.
    const now = this.audioContext.currentTime;
    const stopTime = now + delay;
    this.localGainNode.gain.cancelScheduledValues(now);
    this.localGainNode.gain.setTargetAtTime(0, now, fadeTimeConstant);
    this.activeBufferSources.forEach(source => {
      source.stop(stopTime);
    });

    // The WebAudio spec is a bit unclear about whether stopping a sound will trigger an onended event.  In testing
    // on Chrome in September 2018, I (jbphet) found that onended was NOT being fired when stop() was called, so the
    // code below is needed to clear the array of all active buffer sources.
    this.activeBufferSources.length = 0;

    // clear the flag
    this.isPlayingProperty.value = false;
    if (audioContextStateChangeMonitor.hasListener(this.audioContext, this.audioContextStateChangeListener)) {
      // remove the state change listener that was going to do a deferred play, since the sound has now been stopped
      audioContextStateChangeMonitor.removeStateChangeListener(this.audioContext, this.audioContextStateChangeListener);
    }
  }

  /**
   * Set the playback rate.  Based on the way this SoundClip was created, this may or may not affect in-progress sounds.
   */
  setPlaybackRate(playbackRate, timeConstant = DEFAULT_TC) {
    assert && assert(playbackRate > 0, 'invalid playback rate: ' + playbackRate);
    if (this.rateChangesAffectPlayingSounds) {
      const now = this.audioContext.currentTime;
      this.activeBufferSources.forEach(bufferSource => {
        bufferSource.playbackRate.cancelScheduledValues(now);
        bufferSource.playbackRate.setTargetAtTime(playbackRate, now, timeConstant);
      });
    }
    this._playbackRate = playbackRate;
  }

  /**
   * Get the current playback rate.  Note that it is possible that there are audio buffers that are playing that are not
   * playing at the returned rate if the rate was recently changed.
   */
  getPlaybackRate() {
    return this._playbackRate;
  }

  /**
   * ES5 getter for playback rate
   */
  get playbackRate() {
    return this.getPlaybackRate();
  }

  /**
   * Get a value that indicates whether sound is currently being played.
   */
  get isPlaying() {
    return this.isPlayingProperty.value;
  }

  /**
   * Get the number of instances of the audio buffer that are currently playing.  This can be greater than one because
   * SoundClip supports multiple buffers playing at the same time.  This method is generally used to limit the number
   * of instances that are playing at the same time.
   */
  getNumberOfPlayingInstances() {
    return this.activeBufferSources.length;
  }
}
tambo.register('SoundClip', SoundClip);
export default SoundClip;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJCb29sZWFuUHJvcGVydHkiLCJhdWRpb0NvbnRleHRTdGF0ZUNoYW5nZU1vbml0b3IiLCJzb3VuZENvbnN0YW50cyIsIlNvdW5kVXRpbHMiLCJ0YW1ibyIsIlNvdW5kR2VuZXJhdG9yIiwib3B0aW9uaXplIiwiTUFYX1BMQVlfREVGRVJfVElNRSIsIkRFRkFVTFRfVEMiLCJERUZBVUxUX1BBUkFNX0NIQU5HRV9USU1FX0NPTlNUQU5UIiwiREVGQVVMVF9TVE9QX0RFTEFZIiwiU291bmRDbGlwIiwiY29uc3RydWN0b3IiLCJ3cmFwcGVkQXVkaW9CdWZmZXIiLCJwcm92aWRlZE9wdGlvbnMiLCJvcHRpb25zIiwibG9vcCIsInRyaW1TaWxlbmNlIiwiaW5pdGlhbFBsYXliYWNrUmF0ZSIsImluaXRpYXRlV2hlbkRpc2FibGVkIiwicmF0ZUNoYW5nZXNBZmZlY3RQbGF5aW5nU291bmRzIiwic291bmRTdGFydCIsInNvdW5kRW5kIiwic2V0U3RhcnRBbmRFbmRQb2ludHMiLCJhdWRpb0J1ZmZlciIsImxvb3BCb3VuZHNJbmZvIiwiZGV0ZWN0U291bmRCb3VuZHMiLCJhdWRpb0J1ZmZlclByb3BlcnR5IiwidW5saW5rIiwibGluayIsImFjdGl2ZUJ1ZmZlclNvdXJjZXMiLCJsb2NhbEdhaW5Ob2RlIiwiYXVkaW9Db250ZXh0IiwiY3JlYXRlR2FpbiIsImNvbm5lY3QiLCJzb3VuZFNvdXJjZURlc3RpbmF0aW9uIiwiX3BsYXliYWNrUmF0ZSIsImlzUGxheWluZ1Byb3BlcnR5IiwidGltZU9mRGVmZXJyZWRQbGF5UmVxdWVzdCIsIk51bWJlciIsIk5FR0FUSVZFX0lORklOSVRZIiwiYXVkaW9Db250ZXh0U3RhdGVDaGFuZ2VMaXN0ZW5lciIsInN0YXRlIiwiRGF0ZSIsIm5vdyIsInBsYXkiLCJyZW1vdmVTdGF0ZUNoYW5nZUxpc3RlbmVyIiwiZnVsbHlFbmFibGVkUHJvcGVydHkiLCJsYXp5TGluayIsImZ1bGx5RW5hYmxlZCIsInN0b3AiLCJkaXNwb3NlRW1pdHRlciIsImFkZExpc3RlbmVyIiwiaGFzTGlzdGVuZXIiLCJkZWxheSIsInZhbHVlIiwiY3VycmVudFRpbWUiLCJnZXQiLCJidWZmZXJTb3VyY2UiLCJjcmVhdGVCdWZmZXJTb3VyY2UiLCJidWZmZXIiLCJsb29wU3RhcnQiLCJsb29wRW5kIiwiZ2FpbiIsImNhbmNlbFNjaGVkdWxlZFZhbHVlcyIsInNldFZhbHVlQXRUaW1lIiwicHVzaCIsIm9uZW5kZWQiLCJpbmRleE9mU291cmNlIiwiaW5kZXhPZiIsInNwbGljZSIsImxlbmd0aCIsInBsYXliYWNrUmF0ZSIsInN0YXJ0IiwiYWRkU3RhdGVDaGFuZ2VMaXN0ZW5lciIsImZhZGVUaW1lQ29uc3RhbnQiLCJzdG9wVGltZSIsInNldFRhcmdldEF0VGltZSIsImZvckVhY2giLCJzb3VyY2UiLCJzZXRQbGF5YmFja1JhdGUiLCJ0aW1lQ29uc3RhbnQiLCJhc3NlcnQiLCJnZXRQbGF5YmFja1JhdGUiLCJpc1BsYXlpbmciLCJnZXROdW1iZXJPZlBsYXlpbmdJbnN0YW5jZXMiLCJyZWdpc3RlciJdLCJzb3VyY2VzIjpbIlNvdW5kQ2xpcC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAxOC0yMDI0LCBVbml2ZXJzaXR5IG9mIENvbG9yYWRvIEJvdWxkZXJcclxuXHJcbi8qKlxyXG4gKiBBIHNvdW5kIGdlbmVyYXRvciB0aGF0IHBsYXlzIHByZS1yZWNvcmRlZCBzb3VuZHMsIGVpdGhlciBhcyBhIG9uZS1zaG90IG9yIGFzIGEgbG9vcC5cclxuICpcclxuICogQGF1dGhvciBKb2huIEJsYW5jbyAoUGhFVCBJbnRlcmFjdGl2ZSBTaW11bGF0aW9ucylcclxuICovXHJcblxyXG5pbXBvcnQgQm9vbGVhblByb3BlcnR5IGZyb20gJy4uLy4uLy4uL2F4b24vanMvQm9vbGVhblByb3BlcnR5LmpzJztcclxuaW1wb3J0IGF1ZGlvQ29udGV4dFN0YXRlQ2hhbmdlTW9uaXRvciBmcm9tICcuLi9hdWRpb0NvbnRleHRTdGF0ZUNoYW5nZU1vbml0b3IuanMnO1xyXG5pbXBvcnQgc291bmRDb25zdGFudHMgZnJvbSAnLi4vc291bmRDb25zdGFudHMuanMnO1xyXG5pbXBvcnQgU291bmRVdGlscyBmcm9tICcuLi9Tb3VuZFV0aWxzLmpzJztcclxuaW1wb3J0IHRhbWJvIGZyb20gJy4uL3RhbWJvLmpzJztcclxuaW1wb3J0IFNvdW5kR2VuZXJhdG9yLCB7IFNvdW5kR2VuZXJhdG9yT3B0aW9ucyB9IGZyb20gJy4vU291bmRHZW5lcmF0b3IuanMnO1xyXG5pbXBvcnQgV3JhcHBlZEF1ZGlvQnVmZmVyIGZyb20gJy4uL1dyYXBwZWRBdWRpb0J1ZmZlci5qcyc7XHJcbmltcG9ydCBvcHRpb25pemUgZnJvbSAnLi4vLi4vLi4vcGhldC1jb3JlL2pzL29wdGlvbml6ZS5qcyc7XHJcbmltcG9ydCBQcm9wZXJ0eSBmcm9tICcuLi8uLi8uLi9heG9uL2pzL1Byb3BlcnR5LmpzJztcclxuXHJcbnR5cGUgU2VsZk9wdGlvbnMgPSB7XHJcblxyXG4gIC8vIGNvbnRyb2xzIHdoZXRoZXIgdGhpcyBzb3VuZCB3aWxsIHdyYXAgYXJvdW5kIGFuZCBzdGFydCBvdmVyIHdoZW4gZG9uZSBvciBqdXN0IGJlIHBsYXllZCBvbmNlXHJcbiAgbG9vcD86IGJvb2xlYW47XHJcblxyXG4gIC8vIGNvbnRyb2xzIHdoZXRoZXIgdGhlIHNpbGVuY2UgYXQgdGhlIGJlZ2lubmluZyBhbmQgKGluIHRoZSBjYXNlIG9mIGxvb3BzKSB0aGUgZW5kIGlzIG9taXR0ZWQgd2hlbiBzb3VuZCBpcyBwbGF5ZWRcclxuICB0cmltU2lsZW5jZT86IGJvb2xlYW47XHJcblxyXG4gIC8vIEluaXRpYWwgcGxheWJhY2sgcmF0ZSBmb3IgdGhpcyBjbGlwLiAgVGhpcyB2YWx1ZSBpcyBhIG11bHRpcGxpZXIsIHNvIDEgaXMgdGhlIG5vbWluYWwgcGxheWJhY2sgcmF0ZSwgMC41IGlzIGhhbGZcclxuICAvLyBzcGVlZCAob3IgYW4gb2N0YXZlIGxvd2VyIGluIG11c2ljYWwgdGVybXMpIGFuZCBhIHZhbHVlIG9mIDIgaXMgdHdpY2Ugbm9ybWFsIHNwZWVkIChvciBhbiBvY3RhdmUgaGlnaGVyIGluIG11c2ljYWxcclxuICAvLyB0ZXJtcykuICBUaGUgcGxheWJhY2sgcmF0ZSBjYW4gYmUgY2hhbmdlZCBhZnRlciBjb25zdHJ1Y3Rpb24gdmlhIHRoZSBBUEkuXHJcbiAgaW5pdGlhbFBsYXliYWNrUmF0ZT86IG51bWJlcjtcclxuXHJcbiAgLy8gQ29udHJvbHMgd2hldGhlciBzb3VuZCBnZW5lcmF0aW9uIGNhbiBiZSBpbml0aWF0ZWQgd2hlbiB0aGlzIHNvdW5kIGdlbmVyYXRvciBpcyBkaXNhYmxlZC4gIFRoaXMgaXMgdXNlZnVsIGZvciBhXHJcbiAgLy8gb25lLXNob3Qgc291bmQgdGhhdCBpcyBsb25nLCBzbyBpZiB0aGUgdXNlciBkb2VzIHNvbWV0aGluZyB0aGF0IGdlbmVyYWxseSB3b3VsZCBjYXVzZSBhIHNvdW5kLCBidXQgc291bmQgaXNcclxuICAvLyBkaXNhYmxlZCwgYnV0IHRoZW4gdGhleSBpbW1lZGlhdGVseSByZS1lbmFibGUgc291bmQsIHRoZSBcInRhaWxcIiBvZiB0aGlzIHNvdW5kIHdvdWxkIGJlIGhlYXJkLiAgVGhpcyBvcHRpb24gaXNcclxuICAvLyBpZ25vcmVkIGZvciBsb29wcywgc2luY2UgbG9vcHMgYWx3YXlzIGFsbG93IGluaXRpYXRpb24gd2hlbiBkaXNhYmxlZC5cclxuICBpbml0aWF0ZVdoZW5EaXNhYmxlZD86IGJvb2xlYW47XHJcblxyXG4gIC8vIENvbnRyb2xzIHdoZXRoZXIgY2hhbmdlcyB0byB0aGUgcGxheWJhY2sgcmF0ZSB2aWEgdGhlIEFQSSBjYXVzZXMgY2hhbmdlcyB0byB0aGUgc291bmRzIHRoYXQgYXJlIGFscmVhZHkgYmVpbmdcclxuICAvLyBwbGF5ZWQgYXMgb3Bwb3NlZCB0byBvbmx5IHNvdW5kcyB0aGF0IGFyZSBzdGFydGVkIGFmdGVyIHRoZSBwbGF5YmFjayByYXRlIGlzIGNoYW5nZWQuICBUaGlzIGlzIHJlbGV2YW50IGZvciBib3RoXHJcbiAgLy8gbG9vcHMgYW5kIG9uZS1zaG90IHNvdW5kcywgc2luY2UgYSBvbmUtc2hvdCBzb3VuZCAoZXNwZWNpYWxseSBvbmUgdGhhdCBpcyBmYWlybHkgbG9uZykgY291bGQgYmUgaW4gdGhlIHByb2Nlc3Mgb2ZcclxuICAvLyBwbGF5aW5nIHdoZW4gYSBwbGF5YmFjayByYXRlIGNoYW5nZSBvY2N1cnMuXHJcbiAgcmF0ZUNoYW5nZXNBZmZlY3RQbGF5aW5nU291bmRzPzogYm9vbGVhbjtcclxufTtcclxuZXhwb3J0IHR5cGUgU291bmRDbGlwT3B0aW9ucyA9IFNlbGZPcHRpb25zICYgU291bmRHZW5lcmF0b3JPcHRpb25zO1xyXG5cclxuLy8gY29uc3RhbnRzXHJcbmNvbnN0IE1BWF9QTEFZX0RFRkVSX1RJTUUgPSAwLjI7IC8vIHNlY29uZHMsIG1heCB0aW1lIHRvIGRlZmVyIGEgcGxheSByZXF1ZXN0IHdoaWxlIHdhaXRpbmcgZm9yIGF1ZGlvIGNvbnRleHQgc3RhdGUgY2hhbmdlXHJcbmNvbnN0IERFRkFVTFRfVEMgPSBzb3VuZENvbnN0YW50cy5ERUZBVUxUX1BBUkFNX0NIQU5HRV9USU1FX0NPTlNUQU5UO1xyXG5jb25zdCBERUZBVUxUX1NUT1BfREVMQVkgPSAwLjE7XHJcblxyXG5jbGFzcyBTb3VuZENsaXAgZXh0ZW5kcyBTb3VuZEdlbmVyYXRvciB7XHJcblxyXG4gIC8vIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBhdWRpbyBidWZmZXIgYW5kIGZsYWcgdGhhdCBpbmRpY2F0ZXMgcmVhZGluZXNzLCBpLmUuIHdoZXRoZXIgaXQgaXMgZnVsbHkgbG9hZGVkXHJcbiAgcHJpdmF0ZSByZWFkb25seSB3cmFwcGVkQXVkaW9CdWZmZXI6IFdyYXBwZWRBdWRpb0J1ZmZlcjtcclxuXHJcbiAgLy8gZmxhZyB0aGF0IGNvbnRyb2xzIHdoZXRoZXIgdGhpcyBpcyBhIG9uZS1zaG90IG9yIGxvb3Agc291bmRcclxuICBwdWJsaWMgcmVhZG9ubHkgbG9vcDogYm9vbGVhbjtcclxuXHJcbiAgLy8gZmxhZyB0aGF0IGNvbnRyb2xzIHdoZXRoZXIgY2hhbmdlcyB0byB0aGUgcGxheWJhY2sgcmF0ZSBhZmZlY3RzIGluLXByb2dyZXNzIHNvdW5kc1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgcmF0ZUNoYW5nZXNBZmZlY3RQbGF5aW5nU291bmRzOiBib29sZWFuO1xyXG5cclxuICAvLyBDb250cm9scyB3aGV0aGVyIHRoaXMgY2xpcCBjYW4gYmUgaW5pdGlhdGVkIHdoZW4gaXQgaXMgZGlzYWJsZWQsIHNlZSBkZXNjcmlwdGlvbiBpbiBvcHRpb25zIHR5cGUgZGVmaW5pdGlvbiBhYm92ZS5cclxuICAvLyBUaGlzIGlzIHBhcnQgb2YgdGhlIEFQSSBhbmQgY2FuIGJlIGNoYW5nZWQgaWYgbmVlZGVkLCB0aG91Z2ggc3VjaCBhIG5lZWQgaXMgZ2VuZXJhbGx5IHF1aXRlIHJhcmUuXHJcbiAgcHVibGljIGluaXRpYXRlV2hlbkRpc2FibGVkOiBib29sZWFuO1xyXG5cclxuICAvLyBzdGFydCBwb2ludCBmb3IgcGxheWJhY2sgb2YgdGhlIHNvdW5kIGRhdGFcclxuICBwcml2YXRlIHNvdW5kU3RhcnQ6IG51bWJlcjtcclxuXHJcbiAgLy8gc3RvcCBvciB3cmFwIGFyb3VuZCBwb2ludCBmb3IgcGxheWJhY2sgb2YgdGhlIHNvdW5kIGRhdGFcclxuICBwcml2YXRlIHNvdW5kRW5kOiBudW1iZXIgfCBudWxsO1xyXG5cclxuICAvLyBBIGxpc3Qgb2YgYWN0aXZlIHNvdXJjZSBidWZmZXIgbm9kZXMsIHVzZWQgc28gdGhhdCB0aGlzIGNsaXAgY2FuIGJlIHBsYXllZCBtdWx0aXBsZSB0aW1lcyB3aXRob3V0IGVhY2ggaW5pdGlhdGlvblxyXG4gIC8vIGludGVyZmVyaW5nIHdpdGggdGhlIG90aGVyLlxyXG4gIHByaXZhdGUgcmVhZG9ubHkgYWN0aXZlQnVmZmVyU291cmNlczogQXVkaW9CdWZmZXJTb3VyY2VOb2RlW107XHJcblxyXG4gIC8vIGEgZ2FpbiBub2RlIHRoYXQgaXMgdXNlZCB0byBwcmV2ZW50IGNsaWNrcyB3aGVuIHN0b3BwaW5nIHRoZSBzb3VuZFxyXG4gIHByaXZhdGUgcmVhZG9ubHkgbG9jYWxHYWluTm9kZTogR2Fpbk5vZGU7XHJcblxyXG4gIC8vIFRoZSByYXRlIGF0IHdoaWNoIGNsaXAgaXMgYmVpbmcgcGxheWVkIGJhY2ssIDEgaXMgbm9ybWFsLCBhYm92ZSAxIGlzIGZhc3RlciwgYmVsb3cgMSBpcyBzbG93ZXIuICBTZWUgb25saW5lIGRvY3NcclxuICAvLyBmb3IgQXVkaW9CdWZmZXJTb3VyY2VOb2RlLnBsYXliYWNrUmF0ZSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cclxuICBwcml2YXRlIF9wbGF5YmFja1JhdGU6IG51bWJlcjtcclxuXHJcbiAgLy8gaW5kaWNhdGVzIHdoZXRoZXIgdGhlIHNvdW5kIGlzIGJlaW5nIHBsYXllZFxyXG4gIHB1YmxpYyByZWFkb25seSBpc1BsYXlpbmdQcm9wZXJ0eTogUHJvcGVydHk8Ym9vbGVhbj47XHJcblxyXG4gIC8vIHRpbWUgYXQgd2hpY2ggYSBkZWZlcnJlZCBwbGF5IHJlcXVlc3Qgb2NjdXJyZWQsIGluIG1pbGxpc2Vjb25kcyBzaW5jZSBlcG9jaFxyXG4gIHByaXZhdGUgdGltZU9mRGVmZXJyZWRQbGF5UmVxdWVzdDogbnVtYmVyO1xyXG5cclxuICAvLyBjYWxsYmFjayBmb3Igd2hlbiBhdWRpbyBjb250ZXh0IGlzbid0IGluICdydW5uaW5nJyBzdGF0ZSwgc2VlIHVzYWdlXHJcbiAgcHJpdmF0ZSByZWFkb25seSBhdWRpb0NvbnRleHRTdGF0ZUNoYW5nZUxpc3RlbmVyOiAoIHN0YXRlOiBzdHJpbmcgKSA9PiB2b2lkO1xyXG5cclxuICBwdWJsaWMgY29uc3RydWN0b3IoIHdyYXBwZWRBdWRpb0J1ZmZlcjogV3JhcHBlZEF1ZGlvQnVmZmVyLCBwcm92aWRlZE9wdGlvbnM/OiBTb3VuZENsaXBPcHRpb25zICkge1xyXG5cclxuICAgIGNvbnN0IG9wdGlvbnMgPSBvcHRpb25pemU8U291bmRDbGlwT3B0aW9ucywgU2VsZk9wdGlvbnMsIFNvdW5kR2VuZXJhdG9yT3B0aW9ucz4oKSgge1xyXG4gICAgICBsb29wOiBmYWxzZSxcclxuICAgICAgdHJpbVNpbGVuY2U6IHRydWUsXHJcbiAgICAgIGluaXRpYWxQbGF5YmFja1JhdGU6IDEsXHJcbiAgICAgIGluaXRpYXRlV2hlbkRpc2FibGVkOiBmYWxzZSxcclxuICAgICAgcmF0ZUNoYW5nZXNBZmZlY3RQbGF5aW5nU291bmRzOiB0cnVlXHJcbiAgICB9LCBwcm92aWRlZE9wdGlvbnMgKTtcclxuXHJcbiAgICBzdXBlciggb3B0aW9ucyApO1xyXG5cclxuICAgIC8vIGluaXRpYWxpemUgbG9jYWwgc3RhdGVcclxuICAgIHRoaXMud3JhcHBlZEF1ZGlvQnVmZmVyID0gd3JhcHBlZEF1ZGlvQnVmZmVyO1xyXG4gICAgdGhpcy5sb29wID0gb3B0aW9ucy5sb29wO1xyXG4gICAgdGhpcy5yYXRlQ2hhbmdlc0FmZmVjdFBsYXlpbmdTb3VuZHMgPSBvcHRpb25zLnJhdGVDaGFuZ2VzQWZmZWN0UGxheWluZ1NvdW5kcztcclxuICAgIHRoaXMuaW5pdGlhdGVXaGVuRGlzYWJsZWQgPSBvcHRpb25zLmluaXRpYXRlV2hlbkRpc2FibGVkO1xyXG4gICAgdGhpcy5zb3VuZFN0YXJ0ID0gMDtcclxuICAgIHRoaXMuc291bmRFbmQgPSBudWxsO1xyXG4gICAgaWYgKCBvcHRpb25zLnRyaW1TaWxlbmNlICkge1xyXG5cclxuICAgICAgLy8gRm9yIHNvdW5kcyB0aGF0IGFyZSBjcmVhdGVkIHN0YXRpY2FsbHkgZHVyaW5nIHRoZSBtb2R1bGUgbG9hZCBwaGFzZSwgdGhpcyBsaXN0ZW5lciB3aWxsIGludGVycHJldCB0aGUgYXVkaW9cclxuICAgICAgLy8gZGF0YSBvbmNlIHRoZSBsb2FkIG9mIHRoYXQgZGF0YSBoYXMgY29tcGxldGVkLiAgRm9yIGFsbCBzb3VuZHMgY29uc3RydWN0ZWQgYWZ0ZXIgdGhlIG1vZHVsZSBsb2FkIHBoYXNlIGhhc1xyXG4gICAgICAvLyBjb21wbGV0ZWQsIHRoaXMgd2lsbCBwcm9jZXNzIHJpZ2h0IGF3YXkuXHJcbiAgICAgIGNvbnN0IHNldFN0YXJ0QW5kRW5kUG9pbnRzID0gKCBhdWRpb0J1ZmZlcjogQXVkaW9CdWZmZXIgfCBudWxsICkgPT4ge1xyXG4gICAgICAgIGlmICggYXVkaW9CdWZmZXIgKSB7XHJcbiAgICAgICAgICBjb25zdCBsb29wQm91bmRzSW5mbyA9IFNvdW5kVXRpbHMuZGV0ZWN0U291bmRCb3VuZHMoIGF1ZGlvQnVmZmVyICk7XHJcbiAgICAgICAgICB0aGlzLnNvdW5kU3RhcnQgPSBsb29wQm91bmRzSW5mby5zb3VuZFN0YXJ0O1xyXG4gICAgICAgICAgdGhpcy5zb3VuZEVuZCA9IGxvb3BCb3VuZHNJbmZvLnNvdW5kRW5kO1xyXG4gICAgICAgICAgdGhpcy53cmFwcGVkQXVkaW9CdWZmZXIuYXVkaW9CdWZmZXJQcm9wZXJ0eS51bmxpbmsoIHNldFN0YXJ0QW5kRW5kUG9pbnRzICk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG4gICAgICB0aGlzLndyYXBwZWRBdWRpb0J1ZmZlci5hdWRpb0J1ZmZlclByb3BlcnR5LmxpbmsoIHNldFN0YXJ0QW5kRW5kUG9pbnRzICk7XHJcbiAgICB9XHJcbiAgICB0aGlzLmFjdGl2ZUJ1ZmZlclNvdXJjZXMgPSBbXTtcclxuICAgIHRoaXMubG9jYWxHYWluTm9kZSA9IHRoaXMuYXVkaW9Db250ZXh0LmNyZWF0ZUdhaW4oKTtcclxuICAgIHRoaXMubG9jYWxHYWluTm9kZS5jb25uZWN0KCB0aGlzLnNvdW5kU291cmNlRGVzdGluYXRpb24gKTtcclxuICAgIHRoaXMuX3BsYXliYWNrUmF0ZSA9IG9wdGlvbnMuaW5pdGlhbFBsYXliYWNrUmF0ZTtcclxuICAgIHRoaXMuaXNQbGF5aW5nUHJvcGVydHkgPSBuZXcgQm9vbGVhblByb3BlcnR5KCBmYWxzZSApO1xyXG4gICAgdGhpcy50aW1lT2ZEZWZlcnJlZFBsYXlSZXF1ZXN0ID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xyXG5cclxuICAgIC8vIGNhbGxiYWNrIGZvciB3aGVuIGF1ZGlvIGNvbnRleHQgaXNuJ3QgaW4gJ3J1bm5pbmcnIHN0YXRlLCBzZWUgdXNhZ2VcclxuICAgIHRoaXMuYXVkaW9Db250ZXh0U3RhdGVDaGFuZ2VMaXN0ZW5lciA9IHN0YXRlID0+IHtcclxuXHJcbiAgICAgIGlmICggc3RhdGUgPT09ICdydW5uaW5nJyApIHtcclxuXHJcbiAgICAgICAgLy8gaW5pdGlhdGUgZGVmZXJyZWQgcGxheSBpZiB0aGlzIGlzIGEgbG9vcCBvciBpZiBpdCBoYXNuJ3QgYmVlbiB0b28gbG9uZyBzaW5jZSB0aGUgcmVxdWVzdCB3YXMgbWFkZVxyXG4gICAgICAgIGlmICggdGhpcy5sb29wIHx8ICggRGF0ZS5ub3coKSAtIHRoaXMudGltZU9mRGVmZXJyZWRQbGF5UmVxdWVzdCApIC8gMTAwMCA8IE1BWF9QTEFZX0RFRkVSX1RJTUUgKSB7XHJcblxyXG4gICAgICAgICAgLy8gUGxheSB0aGUgc291bmQsIGJ1dCB3aXRoIGEgbGl0dGxlIGJpdCBvZiBkZWxheS4gIFRoZSBkZWxheSB3YXMgZm91bmQgdG8gYmUgbmVlZGVkIGJlY2F1c2Ugb3RoZXJ3aXNlIG9uXHJcbiAgICAgICAgICAvLyBzb21lIGJyb3dzZXJzIHRoZSBzb3VuZCB3b3VsZCBiZSBzb21ld2hhdCBtdXRlZCwgcHJvYmFibHkgZHVlIHRvIHNvbWUgc29ydCBvZiBmYWRlIGluIG9mIHRoZSBhdWRpbyBsZXZlbHNcclxuICAgICAgICAgIC8vIHRoYXQgdGhlIGJyb3dzZXIgZG9lcyBhdXRvbWF0aWNhbGx5IHRvIGF2b2lkIGhhdmluZyB0aGUgd2ViIHBhZ2UncyBzb3VuZCBzdGFydCB0b28gYWJydXB0bHkuICBUaGUgYW1vdW50IG9mXHJcbiAgICAgICAgICAvLyBkZWxheSB3YXMgZW1waXJpY2FsbHkgZGV0ZXJtaW5lZCBieSB0ZXN0aW5nIG9uIG11bHRpcGxlIGJyb3dzZXJzLlxyXG4gICAgICAgICAgdGhpcy5wbGF5KCAwLjEgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGF1dG9tYXRpY2FsbHkgcmVtb3ZlIGFmdGVyIGZpcmluZ1xyXG4gICAgICAgIGF1ZGlvQ29udGV4dFN0YXRlQ2hhbmdlTW9uaXRvci5yZW1vdmVTdGF0ZUNoYW5nZUxpc3RlbmVyKFxyXG4gICAgICAgICAgdGhpcy5hdWRpb0NvbnRleHQsXHJcbiAgICAgICAgICB0aGlzLmF1ZGlvQ29udGV4dFN0YXRlQ2hhbmdlTGlzdGVuZXJcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIExpc3RlbiB0byB0aGUgUHJvcGVydHkgdGhhdCBpbmRpY2F0ZXMgd2hldGhlciB3ZSBhcmUgZnVsbHkgZW5hYmxlZCBhbmQgc3RvcCBvbmUtc2hvdCBzb3VuZHMgd2hlbiBpdCBnb2VzIGZhbHNlLlxyXG4gICAgdGhpcy5mdWxseUVuYWJsZWRQcm9wZXJ0eS5sYXp5TGluayggZnVsbHlFbmFibGVkID0+IHtcclxuICAgICAgaWYgKCAhdGhpcy5sb29wICYmICFmdWxseUVuYWJsZWQgKSB7XHJcbiAgICAgICAgdGhpcy5zdG9wKCk7XHJcbiAgICAgIH1cclxuICAgIH0gKTtcclxuXHJcbiAgICAvLyBDbGVhbiB1cCBtZW1vcnkgcmVmZXJlbmNlcyB3aGVuIHRoaXMgb2JqZWN0IGlzIGRpc3Bvc2VkIHRvIGF2b2lkIG1lbW9yeSBsZWFrcy5cclxuICAgIHRoaXMuZGlzcG9zZUVtaXR0ZXIuYWRkTGlzdGVuZXIoICgpID0+IHtcclxuICAgICAgaWYgKCBhdWRpb0NvbnRleHRTdGF0ZUNoYW5nZU1vbml0b3IuaGFzTGlzdGVuZXIoIHRoaXMuYXVkaW9Db250ZXh0LCB0aGlzLmF1ZGlvQ29udGV4dFN0YXRlQ2hhbmdlTGlzdGVuZXIgKSApIHtcclxuICAgICAgICBhdWRpb0NvbnRleHRTdGF0ZUNoYW5nZU1vbml0b3IucmVtb3ZlU3RhdGVDaGFuZ2VMaXN0ZW5lcihcclxuICAgICAgICAgIHRoaXMuYXVkaW9Db250ZXh0LFxyXG4gICAgICAgICAgdGhpcy5hdWRpb0NvbnRleHRTdGF0ZUNoYW5nZUxpc3RlbmVyXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgfSApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3RhcnQgcGxheWluZyB0aGUgc291bmQuXHJcbiAgICovXHJcbiAgcHVibGljIHBsYXkoIGRlbGF5ID0gMCApOiB2b2lkIHtcclxuXHJcbiAgICBpZiAoIHRoaXMuYXVkaW9Db250ZXh0LnN0YXRlID09PSAncnVubmluZycgJiYgdGhpcy53cmFwcGVkQXVkaW9CdWZmZXIuYXVkaW9CdWZmZXJQcm9wZXJ0eS52YWx1ZSApIHtcclxuXHJcbiAgICAgIGNvbnN0IG5vdyA9IHRoaXMuYXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lO1xyXG5cclxuICAgICAgaWYgKCAoIHRoaXMubG9vcCAmJiAhdGhpcy5pc1BsYXlpbmdQcm9wZXJ0eS5nZXQoKSApIHx8XHJcbiAgICAgICAgICAgKCAhdGhpcy5sb29wICYmICggdGhpcy5mdWxseUVuYWJsZWQgfHwgdGhpcy5pbml0aWF0ZVdoZW5EaXNhYmxlZCApICkgKSB7XHJcblxyXG4gICAgICAgIC8vIGNyZWF0ZSBhbiBhdWRpbyBidWZmZXIgc291cmNlIG5vZGUgdGhhdCB1c2VzIHRoZSBwcmV2aW91c2x5IGRlY29kZWQgYXVkaW8gZGF0YVxyXG4gICAgICAgIGNvbnN0IGJ1ZmZlclNvdXJjZSA9IHRoaXMuYXVkaW9Db250ZXh0LmNyZWF0ZUJ1ZmZlclNvdXJjZSgpO1xyXG4gICAgICAgIGJ1ZmZlclNvdXJjZS5idWZmZXIgPSB0aGlzLndyYXBwZWRBdWRpb0J1ZmZlci5hdWRpb0J1ZmZlclByb3BlcnR5LnZhbHVlO1xyXG4gICAgICAgIGJ1ZmZlclNvdXJjZS5sb29wID0gdGhpcy5sb29wO1xyXG4gICAgICAgIGJ1ZmZlclNvdXJjZS5sb29wU3RhcnQgPSB0aGlzLnNvdW5kU3RhcnQ7XHJcbiAgICAgICAgaWYgKCB0aGlzLnNvdW5kRW5kICkge1xyXG4gICAgICAgICAgYnVmZmVyU291cmNlLmxvb3BFbmQgPSB0aGlzLnNvdW5kRW5kO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gbWFrZSBzdXJlIHRoZSBsb2NhbCBnYWluIGlzIHNldCB0byB1bml0eSB2YWx1ZVxyXG4gICAgICAgIHRoaXMubG9jYWxHYWluTm9kZS5nYWluLmNhbmNlbFNjaGVkdWxlZFZhbHVlcyggbm93ICk7XHJcbiAgICAgICAgdGhpcy5sb2NhbEdhaW5Ob2RlLmdhaW4uc2V0VmFsdWVBdFRpbWUoIDEsIG5vdyApO1xyXG5cclxuICAgICAgICBidWZmZXJTb3VyY2UuY29ubmVjdCggdGhpcy5zb3VuZFNvdXJjZURlc3RpbmF0aW9uICk7XHJcblxyXG4gICAgICAgIC8vIGFkZCB0aGlzIHRvIHRoZSBsaXN0IG9mIGFjdGl2ZSBzb3VyY2VzIHNvIHRoYXQgaXQgY2FuIGJlIHN0b3BwZWQgaWYgbmVjZXNzYXJ5XHJcbiAgICAgICAgdGhpcy5hY3RpdmVCdWZmZXJTb3VyY2VzLnB1c2goIGJ1ZmZlclNvdXJjZSApO1xyXG5cclxuICAgICAgICBpZiAoICF0aGlzLmxvb3AgKSB7XHJcblxyXG4gICAgICAgICAgLy8gYWRkIGEgaGFuZGxlciBmb3Igd2hlbiB0aGUgc291bmQgZmluaXNoZXMgcGxheWluZ1xyXG4gICAgICAgICAgYnVmZmVyU291cmNlLm9uZW5kZWQgPSAoKSA9PiB7XHJcblxyXG4gICAgICAgICAgICAvLyByZW1vdmUgdGhlIHNvdXJjZSBmcm9tIHRoZSBsaXN0IG9mIGFjdGl2ZSBzb3VyY2VzXHJcbiAgICAgICAgICAgIGNvbnN0IGluZGV4T2ZTb3VyY2UgPSB0aGlzLmFjdGl2ZUJ1ZmZlclNvdXJjZXMuaW5kZXhPZiggYnVmZmVyU291cmNlICk7XHJcbiAgICAgICAgICAgIGlmICggaW5kZXhPZlNvdXJjZSA+IC0xICkge1xyXG4gICAgICAgICAgICAgIHRoaXMuYWN0aXZlQnVmZmVyU291cmNlcy5zcGxpY2UoIGluZGV4T2ZTb3VyY2UsIDEgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmlzUGxheWluZ1Byb3BlcnR5LnZhbHVlID0gdGhpcy5hY3RpdmVCdWZmZXJTb3VyY2VzLmxlbmd0aCA+IDA7XHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gc2V0IHRoZSBwbGF5YmFjayByYXRlIGFuZCBzdGFydCBwbGF5YmFja1xyXG4gICAgICAgIGJ1ZmZlclNvdXJjZS5wbGF5YmFja1JhdGUuc2V0VmFsdWVBdFRpbWUoIHRoaXMuX3BsYXliYWNrUmF0ZSwgbm93ICk7XHJcbiAgICAgICAgYnVmZmVyU291cmNlLnN0YXJ0KCBub3cgKyBkZWxheSwgdGhpcy5zb3VuZFN0YXJ0ICk7XHJcbiAgICAgICAgdGhpcy5pc1BsYXlpbmdQcm9wZXJ0eS52YWx1ZSA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCB0aGlzLmF1ZGlvQ29udGV4dC5zdGF0ZSA9PT0gJ3N1c3BlbmRlZCcgKSB7XHJcblxyXG4gICAgICAvLyBUaGUgcGxheSBtZXRob2Qgd2FzIGNhbGxlZCB3aGVuIHRoZSBhdWRpbyBjb250ZXh0IHdhcyBub3QgeWV0IHJ1bm5pbmcsIHNvIGFkZCBhIGxpc3RlbmVyIHRvIHBsYXkgaWYgYW5kIHdoZW5cclxuICAgICAgLy8gdGhlIGF1ZGlvIGNvbnRleHQgc3RhdGUgY2hhbmdlcy4gIFRoaXMgd2lsbCBzdGFydCBhbnkgbG9vcHMsIGFuZCB3aWxsIGFsc28gcGxheSBhIG9uZS1zaG90IHNvdW5kIGlmIHRoZSB0aW1lXHJcbiAgICAgIC8vIGJldHdlZW4gdGhlIHJlcXVlc3QgYW5kIHRoZSBzdGF0ZSBjaGFuZ2UgaXNuJ3QgdG9vIGdyZWF0LiAgTm90ZSB0aGF0IHRoaXMgZG9lcyBOT1QgcXVldWUgdXAgbW9yZSB0aGFuIG9uZVxyXG4gICAgICAvLyBpbmRpdmlkdWFsIHNvdW5kIHRvIGJlIHBsYXllZC5cclxuICAgICAgdGhpcy50aW1lT2ZEZWZlcnJlZFBsYXlSZXF1ZXN0ID0gRGF0ZS5ub3coKTtcclxuICAgICAgaWYgKCAhYXVkaW9Db250ZXh0U3RhdGVDaGFuZ2VNb25pdG9yLmhhc0xpc3RlbmVyKCB0aGlzLmF1ZGlvQ29udGV4dCwgdGhpcy5hdWRpb0NvbnRleHRTdGF0ZUNoYW5nZUxpc3RlbmVyICkgKSB7XHJcbiAgICAgICAgYXVkaW9Db250ZXh0U3RhdGVDaGFuZ2VNb25pdG9yLmFkZFN0YXRlQ2hhbmdlTGlzdGVuZXIoXHJcbiAgICAgICAgICB0aGlzLmF1ZGlvQ29udGV4dCxcclxuICAgICAgICAgIHRoaXMuYXVkaW9Db250ZXh0U3RhdGVDaGFuZ2VMaXN0ZW5lclxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0b3AgcGxheWluZyB0aGUgc291bmQuXHJcbiAgICpcclxuICAgKiBOb3RlOiBEb2luZyByYXBpZCBzdG9wcyBhbmQgc3RhcnRzIG9mIGEgbG9vcCB1c2luZyB0aGlzIG1ldGhvZCBjYW4gY2F1c2Ugc291bmQgZ2xpdGNoZXMuICBJZiB5b3UgaGF2ZSBhIG5lZWQgdG9cclxuICAgKiBkbyB0aGF0LCB1c2Ugdm9sdW1lIGZhZGVzIGNvbWJpbmVkIHdpdGggemVybyBkZWxheSBzdG9wcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBbZGVsYXldIC0gVGhlIGFtb3VudCBvZiB0aW1lIHRvIHdhaXQgYmVmb3JlIHN0b3BwaW5nLCBnZW5lcmFsbHkgdXNlZCB0byBwcmV2ZW50IHN1ZGRlbiBzdG9wcywgd2hpY2ggY2FuXHJcbiAgICogY2F1c2UgYXVkaWJsZSBjbGlja3MuICBJZiBncmVhdGVyIHRoYW4gemVybywgd2hpY2ggaXQgaXMgYnkgZGVmYXVsdCwgdGhpcyBtZXRob2Qgd2lsbCB0cnkgdG8gZmFkZSBvdXQgdGhlIHNvdW5kXHJcbiAgICogZnVsbHkgcHJpb3IgdG8gc3RvcHBpbmcgdGhlIGF1ZGlvIHBsYXliYWNrLlxyXG4gICAqL1xyXG4gIHB1YmxpYyBzdG9wKCBkZWxheTogbnVtYmVyID0gREVGQVVMVF9TVE9QX0RFTEFZICk6IHZvaWQge1xyXG5cclxuICAgIC8vIENhbGN1bGF0ZSBhIHRpbWUgY29uc3RhbnQgdG8gZmFkZSBvdXRwdXQgbGV2ZWwgYnkgOTklIGJ5IHRoZSBzdG9wIHRpbWUsIHNlZSBXZWIgQXVkaW8gdGltZSBjb25zdGFudCBpbmZvcm1hdGlvblxyXG4gICAgLy8gdG8gdW5kZXJzdGFuZCB0aGlzIGNhbGN1bGF0aW9uLlxyXG4gICAgY29uc3QgZmFkZVRpbWVDb25zdGFudCA9IGRlbGF5ID4gMCA/IGRlbGF5IC8gNC42MSA6IHNvdW5kQ29uc3RhbnRzLkRFRkFVTFRfUEFSQU1fQ0hBTkdFX1RJTUVfQ09OU1RBTlQ7XHJcblxyXG4gICAgLy8gU2ltcGx5IGNhbGxpbmcgc3RvcCgpIG9uIHRoZSBidWZmZXIgc291cmNlIGZyZXF1ZW50bHkgY2F1c2VzIGFuIGF1ZGlibGUgY2xpY2ssIHNvIHdlIHVzZSBhIGdhaW4gbm9kZSBhbmQgdHVyblxyXG4gICAgLy8gZG93biB0aGUgZ2FpbiwgZWZmZWN0aXZlbHkgZG9pbmcgYSBmYWRlIG91dCwgYW5kIHRoZW4gc3RvcHBpbmcgcGxheWJhY2suXHJcbiAgICBjb25zdCBub3cgPSB0aGlzLmF1ZGlvQ29udGV4dC5jdXJyZW50VGltZTtcclxuICAgIGNvbnN0IHN0b3BUaW1lID0gbm93ICsgZGVsYXk7XHJcbiAgICB0aGlzLmxvY2FsR2Fpbk5vZGUuZ2Fpbi5jYW5jZWxTY2hlZHVsZWRWYWx1ZXMoIG5vdyApO1xyXG4gICAgdGhpcy5sb2NhbEdhaW5Ob2RlLmdhaW4uc2V0VGFyZ2V0QXRUaW1lKCAwLCBub3csIGZhZGVUaW1lQ29uc3RhbnQgKTtcclxuICAgIHRoaXMuYWN0aXZlQnVmZmVyU291cmNlcy5mb3JFYWNoKCBzb3VyY2UgPT4geyBzb3VyY2Uuc3RvcCggc3RvcFRpbWUgKTsgfSApO1xyXG5cclxuICAgIC8vIFRoZSBXZWJBdWRpbyBzcGVjIGlzIGEgYml0IHVuY2xlYXIgYWJvdXQgd2hldGhlciBzdG9wcGluZyBhIHNvdW5kIHdpbGwgdHJpZ2dlciBhbiBvbmVuZGVkIGV2ZW50LiAgSW4gdGVzdGluZ1xyXG4gICAgLy8gb24gQ2hyb21lIGluIFNlcHRlbWJlciAyMDE4LCBJIChqYnBoZXQpIGZvdW5kIHRoYXQgb25lbmRlZCB3YXMgTk9UIGJlaW5nIGZpcmVkIHdoZW4gc3RvcCgpIHdhcyBjYWxsZWQsIHNvIHRoZVxyXG4gICAgLy8gY29kZSBiZWxvdyBpcyBuZWVkZWQgdG8gY2xlYXIgdGhlIGFycmF5IG9mIGFsbCBhY3RpdmUgYnVmZmVyIHNvdXJjZXMuXHJcbiAgICB0aGlzLmFjdGl2ZUJ1ZmZlclNvdXJjZXMubGVuZ3RoID0gMDtcclxuXHJcbiAgICAvLyBjbGVhciB0aGUgZmxhZ1xyXG4gICAgdGhpcy5pc1BsYXlpbmdQcm9wZXJ0eS52YWx1ZSA9IGZhbHNlO1xyXG5cclxuICAgIGlmICggYXVkaW9Db250ZXh0U3RhdGVDaGFuZ2VNb25pdG9yLmhhc0xpc3RlbmVyKCB0aGlzLmF1ZGlvQ29udGV4dCwgdGhpcy5hdWRpb0NvbnRleHRTdGF0ZUNoYW5nZUxpc3RlbmVyICkgKSB7XHJcblxyXG4gICAgICAvLyByZW1vdmUgdGhlIHN0YXRlIGNoYW5nZSBsaXN0ZW5lciB0aGF0IHdhcyBnb2luZyB0byBkbyBhIGRlZmVycmVkIHBsYXksIHNpbmNlIHRoZSBzb3VuZCBoYXMgbm93IGJlZW4gc3RvcHBlZFxyXG4gICAgICBhdWRpb0NvbnRleHRTdGF0ZUNoYW5nZU1vbml0b3IucmVtb3ZlU3RhdGVDaGFuZ2VMaXN0ZW5lcihcclxuICAgICAgICB0aGlzLmF1ZGlvQ29udGV4dCxcclxuICAgICAgICB0aGlzLmF1ZGlvQ29udGV4dFN0YXRlQ2hhbmdlTGlzdGVuZXJcclxuICAgICAgKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldCB0aGUgcGxheWJhY2sgcmF0ZS4gIEJhc2VkIG9uIHRoZSB3YXkgdGhpcyBTb3VuZENsaXAgd2FzIGNyZWF0ZWQsIHRoaXMgbWF5IG9yIG1heSBub3QgYWZmZWN0IGluLXByb2dyZXNzIHNvdW5kcy5cclxuICAgKi9cclxuICBwdWJsaWMgc2V0UGxheWJhY2tSYXRlKCBwbGF5YmFja1JhdGU6IG51bWJlciwgdGltZUNvbnN0YW50OiBudW1iZXIgPSBERUZBVUxUX1RDICk6IHZvaWQge1xyXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggcGxheWJhY2tSYXRlID4gMCwgJ2ludmFsaWQgcGxheWJhY2sgcmF0ZTogJyArIHBsYXliYWNrUmF0ZSApO1xyXG4gICAgaWYgKCB0aGlzLnJhdGVDaGFuZ2VzQWZmZWN0UGxheWluZ1NvdW5kcyApIHtcclxuICAgICAgY29uc3Qgbm93ID0gdGhpcy5hdWRpb0NvbnRleHQuY3VycmVudFRpbWU7XHJcbiAgICAgIHRoaXMuYWN0aXZlQnVmZmVyU291cmNlcy5mb3JFYWNoKCBidWZmZXJTb3VyY2UgPT4ge1xyXG4gICAgICAgIGJ1ZmZlclNvdXJjZS5wbGF5YmFja1JhdGUuY2FuY2VsU2NoZWR1bGVkVmFsdWVzKCBub3cgKTtcclxuICAgICAgICBidWZmZXJTb3VyY2UucGxheWJhY2tSYXRlLnNldFRhcmdldEF0VGltZSggcGxheWJhY2tSYXRlLCBub3csIHRpbWVDb25zdGFudCApO1xyXG4gICAgICB9ICk7XHJcbiAgICB9XHJcbiAgICB0aGlzLl9wbGF5YmFja1JhdGUgPSBwbGF5YmFja1JhdGU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgdGhlIGN1cnJlbnQgcGxheWJhY2sgcmF0ZS4gIE5vdGUgdGhhdCBpdCBpcyBwb3NzaWJsZSB0aGF0IHRoZXJlIGFyZSBhdWRpbyBidWZmZXJzIHRoYXQgYXJlIHBsYXlpbmcgdGhhdCBhcmUgbm90XHJcbiAgICogcGxheWluZyBhdCB0aGUgcmV0dXJuZWQgcmF0ZSBpZiB0aGUgcmF0ZSB3YXMgcmVjZW50bHkgY2hhbmdlZC5cclxuICAgKi9cclxuICBwdWJsaWMgZ2V0UGxheWJhY2tSYXRlKCk6IG51bWJlciB7XHJcbiAgICByZXR1cm4gdGhpcy5fcGxheWJhY2tSYXRlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRVM1IGdldHRlciBmb3IgcGxheWJhY2sgcmF0ZVxyXG4gICAqL1xyXG4gIHB1YmxpYyBnZXQgcGxheWJhY2tSYXRlKCk6IG51bWJlciB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRQbGF5YmFja1JhdGUoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBhIHZhbHVlIHRoYXQgaW5kaWNhdGVzIHdoZXRoZXIgc291bmQgaXMgY3VycmVudGx5IGJlaW5nIHBsYXllZC5cclxuICAgKi9cclxuICBwdWJsaWMgZ2V0IGlzUGxheWluZygpOiBib29sZWFuIHtcclxuICAgIHJldHVybiB0aGlzLmlzUGxheWluZ1Byb3BlcnR5LnZhbHVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IHRoZSBudW1iZXIgb2YgaW5zdGFuY2VzIG9mIHRoZSBhdWRpbyBidWZmZXIgdGhhdCBhcmUgY3VycmVudGx5IHBsYXlpbmcuICBUaGlzIGNhbiBiZSBncmVhdGVyIHRoYW4gb25lIGJlY2F1c2VcclxuICAgKiBTb3VuZENsaXAgc3VwcG9ydHMgbXVsdGlwbGUgYnVmZmVycyBwbGF5aW5nIGF0IHRoZSBzYW1lIHRpbWUuICBUaGlzIG1ldGhvZCBpcyBnZW5lcmFsbHkgdXNlZCB0byBsaW1pdCB0aGUgbnVtYmVyXHJcbiAgICogb2YgaW5zdGFuY2VzIHRoYXQgYXJlIHBsYXlpbmcgYXQgdGhlIHNhbWUgdGltZS5cclxuICAgKi9cclxuICBwdWJsaWMgZ2V0TnVtYmVyT2ZQbGF5aW5nSW5zdGFuY2VzKCk6IG51bWJlciB7XHJcbiAgICByZXR1cm4gdGhpcy5hY3RpdmVCdWZmZXJTb3VyY2VzLmxlbmd0aDtcclxuICB9XHJcbn1cclxuXHJcbnRhbWJvLnJlZ2lzdGVyKCAnU291bmRDbGlwJywgU291bmRDbGlwICk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBTb3VuZENsaXA7Il0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU9BLGVBQWUsTUFBTSxxQ0FBcUM7QUFDakUsT0FBT0MsOEJBQThCLE1BQU0sc0NBQXNDO0FBQ2pGLE9BQU9D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