// Copyright 2018-2024, University of Colorado Boulder

/**
 * a singleton object with functions for analyzing and manipulating sound data
 *
 * @author John Blanco (PhET Interactive Simulations)
 */

import tambo from './tambo.js';
import soundConstants from './soundConstants.js';

// a type that contains information about where the audible sounds begin and end within an audio buffer

// This threshold is used for analyzing individual decoded sound samples in order to find where the actual sound
// values start and end.  Its value was determined through experimentation on a single loop (charges-in-body) at a
// number of different encodings.  It may need to be refined over time as we add new sounds.  Or it may work perfectly
// forever (one can only hope).  See https://github.com/phetsims/tambo/issues/35.
const AUDIO_DATA_THRESHOLD = 0.05;

// A set of multipliers that can be used as playback rates to create a major scale.
const MAJOR_SCALE_MULTIPLIERS = [1, Math.pow(soundConstants.TWELFTH_ROOT_OF_TWO, 2), Math.pow(soundConstants.TWELFTH_ROOT_OF_TWO, 4), Math.pow(soundConstants.TWELFTH_ROOT_OF_TWO, 5), Math.pow(soundConstants.TWELFTH_ROOT_OF_TWO, 7), Math.pow(soundConstants.TWELFTH_ROOT_OF_TWO, 9), Math.pow(soundConstants.TWELFTH_ROOT_OF_TWO, 11)];

/**
 * sound utility object definition
 */
const SoundUtils = {
  /**
   * Detect the start and end points of a sound within and AudioBuffer based on the points where the samples exceed a
   * predetermined threshold.
   */
  detectSoundBounds: audioBuffer => {
    const soundDataLength = audioBuffer.length;
    const soundStartIndexes = [];
    const soundEndIndexes = [];

    // analyze each channel of the sound data
    for (let channelNumber = 0; channelNumber < audioBuffer.numberOfChannels; channelNumber++) {
      // initialize some variables that will be used to analyze the data
      const soundData = audioBuffer.getChannelData(channelNumber);

      // find where the sound first exceeds the threshold
      soundStartIndexes[channelNumber] = findSoundStartIndex(soundData, soundDataLength, AUDIO_DATA_THRESHOLD);

      // find the last point at which the sound exceeds the threshold, then go a little past
      soundEndIndexes[channelNumber] = findSoundEndIndex(soundData, soundDataLength, AUDIO_DATA_THRESHOLD);
    }

    // return an object with values for where the loop should start and end
    const sampleRate = audioBuffer.sampleRate;
    return {
      soundStart: _.min(soundStartIndexes) / sampleRate,
      soundEnd: _.max(soundEndIndexes) / sampleRate
    };
  },
  /**
   * Get a playback rate that can be used to compose a major scale from a pitched sound based on an index.  For example,
   * if a sound is pitched at middle C, providing a value of 1 to this function and then using this for the playback
   * rate, the sound would be pitched at the D just above middle C.  Negative values are allowed.  Basically it's like
   * mapping a major scale to a number line.
   */
  getMajorScalePlaybackRate: index => {
    const moddedIndex = index % 7;
    const octave = Math.floor(index / 7);
    const octaveMultiplier = Math.pow(2, octave);
    return octaveMultiplier * MAJOR_SCALE_MULTIPLIERS[moddedIndex];
  }
};

/**
 * Find the index in the provided audio buffer where the sound begins, i.e. find the end of any leading silence.
 * @param soundData - sound data to be analyzed
 * @param length - length of the sound data
 * @param threshold - detection level for initial sound, should be between 0 and 1
 * @returns index where sound can be considered to start
 */
const findSoundStartIndex = (soundData, length, threshold) => {
  // find the first occurrence of the threshold that is trending in the up direction
  let startThresholdIndex = 0;
  let dataIndex;
  let found = false;
  for (dataIndex = 0; dataIndex < length - 1 && !found; dataIndex++) {
    if (soundData[dataIndex] > threshold && soundData[dataIndex + 1] > soundData[dataIndex]) {
      startThresholdIndex = dataIndex;
      found = true;
    }
  }

  // work backwards from the first threshold found to find the first zero or zero crossing
  let soundStartIndex = 0;
  found = false;
  for (dataIndex = startThresholdIndex; dataIndex > 0 && !found; dataIndex--) {
    const value = soundData[dataIndex];
    if (value <= 0) {
      soundStartIndex = value === 0 ? dataIndex : dataIndex + 1;
      found = true;
    }
  }

  // detect and log the peaks in the pre-start data, useful for determining what the threshold value should be
  let maxPreStartPeak = 0;
  let minPreStartPeak = 0;
  for (dataIndex = 0; dataIndex < soundStartIndex; dataIndex++) {
    maxPreStartPeak = Math.max(maxPreStartPeak, soundData[dataIndex]);
    minPreStartPeak = Math.min(minPreStartPeak, soundData[dataIndex]);
  }
  return soundStartIndex;
};

/**
 * Find the index in the provided sound data where the sound can be considered to end, meaning that there is only
 * silence or very little sound energy thereafter.
 * @param soundData - the sample values for the sound
 * @param length - length of the sound data
 * @param threshold - detection level for the presence of sound, should be between 0 and 1
 */
const findSoundEndIndex = (soundData, length, threshold) => {
  // work backwards from the end of the data to find the first negative occurrence of the threshold
  let endThresholdIndex = length - 1;
  let found = false;
  let dataIndex;
  for (dataIndex = length - 1; dataIndex > 0 && !found; dataIndex--) {
    if (soundData[dataIndex] <= -threshold && soundData[dataIndex - 1] < soundData[dataIndex]) {
      endThresholdIndex = dataIndex;
      found = true;
    }
  }

  // work forward from the end threshold to find a zero or zero crossing that can work as the end of the loop
  let soundEndIndex = endThresholdIndex;
  found = false;
  for (dataIndex = endThresholdIndex; dataIndex < length - 1 && !found; dataIndex++) {
    if (soundData[dataIndex + 1] >= 0) {
      soundEndIndex = dataIndex;
      found = true;
    }
  }

  // detect and log the peaks in the post-end data, useful for determining what the threshold value should be
  let maxPostEndPeak = 0;
  let minPostEndPeak = 0;
  for (dataIndex = soundEndIndex; dataIndex < length; dataIndex++) {
    maxPostEndPeak = Math.max(maxPostEndPeak, soundData[dataIndex]);
    minPostEndPeak = Math.min(minPostEndPeak, soundData[dataIndex]);
  }
  return soundEndIndex;
};
tambo.register('SoundUtils', SoundUtils);
export default SoundUtils;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJ0YW1ibyIsInNvdW5kQ29uc3RhbnRzIiwiQVVESU9fREFUQV9USFJFU0hPTEQiLCJNQUpPUl9TQ0FMRV9NVUxUSVBMSUVSUyIsIk1hdGgiLCJwb3ciLCJUV0VMRlRIX1JPT1RfT0ZfVFdPIiwiU291bmRVdGlscyIsImRldGVjdFNvdW5kQm91bmRzIiwiYXVkaW9CdWZmZXIiLCJzb3VuZERhdGFMZW5ndGgiLCJsZW5ndGgiLCJzb3VuZFN0YXJ0SW5kZXhlcyIsInNvdW5kRW5kSW5kZXhlcyIsImNoYW5uZWxOdW1iZXIiLCJudW1iZXJPZkNoYW5uZWxzIiwic291bmREYXRhIiwiZ2V0Q2hhbm5lbERhdGEiLCJmaW5kU291bmRTdGFydEluZGV4IiwiZmluZFNvdW5kRW5kSW5kZXgiLCJzYW1wbGVSYXRlIiwic291bmRTdGFydCIsIl8iLCJtaW4iLCJzb3VuZEVuZCIsIm1heCIsImdldE1ham9yU2NhbGVQbGF5YmFja1JhdGUiLCJpbmRleCIsIm1vZGRlZEluZGV4Iiwib2N0YXZlIiwiZmxvb3IiLCJvY3RhdmVNdWx0aXBsaWVyIiwidGhyZXNob2xkIiwic3RhcnRUaHJlc2hvbGRJbmRleCIsImRhdGFJbmRleCIsImZvdW5kIiwic291bmRTdGFydEluZGV4IiwidmFsdWUiLCJtYXhQcmVTdGFydFBlYWsiLCJtaW5QcmVTdGFydFBlYWsiLCJlbmRUaHJlc2hvbGRJbmRleCIsInNvdW5kRW5kSW5kZXgiLCJtYXhQb3N0RW5kUGVhayIsIm1pblBvc3RFbmRQZWFrIiwicmVnaXN0ZXIiXSwic291cmNlcyI6WyJTb3VuZFV0aWxzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDE4LTIwMjQsIFVuaXZlcnNpdHkgb2YgQ29sb3JhZG8gQm91bGRlclxyXG5cclxuLyoqXHJcbiAqIGEgc2luZ2xldG9uIG9iamVjdCB3aXRoIGZ1bmN0aW9ucyBmb3IgYW5hbHl6aW5nIGFuZCBtYW5pcHVsYXRpbmcgc291bmQgZGF0YVxyXG4gKlxyXG4gKiBAYXV0aG9yIEpvaG4gQmxhbmNvIChQaEVUIEludGVyYWN0aXZlIFNpbXVsYXRpb25zKVxyXG4gKi9cclxuXHJcbmltcG9ydCB0YW1ibyBmcm9tICcuL3RhbWJvLmpzJztcclxuaW1wb3J0IHNvdW5kQ29uc3RhbnRzIGZyb20gJy4vc291bmRDb25zdGFudHMuanMnO1xyXG5cclxuLy8gYSB0eXBlIHRoYXQgY29udGFpbnMgaW5mb3JtYXRpb24gYWJvdXQgd2hlcmUgdGhlIGF1ZGlibGUgc291bmRzIGJlZ2luIGFuZCBlbmQgd2l0aGluIGFuIGF1ZGlvIGJ1ZmZlclxyXG50eXBlIFNvdW5kQm91bmRzID0ge1xyXG4gIHNvdW5kU3RhcnQ6IG51bWJlcjtcclxuICBzb3VuZEVuZDogbnVtYmVyIHwgbnVsbDtcclxufTtcclxuXHJcbi8vIFRoaXMgdGhyZXNob2xkIGlzIHVzZWQgZm9yIGFuYWx5emluZyBpbmRpdmlkdWFsIGRlY29kZWQgc291bmQgc2FtcGxlcyBpbiBvcmRlciB0byBmaW5kIHdoZXJlIHRoZSBhY3R1YWwgc291bmRcclxuLy8gdmFsdWVzIHN0YXJ0IGFuZCBlbmQuICBJdHMgdmFsdWUgd2FzIGRldGVybWluZWQgdGhyb3VnaCBleHBlcmltZW50YXRpb24gb24gYSBzaW5nbGUgbG9vcCAoY2hhcmdlcy1pbi1ib2R5KSBhdCBhXHJcbi8vIG51bWJlciBvZiBkaWZmZXJlbnQgZW5jb2RpbmdzLiAgSXQgbWF5IG5lZWQgdG8gYmUgcmVmaW5lZCBvdmVyIHRpbWUgYXMgd2UgYWRkIG5ldyBzb3VuZHMuICBPciBpdCBtYXkgd29yayBwZXJmZWN0bHlcclxuLy8gZm9yZXZlciAob25lIGNhbiBvbmx5IGhvcGUpLiAgU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waGV0c2ltcy90YW1iby9pc3N1ZXMvMzUuXHJcbmNvbnN0IEFVRElPX0RBVEFfVEhSRVNIT0xEID0gMC4wNTtcclxuXHJcbi8vIEEgc2V0IG9mIG11bHRpcGxpZXJzIHRoYXQgY2FuIGJlIHVzZWQgYXMgcGxheWJhY2sgcmF0ZXMgdG8gY3JlYXRlIGEgbWFqb3Igc2NhbGUuXHJcbmNvbnN0IE1BSk9SX1NDQUxFX01VTFRJUExJRVJTID0gW1xyXG4gIDEsXHJcbiAgTWF0aC5wb3coIHNvdW5kQ29uc3RhbnRzLlRXRUxGVEhfUk9PVF9PRl9UV08sIDIgKSxcclxuICBNYXRoLnBvdyggc291bmRDb25zdGFudHMuVFdFTEZUSF9ST09UX09GX1RXTywgNCApLFxyXG4gIE1hdGgucG93KCBzb3VuZENvbnN0YW50cy5UV0VMRlRIX1JPT1RfT0ZfVFdPLCA1ICksXHJcbiAgTWF0aC5wb3coIHNvdW5kQ29uc3RhbnRzLlRXRUxGVEhfUk9PVF9PRl9UV08sIDcgKSxcclxuICBNYXRoLnBvdyggc291bmRDb25zdGFudHMuVFdFTEZUSF9ST09UX09GX1RXTywgOSApLFxyXG4gIE1hdGgucG93KCBzb3VuZENvbnN0YW50cy5UV0VMRlRIX1JPT1RfT0ZfVFdPLCAxMSApXHJcbl07XHJcblxyXG4vKipcclxuICogc291bmQgdXRpbGl0eSBvYmplY3QgZGVmaW5pdGlvblxyXG4gKi9cclxuY29uc3QgU291bmRVdGlscyA9IHtcclxuXHJcbiAgLyoqXHJcbiAgICogRGV0ZWN0IHRoZSBzdGFydCBhbmQgZW5kIHBvaW50cyBvZiBhIHNvdW5kIHdpdGhpbiBhbmQgQXVkaW9CdWZmZXIgYmFzZWQgb24gdGhlIHBvaW50cyB3aGVyZSB0aGUgc2FtcGxlcyBleGNlZWQgYVxyXG4gICAqIHByZWRldGVybWluZWQgdGhyZXNob2xkLlxyXG4gICAqL1xyXG4gIGRldGVjdFNvdW5kQm91bmRzOiAoIGF1ZGlvQnVmZmVyOiBBdWRpb0J1ZmZlciApOiBTb3VuZEJvdW5kcyA9PiB7XHJcblxyXG4gICAgY29uc3Qgc291bmREYXRhTGVuZ3RoID0gYXVkaW9CdWZmZXIubGVuZ3RoO1xyXG4gICAgY29uc3Qgc291bmRTdGFydEluZGV4ZXMgPSBbXTtcclxuICAgIGNvbnN0IHNvdW5kRW5kSW5kZXhlcyA9IFtdO1xyXG5cclxuICAgIC8vIGFuYWx5emUgZWFjaCBjaGFubmVsIG9mIHRoZSBzb3VuZCBkYXRhXHJcbiAgICBmb3IgKCBsZXQgY2hhbm5lbE51bWJlciA9IDA7IGNoYW5uZWxOdW1iZXIgPCBhdWRpb0J1ZmZlci5udW1iZXJPZkNoYW5uZWxzOyBjaGFubmVsTnVtYmVyKysgKSB7XHJcblxyXG4gICAgICAvLyBpbml0aWFsaXplIHNvbWUgdmFyaWFibGVzIHRoYXQgd2lsbCBiZSB1c2VkIHRvIGFuYWx5emUgdGhlIGRhdGFcclxuICAgICAgY29uc3Qgc291bmREYXRhID0gYXVkaW9CdWZmZXIuZ2V0Q2hhbm5lbERhdGEoIGNoYW5uZWxOdW1iZXIgKTtcclxuXHJcbiAgICAgIC8vIGZpbmQgd2hlcmUgdGhlIHNvdW5kIGZpcnN0IGV4Y2VlZHMgdGhlIHRocmVzaG9sZFxyXG4gICAgICBzb3VuZFN0YXJ0SW5kZXhlc1sgY2hhbm5lbE51bWJlciBdID0gZmluZFNvdW5kU3RhcnRJbmRleChcclxuICAgICAgICBzb3VuZERhdGEsXHJcbiAgICAgICAgc291bmREYXRhTGVuZ3RoLFxyXG4gICAgICAgIEFVRElPX0RBVEFfVEhSRVNIT0xEXHJcbiAgICAgICk7XHJcblxyXG4gICAgICAvLyBmaW5kIHRoZSBsYXN0IHBvaW50IGF0IHdoaWNoIHRoZSBzb3VuZCBleGNlZWRzIHRoZSB0aHJlc2hvbGQsIHRoZW4gZ28gYSBsaXR0bGUgcGFzdFxyXG4gICAgICBzb3VuZEVuZEluZGV4ZXNbIGNoYW5uZWxOdW1iZXIgXSA9IGZpbmRTb3VuZEVuZEluZGV4KCBzb3VuZERhdGEsIHNvdW5kRGF0YUxlbmd0aCwgQVVESU9fREFUQV9USFJFU0hPTEQgKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyByZXR1cm4gYW4gb2JqZWN0IHdpdGggdmFsdWVzIGZvciB3aGVyZSB0aGUgbG9vcCBzaG91bGQgc3RhcnQgYW5kIGVuZFxyXG4gICAgY29uc3Qgc2FtcGxlUmF0ZSA9IGF1ZGlvQnVmZmVyLnNhbXBsZVJhdGU7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBzb3VuZFN0YXJ0OiBfLm1pbiggc291bmRTdGFydEluZGV4ZXMgKSEgLyBzYW1wbGVSYXRlLFxyXG4gICAgICBzb3VuZEVuZDogXy5tYXgoIHNvdW5kRW5kSW5kZXhlcyApISAvIHNhbXBsZVJhdGVcclxuICAgIH07XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IGEgcGxheWJhY2sgcmF0ZSB0aGF0IGNhbiBiZSB1c2VkIHRvIGNvbXBvc2UgYSBtYWpvciBzY2FsZSBmcm9tIGEgcGl0Y2hlZCBzb3VuZCBiYXNlZCBvbiBhbiBpbmRleC4gIEZvciBleGFtcGxlLFxyXG4gICAqIGlmIGEgc291bmQgaXMgcGl0Y2hlZCBhdCBtaWRkbGUgQywgcHJvdmlkaW5nIGEgdmFsdWUgb2YgMSB0byB0aGlzIGZ1bmN0aW9uIGFuZCB0aGVuIHVzaW5nIHRoaXMgZm9yIHRoZSBwbGF5YmFja1xyXG4gICAqIHJhdGUsIHRoZSBzb3VuZCB3b3VsZCBiZSBwaXRjaGVkIGF0IHRoZSBEIGp1c3QgYWJvdmUgbWlkZGxlIEMuICBOZWdhdGl2ZSB2YWx1ZXMgYXJlIGFsbG93ZWQuICBCYXNpY2FsbHkgaXQncyBsaWtlXHJcbiAgICogbWFwcGluZyBhIG1ham9yIHNjYWxlIHRvIGEgbnVtYmVyIGxpbmUuXHJcbiAgICovXHJcbiAgZ2V0TWFqb3JTY2FsZVBsYXliYWNrUmF0ZTogKCBpbmRleDogbnVtYmVyICk6IG51bWJlciA9PiB7XHJcbiAgICBjb25zdCBtb2RkZWRJbmRleCA9IGluZGV4ICUgNztcclxuICAgIGNvbnN0IG9jdGF2ZSA9IE1hdGguZmxvb3IoIGluZGV4IC8gNyApO1xyXG4gICAgY29uc3Qgb2N0YXZlTXVsdGlwbGllciA9IE1hdGgucG93KCAyLCBvY3RhdmUgKTtcclxuICAgIHJldHVybiBvY3RhdmVNdWx0aXBsaWVyICogTUFKT1JfU0NBTEVfTVVMVElQTElFUlNbIG1vZGRlZEluZGV4IF07XHJcbiAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEZpbmQgdGhlIGluZGV4IGluIHRoZSBwcm92aWRlZCBhdWRpbyBidWZmZXIgd2hlcmUgdGhlIHNvdW5kIGJlZ2lucywgaS5lLiBmaW5kIHRoZSBlbmQgb2YgYW55IGxlYWRpbmcgc2lsZW5jZS5cclxuICogQHBhcmFtIHNvdW5kRGF0YSAtIHNvdW5kIGRhdGEgdG8gYmUgYW5hbHl6ZWRcclxuICogQHBhcmFtIGxlbmd0aCAtIGxlbmd0aCBvZiB0aGUgc291bmQgZGF0YVxyXG4gKiBAcGFyYW0gdGhyZXNob2xkIC0gZGV0ZWN0aW9uIGxldmVsIGZvciBpbml0aWFsIHNvdW5kLCBzaG91bGQgYmUgYmV0d2VlbiAwIGFuZCAxXHJcbiAqIEByZXR1cm5zIGluZGV4IHdoZXJlIHNvdW5kIGNhbiBiZSBjb25zaWRlcmVkIHRvIHN0YXJ0XHJcbiAqL1xyXG5jb25zdCBmaW5kU291bmRTdGFydEluZGV4ID0gKCBzb3VuZERhdGE6IEZsb2F0MzJBcnJheSwgbGVuZ3RoOiBudW1iZXIsIHRocmVzaG9sZDogbnVtYmVyICk6IG51bWJlciA9PiB7XHJcblxyXG4gIC8vIGZpbmQgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgdGhlIHRocmVzaG9sZCB0aGF0IGlzIHRyZW5kaW5nIGluIHRoZSB1cCBkaXJlY3Rpb25cclxuICBsZXQgc3RhcnRUaHJlc2hvbGRJbmRleCA9IDA7XHJcbiAgbGV0IGRhdGFJbmRleDtcclxuICBsZXQgZm91bmQgPSBmYWxzZTtcclxuICBmb3IgKCBkYXRhSW5kZXggPSAwOyBkYXRhSW5kZXggPCBsZW5ndGggLSAxICYmICFmb3VuZDsgZGF0YUluZGV4KysgKSB7XHJcbiAgICBpZiAoIHNvdW5kRGF0YVsgZGF0YUluZGV4IF0gPiB0aHJlc2hvbGQgJiYgc291bmREYXRhWyBkYXRhSW5kZXggKyAxIF0gPiBzb3VuZERhdGFbIGRhdGFJbmRleCBdICkge1xyXG4gICAgICBzdGFydFRocmVzaG9sZEluZGV4ID0gZGF0YUluZGV4O1xyXG4gICAgICBmb3VuZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyB3b3JrIGJhY2t3YXJkcyBmcm9tIHRoZSBmaXJzdCB0aHJlc2hvbGQgZm91bmQgdG8gZmluZCB0aGUgZmlyc3QgemVybyBvciB6ZXJvIGNyb3NzaW5nXHJcbiAgbGV0IHNvdW5kU3RhcnRJbmRleCA9IDA7XHJcbiAgZm91bmQgPSBmYWxzZTtcclxuICBmb3IgKCBkYXRhSW5kZXggPSBzdGFydFRocmVzaG9sZEluZGV4OyBkYXRhSW5kZXggPiAwICYmICFmb3VuZDsgZGF0YUluZGV4LS0gKSB7XHJcbiAgICBjb25zdCB2YWx1ZSA9IHNvdW5kRGF0YVsgZGF0YUluZGV4IF07XHJcbiAgICBpZiAoIHZhbHVlIDw9IDAgKSB7XHJcbiAgICAgIHNvdW5kU3RhcnRJbmRleCA9IHZhbHVlID09PSAwID8gZGF0YUluZGV4IDogZGF0YUluZGV4ICsgMTtcclxuICAgICAgZm91bmQgPSB0cnVlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gZGV0ZWN0IGFuZCBsb2cgdGhlIHBlYWtzIGluIHRoZSBwcmUtc3RhcnQgZGF0YSwgdXNlZnVsIGZvciBkZXRlcm1pbmluZyB3aGF0IHRoZSB0aHJlc2hvbGQgdmFsdWUgc2hvdWxkIGJlXHJcbiAgbGV0IG1heFByZVN0YXJ0UGVhayA9IDA7XHJcbiAgbGV0IG1pblByZVN0YXJ0UGVhayA9IDA7XHJcbiAgZm9yICggZGF0YUluZGV4ID0gMDsgZGF0YUluZGV4IDwgc291bmRTdGFydEluZGV4OyBkYXRhSW5kZXgrKyApIHtcclxuICAgIG1heFByZVN0YXJ0UGVhayA9IE1hdGgubWF4KCBtYXhQcmVTdGFydFBlYWssIHNvdW5kRGF0YVsgZGF0YUluZGV4IF0gKTtcclxuICAgIG1pblByZVN0YXJ0UGVhayA9IE1hdGgubWluKCBtaW5QcmVTdGFydFBlYWssIHNvdW5kRGF0YVsgZGF0YUluZGV4IF0gKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBzb3VuZFN0YXJ0SW5kZXg7XHJcbn07XHJcblxyXG4vKipcclxuICogRmluZCB0aGUgaW5kZXggaW4gdGhlIHByb3ZpZGVkIHNvdW5kIGRhdGEgd2hlcmUgdGhlIHNvdW5kIGNhbiBiZSBjb25zaWRlcmVkIHRvIGVuZCwgbWVhbmluZyB0aGF0IHRoZXJlIGlzIG9ubHlcclxuICogc2lsZW5jZSBvciB2ZXJ5IGxpdHRsZSBzb3VuZCBlbmVyZ3kgdGhlcmVhZnRlci5cclxuICogQHBhcmFtIHNvdW5kRGF0YSAtIHRoZSBzYW1wbGUgdmFsdWVzIGZvciB0aGUgc291bmRcclxuICogQHBhcmFtIGxlbmd0aCAtIGxlbmd0aCBvZiB0aGUgc291bmQgZGF0YVxyXG4gKiBAcGFyYW0gdGhyZXNob2xkIC0gZGV0ZWN0aW9uIGxldmVsIGZvciB0aGUgcHJlc2VuY2Ugb2Ygc291bmQsIHNob3VsZCBiZSBiZXR3ZWVuIDAgYW5kIDFcclxuICovXHJcbmNvbnN0IGZpbmRTb3VuZEVuZEluZGV4ID0gKCBzb3VuZERhdGE6IEZsb2F0MzJBcnJheSwgbGVuZ3RoOiBudW1iZXIsIHRocmVzaG9sZDogbnVtYmVyICk6IG51bWJlciA9PiB7XHJcblxyXG4gIC8vIHdvcmsgYmFja3dhcmRzIGZyb20gdGhlIGVuZCBvZiB0aGUgZGF0YSB0byBmaW5kIHRoZSBmaXJzdCBuZWdhdGl2ZSBvY2N1cnJlbmNlIG9mIHRoZSB0aHJlc2hvbGRcclxuICBsZXQgZW5kVGhyZXNob2xkSW5kZXggPSBsZW5ndGggLSAxO1xyXG4gIGxldCBmb3VuZCA9IGZhbHNlO1xyXG4gIGxldCBkYXRhSW5kZXg7XHJcbiAgZm9yICggZGF0YUluZGV4ID0gbGVuZ3RoIC0gMTsgZGF0YUluZGV4ID4gMCAmJiAhZm91bmQ7IGRhdGFJbmRleC0tICkge1xyXG4gICAgaWYgKCBzb3VuZERhdGFbIGRhdGFJbmRleCBdIDw9IC10aHJlc2hvbGQgJiYgc291bmREYXRhWyBkYXRhSW5kZXggLSAxIF0gPCBzb3VuZERhdGFbIGRhdGFJbmRleCBdICkge1xyXG4gICAgICBlbmRUaHJlc2hvbGRJbmRleCA9IGRhdGFJbmRleDtcclxuICAgICAgZm91bmQgPSB0cnVlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gd29yayBmb3J3YXJkIGZyb20gdGhlIGVuZCB0aHJlc2hvbGQgdG8gZmluZCBhIHplcm8gb3IgemVybyBjcm9zc2luZyB0aGF0IGNhbiB3b3JrIGFzIHRoZSBlbmQgb2YgdGhlIGxvb3BcclxuICBsZXQgc291bmRFbmRJbmRleCA9IGVuZFRocmVzaG9sZEluZGV4O1xyXG4gIGZvdW5kID0gZmFsc2U7XHJcbiAgZm9yICggZGF0YUluZGV4ID0gZW5kVGhyZXNob2xkSW5kZXg7IGRhdGFJbmRleCA8IGxlbmd0aCAtIDEgJiYgIWZvdW5kOyBkYXRhSW5kZXgrKyApIHtcclxuICAgIGlmICggc291bmREYXRhWyBkYXRhSW5kZXggKyAxIF0gPj0gMCApIHtcclxuICAgICAgc291bmRFbmRJbmRleCA9IGRhdGFJbmRleDtcclxuICAgICAgZm91bmQgPSB0cnVlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gZGV0ZWN0IGFuZCBsb2cgdGhlIHBlYWtzIGluIHRoZSBwb3N0LWVuZCBkYXRhLCB1c2VmdWwgZm9yIGRldGVybWluaW5nIHdoYXQgdGhlIHRocmVzaG9sZCB2YWx1ZSBzaG91bGQgYmVcclxuICBsZXQgbWF4UG9zdEVuZFBlYWsgPSAwO1xyXG4gIGxldCBtaW5Qb3N0RW5kUGVhayA9IDA7XHJcbiAgZm9yICggZGF0YUluZGV4ID0gc291bmRFbmRJbmRleDsgZGF0YUluZGV4IDwgbGVuZ3RoOyBkYXRhSW5kZXgrKyApIHtcclxuICAgIG1heFBvc3RFbmRQZWFrID0gTWF0aC5tYXgoIG1heFBvc3RFbmRQZWFrLCBzb3VuZERhdGFbIGRhdGFJbmRleCBdICk7XHJcbiAgICBtaW5Qb3N0RW5kUGVhayA9IE1hdGgubWluKCBtaW5Qb3N0RW5kUGVhaywgc291bmREYXRhWyBkYXRhSW5kZXggXSApO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHNvdW5kRW5kSW5kZXg7XHJcbn07XHJcblxyXG50YW1iby5yZWdpc3RlciggJ1NvdW5kVXRpbHMnLCBTb3VuZFV0aWxzICk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBTb3VuZFV0aWxzOyJdLCJtYXBwaW5ncyI6IkFBQUE7O0FB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LE1BQU1qQixpQkFBaUIsR0FBR0EsQ0FBRUgsU0FBdUIsRUFBRUwsTUFBYyxFQUFFcUIsU0FBaUIsS0FBYztFQUVsRztFQUNBLElBQUlRLGlCQUFpQixHQUFHN0IsTUFBTSxHQUFHLENBQUM7RUFDbEMsSUFBSXdCLEtBQUssR0FBRyxLQUFLO0VBQ2pCLElBQUlELFNBQVM7RUFDYixLQUFNQSxTQUFTLEdBQUd2QixNQUFNLEdBQUcsQ0FBQyxFQUFFdUIsU0FBUyxHQUFHLENBQUMsSUFBSSxDQUFDQyxLQUFLLEVBQUVELFNBQVMsRUFBRSxFQUFHO0lBQ25FLElBQUtsQixTQUFTLENBQUVrQixTQUFTLENBQUUsSUFBSSxDQUFDRixTQUFTLElBQUloQixTQUFTLENBQUVrQixTQUFTLEdBQUcsQ0FBQyxDQUFFLEdBQUdsQixTQUFTLENBQUVrQixTQUFTLENBQUUsRUFBRztNQUNqR00saUJBQWlCLEdBQUdOLFNBQVM7TUFDN0JDLEtBQUssR0FBRyxJQUFJO0lBQ2Q7RUFDRjs7RUFFQTtFQUNBLElBQUlNLGFBQWEsR0FBR0QsaUJBQWlCO0VBQ3JDTCxLQUFLLEdBQUcsS0FBSztFQUNiLEtBQU1ELFNBQVMsR0FBR00saUJBQWlCLEVBQUVOLFNBQVMsR0FBR3ZCLE1BQU0sR0FBRyxDQUFDLElBQUksQ0FBQ3dCLEtBQUssRUFBRUQsU0FBUyxFQUFFLEVBQUc7SUFDbkYsSUFBS2xCLFNBQVMsQ0FBRWtCLFNBQVMsR0FBRyxDQUFDLENBQUUsSUFBSSxDQUFDLEVBQUc7TUFDckNPLGFBQWEsR0FBR1AsU0FBUztNQUN6QkMsS0FBSyxHQUFHLElBQUk7SUFDZDtFQUNGOztFQUVBO0VBQ0EsSUFBSU8sY0FBYyxHQUFHLENBQUM7RUFDdEIsSUFBSUMsY0FBYyxHQUFHLENBQUM7RUFDdEIsS0FBTVQsU0FBUyxHQUFHTyxhQUFhLEVBQUVQLFNBQVMsR0FBR3ZCLE1BQU0sRUFBRXVCLFNBQVMsRUFBRSxFQUFHO0lBQ2pFUSxjQUFjLEdBQUd0QyxJQUFJLENBQUNxQixHQUFHLENBQUVpQixjQUFjLEVBQUUxQixTQUFTLENBQUVrQixTQUFTLENBQUcsQ0FBQztJQUNuRVMsY0FBYyxHQUFHdkMsSUFBSSxDQUFDbUIsR0FBRyxDQUFFb0IsY0FBYyxFQUFFM0IsU0FBUyxDQUFFa0IsU0FBUyxDQUFHLENBQUM7RUFDckU7RUFFQSxPQUFPTyxhQUFhO0FBQ3RCLENBQUM7QUFFRHpDLEtBQUssQ0FBQzRDLFFBQVEsQ0FBRSxZQUFZLEVBQUVyQyxVQUFXLENBQUM7QUFFMUMsZUFBZUEsVUFBVSIsImlnbm9yZUxpc3QiOltdfQ==