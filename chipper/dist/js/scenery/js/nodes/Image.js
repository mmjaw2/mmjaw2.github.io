// Copyright 2013-2024, University of Colorado Boulder

/**
 * A node that displays a single image either from an actual HTMLImageElement, a URL, a Canvas element, or a mipmap
 * data structure described in the constructor.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

import Bounds2 from '../../../dot/js/Bounds2.js';
import IOType from '../../../tandem/js/types/IOType.js';
import StringIO from '../../../tandem/js/types/StringIO.js';
import VoidIO from '../../../tandem/js/types/VoidIO.js';
import { Imageable, ImageCanvasDrawable, ImageDOMDrawable, ImageSVGDrawable, ImageWebGLDrawable, Node, Renderer, scenery, SpriteSheet } from '../imports.js';
import optionize, { combineOptions } from '../../../phet-core/js/optionize.js';
import { isTReadOnlyProperty } from '../../../axon/js/TReadOnlyProperty.js';

// Image-specific options that can be passed in the constructor or mutate() call.
const IMAGE_OPTION_KEYS = ['image',
// {string|HTMLImageElement|HTMLCanvasElement|Array} - Changes the image displayed, see setImage() for documentation
'imageProperty',
// {TReadOnlyProperty.<string|HTMLImageElement|HTMLCanvasElement|Array>|null} - Changes the image displayed, see setImageProperty() for documentation
'imageOpacity',
// {number} - Controls opacity of this image (and not children), see setImageOpacity() for documentation
'imageBounds',
// {Bounds2|null} - Controls the amount of the image that is hit-tested or considered "inside" the image, see setImageBounds()
'initialWidth',
// {number} - Width of an image not-yet loaded (for layout), see setInitialWidth() for documentation
'initialHeight',
// {number} - Height of an image not-yet loaded (for layout), see setInitialHeight() for documentation
'mipmap',
// {boolean} - Whether mipmapped output is supported, see setMipmap() for documentation
'mipmapBias',
// {number} - Whether mipmapping tends towards sharp/aliased or blurry, see setMipmapBias() for documentation
'mipmapInitialLevel',
// {number} - How many mipmap levels to generate if needed, see setMipmapInitialLevel() for documentation
'mipmapMaxLevel',
// {number} The maximum mipmap level to compute if needed, see setMipmapMaxLevel() for documentation
'hitTestPixels' // {boolean} - Whether non-transparent pixels will control contained points, see setHitTestPixels() for documentation
];
export default class Image extends Imageable(Node) {
  // If non-null, determines what is considered "inside" the image for containment and hit-testing.

  constructor(image, providedOptions) {
    const initImageOptions = {};
    if (isTReadOnlyProperty(image)) {
      initImageOptions.imageProperty = image;
    } else {
      initImageOptions.image = image;
    }

    // rely on the setImage call from the super constructor to do the setup
    const options = optionize()(initImageOptions, providedOptions);
    super();
    this._imageBounds = null;
    this.mutate(options);
    this.invalidateSupportedRenderers();
  }

  /**
   * Triggers recomputation of the image's bounds and refreshes any displays output of the image.
   *
   * Generally this can trigger recomputation of mipmaps, will mark any drawables as needing repaints, and will
   * cause a spritesheet change for WebGL.
   *
   * This should be done when the underlying image has changed appearance (usually the case with a Canvas changing,
   * but this is also triggered by our actual image reference changing).
   */
  invalidateImage() {
    if (this._image) {
      this.invalidateSelf(this._imageBounds || new Bounds2(0, 0, this.getImageWidth(), this.getImageHeight()));
    } else {
      this.invalidateSelf(Bounds2.NOTHING);
    }
    const stateLen = this._drawables.length;
    for (let i = 0; i < stateLen; i++) {
      this._drawables[i].markDirtyImage();
    }
    super.invalidateImage();
    this.invalidateSupportedRenderers();
  }

  /**
   * Recomputes what renderers are supported, given the current image information.
   */
  invalidateSupportedRenderers() {
    // Canvas is always permitted
    let r = Renderer.bitmaskCanvas;

    // If it fits within the sprite sheet, then WebGL is also permitted
    // If the image hasn't loaded, the getImageWidth/Height will be 0 and this rule would pass.  However, this
    // function will be called again after the image loads, and would correctly invalidate WebGL, if too large to fit
    // in a SpriteSheet
    const fitsWithinSpriteSheet = this.getImageWidth() <= SpriteSheet.MAX_DIMENSION.width && this.getImageHeight() <= SpriteSheet.MAX_DIMENSION.height;
    if (fitsWithinSpriteSheet) {
      r |= Renderer.bitmaskWebGL;
    }

    // If it is not a canvas, then it can additionally be rendered in SVG or DOM
    if (!(this._image instanceof HTMLCanvasElement)) {
      // assumes HTMLImageElement
      r |= Renderer.bitmaskSVG | Renderer.bitmaskDOM;
    }
    this.setRendererBitmask(r);
  }

  /**
   * Sets an opacity that is applied only to this image (will not affect children or the rest of the node's subtree).
   *
   * This should generally be preferred over Node's opacity if it has the same result, as modifying this will be much
   * faster, and will not force additional Canvases or intermediate steps in display.
   *
   * @param imageOpacity - Should be a number between 0 (transparent) and 1 (opaque), just like normal opacity.
   */
  setImageOpacity(imageOpacity) {
    const changed = this._imageOpacity !== imageOpacity;
    super.setImageOpacity(imageOpacity);
    if (changed) {
      const stateLen = this._drawables.length;
      for (let i = 0; i < stateLen; i++) {
        this._drawables[i].markDirtyImageOpacity();
      }
    }
  }

  /**
   * Sets the imageBounds value for the Image. If non-null, determines what is considered "inside" the image for
   * containment and hit-testing.
   *
   * NOTE: This is accomplished by using any provided imageBounds as the node's own selfBounds. This will affect layout,
   * hit-testing, and anything else using the bounds of this node.
   */
  setImageBounds(imageBounds) {
    if (this._imageBounds !== imageBounds) {
      this._imageBounds = imageBounds;
      this.invalidateImage();
    }
  }
  set imageBounds(value) {
    this.setImageBounds(value);
  }
  get imageBounds() {
    return this._imageBounds;
  }

  /**
   * Returns the imageBounds, see setImageBounds for details.
   */
  getImageBounds() {
    return this._imageBounds;
  }

  /**
   * Whether this Node itself is painted (displays something itself).
   */
  isPainted() {
    // Always true for Image nodes
    return true;
  }

  /**
   * Draws the current Node's self representation, assuming the wrapper's Canvas context is already in the local
   * coordinate frame of this node.
   *
   * @param wrapper
   * @param matrix - The transformation matrix already applied to the context.
   */
  canvasPaintSelf(wrapper, matrix) {
    //TODO: Have a separate method for this, instead of touching the prototype. Can make 'this' references too easily. https://github.com/phetsims/scenery/issues/1581
    ImageCanvasDrawable.prototype.paintCanvas(wrapper, this, matrix);
  }

  /**
   * Creates a DOM drawable for this Image. (scenery-internal)
   *
   * @param renderer - In the bitmask format specified by Renderer, which may contain additional bit flags.
   * @param instance - Instance object that will be associated with the drawable
   */
  createDOMDrawable(renderer, instance) {
    // @ts-expect-error - Poolable
    return ImageDOMDrawable.createFromPool(renderer, instance);
  }

  /**
   * Creates a SVG drawable for this Image. (scenery-internal)
   *
   * @param renderer - In the bitmask format specified by Renderer, which may contain additional bit flags.
   * @param instance - Instance object that will be associated with the drawable
   */
  createSVGDrawable(renderer, instance) {
    // @ts-expect-error - Poolable
    return ImageSVGDrawable.createFromPool(renderer, instance);
  }

  /**
   * Creates a Canvas drawable for this Image. (scenery-internal)
   *
   * @param renderer - In the bitmask format specified by Renderer, which may contain additional bit flags.
   * @param instance - Instance object that will be associated with the drawable
   */
  createCanvasDrawable(renderer, instance) {
    // @ts-expect-error - Poolable
    return ImageCanvasDrawable.createFromPool(renderer, instance);
  }

  /**
   * Creates a WebGL drawable for this Image. (scenery-internal)
   *
   * @param renderer - In the bitmask format specified by Renderer, which may contain additional bit flags.
   * @param instance - Instance object that will be associated with the drawable
   */
  createWebGLDrawable(renderer, instance) {
    // @ts-expect-error - Poolable
    return ImageWebGLDrawable.createFromPool(renderer, instance);
  }

  /**
   * Override this for computation of whether a point is inside our self content (defaults to selfBounds check).
   *
   * @param point - Considered to be in the local coordinate frame
   */
  containsPointSelf(point) {
    const inBounds = Node.prototype.containsPointSelf.call(this, point);
    if (!inBounds || !this._hitTestPixels || !this._hitTestImageData) {
      return inBounds;
    }
    return Imageable.testHitTestData(this._hitTestImageData, this.imageWidth, this.imageHeight, point);
  }

  /**
   * Returns a Shape that represents the area covered by containsPointSelf.
   */
  getSelfShape() {
    if (this._hitTestPixels && this._hitTestImageData) {
      // If we're hit-testing pixels, return that shape included.
      return Imageable.hitTestDataToShape(this._hitTestImageData, this.imageWidth, this.imageHeight);
    } else {
      // Otherwise the super call will just include the rectangle (bounds).
      return Node.prototype.getSelfShape.call(this);
    }
  }

  /**
   * Triggers recomputation of mipmaps (as long as mipmapping is enabled)
   */
  invalidateMipmaps() {
    const markDirty = this._image && this._mipmap && !this._mipmapData;
    super.invalidateMipmaps();
    if (markDirty) {
      const stateLen = this._drawables.length;
      for (let i = 0; i < stateLen; i++) {
        this._drawables[i].markDirtyMipmap();
      }
    }
  }
  mutate(options) {
    return super.mutate(options);
  }
  // Initial values for most Node mutator options
  static DEFAULT_IMAGE_OPTIONS = combineOptions({}, Node.DEFAULT_NODE_OPTIONS, Imageable.DEFAULT_OPTIONS);
}

/**
 * {Array.<string>} - String keys for all of the allowed options that will be set by node.mutate( options ), in the
 * order they will be evaluated in.
 *
 * NOTE: See Node's _mutatorKeys documentation for more information on how this operates, and potential special
 *       cases that may apply.
 */
Image.prototype._mutatorKeys = [...IMAGE_OPTION_KEYS, ...Node.prototype._mutatorKeys];

/**
 * {Array.<String>} - List of all dirty flags that should be available on drawables created from this node (or
 *                    subtype). Given a flag (e.g. radius), it indicates the existence of a function
 *                    drawable.markDirtyRadius() that will indicate to the drawable that the radius has changed.
 * (scenery-internal)
 * @override
 */
Image.prototype.drawableMarkFlags = [...Node.prototype.drawableMarkFlags, 'image', 'imageOpacity', 'mipmap'];

// NOTE: Not currently in use
Image.ImageIO = new IOType('ImageIO', {
  valueType: Image,
  supertype: Node.NodeIO,
  events: ['changed'],
  methods: {
    setImage: {
      returnType: VoidIO,
      parameterTypes: [StringIO],
      implementation: function (base64Text) {
        const im = new window.Image();
        im.src = base64Text;
        // @ts-expect-error TODO: how would this even work? https://github.com/phetsims/scenery/issues/1581
        this.image = im;
      },
      documentation: 'Set the image from a base64 string',
      invocableForReadOnlyElements: false
    }
  }
});
scenery.register('Image', Image);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJCb3VuZHMyIiwiSU9UeXBlIiwiU3RyaW5nSU8iLCJWb2lkSU8iLCJJbWFnZWFibGUiLCJJbWFnZUNhbnZhc0RyYXdhYmxlIiwiSW1hZ2VET01EcmF3YWJsZSIsIkltYWdlU1ZHRHJhd2FibGUiLCJJbWFnZVdlYkdMRHJhd2FibGUiLCJOb2RlIiwiUmVuZGVyZXIiLCJzY2VuZXJ5IiwiU3ByaXRlU2hlZXQiLCJvcHRpb25pemUiLCJjb21iaW5lT3B0aW9ucyIsImlzVFJlYWRPbmx5UHJvcGVydHkiLCJJTUFHRV9PUFRJT05fS0VZUyIsIkltYWdlIiwiY29uc3RydWN0b3IiLCJpbWFnZSIsInByb3ZpZGVkT3B0aW9ucyIsImluaXRJbWFnZU9wdGlvbnMiLCJpbWFnZVByb3BlcnR5Iiwib3B0aW9ucyIsIl9pbWFnZUJvdW5kcyIsIm11dGF0ZSIsImludmFsaWRhdGVTdXBwb3J0ZWRSZW5kZXJlcnMiLCJpbnZhbGlkYXRlSW1hZ2UiLCJfaW1hZ2UiLCJpbnZhbGlkYXRlU2VsZiIsImdldEltYWdlV2lkdGgiLCJnZXRJbWFnZUhlaWdodCIsIk5PVEhJTkciLCJzdGF0ZUxlbiIsIl9kcmF3YWJsZXMiLCJsZW5ndGgiLCJpIiwibWFya0RpcnR5SW1hZ2UiLCJyIiwiYml0bWFza0NhbnZhcyIsImZpdHNXaXRoaW5TcHJpdGVTaGVldCIsIk1BWF9ESU1FTlNJT04iLCJ3aWR0aCIsImhlaWdodCIsImJpdG1hc2tXZWJHTCIsIkhUTUxDYW52YXNFbGVtZW50IiwiYml0bWFza1NWRyIsImJpdG1hc2tET00iLCJzZXRSZW5kZXJlckJpdG1hc2siLCJzZXRJbWFnZU9wYWNpdHkiLCJpbWFnZU9wYWNpdHkiLCJjaGFuZ2VkIiwiX2ltYWdlT3BhY2l0eSIsIm1hcmtEaXJ0eUltYWdlT3BhY2l0eSIsInNldEltYWdlQm91bmRzIiwiaW1hZ2VCb3VuZHMiLCJ2YWx1ZSIsImdldEltYWdlQm91bmRzIiwiaXNQYWludGVkIiwiY2FudmFzUGFpbnRTZWxmIiwid3JhcHBlciIsIm1hdHJpeCIsInByb3RvdHlwZSIsInBhaW50Q2FudmFzIiwiY3JlYXRlRE9NRHJhd2FibGUiLCJyZW5kZXJlciIsImluc3RhbmNlIiwiY3JlYXRlRnJvbVBvb2wiLCJjcmVhdGVTVkdEcmF3YWJsZSIsImNyZWF0ZUNhbnZhc0RyYXdhYmxlIiwiY3JlYXRlV2ViR0xEcmF3YWJsZSIsImNvbnRhaW5zUG9pbnRTZWxmIiwicG9pbnQiLCJpbkJvdW5kcyIsImNhbGwiLCJfaGl0VGVzdFBpeGVscyIsIl9oaXRUZXN0SW1hZ2VEYXRhIiwidGVzdEhpdFRlc3REYXRhIiwiaW1hZ2VXaWR0aCIsImltYWdlSGVpZ2h0IiwiZ2V0U2VsZlNoYXBlIiwiaGl0VGVzdERhdGFUb1NoYXBlIiwiaW52YWxpZGF0ZU1pcG1hcHMiLCJtYXJrRGlydHkiLCJfbWlwbWFwIiwiX21pcG1hcERhdGEiLCJtYXJrRGlydHlNaXBtYXAiLCJERUZBVUxUX0lNQUdFX09QVElPTlMiLCJERUZBVUxUX05PREVfT1BUSU9OUyIsIkRFRkFVTFRfT1BUSU9OUyIsIl9tdXRhdG9yS2V5cyIsImRyYXdhYmxlTWFya0ZsYWdzIiwiSW1hZ2VJTyIsInZhbHVlVHlwZSIsInN1cGVydHlwZSIsIk5vZGVJTyIsImV2ZW50cyIsIm1ldGhvZHMiLCJzZXRJbWFnZSIsInJldHVyblR5cGUiLCJwYXJhbWV0ZXJUeXBlcyIsImltcGxlbWVudGF0aW9uIiwiYmFzZTY0VGV4dCIsImltIiwid2luZG93Iiwic3JjIiwiZG9jdW1lbnRhdGlvbiIsImludm9jYWJsZUZvclJlYWRPbmx5RWxlbWVudHMiLCJyZWdpc3RlciJdLCJzb3VyY2VzIjpbIkltYWdlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDEzLTIwMjQsIFVuaXZlcnNpdHkgb2YgQ29sb3JhZG8gQm91bGRlclxyXG5cclxuLyoqXHJcbiAqIEEgbm9kZSB0aGF0IGRpc3BsYXlzIGEgc2luZ2xlIGltYWdlIGVpdGhlciBmcm9tIGFuIGFjdHVhbCBIVE1MSW1hZ2VFbGVtZW50LCBhIFVSTCwgYSBDYW52YXMgZWxlbWVudCwgb3IgYSBtaXBtYXBcclxuICogZGF0YSBzdHJ1Y3R1cmUgZGVzY3JpYmVkIGluIHRoZSBjb25zdHJ1Y3Rvci5cclxuICpcclxuICogQGF1dGhvciBKb25hdGhhbiBPbHNvbiA8am9uYXRoYW4ub2xzb25AY29sb3JhZG8uZWR1PlxyXG4gKi9cclxuXHJcbmltcG9ydCBCb3VuZHMyIGZyb20gJy4uLy4uLy4uL2RvdC9qcy9Cb3VuZHMyLmpzJztcclxuaW1wb3J0IElPVHlwZSBmcm9tICcuLi8uLi8uLi90YW5kZW0vanMvdHlwZXMvSU9UeXBlLmpzJztcclxuaW1wb3J0IFN0cmluZ0lPIGZyb20gJy4uLy4uLy4uL3RhbmRlbS9qcy90eXBlcy9TdHJpbmdJTy5qcyc7XHJcbmltcG9ydCBWb2lkSU8gZnJvbSAnLi4vLi4vLi4vdGFuZGVtL2pzL3R5cGVzL1ZvaWRJTy5qcyc7XHJcbmltcG9ydCBNYXRyaXgzIGZyb20gJy4uLy4uLy4uL2RvdC9qcy9NYXRyaXgzLmpzJztcclxuaW1wb3J0IFZlY3RvcjIgZnJvbSAnLi4vLi4vLi4vZG90L2pzL1ZlY3RvcjIuanMnO1xyXG5pbXBvcnQgeyBTaGFwZSB9IGZyb20gJy4uLy4uLy4uL2tpdGUvanMvaW1wb3J0cy5qcyc7XHJcbmltcG9ydCB7IENhbnZhc0NvbnRleHRXcmFwcGVyLCBDYW52YXNTZWxmRHJhd2FibGUsIERPTVNlbGZEcmF3YWJsZSwgSW1hZ2VhYmxlLCBJbWFnZWFibGVJbWFnZSwgSW1hZ2VhYmxlT3B0aW9ucywgSW1hZ2VDYW52YXNEcmF3YWJsZSwgSW1hZ2VET01EcmF3YWJsZSwgSW1hZ2VTVkdEcmF3YWJsZSwgSW1hZ2VXZWJHTERyYXdhYmxlLCBJbnN0YW5jZSwgTm9kZSwgTm9kZU9wdGlvbnMsIFJlbmRlcmVyLCBzY2VuZXJ5LCBTcHJpdGVTaGVldCwgU1ZHU2VsZkRyYXdhYmxlLCBUSW1hZ2VEcmF3YWJsZSwgV2ViR0xTZWxmRHJhd2FibGUgfSBmcm9tICcuLi9pbXBvcnRzLmpzJztcclxuaW1wb3J0IG9wdGlvbml6ZSwgeyBjb21iaW5lT3B0aW9ucywgRW1wdHlTZWxmT3B0aW9ucyB9IGZyb20gJy4uLy4uLy4uL3BoZXQtY29yZS9qcy9vcHRpb25pemUuanMnO1xyXG5pbXBvcnQgVFJlYWRPbmx5UHJvcGVydHksIHsgaXNUUmVhZE9ubHlQcm9wZXJ0eSB9IGZyb20gJy4uLy4uLy4uL2F4b24vanMvVFJlYWRPbmx5UHJvcGVydHkuanMnO1xyXG5cclxuXHJcbi8vIEltYWdlLXNwZWNpZmljIG9wdGlvbnMgdGhhdCBjYW4gYmUgcGFzc2VkIGluIHRoZSBjb25zdHJ1Y3RvciBvciBtdXRhdGUoKSBjYWxsLlxyXG5jb25zdCBJTUFHRV9PUFRJT05fS0VZUyA9IFtcclxuICAnaW1hZ2UnLCAvLyB7c3RyaW5nfEhUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR8QXJyYXl9IC0gQ2hhbmdlcyB0aGUgaW1hZ2UgZGlzcGxheWVkLCBzZWUgc2V0SW1hZ2UoKSBmb3IgZG9jdW1lbnRhdGlvblxyXG4gICdpbWFnZVByb3BlcnR5JywgLy8ge1RSZWFkT25seVByb3BlcnR5LjxzdHJpbmd8SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudHxBcnJheT58bnVsbH0gLSBDaGFuZ2VzIHRoZSBpbWFnZSBkaXNwbGF5ZWQsIHNlZSBzZXRJbWFnZVByb3BlcnR5KCkgZm9yIGRvY3VtZW50YXRpb25cclxuICAnaW1hZ2VPcGFjaXR5JywgLy8ge251bWJlcn0gLSBDb250cm9scyBvcGFjaXR5IG9mIHRoaXMgaW1hZ2UgKGFuZCBub3QgY2hpbGRyZW4pLCBzZWUgc2V0SW1hZ2VPcGFjaXR5KCkgZm9yIGRvY3VtZW50YXRpb25cclxuICAnaW1hZ2VCb3VuZHMnLCAvLyB7Qm91bmRzMnxudWxsfSAtIENvbnRyb2xzIHRoZSBhbW91bnQgb2YgdGhlIGltYWdlIHRoYXQgaXMgaGl0LXRlc3RlZCBvciBjb25zaWRlcmVkIFwiaW5zaWRlXCIgdGhlIGltYWdlLCBzZWUgc2V0SW1hZ2VCb3VuZHMoKVxyXG4gICdpbml0aWFsV2lkdGgnLCAvLyB7bnVtYmVyfSAtIFdpZHRoIG9mIGFuIGltYWdlIG5vdC15ZXQgbG9hZGVkIChmb3IgbGF5b3V0KSwgc2VlIHNldEluaXRpYWxXaWR0aCgpIGZvciBkb2N1bWVudGF0aW9uXHJcbiAgJ2luaXRpYWxIZWlnaHQnLCAvLyB7bnVtYmVyfSAtIEhlaWdodCBvZiBhbiBpbWFnZSBub3QteWV0IGxvYWRlZCAoZm9yIGxheW91dCksIHNlZSBzZXRJbml0aWFsSGVpZ2h0KCkgZm9yIGRvY3VtZW50YXRpb25cclxuICAnbWlwbWFwJywgLy8ge2Jvb2xlYW59IC0gV2hldGhlciBtaXBtYXBwZWQgb3V0cHV0IGlzIHN1cHBvcnRlZCwgc2VlIHNldE1pcG1hcCgpIGZvciBkb2N1bWVudGF0aW9uXHJcbiAgJ21pcG1hcEJpYXMnLCAvLyB7bnVtYmVyfSAtIFdoZXRoZXIgbWlwbWFwcGluZyB0ZW5kcyB0b3dhcmRzIHNoYXJwL2FsaWFzZWQgb3IgYmx1cnJ5LCBzZWUgc2V0TWlwbWFwQmlhcygpIGZvciBkb2N1bWVudGF0aW9uXHJcbiAgJ21pcG1hcEluaXRpYWxMZXZlbCcsIC8vIHtudW1iZXJ9IC0gSG93IG1hbnkgbWlwbWFwIGxldmVscyB0byBnZW5lcmF0ZSBpZiBuZWVkZWQsIHNlZSBzZXRNaXBtYXBJbml0aWFsTGV2ZWwoKSBmb3IgZG9jdW1lbnRhdGlvblxyXG4gICdtaXBtYXBNYXhMZXZlbCcsIC8vIHtudW1iZXJ9IFRoZSBtYXhpbXVtIG1pcG1hcCBsZXZlbCB0byBjb21wdXRlIGlmIG5lZWRlZCwgc2VlIHNldE1pcG1hcE1heExldmVsKCkgZm9yIGRvY3VtZW50YXRpb25cclxuICAnaGl0VGVzdFBpeGVscycgLy8ge2Jvb2xlYW59IC0gV2hldGhlciBub24tdHJhbnNwYXJlbnQgcGl4ZWxzIHdpbGwgY29udHJvbCBjb250YWluZWQgcG9pbnRzLCBzZWUgc2V0SGl0VGVzdFBpeGVscygpIGZvciBkb2N1bWVudGF0aW9uXHJcbl07XHJcblxyXG50eXBlIFNlbGZPcHRpb25zID0ge1xyXG4gIGltYWdlQm91bmRzPzogQm91bmRzMiB8IG51bGw7XHJcbn07XHJcblxyXG50eXBlIFBhcmVudE9wdGlvbnMgPSBOb2RlT3B0aW9ucyAmIEltYWdlYWJsZU9wdGlvbnM7XHJcblxyXG5leHBvcnQgdHlwZSBJbWFnZU9wdGlvbnMgPSBTZWxmT3B0aW9ucyAmIFBhcmVudE9wdGlvbnM7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJbWFnZSBleHRlbmRzIEltYWdlYWJsZSggTm9kZSApIHtcclxuXHJcbiAgLy8gSWYgbm9uLW51bGwsIGRldGVybWluZXMgd2hhdCBpcyBjb25zaWRlcmVkIFwiaW5zaWRlXCIgdGhlIGltYWdlIGZvciBjb250YWlubWVudCBhbmQgaGl0LXRlc3RpbmcuXHJcbiAgcHJpdmF0ZSBfaW1hZ2VCb3VuZHM6IEJvdW5kczIgfCBudWxsO1xyXG5cclxuICBwdWJsaWMgY29uc3RydWN0b3IoIGltYWdlOiBJbWFnZWFibGVJbWFnZSB8IFRSZWFkT25seVByb3BlcnR5PEltYWdlYWJsZUltYWdlPiwgcHJvdmlkZWRPcHRpb25zPzogSW1hZ2VPcHRpb25zICkge1xyXG5cclxuICAgIGNvbnN0IGluaXRJbWFnZU9wdGlvbnM6IEltYWdlT3B0aW9ucyA9IHt9O1xyXG4gICAgaWYgKCBpc1RSZWFkT25seVByb3BlcnR5KCBpbWFnZSApICkge1xyXG4gICAgICBpbml0SW1hZ2VPcHRpb25zLmltYWdlUHJvcGVydHkgPSBpbWFnZTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICBpbml0SW1hZ2VPcHRpb25zLmltYWdlID0gaW1hZ2U7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gcmVseSBvbiB0aGUgc2V0SW1hZ2UgY2FsbCBmcm9tIHRoZSBzdXBlciBjb25zdHJ1Y3RvciB0byBkbyB0aGUgc2V0dXBcclxuICAgIGNvbnN0IG9wdGlvbnMgPSBvcHRpb25pemU8SW1hZ2VPcHRpb25zLCBFbXB0eVNlbGZPcHRpb25zLCBQYXJlbnRPcHRpb25zPigpKCBpbml0SW1hZ2VPcHRpb25zLCBwcm92aWRlZE9wdGlvbnMgKTtcclxuXHJcbiAgICBzdXBlcigpO1xyXG5cclxuICAgIHRoaXMuX2ltYWdlQm91bmRzID0gbnVsbDtcclxuXHJcbiAgICB0aGlzLm11dGF0ZSggb3B0aW9ucyApO1xyXG5cclxuICAgIHRoaXMuaW52YWxpZGF0ZVN1cHBvcnRlZFJlbmRlcmVycygpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVHJpZ2dlcnMgcmVjb21wdXRhdGlvbiBvZiB0aGUgaW1hZ2UncyBib3VuZHMgYW5kIHJlZnJlc2hlcyBhbnkgZGlzcGxheXMgb3V0cHV0IG9mIHRoZSBpbWFnZS5cclxuICAgKlxyXG4gICAqIEdlbmVyYWxseSB0aGlzIGNhbiB0cmlnZ2VyIHJlY29tcHV0YXRpb24gb2YgbWlwbWFwcywgd2lsbCBtYXJrIGFueSBkcmF3YWJsZXMgYXMgbmVlZGluZyByZXBhaW50cywgYW5kIHdpbGxcclxuICAgKiBjYXVzZSBhIHNwcml0ZXNoZWV0IGNoYW5nZSBmb3IgV2ViR0wuXHJcbiAgICpcclxuICAgKiBUaGlzIHNob3VsZCBiZSBkb25lIHdoZW4gdGhlIHVuZGVybHlpbmcgaW1hZ2UgaGFzIGNoYW5nZWQgYXBwZWFyYW5jZSAodXN1YWxseSB0aGUgY2FzZSB3aXRoIGEgQ2FudmFzIGNoYW5naW5nLFxyXG4gICAqIGJ1dCB0aGlzIGlzIGFsc28gdHJpZ2dlcmVkIGJ5IG91ciBhY3R1YWwgaW1hZ2UgcmVmZXJlbmNlIGNoYW5naW5nKS5cclxuICAgKi9cclxuICBwdWJsaWMgb3ZlcnJpZGUgaW52YWxpZGF0ZUltYWdlKCk6IHZvaWQge1xyXG4gICAgaWYgKCB0aGlzLl9pbWFnZSApIHtcclxuICAgICAgdGhpcy5pbnZhbGlkYXRlU2VsZiggdGhpcy5faW1hZ2VCb3VuZHMgfHwgbmV3IEJvdW5kczIoIDAsIDAsIHRoaXMuZ2V0SW1hZ2VXaWR0aCgpLCB0aGlzLmdldEltYWdlSGVpZ2h0KCkgKSApO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgIHRoaXMuaW52YWxpZGF0ZVNlbGYoIEJvdW5kczIuTk9USElORyApO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHN0YXRlTGVuID0gdGhpcy5fZHJhd2FibGVzLmxlbmd0aDtcclxuICAgIGZvciAoIGxldCBpID0gMDsgaSA8IHN0YXRlTGVuOyBpKysgKSB7XHJcbiAgICAgICggdGhpcy5fZHJhd2FibGVzWyBpIF0gYXMgdW5rbm93biBhcyBUSW1hZ2VEcmF3YWJsZSApLm1hcmtEaXJ0eUltYWdlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgc3VwZXIuaW52YWxpZGF0ZUltYWdlKCk7XHJcblxyXG4gICAgdGhpcy5pbnZhbGlkYXRlU3VwcG9ydGVkUmVuZGVyZXJzKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZWNvbXB1dGVzIHdoYXQgcmVuZGVyZXJzIGFyZSBzdXBwb3J0ZWQsIGdpdmVuIHRoZSBjdXJyZW50IGltYWdlIGluZm9ybWF0aW9uLlxyXG4gICAqL1xyXG4gIHB1YmxpYyBvdmVycmlkZSBpbnZhbGlkYXRlU3VwcG9ydGVkUmVuZGVyZXJzKCk6IHZvaWQge1xyXG5cclxuICAgIC8vIENhbnZhcyBpcyBhbHdheXMgcGVybWl0dGVkXHJcbiAgICBsZXQgciA9IFJlbmRlcmVyLmJpdG1hc2tDYW52YXM7XHJcblxyXG4gICAgLy8gSWYgaXQgZml0cyB3aXRoaW4gdGhlIHNwcml0ZSBzaGVldCwgdGhlbiBXZWJHTCBpcyBhbHNvIHBlcm1pdHRlZFxyXG4gICAgLy8gSWYgdGhlIGltYWdlIGhhc24ndCBsb2FkZWQsIHRoZSBnZXRJbWFnZVdpZHRoL0hlaWdodCB3aWxsIGJlIDAgYW5kIHRoaXMgcnVsZSB3b3VsZCBwYXNzLiAgSG93ZXZlciwgdGhpc1xyXG4gICAgLy8gZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgYWdhaW4gYWZ0ZXIgdGhlIGltYWdlIGxvYWRzLCBhbmQgd291bGQgY29ycmVjdGx5IGludmFsaWRhdGUgV2ViR0wsIGlmIHRvbyBsYXJnZSB0byBmaXRcclxuICAgIC8vIGluIGEgU3ByaXRlU2hlZXRcclxuICAgIGNvbnN0IGZpdHNXaXRoaW5TcHJpdGVTaGVldCA9IHRoaXMuZ2V0SW1hZ2VXaWR0aCgpIDw9IFNwcml0ZVNoZWV0Lk1BWF9ESU1FTlNJT04ud2lkdGggJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0SW1hZ2VIZWlnaHQoKSA8PSBTcHJpdGVTaGVldC5NQVhfRElNRU5TSU9OLmhlaWdodDtcclxuICAgIGlmICggZml0c1dpdGhpblNwcml0ZVNoZWV0ICkge1xyXG4gICAgICByIHw9IFJlbmRlcmVyLmJpdG1hc2tXZWJHTDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBJZiBpdCBpcyBub3QgYSBjYW52YXMsIHRoZW4gaXQgY2FuIGFkZGl0aW9uYWxseSBiZSByZW5kZXJlZCBpbiBTVkcgb3IgRE9NXHJcbiAgICBpZiAoICEoIHRoaXMuX2ltYWdlIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQgKSApIHtcclxuICAgICAgLy8gYXNzdW1lcyBIVE1MSW1hZ2VFbGVtZW50XHJcbiAgICAgIHIgfD0gUmVuZGVyZXIuYml0bWFza1NWRyB8IFJlbmRlcmVyLmJpdG1hc2tET007XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5zZXRSZW5kZXJlckJpdG1hc2soIHIgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgYW4gb3BhY2l0eSB0aGF0IGlzIGFwcGxpZWQgb25seSB0byB0aGlzIGltYWdlICh3aWxsIG5vdCBhZmZlY3QgY2hpbGRyZW4gb3IgdGhlIHJlc3Qgb2YgdGhlIG5vZGUncyBzdWJ0cmVlKS5cclxuICAgKlxyXG4gICAqIFRoaXMgc2hvdWxkIGdlbmVyYWxseSBiZSBwcmVmZXJyZWQgb3ZlciBOb2RlJ3Mgb3BhY2l0eSBpZiBpdCBoYXMgdGhlIHNhbWUgcmVzdWx0LCBhcyBtb2RpZnlpbmcgdGhpcyB3aWxsIGJlIG11Y2hcclxuICAgKiBmYXN0ZXIsIGFuZCB3aWxsIG5vdCBmb3JjZSBhZGRpdGlvbmFsIENhbnZhc2VzIG9yIGludGVybWVkaWF0ZSBzdGVwcyBpbiBkaXNwbGF5LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIGltYWdlT3BhY2l0eSAtIFNob3VsZCBiZSBhIG51bWJlciBiZXR3ZWVuIDAgKHRyYW5zcGFyZW50KSBhbmQgMSAob3BhcXVlKSwganVzdCBsaWtlIG5vcm1hbCBvcGFjaXR5LlxyXG4gICAqL1xyXG4gIHB1YmxpYyBvdmVycmlkZSBzZXRJbWFnZU9wYWNpdHkoIGltYWdlT3BhY2l0eTogbnVtYmVyICk6IHZvaWQge1xyXG4gICAgY29uc3QgY2hhbmdlZCA9IHRoaXMuX2ltYWdlT3BhY2l0eSAhPT0gaW1hZ2VPcGFjaXR5O1xyXG5cclxuICAgIHN1cGVyLnNldEltYWdlT3BhY2l0eSggaW1hZ2VPcGFjaXR5ICk7XHJcblxyXG4gICAgaWYgKCBjaGFuZ2VkICkge1xyXG4gICAgICBjb25zdCBzdGF0ZUxlbiA9IHRoaXMuX2RyYXdhYmxlcy5sZW5ndGg7XHJcbiAgICAgIGZvciAoIGxldCBpID0gMDsgaSA8IHN0YXRlTGVuOyBpKysgKSB7XHJcbiAgICAgICAgKCB0aGlzLl9kcmF3YWJsZXNbIGkgXSBhcyB1bmtub3duIGFzIFRJbWFnZURyYXdhYmxlICkubWFya0RpcnR5SW1hZ2VPcGFjaXR5KCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgdGhlIGltYWdlQm91bmRzIHZhbHVlIGZvciB0aGUgSW1hZ2UuIElmIG5vbi1udWxsLCBkZXRlcm1pbmVzIHdoYXQgaXMgY29uc2lkZXJlZCBcImluc2lkZVwiIHRoZSBpbWFnZSBmb3JcclxuICAgKiBjb250YWlubWVudCBhbmQgaGl0LXRlc3RpbmcuXHJcbiAgICpcclxuICAgKiBOT1RFOiBUaGlzIGlzIGFjY29tcGxpc2hlZCBieSB1c2luZyBhbnkgcHJvdmlkZWQgaW1hZ2VCb3VuZHMgYXMgdGhlIG5vZGUncyBvd24gc2VsZkJvdW5kcy4gVGhpcyB3aWxsIGFmZmVjdCBsYXlvdXQsXHJcbiAgICogaGl0LXRlc3RpbmcsIGFuZCBhbnl0aGluZyBlbHNlIHVzaW5nIHRoZSBib3VuZHMgb2YgdGhpcyBub2RlLlxyXG4gICAqL1xyXG4gIHB1YmxpYyBzZXRJbWFnZUJvdW5kcyggaW1hZ2VCb3VuZHM6IEJvdW5kczIgfCBudWxsICk6IHZvaWQge1xyXG4gICAgaWYgKCB0aGlzLl9pbWFnZUJvdW5kcyAhPT0gaW1hZ2VCb3VuZHMgKSB7XHJcbiAgICAgIHRoaXMuX2ltYWdlQm91bmRzID0gaW1hZ2VCb3VuZHM7XHJcblxyXG4gICAgICB0aGlzLmludmFsaWRhdGVJbWFnZSgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHVibGljIHNldCBpbWFnZUJvdW5kcyggdmFsdWU6IEJvdW5kczIgfCBudWxsICkgeyB0aGlzLnNldEltYWdlQm91bmRzKCB2YWx1ZSApOyB9XHJcblxyXG4gIHB1YmxpYyBnZXQgaW1hZ2VCb3VuZHMoKTogQm91bmRzMiB8IG51bGwgeyByZXR1cm4gdGhpcy5faW1hZ2VCb3VuZHM7IH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgaW1hZ2VCb3VuZHMsIHNlZSBzZXRJbWFnZUJvdW5kcyBmb3IgZGV0YWlscy5cclxuICAgKi9cclxuICBwdWJsaWMgZ2V0SW1hZ2VCb3VuZHMoKTogQm91bmRzMiB8IG51bGwge1xyXG4gICAgcmV0dXJuIHRoaXMuX2ltYWdlQm91bmRzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogV2hldGhlciB0aGlzIE5vZGUgaXRzZWxmIGlzIHBhaW50ZWQgKGRpc3BsYXlzIHNvbWV0aGluZyBpdHNlbGYpLlxyXG4gICAqL1xyXG4gIHB1YmxpYyBvdmVycmlkZSBpc1BhaW50ZWQoKTogYm9vbGVhbiB7XHJcbiAgICAvLyBBbHdheXMgdHJ1ZSBmb3IgSW1hZ2Ugbm9kZXNcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJhd3MgdGhlIGN1cnJlbnQgTm9kZSdzIHNlbGYgcmVwcmVzZW50YXRpb24sIGFzc3VtaW5nIHRoZSB3cmFwcGVyJ3MgQ2FudmFzIGNvbnRleHQgaXMgYWxyZWFkeSBpbiB0aGUgbG9jYWxcclxuICAgKiBjb29yZGluYXRlIGZyYW1lIG9mIHRoaXMgbm9kZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB3cmFwcGVyXHJcbiAgICogQHBhcmFtIG1hdHJpeCAtIFRoZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggYWxyZWFkeSBhcHBsaWVkIHRvIHRoZSBjb250ZXh0LlxyXG4gICAqL1xyXG4gIHByb3RlY3RlZCBvdmVycmlkZSBjYW52YXNQYWludFNlbGYoIHdyYXBwZXI6IENhbnZhc0NvbnRleHRXcmFwcGVyLCBtYXRyaXg6IE1hdHJpeDMgKTogdm9pZCB7XHJcbiAgICAvL1RPRE86IEhhdmUgYSBzZXBhcmF0ZSBtZXRob2QgZm9yIHRoaXMsIGluc3RlYWQgb2YgdG91Y2hpbmcgdGhlIHByb3RvdHlwZS4gQ2FuIG1ha2UgJ3RoaXMnIHJlZmVyZW5jZXMgdG9vIGVhc2lseS4gaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL3NjZW5lcnkvaXNzdWVzLzE1ODFcclxuICAgIEltYWdlQ2FudmFzRHJhd2FibGUucHJvdG90eXBlLnBhaW50Q2FudmFzKCB3cmFwcGVyLCB0aGlzLCBtYXRyaXggKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYSBET00gZHJhd2FibGUgZm9yIHRoaXMgSW1hZ2UuIChzY2VuZXJ5LWludGVybmFsKVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHJlbmRlcmVyIC0gSW4gdGhlIGJpdG1hc2sgZm9ybWF0IHNwZWNpZmllZCBieSBSZW5kZXJlciwgd2hpY2ggbWF5IGNvbnRhaW4gYWRkaXRpb25hbCBiaXQgZmxhZ3MuXHJcbiAgICogQHBhcmFtIGluc3RhbmNlIC0gSW5zdGFuY2Ugb2JqZWN0IHRoYXQgd2lsbCBiZSBhc3NvY2lhdGVkIHdpdGggdGhlIGRyYXdhYmxlXHJcbiAgICovXHJcbiAgcHVibGljIG92ZXJyaWRlIGNyZWF0ZURPTURyYXdhYmxlKCByZW5kZXJlcjogbnVtYmVyLCBpbnN0YW5jZTogSW5zdGFuY2UgKTogRE9NU2VsZkRyYXdhYmxlIHtcclxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLSBQb29sYWJsZVxyXG4gICAgcmV0dXJuIEltYWdlRE9NRHJhd2FibGUuY3JlYXRlRnJvbVBvb2woIHJlbmRlcmVyLCBpbnN0YW5jZSApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhIFNWRyBkcmF3YWJsZSBmb3IgdGhpcyBJbWFnZS4gKHNjZW5lcnktaW50ZXJuYWwpXHJcbiAgICpcclxuICAgKiBAcGFyYW0gcmVuZGVyZXIgLSBJbiB0aGUgYml0bWFzayBmb3JtYXQgc3BlY2lmaWVkIGJ5IFJlbmRlcmVyLCB3aGljaCBtYXkgY29udGFpbiBhZGRpdGlvbmFsIGJpdCBmbGFncy5cclxuICAgKiBAcGFyYW0gaW5zdGFuY2UgLSBJbnN0YW5jZSBvYmplY3QgdGhhdCB3aWxsIGJlIGFzc29jaWF0ZWQgd2l0aCB0aGUgZHJhd2FibGVcclxuICAgKi9cclxuICBwdWJsaWMgb3ZlcnJpZGUgY3JlYXRlU1ZHRHJhd2FibGUoIHJlbmRlcmVyOiBudW1iZXIsIGluc3RhbmNlOiBJbnN0YW5jZSApOiBTVkdTZWxmRHJhd2FibGUge1xyXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciAtIFBvb2xhYmxlXHJcbiAgICByZXR1cm4gSW1hZ2VTVkdEcmF3YWJsZS5jcmVhdGVGcm9tUG9vbCggcmVuZGVyZXIsIGluc3RhbmNlICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIGEgQ2FudmFzIGRyYXdhYmxlIGZvciB0aGlzIEltYWdlLiAoc2NlbmVyeS1pbnRlcm5hbClcclxuICAgKlxyXG4gICAqIEBwYXJhbSByZW5kZXJlciAtIEluIHRoZSBiaXRtYXNrIGZvcm1hdCBzcGVjaWZpZWQgYnkgUmVuZGVyZXIsIHdoaWNoIG1heSBjb250YWluIGFkZGl0aW9uYWwgYml0IGZsYWdzLlxyXG4gICAqIEBwYXJhbSBpbnN0YW5jZSAtIEluc3RhbmNlIG9iamVjdCB0aGF0IHdpbGwgYmUgYXNzb2NpYXRlZCB3aXRoIHRoZSBkcmF3YWJsZVxyXG4gICAqL1xyXG4gIHB1YmxpYyBvdmVycmlkZSBjcmVhdGVDYW52YXNEcmF3YWJsZSggcmVuZGVyZXI6IG51bWJlciwgaW5zdGFuY2U6IEluc3RhbmNlICk6IENhbnZhc1NlbGZEcmF3YWJsZSB7XHJcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC0gUG9vbGFibGVcclxuICAgIHJldHVybiBJbWFnZUNhbnZhc0RyYXdhYmxlLmNyZWF0ZUZyb21Qb29sKCByZW5kZXJlciwgaW5zdGFuY2UgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYSBXZWJHTCBkcmF3YWJsZSBmb3IgdGhpcyBJbWFnZS4gKHNjZW5lcnktaW50ZXJuYWwpXHJcbiAgICpcclxuICAgKiBAcGFyYW0gcmVuZGVyZXIgLSBJbiB0aGUgYml0bWFzayBmb3JtYXQgc3BlY2lmaWVkIGJ5IFJlbmRlcmVyLCB3aGljaCBtYXkgY29udGFpbiBhZGRpdGlvbmFsIGJpdCBmbGFncy5cclxuICAgKiBAcGFyYW0gaW5zdGFuY2UgLSBJbnN0YW5jZSBvYmplY3QgdGhhdCB3aWxsIGJlIGFzc29jaWF0ZWQgd2l0aCB0aGUgZHJhd2FibGVcclxuICAgKi9cclxuICBwdWJsaWMgb3ZlcnJpZGUgY3JlYXRlV2ViR0xEcmF3YWJsZSggcmVuZGVyZXI6IG51bWJlciwgaW5zdGFuY2U6IEluc3RhbmNlICk6IFdlYkdMU2VsZkRyYXdhYmxlIHtcclxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLSBQb29sYWJsZVxyXG4gICAgcmV0dXJuIEltYWdlV2ViR0xEcmF3YWJsZS5jcmVhdGVGcm9tUG9vbCggcmVuZGVyZXIsIGluc3RhbmNlICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBPdmVycmlkZSB0aGlzIGZvciBjb21wdXRhdGlvbiBvZiB3aGV0aGVyIGEgcG9pbnQgaXMgaW5zaWRlIG91ciBzZWxmIGNvbnRlbnQgKGRlZmF1bHRzIHRvIHNlbGZCb3VuZHMgY2hlY2spLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHBvaW50IC0gQ29uc2lkZXJlZCB0byBiZSBpbiB0aGUgbG9jYWwgY29vcmRpbmF0ZSBmcmFtZVxyXG4gICAqL1xyXG4gIHB1YmxpYyBvdmVycmlkZSBjb250YWluc1BvaW50U2VsZiggcG9pbnQ6IFZlY3RvcjIgKTogYm9vbGVhbiB7XHJcbiAgICBjb25zdCBpbkJvdW5kcyA9IE5vZGUucHJvdG90eXBlLmNvbnRhaW5zUG9pbnRTZWxmLmNhbGwoIHRoaXMsIHBvaW50ICk7XHJcblxyXG4gICAgaWYgKCAhaW5Cb3VuZHMgfHwgIXRoaXMuX2hpdFRlc3RQaXhlbHMgfHwgIXRoaXMuX2hpdFRlc3RJbWFnZURhdGEgKSB7XHJcbiAgICAgIHJldHVybiBpbkJvdW5kcztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gSW1hZ2VhYmxlLnRlc3RIaXRUZXN0RGF0YSggdGhpcy5faGl0VGVzdEltYWdlRGF0YSwgdGhpcy5pbWFnZVdpZHRoLCB0aGlzLmltYWdlSGVpZ2h0LCBwb2ludCApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBhIFNoYXBlIHRoYXQgcmVwcmVzZW50cyB0aGUgYXJlYSBjb3ZlcmVkIGJ5IGNvbnRhaW5zUG9pbnRTZWxmLlxyXG4gICAqL1xyXG4gIHB1YmxpYyBvdmVycmlkZSBnZXRTZWxmU2hhcGUoKTogU2hhcGUge1xyXG4gICAgaWYgKCB0aGlzLl9oaXRUZXN0UGl4ZWxzICYmIHRoaXMuX2hpdFRlc3RJbWFnZURhdGEgKSB7XHJcbiAgICAgIC8vIElmIHdlJ3JlIGhpdC10ZXN0aW5nIHBpeGVscywgcmV0dXJuIHRoYXQgc2hhcGUgaW5jbHVkZWQuXHJcbiAgICAgIHJldHVybiBJbWFnZWFibGUuaGl0VGVzdERhdGFUb1NoYXBlKCB0aGlzLl9oaXRUZXN0SW1hZ2VEYXRhLCB0aGlzLmltYWdlV2lkdGgsIHRoaXMuaW1hZ2VIZWlnaHQgKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAvLyBPdGhlcndpc2UgdGhlIHN1cGVyIGNhbGwgd2lsbCBqdXN0IGluY2x1ZGUgdGhlIHJlY3RhbmdsZSAoYm91bmRzKS5cclxuICAgICAgcmV0dXJuIE5vZGUucHJvdG90eXBlLmdldFNlbGZTaGFwZS5jYWxsKCB0aGlzICk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUcmlnZ2VycyByZWNvbXB1dGF0aW9uIG9mIG1pcG1hcHMgKGFzIGxvbmcgYXMgbWlwbWFwcGluZyBpcyBlbmFibGVkKVxyXG4gICAqL1xyXG4gIHB1YmxpYyBvdmVycmlkZSBpbnZhbGlkYXRlTWlwbWFwcygpOiB2b2lkIHtcclxuICAgIGNvbnN0IG1hcmtEaXJ0eSA9IHRoaXMuX2ltYWdlICYmIHRoaXMuX21pcG1hcCAmJiAhdGhpcy5fbWlwbWFwRGF0YTtcclxuXHJcbiAgICBzdXBlci5pbnZhbGlkYXRlTWlwbWFwcygpO1xyXG5cclxuICAgIGlmICggbWFya0RpcnR5ICkge1xyXG4gICAgICBjb25zdCBzdGF0ZUxlbiA9IHRoaXMuX2RyYXdhYmxlcy5sZW5ndGg7XHJcbiAgICAgIGZvciAoIGxldCBpID0gMDsgaSA8IHN0YXRlTGVuOyBpKysgKSB7XHJcbiAgICAgICAgKCB0aGlzLl9kcmF3YWJsZXNbIGkgXSBhcyB1bmtub3duIGFzIFRJbWFnZURyYXdhYmxlICkubWFya0RpcnR5TWlwbWFwKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIHB1YmxpYyBvdmVycmlkZSBtdXRhdGUoIG9wdGlvbnM/OiBJbWFnZU9wdGlvbnMgKTogdGhpcyB7XHJcbiAgICByZXR1cm4gc3VwZXIubXV0YXRlKCBvcHRpb25zICk7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgc3RhdGljIEltYWdlSU86IElPVHlwZTtcclxuXHJcbiAgLy8gSW5pdGlhbCB2YWx1ZXMgZm9yIG1vc3QgTm9kZSBtdXRhdG9yIG9wdGlvbnNcclxuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IERFRkFVTFRfSU1BR0VfT1BUSU9OUyA9IGNvbWJpbmVPcHRpb25zPEltYWdlT3B0aW9ucz4oIHt9LCBOb2RlLkRFRkFVTFRfTk9ERV9PUFRJT05TLCBJbWFnZWFibGUuREVGQVVMVF9PUFRJT05TICk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiB7QXJyYXkuPHN0cmluZz59IC0gU3RyaW5nIGtleXMgZm9yIGFsbCBvZiB0aGUgYWxsb3dlZCBvcHRpb25zIHRoYXQgd2lsbCBiZSBzZXQgYnkgbm9kZS5tdXRhdGUoIG9wdGlvbnMgKSwgaW4gdGhlXHJcbiAqIG9yZGVyIHRoZXkgd2lsbCBiZSBldmFsdWF0ZWQgaW4uXHJcbiAqXHJcbiAqIE5PVEU6IFNlZSBOb2RlJ3MgX211dGF0b3JLZXlzIGRvY3VtZW50YXRpb24gZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gaG93IHRoaXMgb3BlcmF0ZXMsIGFuZCBwb3RlbnRpYWwgc3BlY2lhbFxyXG4gKiAgICAgICBjYXNlcyB0aGF0IG1heSBhcHBseS5cclxuICovXHJcbkltYWdlLnByb3RvdHlwZS5fbXV0YXRvcktleXMgPSBbIC4uLklNQUdFX09QVElPTl9LRVlTLCAuLi5Ob2RlLnByb3RvdHlwZS5fbXV0YXRvcktleXMgXTtcclxuXHJcbi8qKlxyXG4gKiB7QXJyYXkuPFN0cmluZz59IC0gTGlzdCBvZiBhbGwgZGlydHkgZmxhZ3MgdGhhdCBzaG91bGQgYmUgYXZhaWxhYmxlIG9uIGRyYXdhYmxlcyBjcmVhdGVkIGZyb20gdGhpcyBub2RlIChvclxyXG4gKiAgICAgICAgICAgICAgICAgICAgc3VidHlwZSkuIEdpdmVuIGEgZmxhZyAoZS5nLiByYWRpdXMpLCBpdCBpbmRpY2F0ZXMgdGhlIGV4aXN0ZW5jZSBvZiBhIGZ1bmN0aW9uXHJcbiAqICAgICAgICAgICAgICAgICAgICBkcmF3YWJsZS5tYXJrRGlydHlSYWRpdXMoKSB0aGF0IHdpbGwgaW5kaWNhdGUgdG8gdGhlIGRyYXdhYmxlIHRoYXQgdGhlIHJhZGl1cyBoYXMgY2hhbmdlZC5cclxuICogKHNjZW5lcnktaW50ZXJuYWwpXHJcbiAqIEBvdmVycmlkZVxyXG4gKi9cclxuSW1hZ2UucHJvdG90eXBlLmRyYXdhYmxlTWFya0ZsYWdzID0gWyAuLi5Ob2RlLnByb3RvdHlwZS5kcmF3YWJsZU1hcmtGbGFncywgJ2ltYWdlJywgJ2ltYWdlT3BhY2l0eScsICdtaXBtYXAnIF07XHJcblxyXG4vLyBOT1RFOiBOb3QgY3VycmVudGx5IGluIHVzZVxyXG5JbWFnZS5JbWFnZUlPID0gbmV3IElPVHlwZSggJ0ltYWdlSU8nLCB7XHJcbiAgdmFsdWVUeXBlOiBJbWFnZSxcclxuICBzdXBlcnR5cGU6IE5vZGUuTm9kZUlPLFxyXG4gIGV2ZW50czogWyAnY2hhbmdlZCcgXSxcclxuICBtZXRob2RzOiB7XHJcbiAgICBzZXRJbWFnZToge1xyXG4gICAgICByZXR1cm5UeXBlOiBWb2lkSU8sXHJcbiAgICAgIHBhcmFtZXRlclR5cGVzOiBbIFN0cmluZ0lPIF0sXHJcbiAgICAgIGltcGxlbWVudGF0aW9uOiBmdW5jdGlvbiggYmFzZTY0VGV4dDogc3RyaW5nICkge1xyXG4gICAgICAgIGNvbnN0IGltID0gbmV3IHdpbmRvdy5JbWFnZSgpO1xyXG4gICAgICAgIGltLnNyYyA9IGJhc2U2NFRleHQ7XHJcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBUT0RPOiBob3cgd291bGQgdGhpcyBldmVuIHdvcms/IGh0dHBzOi8vZ2l0aHViLmNvbS9waGV0c2ltcy9zY2VuZXJ5L2lzc3Vlcy8xNTgxXHJcbiAgICAgICAgdGhpcy5pbWFnZSA9IGltO1xyXG4gICAgICB9LFxyXG4gICAgICBkb2N1bWVudGF0aW9uOiAnU2V0IHRoZSBpbWFnZSBmcm9tIGEgYmFzZTY0IHN0cmluZycsXHJcbiAgICAgIGludm9jYWJsZUZvclJlYWRPbmx5RWxlbWVudHM6IGZhbHNlXHJcbiAgICB9XHJcbiAgfVxyXG59ICk7XHJcblxyXG5zY2VuZXJ5LnJlZ2lzdGVyKCAnSW1hZ2UnLCBJbWFnZSApOyJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNB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