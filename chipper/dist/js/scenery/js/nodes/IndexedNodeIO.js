// Copyright 2020-2023, University of Colorado Boulder

/**
 * IOType for Nodes that can save their own index (if phetioState: true).  Can be used to customize z-order
 * or layout order.
 *
 * This IOType supports PhET-iO state, but only when every child within a Node's children array is an IndexedNodeIO
 * and is stateful (`phetioState: true`). This applyState algorithm uses Node "swaps" instead of index-based inserts
 * to ensure that by the end of state setting, all Nodes are in the correct order.
 * see https://github.com/phetsims/scenery/issues/1252#issuecomment-888014859 for more information.
 *
 * Invisible nodes are skipped in order to ensure that "move forward" moves past the next visible item and "move backward"
 * moves before the prior visible item. If we did not skip invisible nodes, then a user could press "move forward" and
 * be confused that the visible order does not change (even though the index changes).
 *
 * @author Sam Reid (PhET Interactive Simulations)
 */

import FunctionIO from '../../../tandem/js/types/FunctionIO.js';
import IOType from '../../../tandem/js/types/IOType.js';
import NullableIO from '../../../tandem/js/types/NullableIO.js';
import NumberIO from '../../../tandem/js/types/NumberIO.js';
import VoidIO from '../../../tandem/js/types/VoidIO.js';
import { Node, scenery } from '../imports.js';
import deprecationWarning from '../../../phet-core/js/deprecationWarning.js';
// In order to support unlinking from listening to the index property, keep an indexed map to callback functions
const map = {};

// The next index at which a callback will appear in the map. This always increments and we do reuse old indices
let index = 0;

// Move this node one index forward in each of its parents, jumping over invisible nodes. If the Node is already at the front, this is a no-op.
function moveForward(node) {
  node._parents.forEach(parent => moveChild(parent, node, +1));
}

// Move this node one index backward in each of its parents, jumping over invisible nodes.  If the Node is already at the back, this is a no-op.
function moveBackward(node) {
  node._parents.forEach(parent => moveChild(parent, node, -1));
}

// factored out for use with the deprecated method name too
function unlinkIndex(index) {
  const method = map[index];
  assert && assert(this.parents.length === 1, 'IndexedNodeIO only supports nodes with a single parent');
  this.parents[0].childrenChangedEmitter.removeListener(method);
  delete map[index];
}

/**
 * Moves the specified child by +1/-1 indices, without going past the beginning or end.
 */
function moveChild(parent, child, delta) {
  const index = parent.indexOfChild(child);
  let targetIndex = index + delta;

  // skip invisible children
  while (targetIndex > 0 && targetIndex < parent.children.length && !parent.children[targetIndex].visible) {
    targetIndex += delta;
  }
  if (targetIndex >= 0 && targetIndex < parent.children.length) {
    parent.moveChildToIndex(child, targetIndex);
  }
  parent.onIndexedNodeIOChildMoved && parent.onIndexedNodeIOChildMoved(child);
}
const IndexedNodeIO = new IOType('IndexedNodeIO', {
  valueType: Node,
  documentation: 'Node that can be moved forward/back by index, which specifies z-order and/or layout order',
  supertype: Node.NodeIO,
  toStateObject: node => {
    const stateObject = {
      index: null
    };
    if (node.parents[0]) {
      assert && assert(node.parents.length === 1, 'IndexedNodeIO only supports nodes with a single parent');
      stateObject.index = node.parents[0].indexOfChild(node);
    }
    return stateObject;
  },
  applyState: (node, stateObject) => {
    const nodeParent = node.parents[0];
    if (nodeParent && stateObject.index) {
      assert && assert(node.parents.length === 1, 'IndexedNodeIO only supports nodes with a single parent');

      // Swap the child at the destination index with current position of this Node, that way the operation is atomic.
      // This implementation assumes that all children are instrumented IndexedNodeIO instances and can have state set
      // on them to "fix them" after this operation. Without this implementation, using Node.moveChildToIndex could blow
      // away another IndexedNode state set. See https://github.com/phetsims/ph-scale/issues/227
      const children = nodeParent.children;
      const currentIndex = nodeParent.indexOfChild(node);
      children[currentIndex] = children[stateObject.index];
      children[stateObject.index] = node;
      nodeParent.setChildren(children);
    }
  },
  stateSchema: {
    index: NullableIO(NumberIO)
  },
  methods: {
    linkIndex: {
      returnType: NumberIO,
      parameterTypes: [FunctionIO(VoidIO, [NumberIO])],
      documentation: 'Following the PropertyIO.link pattern, subscribe for notifications when the index in the parent ' + 'changes, and receive a callback with the current value.  The return value is a numeric ID for use ' + 'with clearLinkIndex.',
      implementation: function (listener) {
        // The callback which signifies the current index
        const callback = () => {
          assert && assert(this.parents.length === 1, 'IndexedNodeIO only supports nodes with a single parent');
          const index = this.parents[0].indexOfChild(this);
          listener(index);
        };
        assert && assert(this.parents.length === 1, 'IndexedNodeIO only supports nodes with a single parent');
        this.parents[0].childrenChangedEmitter.addListener(callback);
        callback();
        const myIndex = index;
        map[myIndex] = callback;
        index++;
        return myIndex;
      }
    },
    unlinkIndex: {
      returnType: VoidIO,
      parameterTypes: [NumberIO],
      documentation: 'Unlink a listener that has been added using linkIndex, by its numerical ID (like setTimeout/clearTimeout)',
      implementation: unlinkIndex
    },
    clearLinkIndex: {
      returnType: VoidIO,
      parameterTypes: [NumberIO],
      documentation: 'Deprecated, see "unlinkIndex".',
      implementation: function (index) {
        assert && deprecationWarning('clearLinkIndex is deprecated, use unlinkIndex instead.', true);
        unlinkIndex.call(this, index);
      }
    },
    moveForward: {
      returnType: VoidIO,
      parameterTypes: [],
      implementation: function () {
        return moveForward(this);
      },
      documentation: 'Move this Node one index forward in each of its parents, skipping invisible Nodes. If the Node is already at the front, this is a no-op.'
    },
    moveBackward: {
      returnType: VoidIO,
      parameterTypes: [],
      implementation: function () {
        return moveBackward(this);
      },
      documentation: 'Move this Node one index backward in each of its parents, skipping invisible Nodes. If the Node is already at the back, this is a no-op.'
    }
  }
});
scenery.register('IndexedNodeIO', IndexedNodeIO);
export default IndexedNodeIO;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJGdW5jdGlvbklPIiwiSU9UeXBlIiwiTnVsbGFibGVJTyIsIk51bWJlcklPIiwiVm9pZElPIiwiTm9kZSIsInNjZW5lcnkiLCJkZXByZWNhdGlvbldhcm5pbmciLCJtYXAiLCJpbmRleCIsIm1vdmVGb3J3YXJkIiwibm9kZSIsIl9wYXJlbnRzIiwiZm9yRWFjaCIsInBhcmVudCIsIm1vdmVDaGlsZCIsIm1vdmVCYWNrd2FyZCIsInVubGlua0luZGV4IiwibWV0aG9kIiwiYXNzZXJ0IiwicGFyZW50cyIsImxlbmd0aCIsImNoaWxkcmVuQ2hhbmdlZEVtaXR0ZXIiLCJyZW1vdmVMaXN0ZW5lciIsImNoaWxkIiwiZGVsdGEiLCJpbmRleE9mQ2hpbGQiLCJ0YXJnZXRJbmRleCIsImNoaWxkcmVuIiwidmlzaWJsZSIsIm1vdmVDaGlsZFRvSW5kZXgiLCJvbkluZGV4ZWROb2RlSU9DaGlsZE1vdmVkIiwiSW5kZXhlZE5vZGVJTyIsInZhbHVlVHlwZSIsImRvY3VtZW50YXRpb24iLCJzdXBlcnR5cGUiLCJOb2RlSU8iLCJ0b1N0YXRlT2JqZWN0Iiwic3RhdGVPYmplY3QiLCJhcHBseVN0YXRlIiwibm9kZVBhcmVudCIsImN1cnJlbnRJbmRleCIsInNldENoaWxkcmVuIiwic3RhdGVTY2hlbWEiLCJtZXRob2RzIiwibGlua0luZGV4IiwicmV0dXJuVHlwZSIsInBhcmFtZXRlclR5cGVzIiwiaW1wbGVtZW50YXRpb24iLCJsaXN0ZW5lciIsImNhbGxiYWNrIiwiYWRkTGlzdGVuZXIiLCJteUluZGV4IiwiY2xlYXJMaW5rSW5kZXgiLCJjYWxsIiwicmVnaXN0ZXIiXSwic291cmNlcyI6WyJJbmRleGVkTm9kZUlPLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDIwLTIwMjMsIFVuaXZlcnNpdHkgb2YgQ29sb3JhZG8gQm91bGRlclxyXG5cclxuLyoqXHJcbiAqIElPVHlwZSBmb3IgTm9kZXMgdGhhdCBjYW4gc2F2ZSB0aGVpciBvd24gaW5kZXggKGlmIHBoZXRpb1N0YXRlOiB0cnVlKS4gIENhbiBiZSB1c2VkIHRvIGN1c3RvbWl6ZSB6LW9yZGVyXHJcbiAqIG9yIGxheW91dCBvcmRlci5cclxuICpcclxuICogVGhpcyBJT1R5cGUgc3VwcG9ydHMgUGhFVC1pTyBzdGF0ZSwgYnV0IG9ubHkgd2hlbiBldmVyeSBjaGlsZCB3aXRoaW4gYSBOb2RlJ3MgY2hpbGRyZW4gYXJyYXkgaXMgYW4gSW5kZXhlZE5vZGVJT1xyXG4gKiBhbmQgaXMgc3RhdGVmdWwgKGBwaGV0aW9TdGF0ZTogdHJ1ZWApLiBUaGlzIGFwcGx5U3RhdGUgYWxnb3JpdGhtIHVzZXMgTm9kZSBcInN3YXBzXCIgaW5zdGVhZCBvZiBpbmRleC1iYXNlZCBpbnNlcnRzXHJcbiAqIHRvIGVuc3VyZSB0aGF0IGJ5IHRoZSBlbmQgb2Ygc3RhdGUgc2V0dGluZywgYWxsIE5vZGVzIGFyZSBpbiB0aGUgY29ycmVjdCBvcmRlci5cclxuICogc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waGV0c2ltcy9zY2VuZXJ5L2lzc3Vlcy8xMjUyI2lzc3VlY29tbWVudC04ODgwMTQ4NTkgZm9yIG1vcmUgaW5mb3JtYXRpb24uXHJcbiAqXHJcbiAqIEludmlzaWJsZSBub2RlcyBhcmUgc2tpcHBlZCBpbiBvcmRlciB0byBlbnN1cmUgdGhhdCBcIm1vdmUgZm9yd2FyZFwiIG1vdmVzIHBhc3QgdGhlIG5leHQgdmlzaWJsZSBpdGVtIGFuZCBcIm1vdmUgYmFja3dhcmRcIlxyXG4gKiBtb3ZlcyBiZWZvcmUgdGhlIHByaW9yIHZpc2libGUgaXRlbS4gSWYgd2UgZGlkIG5vdCBza2lwIGludmlzaWJsZSBub2RlcywgdGhlbiBhIHVzZXIgY291bGQgcHJlc3MgXCJtb3ZlIGZvcndhcmRcIiBhbmRcclxuICogYmUgY29uZnVzZWQgdGhhdCB0aGUgdmlzaWJsZSBvcmRlciBkb2VzIG5vdCBjaGFuZ2UgKGV2ZW4gdGhvdWdoIHRoZSBpbmRleCBjaGFuZ2VzKS5cclxuICpcclxuICogQGF1dGhvciBTYW0gUmVpZCAoUGhFVCBJbnRlcmFjdGl2ZSBTaW11bGF0aW9ucylcclxuICovXHJcblxyXG5pbXBvcnQgRnVuY3Rpb25JTyBmcm9tICcuLi8uLi8uLi90YW5kZW0vanMvdHlwZXMvRnVuY3Rpb25JTy5qcyc7XHJcbmltcG9ydCBJT1R5cGUgZnJvbSAnLi4vLi4vLi4vdGFuZGVtL2pzL3R5cGVzL0lPVHlwZS5qcyc7XHJcbmltcG9ydCBOdWxsYWJsZUlPIGZyb20gJy4uLy4uLy4uL3RhbmRlbS9qcy90eXBlcy9OdWxsYWJsZUlPLmpzJztcclxuaW1wb3J0IE51bWJlcklPIGZyb20gJy4uLy4uLy4uL3RhbmRlbS9qcy90eXBlcy9OdW1iZXJJTy5qcyc7XHJcbmltcG9ydCBWb2lkSU8gZnJvbSAnLi4vLi4vLi4vdGFuZGVtL2pzL3R5cGVzL1ZvaWRJTy5qcyc7XHJcbmltcG9ydCB7IE5vZGUsIHNjZW5lcnkgfSBmcm9tICcuLi9pbXBvcnRzLmpzJztcclxuaW1wb3J0IGRlcHJlY2F0aW9uV2FybmluZyBmcm9tICcuLi8uLi8uLi9waGV0LWNvcmUvanMvZGVwcmVjYXRpb25XYXJuaW5nLmpzJztcclxuXHJcbmV4cG9ydCB0eXBlIEluZGV4ZWROb2RlSU9QYXJlbnQgPSB7XHJcbiAgb25JbmRleGVkTm9kZUlPQ2hpbGRNb3ZlZDogKCBub2RlOiBOb2RlICkgPT4gdm9pZDtcclxufTtcclxudHlwZSBJbmRleGVkTm9kZUlPT2JzZXJ2ZXIgPSBQYXJ0aWFsPEluZGV4ZWROb2RlSU9QYXJlbnQ+ICYgTm9kZTtcclxuXHJcbi8vIEluIG9yZGVyIHRvIHN1cHBvcnQgdW5saW5raW5nIGZyb20gbGlzdGVuaW5nIHRvIHRoZSBpbmRleCBwcm9wZXJ0eSwga2VlcCBhbiBpbmRleGVkIG1hcCB0byBjYWxsYmFjayBmdW5jdGlvbnNcclxuY29uc3QgbWFwOiBSZWNvcmQ8bnVtYmVyLCAoKSA9PiB2b2lkPiA9IHt9O1xyXG5cclxuLy8gVGhlIG5leHQgaW5kZXggYXQgd2hpY2ggYSBjYWxsYmFjayB3aWxsIGFwcGVhciBpbiB0aGUgbWFwLiBUaGlzIGFsd2F5cyBpbmNyZW1lbnRzIGFuZCB3ZSBkbyByZXVzZSBvbGQgaW5kaWNlc1xyXG5sZXQgaW5kZXggPSAwO1xyXG5cclxuLy8gTW92ZSB0aGlzIG5vZGUgb25lIGluZGV4IGZvcndhcmQgaW4gZWFjaCBvZiBpdHMgcGFyZW50cywganVtcGluZyBvdmVyIGludmlzaWJsZSBub2Rlcy4gSWYgdGhlIE5vZGUgaXMgYWxyZWFkeSBhdCB0aGUgZnJvbnQsIHRoaXMgaXMgYSBuby1vcC5cclxuZnVuY3Rpb24gbW92ZUZvcndhcmQoIG5vZGU6IE5vZGUgKTogdm9pZCB7XHJcbiAgbm9kZS5fcGFyZW50cy5mb3JFYWNoKCBwYXJlbnQgPT4gbW92ZUNoaWxkKCBwYXJlbnQgYXMgSW5kZXhlZE5vZGVJT09ic2VydmVyLCBub2RlLCArMSApICk7XHJcbn1cclxuXHJcbi8vIE1vdmUgdGhpcyBub2RlIG9uZSBpbmRleCBiYWNrd2FyZCBpbiBlYWNoIG9mIGl0cyBwYXJlbnRzLCBqdW1waW5nIG92ZXIgaW52aXNpYmxlIG5vZGVzLiAgSWYgdGhlIE5vZGUgaXMgYWxyZWFkeSBhdCB0aGUgYmFjaywgdGhpcyBpcyBhIG5vLW9wLlxyXG5mdW5jdGlvbiBtb3ZlQmFja3dhcmQoIG5vZGU6IE5vZGUgKTogdm9pZCB7XHJcbiAgbm9kZS5fcGFyZW50cy5mb3JFYWNoKCBwYXJlbnQgPT4gbW92ZUNoaWxkKCBwYXJlbnQgYXMgSW5kZXhlZE5vZGVJT09ic2VydmVyLCBub2RlLCAtMSApICk7XHJcbn1cclxuXHJcbi8vIGZhY3RvcmVkIG91dCBmb3IgdXNlIHdpdGggdGhlIGRlcHJlY2F0ZWQgbWV0aG9kIG5hbWUgdG9vXHJcbmZ1bmN0aW9uIHVubGlua0luZGV4KCB0aGlzOiBOb2RlLCBpbmRleDogbnVtYmVyICk6IHZvaWQge1xyXG4gIGNvbnN0IG1ldGhvZCA9IG1hcFsgaW5kZXggXTtcclxuICBhc3NlcnQgJiYgYXNzZXJ0KCB0aGlzLnBhcmVudHMubGVuZ3RoID09PSAxLCAnSW5kZXhlZE5vZGVJTyBvbmx5IHN1cHBvcnRzIG5vZGVzIHdpdGggYSBzaW5nbGUgcGFyZW50JyApO1xyXG4gIHRoaXMucGFyZW50c1sgMCBdLmNoaWxkcmVuQ2hhbmdlZEVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoIG1ldGhvZCApO1xyXG4gIGRlbGV0ZSBtYXBbIGluZGV4IF07XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogTW92ZXMgdGhlIHNwZWNpZmllZCBjaGlsZCBieSArMS8tMSBpbmRpY2VzLCB3aXRob3V0IGdvaW5nIHBhc3QgdGhlIGJlZ2lubmluZyBvciBlbmQuXHJcbiAqL1xyXG5mdW5jdGlvbiBtb3ZlQ2hpbGQoIHBhcmVudDogSW5kZXhlZE5vZGVJT09ic2VydmVyLCBjaGlsZDogTm9kZSwgZGVsdGE6IG51bWJlciApOiB2b2lkIHtcclxuICBjb25zdCBpbmRleCA9IHBhcmVudC5pbmRleE9mQ2hpbGQoIGNoaWxkICk7XHJcblxyXG4gIGxldCB0YXJnZXRJbmRleCA9IGluZGV4ICsgZGVsdGE7XHJcblxyXG4gIC8vIHNraXAgaW52aXNpYmxlIGNoaWxkcmVuXHJcbiAgd2hpbGUgKCB0YXJnZXRJbmRleCA+IDAgJiYgdGFyZ2V0SW5kZXggPCBwYXJlbnQuY2hpbGRyZW4ubGVuZ3RoICYmICFwYXJlbnQuY2hpbGRyZW5bIHRhcmdldEluZGV4IF0udmlzaWJsZSApIHtcclxuICAgIHRhcmdldEluZGV4ICs9IGRlbHRhO1xyXG4gIH1cclxuXHJcbiAgaWYgKCB0YXJnZXRJbmRleCA+PSAwICYmIHRhcmdldEluZGV4IDwgcGFyZW50LmNoaWxkcmVuLmxlbmd0aCApIHtcclxuICAgIHBhcmVudC5tb3ZlQ2hpbGRUb0luZGV4KCBjaGlsZCwgdGFyZ2V0SW5kZXggKTtcclxuICB9XHJcblxyXG4gIHBhcmVudC5vbkluZGV4ZWROb2RlSU9DaGlsZE1vdmVkICYmIHBhcmVudC5vbkluZGV4ZWROb2RlSU9DaGlsZE1vdmVkKCBjaGlsZCApO1xyXG59XHJcblxyXG5jb25zdCBJbmRleGVkTm9kZUlPID0gbmV3IElPVHlwZSggJ0luZGV4ZWROb2RlSU8nLCB7XHJcbiAgdmFsdWVUeXBlOiBOb2RlLFxyXG4gIGRvY3VtZW50YXRpb246ICdOb2RlIHRoYXQgY2FuIGJlIG1vdmVkIGZvcndhcmQvYmFjayBieSBpbmRleCwgd2hpY2ggc3BlY2lmaWVzIHotb3JkZXIgYW5kL29yIGxheW91dCBvcmRlcicsXHJcbiAgc3VwZXJ0eXBlOiBOb2RlLk5vZGVJTyxcclxuICB0b1N0YXRlT2JqZWN0OiBub2RlID0+IHtcclxuICAgIGNvbnN0IHN0YXRlT2JqZWN0OiB7IGluZGV4OiBudW1iZXIgfCBudWxsIH0gPSB7IGluZGV4OiBudWxsIH07XHJcbiAgICBpZiAoIG5vZGUucGFyZW50c1sgMCBdICkge1xyXG4gICAgICBhc3NlcnQgJiYgYXNzZXJ0KCBub2RlLnBhcmVudHMubGVuZ3RoID09PSAxLCAnSW5kZXhlZE5vZGVJTyBvbmx5IHN1cHBvcnRzIG5vZGVzIHdpdGggYSBzaW5nbGUgcGFyZW50JyApO1xyXG4gICAgICBzdGF0ZU9iamVjdC5pbmRleCA9IG5vZGUucGFyZW50c1sgMCBdLmluZGV4T2ZDaGlsZCggbm9kZSApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHN0YXRlT2JqZWN0O1xyXG4gIH0sXHJcbiAgYXBwbHlTdGF0ZTogKCBub2RlLCBzdGF0ZU9iamVjdCApID0+IHtcclxuICAgIGNvbnN0IG5vZGVQYXJlbnQgPSBub2RlLnBhcmVudHNbIDAgXTtcclxuXHJcbiAgICBpZiAoIG5vZGVQYXJlbnQgJiYgc3RhdGVPYmplY3QuaW5kZXggKSB7XHJcbiAgICAgIGFzc2VydCAmJiBhc3NlcnQoIG5vZGUucGFyZW50cy5sZW5ndGggPT09IDEsICdJbmRleGVkTm9kZUlPIG9ubHkgc3VwcG9ydHMgbm9kZXMgd2l0aCBhIHNpbmdsZSBwYXJlbnQnICk7XHJcblxyXG4gICAgICAvLyBTd2FwIHRoZSBjaGlsZCBhdCB0aGUgZGVzdGluYXRpb24gaW5kZXggd2l0aCBjdXJyZW50IHBvc2l0aW9uIG9mIHRoaXMgTm9kZSwgdGhhdCB3YXkgdGhlIG9wZXJhdGlvbiBpcyBhdG9taWMuXHJcbiAgICAgIC8vIFRoaXMgaW1wbGVtZW50YXRpb24gYXNzdW1lcyB0aGF0IGFsbCBjaGlsZHJlbiBhcmUgaW5zdHJ1bWVudGVkIEluZGV4ZWROb2RlSU8gaW5zdGFuY2VzIGFuZCBjYW4gaGF2ZSBzdGF0ZSBzZXRcclxuICAgICAgLy8gb24gdGhlbSB0byBcImZpeCB0aGVtXCIgYWZ0ZXIgdGhpcyBvcGVyYXRpb24uIFdpdGhvdXQgdGhpcyBpbXBsZW1lbnRhdGlvbiwgdXNpbmcgTm9kZS5tb3ZlQ2hpbGRUb0luZGV4IGNvdWxkIGJsb3dcclxuICAgICAgLy8gYXdheSBhbm90aGVyIEluZGV4ZWROb2RlIHN0YXRlIHNldC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waGV0c2ltcy9waC1zY2FsZS9pc3N1ZXMvMjI3XHJcbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gbm9kZVBhcmVudC5jaGlsZHJlbjtcclxuICAgICAgY29uc3QgY3VycmVudEluZGV4ID0gbm9kZVBhcmVudC5pbmRleE9mQ2hpbGQoIG5vZGUgKTtcclxuICAgICAgY2hpbGRyZW5bIGN1cnJlbnRJbmRleCBdID0gY2hpbGRyZW5bIHN0YXRlT2JqZWN0LmluZGV4IF07XHJcbiAgICAgIGNoaWxkcmVuWyBzdGF0ZU9iamVjdC5pbmRleCBdID0gbm9kZTtcclxuICAgICAgbm9kZVBhcmVudC5zZXRDaGlsZHJlbiggY2hpbGRyZW4gKTtcclxuICAgIH1cclxuICB9LFxyXG4gIHN0YXRlU2NoZW1hOiB7XHJcbiAgICBpbmRleDogTnVsbGFibGVJTyggTnVtYmVySU8gKVxyXG4gIH0sXHJcbiAgbWV0aG9kczoge1xyXG4gICAgbGlua0luZGV4OiB7XHJcbiAgICAgIHJldHVyblR5cGU6IE51bWJlcklPLFxyXG4gICAgICBwYXJhbWV0ZXJUeXBlczogWyBGdW5jdGlvbklPKCBWb2lkSU8sIFsgTnVtYmVySU8gXSApIF0sXHJcbiAgICAgIGRvY3VtZW50YXRpb246ICdGb2xsb3dpbmcgdGhlIFByb3BlcnR5SU8ubGluayBwYXR0ZXJuLCBzdWJzY3JpYmUgZm9yIG5vdGlmaWNhdGlvbnMgd2hlbiB0aGUgaW5kZXggaW4gdGhlIHBhcmVudCAnICtcclxuICAgICAgICAgICAgICAgICAgICAgJ2NoYW5nZXMsIGFuZCByZWNlaXZlIGEgY2FsbGJhY2sgd2l0aCB0aGUgY3VycmVudCB2YWx1ZS4gIFRoZSByZXR1cm4gdmFsdWUgaXMgYSBudW1lcmljIElEIGZvciB1c2UgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICd3aXRoIGNsZWFyTGlua0luZGV4LicsXHJcbiAgICAgIGltcGxlbWVudGF0aW9uOiBmdW5jdGlvbiggdGhpczogTm9kZSwgbGlzdGVuZXIgKSB7XHJcblxyXG4gICAgICAgIC8vIFRoZSBjYWxsYmFjayB3aGljaCBzaWduaWZpZXMgdGhlIGN1cnJlbnQgaW5kZXhcclxuICAgICAgICBjb25zdCBjYWxsYmFjayA9ICgpID0+IHtcclxuICAgICAgICAgIGFzc2VydCAmJiBhc3NlcnQoIHRoaXMucGFyZW50cy5sZW5ndGggPT09IDEsICdJbmRleGVkTm9kZUlPIG9ubHkgc3VwcG9ydHMgbm9kZXMgd2l0aCBhIHNpbmdsZSBwYXJlbnQnICk7XHJcbiAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMucGFyZW50c1sgMCBdLmluZGV4T2ZDaGlsZCggdGhpcyApO1xyXG4gICAgICAgICAgbGlzdGVuZXIoIGluZGV4ICk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgYXNzZXJ0ICYmIGFzc2VydCggdGhpcy5wYXJlbnRzLmxlbmd0aCA9PT0gMSwgJ0luZGV4ZWROb2RlSU8gb25seSBzdXBwb3J0cyBub2RlcyB3aXRoIGEgc2luZ2xlIHBhcmVudCcgKTtcclxuICAgICAgICB0aGlzLnBhcmVudHNbIDAgXS5jaGlsZHJlbkNoYW5nZWRFbWl0dGVyLmFkZExpc3RlbmVyKCBjYWxsYmFjayApO1xyXG4gICAgICAgIGNhbGxiYWNrKCk7XHJcblxyXG4gICAgICAgIGNvbnN0IG15SW5kZXggPSBpbmRleDtcclxuICAgICAgICBtYXBbIG15SW5kZXggXSA9IGNhbGxiYWNrO1xyXG4gICAgICAgIGluZGV4Kys7XHJcbiAgICAgICAgcmV0dXJuIG15SW5kZXg7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICB1bmxpbmtJbmRleDoge1xyXG4gICAgICByZXR1cm5UeXBlOiBWb2lkSU8sXHJcbiAgICAgIHBhcmFtZXRlclR5cGVzOiBbIE51bWJlcklPIF0sXHJcbiAgICAgIGRvY3VtZW50YXRpb246ICdVbmxpbmsgYSBsaXN0ZW5lciB0aGF0IGhhcyBiZWVuIGFkZGVkIHVzaW5nIGxpbmtJbmRleCwgYnkgaXRzIG51bWVyaWNhbCBJRCAobGlrZSBzZXRUaW1lb3V0L2NsZWFyVGltZW91dCknLFxyXG4gICAgICBpbXBsZW1lbnRhdGlvbjogdW5saW5rSW5kZXhcclxuICAgIH0sXHJcbiAgICBjbGVhckxpbmtJbmRleDoge1xyXG4gICAgICByZXR1cm5UeXBlOiBWb2lkSU8sXHJcbiAgICAgIHBhcmFtZXRlclR5cGVzOiBbIE51bWJlcklPIF0sXHJcbiAgICAgIGRvY3VtZW50YXRpb246ICdEZXByZWNhdGVkLCBzZWUgXCJ1bmxpbmtJbmRleFwiLicsXHJcbiAgICAgIGltcGxlbWVudGF0aW9uOiBmdW5jdGlvbiggdGhpczogTm9kZSwgaW5kZXg6IG51bWJlciApOiB2b2lkIHtcclxuICAgICAgICBhc3NlcnQgJiYgZGVwcmVjYXRpb25XYXJuaW5nKCAnY2xlYXJMaW5rSW5kZXggaXMgZGVwcmVjYXRlZCwgdXNlIHVubGlua0luZGV4IGluc3RlYWQuJywgdHJ1ZSApO1xyXG4gICAgICAgIHVubGlua0luZGV4LmNhbGwoIHRoaXMsIGluZGV4ICk7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICBtb3ZlRm9yd2FyZDoge1xyXG4gICAgICByZXR1cm5UeXBlOiBWb2lkSU8sXHJcbiAgICAgIHBhcmFtZXRlclR5cGVzOiBbXSxcclxuICAgICAgaW1wbGVtZW50YXRpb246IGZ1bmN0aW9uKCB0aGlzOiBOb2RlICkge1xyXG4gICAgICAgIHJldHVybiBtb3ZlRm9yd2FyZCggdGhpcyApO1xyXG4gICAgICB9LFxyXG4gICAgICBkb2N1bWVudGF0aW9uOiAnTW92ZSB0aGlzIE5vZGUgb25lIGluZGV4IGZvcndhcmQgaW4gZWFjaCBvZiBpdHMgcGFyZW50cywgc2tpcHBpbmcgaW52aXNpYmxlIE5vZGVzLiBJZiB0aGUgTm9kZSBpcyBhbHJlYWR5IGF0IHRoZSBmcm9udCwgdGhpcyBpcyBhIG5vLW9wLidcclxuICAgIH0sXHJcblxyXG4gICAgbW92ZUJhY2t3YXJkOiB7XHJcbiAgICAgIHJldHVyblR5cGU6IFZvaWRJTyxcclxuICAgICAgcGFyYW1ldGVyVHlwZXM6IFtdLFxyXG4gICAgICBpbXBsZW1lbnRhdGlvbjogZnVuY3Rpb24oIHRoaXM6IE5vZGUgKSB7XHJcbiAgICAgICAgcmV0dXJuIG1vdmVCYWNrd2FyZCggdGhpcyApO1xyXG4gICAgICB9LFxyXG4gICAgICBkb2N1bWVudGF0aW9uOiAnTW92ZSB0aGlzIE5vZGUgb25lIGluZGV4IGJhY2t3YXJkIGluIGVhY2ggb2YgaXRzIHBhcmVudHMsIHNraXBwaW5nIGludmlzaWJsZSBOb2Rlcy4gSWYgdGhlIE5vZGUgaXMgYWxyZWFkeSBhdCB0aGUgYmFjaywgdGhpcyBpcyBhIG5vLW9wLidcclxuICAgIH1cclxuICB9XHJcbn0gKTtcclxuXHJcbnNjZW5lcnkucmVnaXN0ZXIoICdJbmRleGVkTm9kZUlPJywgSW5kZXhlZE5vZGVJTyApO1xyXG5leHBvcnQgZGVmYXVsdCBJbmRleGVkTm9kZUlPOyJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU9BLFVBQVUsTUFBTSx3Q0FBd0M7QUFDL0QsT0FBT0MsTUFBTSxNQUFNLG9DQUFvQztBQUN2RCxPQUFPQyxVQUFVLE1BQU0sd0NBQXdDO0FBQy9ELE9BQU9DLFFBQVEsTUFBTSxzQ0FBc0M7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