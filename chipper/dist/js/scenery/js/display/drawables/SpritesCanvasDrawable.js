// Copyright 2019-2024, University of Colorado Boulder

/**
 * Canvas drawable for Sprites nodes.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

import Poolable from '../../../../phet-core/js/Poolable.js';
import { CanvasSelfDrawable, Imageable, Node, scenery, SpriteInstanceTransformType } from '../../imports.js';
class SpritesCanvasDrawable extends CanvasSelfDrawable {
  /**
   * Paints this drawable to a Canvas (the wrapper contains both a Canvas reference and its drawing context).
   * @public
   *
   * Assumes that the Canvas's context is already in the proper local coordinate frame for the node, and that any
   * other required effects (opacity, clipping, etc.) have already been prepared.
   *
   * This is part of the CanvasSelfDrawable API required to be implemented for subtypes.
   *
   * @param {CanvasContextWrapper} wrapper - Contains the Canvas and its drawing context
   * @param {Node} node - Our node that is being drawn
   * @param {Matrix3} matrix - The transformation matrix applied for this node's coordinate system.
   */
  paintCanvas(wrapper, node, matrix) {
    assert && assert(node instanceof Node);
    const baseMipmapScale = Imageable.getApproximateMatrixScale(matrix) * (window.devicePixelRatio || 1);
    const numInstances = node._spriteInstances.length;
    if (assert && numInstances > 0) {
      assert(node.canvasBounds.isValid(), 'Sprites canvasBounds should be set and have non-negative area if it renders sprites');
    }
    for (let i = 0; i < numInstances; i++) {
      const spriteInstance = node._spriteInstances[i];
      const spriteImage = spriteInstance.sprite.imageProperty.value;
      const hasOpacity = spriteInstance.alpha !== 1 || spriteImage.imageOpacity !== 1;
      const hasMipmaps = spriteImage._mipmap && spriteImage.hasMipmaps();

      // If it includes opacity, we'll do a context save/restore
      if (hasOpacity) {
        wrapper.context.save();
        wrapper.context.globalAlpha *= spriteInstance.alpha * spriteImage.imageOpacity;
      }

      // If it's a translation only, we can add the offsets to the drawImage call directly (higher performance)
      if (spriteInstance.transformType === SpriteInstanceTransformType.TRANSLATION && matrix.isTranslation()) {
        if (hasMipmaps) {
          const level = spriteImage.getMipmapLevelFromScale(baseMipmapScale, Imageable.CANVAS_MIPMAP_BIAS_ADJUSTMENT);
          const canvas = spriteImage.getMipmapCanvas(level);
          const multiplier = Math.pow(2, level);
          wrapper.context.drawImage(canvas, spriteInstance.matrix.m02() - spriteImage.offset.x, spriteInstance.matrix.m12() - spriteImage.offset.y, canvas.width * multiplier, canvas.height * multiplier);
        } else {
          wrapper.context.drawImage(spriteImage.image, spriteInstance.matrix.m02() - spriteImage.offset.x, spriteInstance.matrix.m12() - spriteImage.offset.y);
        }
      } else {
        wrapper.context.save();
        spriteInstance.matrix.canvasAppendTransform(wrapper.context);
        if (hasMipmaps) {
          const level = spriteImage.getMipmapLevelFromScale(baseMipmapScale * Imageable.getApproximateMatrixScale(spriteInstance.matrix), Imageable.CANVAS_MIPMAP_BIAS_ADJUSTMENT);
          const canvas = spriteImage.getMipmapCanvas(level);
          const multiplier = Math.pow(2, level);
          wrapper.context.drawImage(canvas, -spriteImage.offset.x, -spriteImage.offset.y, canvas.width * multiplier, canvas.height * multiplier);
        } else {
          wrapper.context.drawImage(spriteImage.image, -spriteImage.offset.x, -spriteImage.offset.y);
        }
        wrapper.context.restore();
      }
      if (hasOpacity) {
        wrapper.context.restore();
      }
    }
  }
}
scenery.register('SpritesCanvasDrawable', SpritesCanvasDrawable);
Poolable.mixInto(SpritesCanvasDrawable);
export default SpritesCanvasDrawable;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJQb29sYWJsZSIsIkNhbnZhc1NlbGZEcmF3YWJsZSIsIkltYWdlYWJsZSIsIk5vZGUiLCJzY2VuZXJ5IiwiU3ByaXRlSW5zdGFuY2VUcmFuc2Zvcm1UeXBlIiwiU3ByaXRlc0NhbnZhc0RyYXdhYmxlIiwicGFpbnRDYW52YXMiLCJ3cmFwcGVyIiwibm9kZSIsIm1hdHJpeCIsImFzc2VydCIsImJhc2VNaXBtYXBTY2FsZSIsImdldEFwcHJveGltYXRlTWF0cml4U2NhbGUiLCJ3aW5kb3ciLCJkZXZpY2VQaXhlbFJhdGlvIiwibnVtSW5zdGFuY2VzIiwiX3Nwcml0ZUluc3RhbmNlcyIsImxlbmd0aCIsImNhbnZhc0JvdW5kcyIsImlzVmFsaWQiLCJpIiwic3ByaXRlSW5zdGFuY2UiLCJzcHJpdGVJbWFnZSIsInNwcml0ZSIsImltYWdlUHJvcGVydHkiLCJ2YWx1ZSIsImhhc09wYWNpdHkiLCJhbHBoYSIsImltYWdlT3BhY2l0eSIsImhhc01pcG1hcHMiLCJfbWlwbWFwIiwiY29udGV4dCIsInNhdmUiLCJnbG9iYWxBbHBoYSIsInRyYW5zZm9ybVR5cGUiLCJUUkFOU0xBVElPTiIsImlzVHJhbnNsYXRpb24iLCJsZXZlbCIsImdldE1pcG1hcExldmVsRnJvbVNjYWxlIiwiQ0FOVkFTX01JUE1BUF9CSUFTX0FESlVTVE1FTlQiLCJjYW52YXMiLCJnZXRNaXBtYXBDYW52YXMiLCJtdWx0aXBsaWVyIiwiTWF0aCIsInBvdyIsImRyYXdJbWFnZSIsIm0wMiIsIm9mZnNldCIsIngiLCJtMTIiLCJ5Iiwid2lkdGgiLCJoZWlnaHQiLCJpbWFnZSIsImNhbnZhc0FwcGVuZFRyYW5zZm9ybSIsInJlc3RvcmUiLCJyZWdpc3RlciIsIm1peEludG8iXSwic291cmNlcyI6WyJTcHJpdGVzQ2FudmFzRHJhd2FibGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTktMjAyNCwgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXHJcblxyXG4vKipcclxuICogQ2FudmFzIGRyYXdhYmxlIGZvciBTcHJpdGVzIG5vZGVzLlxyXG4gKlxyXG4gKiBAYXV0aG9yIEpvbmF0aGFuIE9sc29uIDxqb25hdGhhbi5vbHNvbkBjb2xvcmFkby5lZHU+XHJcbiAqL1xyXG5cclxuaW1wb3J0IFBvb2xhYmxlIGZyb20gJy4uLy4uLy4uLy4uL3BoZXQtY29yZS9qcy9Qb29sYWJsZS5qcyc7XHJcbmltcG9ydCB7IENhbnZhc1NlbGZEcmF3YWJsZSwgSW1hZ2VhYmxlLCBOb2RlLCBzY2VuZXJ5LCBTcHJpdGVJbnN0YW5jZVRyYW5zZm9ybVR5cGUgfSBmcm9tICcuLi8uLi9pbXBvcnRzLmpzJztcclxuXHJcbmNsYXNzIFNwcml0ZXNDYW52YXNEcmF3YWJsZSBleHRlbmRzIENhbnZhc1NlbGZEcmF3YWJsZSB7XHJcbiAgLyoqXHJcbiAgICogUGFpbnRzIHRoaXMgZHJhd2FibGUgdG8gYSBDYW52YXMgKHRoZSB3cmFwcGVyIGNvbnRhaW5zIGJvdGggYSBDYW52YXMgcmVmZXJlbmNlIGFuZCBpdHMgZHJhd2luZyBjb250ZXh0KS5cclxuICAgKiBAcHVibGljXHJcbiAgICpcclxuICAgKiBBc3N1bWVzIHRoYXQgdGhlIENhbnZhcydzIGNvbnRleHQgaXMgYWxyZWFkeSBpbiB0aGUgcHJvcGVyIGxvY2FsIGNvb3JkaW5hdGUgZnJhbWUgZm9yIHRoZSBub2RlLCBhbmQgdGhhdCBhbnlcclxuICAgKiBvdGhlciByZXF1aXJlZCBlZmZlY3RzIChvcGFjaXR5LCBjbGlwcGluZywgZXRjLikgaGF2ZSBhbHJlYWR5IGJlZW4gcHJlcGFyZWQuXHJcbiAgICpcclxuICAgKiBUaGlzIGlzIHBhcnQgb2YgdGhlIENhbnZhc1NlbGZEcmF3YWJsZSBBUEkgcmVxdWlyZWQgdG8gYmUgaW1wbGVtZW50ZWQgZm9yIHN1YnR5cGVzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtDYW52YXNDb250ZXh0V3JhcHBlcn0gd3JhcHBlciAtIENvbnRhaW5zIHRoZSBDYW52YXMgYW5kIGl0cyBkcmF3aW5nIGNvbnRleHRcclxuICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgLSBPdXIgbm9kZSB0aGF0IGlzIGJlaW5nIGRyYXduXHJcbiAgICogQHBhcmFtIHtNYXRyaXgzfSBtYXRyaXggLSBUaGUgdHJhbnNmb3JtYXRpb24gbWF0cml4IGFwcGxpZWQgZm9yIHRoaXMgbm9kZSdzIGNvb3JkaW5hdGUgc3lzdGVtLlxyXG4gICAqL1xyXG4gIHBhaW50Q2FudmFzKCB3cmFwcGVyLCBub2RlLCBtYXRyaXggKSB7XHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCBub2RlIGluc3RhbmNlb2YgTm9kZSApO1xyXG5cclxuICAgIGNvbnN0IGJhc2VNaXBtYXBTY2FsZSA9IEltYWdlYWJsZS5nZXRBcHByb3hpbWF0ZU1hdHJpeFNjYWxlKCBtYXRyaXggKSAqICggd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSApO1xyXG5cclxuICAgIGNvbnN0IG51bUluc3RhbmNlcyA9IG5vZGUuX3Nwcml0ZUluc3RhbmNlcy5sZW5ndGg7XHJcblxyXG4gICAgaWYgKCBhc3NlcnQgJiYgbnVtSW5zdGFuY2VzID4gMCApIHtcclxuICAgICAgYXNzZXJ0KCBub2RlLmNhbnZhc0JvdW5kcy5pc1ZhbGlkKCksXHJcbiAgICAgICAgJ1Nwcml0ZXMgY2FudmFzQm91bmRzIHNob3VsZCBiZSBzZXQgYW5kIGhhdmUgbm9uLW5lZ2F0aXZlIGFyZWEgaWYgaXQgcmVuZGVycyBzcHJpdGVzJyApO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAoIGxldCBpID0gMDsgaSA8IG51bUluc3RhbmNlczsgaSsrICkge1xyXG4gICAgICBjb25zdCBzcHJpdGVJbnN0YW5jZSA9IG5vZGUuX3Nwcml0ZUluc3RhbmNlc1sgaSBdO1xyXG4gICAgICBjb25zdCBzcHJpdGVJbWFnZSA9IHNwcml0ZUluc3RhbmNlLnNwcml0ZS5pbWFnZVByb3BlcnR5LnZhbHVlO1xyXG4gICAgICBjb25zdCBoYXNPcGFjaXR5ID0gc3ByaXRlSW5zdGFuY2UuYWxwaGEgIT09IDEgfHwgc3ByaXRlSW1hZ2UuaW1hZ2VPcGFjaXR5ICE9PSAxO1xyXG4gICAgICBjb25zdCBoYXNNaXBtYXBzID0gc3ByaXRlSW1hZ2UuX21pcG1hcCAmJiBzcHJpdGVJbWFnZS5oYXNNaXBtYXBzKCk7XHJcblxyXG4gICAgICAvLyBJZiBpdCBpbmNsdWRlcyBvcGFjaXR5LCB3ZSdsbCBkbyBhIGNvbnRleHQgc2F2ZS9yZXN0b3JlXHJcbiAgICAgIGlmICggaGFzT3BhY2l0eSApIHtcclxuICAgICAgICB3cmFwcGVyLmNvbnRleHQuc2F2ZSgpO1xyXG4gICAgICAgIHdyYXBwZXIuY29udGV4dC5nbG9iYWxBbHBoYSAqPSBzcHJpdGVJbnN0YW5jZS5hbHBoYSAqIHNwcml0ZUltYWdlLmltYWdlT3BhY2l0eTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gSWYgaXQncyBhIHRyYW5zbGF0aW9uIG9ubHksIHdlIGNhbiBhZGQgdGhlIG9mZnNldHMgdG8gdGhlIGRyYXdJbWFnZSBjYWxsIGRpcmVjdGx5IChoaWdoZXIgcGVyZm9ybWFuY2UpXHJcbiAgICAgIGlmICggc3ByaXRlSW5zdGFuY2UudHJhbnNmb3JtVHlwZSA9PT0gU3ByaXRlSW5zdGFuY2VUcmFuc2Zvcm1UeXBlLlRSQU5TTEFUSU9OICYmIG1hdHJpeC5pc1RyYW5zbGF0aW9uKCkgKSB7XHJcbiAgICAgICAgaWYgKCBoYXNNaXBtYXBzICkge1xyXG4gICAgICAgICAgY29uc3QgbGV2ZWwgPSBzcHJpdGVJbWFnZS5nZXRNaXBtYXBMZXZlbEZyb21TY2FsZSggYmFzZU1pcG1hcFNjYWxlLCBJbWFnZWFibGUuQ0FOVkFTX01JUE1BUF9CSUFTX0FESlVTVE1FTlQgKTtcclxuICAgICAgICAgIGNvbnN0IGNhbnZhcyA9IHNwcml0ZUltYWdlLmdldE1pcG1hcENhbnZhcyggbGV2ZWwgKTtcclxuICAgICAgICAgIGNvbnN0IG11bHRpcGxpZXIgPSBNYXRoLnBvdyggMiwgbGV2ZWwgKTtcclxuICAgICAgICAgIHdyYXBwZXIuY29udGV4dC5kcmF3SW1hZ2UoXHJcbiAgICAgICAgICAgIGNhbnZhcyxcclxuICAgICAgICAgICAgc3ByaXRlSW5zdGFuY2UubWF0cml4Lm0wMigpIC0gc3ByaXRlSW1hZ2Uub2Zmc2V0LngsXHJcbiAgICAgICAgICAgIHNwcml0ZUluc3RhbmNlLm1hdHJpeC5tMTIoKSAtIHNwcml0ZUltYWdlLm9mZnNldC55LFxyXG4gICAgICAgICAgICBjYW52YXMud2lkdGggKiBtdWx0aXBsaWVyLFxyXG4gICAgICAgICAgICBjYW52YXMuaGVpZ2h0ICogbXVsdGlwbGllclxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICB3cmFwcGVyLmNvbnRleHQuZHJhd0ltYWdlKFxyXG4gICAgICAgICAgICBzcHJpdGVJbWFnZS5pbWFnZSxcclxuICAgICAgICAgICAgc3ByaXRlSW5zdGFuY2UubWF0cml4Lm0wMigpIC0gc3ByaXRlSW1hZ2Uub2Zmc2V0LngsXHJcbiAgICAgICAgICAgIHNwcml0ZUluc3RhbmNlLm1hdHJpeC5tMTIoKSAtIHNwcml0ZUltYWdlLm9mZnNldC55XHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICB3cmFwcGVyLmNvbnRleHQuc2F2ZSgpO1xyXG4gICAgICAgIHNwcml0ZUluc3RhbmNlLm1hdHJpeC5jYW52YXNBcHBlbmRUcmFuc2Zvcm0oIHdyYXBwZXIuY29udGV4dCApO1xyXG5cclxuICAgICAgICBpZiAoIGhhc01pcG1hcHMgKSB7XHJcbiAgICAgICAgICBjb25zdCBsZXZlbCA9IHNwcml0ZUltYWdlLmdldE1pcG1hcExldmVsRnJvbVNjYWxlKCBiYXNlTWlwbWFwU2NhbGUgKiBJbWFnZWFibGUuZ2V0QXBwcm94aW1hdGVNYXRyaXhTY2FsZSggc3ByaXRlSW5zdGFuY2UubWF0cml4ICksIEltYWdlYWJsZS5DQU5WQVNfTUlQTUFQX0JJQVNfQURKVVNUTUVOVCApO1xyXG4gICAgICAgICAgY29uc3QgY2FudmFzID0gc3ByaXRlSW1hZ2UuZ2V0TWlwbWFwQ2FudmFzKCBsZXZlbCApO1xyXG4gICAgICAgICAgY29uc3QgbXVsdGlwbGllciA9IE1hdGgucG93KCAyLCBsZXZlbCApO1xyXG4gICAgICAgICAgd3JhcHBlci5jb250ZXh0LmRyYXdJbWFnZShcclxuICAgICAgICAgICAgY2FudmFzLFxyXG4gICAgICAgICAgICAtc3ByaXRlSW1hZ2Uub2Zmc2V0LngsXHJcbiAgICAgICAgICAgIC1zcHJpdGVJbWFnZS5vZmZzZXQueSxcclxuICAgICAgICAgICAgY2FudmFzLndpZHRoICogbXVsdGlwbGllcixcclxuICAgICAgICAgICAgY2FudmFzLmhlaWdodCAqIG11bHRpcGxpZXJcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgd3JhcHBlci5jb250ZXh0LmRyYXdJbWFnZShcclxuICAgICAgICAgICAgc3ByaXRlSW1hZ2UuaW1hZ2UsXHJcbiAgICAgICAgICAgIC1zcHJpdGVJbWFnZS5vZmZzZXQueCxcclxuICAgICAgICAgICAgLXNwcml0ZUltYWdlLm9mZnNldC55XHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgd3JhcHBlci5jb250ZXh0LnJlc3RvcmUoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCBoYXNPcGFjaXR5ICkge1xyXG4gICAgICAgIHdyYXBwZXIuY29udGV4dC5yZXN0b3JlKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbnNjZW5lcnkucmVnaXN0ZXIoICdTcHJpdGVzQ2FudmFzRHJhd2FibGUnLCBTcHJpdGVzQ2FudmFzRHJhd2FibGUgKTtcclxuXHJcblBvb2xhYmxlLm1peEludG8oIFNwcml0ZXNDYW52YXNEcmF3YWJsZSApO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgU3ByaXRlc0NhbnZhc0RyYXdhYmxlOyJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNB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