// Copyright 2021-2024, University of Colorado Boulder

/**
 * HeightSizable is a trait that provides a minimum and preferred height. The minimum height is set by the component,
 * so that layout containers could know how "small" the component can be made. The preferred height is set by the
 * layout container, and the component should adjust its size so that it takes up that height.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

import TinyProperty from '../../../axon/js/TinyProperty.js';
import memoize from '../../../phet-core/js/memoize.js';
import { DelayedMutate, REQUIRES_BOUNDS_OPTION_KEYS, scenery } from '../imports.js';
// Position changes smaller than this will be ignored
const CHANGE_POSITION_THRESHOLD = 1e-9;
export const HEIGHT_SIZABLE_OPTION_KEYS = ['preferredHeight', 'minimumHeight', 'localPreferredHeight', 'localMinimumHeight', 'heightSizable'];
// IMPORTANT: If you're combining this in, typically don't pass options that HeightSizable would take through the
// constructor. It will hit Node's mutate() likely, and then will fail because we haven't been able to set the
// values yet. If you're making something HeightSizable, please use a later mutate() to pass these options through.
// They WILL be caught by assertions if someone adds one of those options, but it could be a silent bug if no one
// is yet passing those options through.
const HeightSizable = memoize(Type => {
  const HeightSizableTrait = DelayedMutate('HeightSizable', HEIGHT_SIZABLE_OPTION_KEYS, class HeightSizableTrait extends Type {
    // parent/local preferred/minimum Properties. See the options above for more documentation
    preferredHeightProperty = new TinyProperty(null);
    minimumHeightProperty = new TinyProperty(null);
    localPreferredHeightProperty = new TinyProperty(null);
    localMinimumHeightProperty = new TinyProperty(null);
    isHeightResizableProperty = new TinyProperty(true);

    // Flags so that we can change one (parent/local) value and not enter an infinite loop changing the others.
    // We want to lock out all other local or non-local preferred minimum sizes, whether in HeightSizable or WidthSizable
    // NOTE: We are merging declarations between HeightSizable and WidthSizable. If Sizable is used these flags
    // will be shared by both HeightSizable and WidthSizable.
    // @mixin-protected - made public for use in the mixin only
    _preferredSizeChanging = false;
    // @mixin-protected - made public for use in the mixin only
    _minimumSizeChanging = false;

    // We'll need to detect reentrancy when setting the dual of the preferred/minimum properties (e.g. local vs parent).
    // If we get a reentrant case, we'll need to detect it and clear things up at the end (updating the minimum size
    // in the parent coordinate frame, and the preferred size in the local coordinate frame).
    // An example is if the minimum size is set, and that triggers a listener that UPDATES something that changes the
    // minimum size, we'll need to make sure that the local minimum size is updated AFTER everything has happened.
    // These locks are used to detect these cases, and then run the appropriate updates afterward to make sure that the
    // local and parent values are in sync (based on the transform used).
    // @mixin-protected - made public for use in the mixin only
    _preferredSizeChangeAttemptDuringLock = false;
    // @mixin-protected - made public for use in the mixin only
    _minimumSizeChangeAttemptDuringLock = false;

    // Expose listeners, so that we'll be able to hook them up to the opposite dimension in Sizable
    // @mixin-protected - made public for use in the mixin only

    // @mixin-protected - made public for use in the mixin only

    // @mixin-protected - made public for use in the mixin only

    // @mixin-protected - made public for use in the mixin only

    // IMPORTANT: If you're combining this in, typically don't pass options that HeightSizable would take through the
    // constructor. It will hit Node's mutate() likely, and then will fail because we haven't been able to set the
    // values yet. If you're making something HeightSizable, please use a later mutate() to pass these options through.
    // They WILL be caught by assertions if someone adds one of those options, but it could be a silent bug if no one
    // is yet passing those options through.
    constructor(...args) {
      super(...args);
      this._updatePreferredHeightListener = this._updatePreferredHeight.bind(this);
      this._updateLocalPreferredHeightListener = this._updateLocalPreferredHeight.bind(this);
      this._updateMinimumHeightListener = this._updateMinimumHeight.bind(this);
      this._updateLocalMinimumHeightListener = this._updateLocalMinimumHeight.bind(this);

      // Update the opposite of parent/local when one changes
      this.preferredHeightProperty.lazyLink(this._updateLocalPreferredHeightListener);
      this.localPreferredHeightProperty.lazyLink(this._updatePreferredHeightListener);
      this.minimumHeightProperty.lazyLink(this._updateLocalMinimumHeightListener);
      this.localMinimumHeightProperty.lazyLink(this._updateMinimumHeightListener);

      // On a transform change, keep our local minimum (presumably unchanged), and our parent preferred size
      this.transformEmitter.addListener(this._updateLocalPreferredHeightListener);
      // On a transform change this should update the minimum
      this.transformEmitter.addListener(this._updateMinimumHeightListener);
    }
    get preferredHeight() {
      assert && assert(this.preferredHeightProperty, 'HeightSizable options should be set from a later mutate() call instead of the super constructor');
      return this.preferredHeightProperty.value;
    }
    set preferredHeight(value) {
      assert && assert(this.preferredHeightProperty, 'HeightSizable options should be set from a later mutate() call instead of the super constructor');
      assert && assert(value === null || typeof value === 'number' && isFinite(value) && value >= 0, 'preferredHeight should be null or a non-negative finite number');
      this.preferredHeightProperty.value = value;
    }
    get localPreferredHeight() {
      assert && assert(this.localPreferredHeightProperty, 'HeightSizable options should be set from a later mutate() call instead of the super constructor');
      return this.localPreferredHeightProperty.value;
    }
    set localPreferredHeight(value) {
      assert && assert(this.localPreferredHeightProperty, 'HeightSizable options should be set from a later mutate() call instead of the super constructor');
      assert && assert(value === null || typeof value === 'number' && isFinite(value) && value >= 0, 'localPreferredHeight should be null or a non-negative finite number');
      this.localPreferredHeightProperty.value = value;
    }
    get minimumHeight() {
      assert && assert(this.minimumHeightProperty, 'HeightSizable options should be set from a later mutate() call instead of the super constructor');
      return this.minimumHeightProperty.value;
    }
    set minimumHeight(value) {
      assert && assert(this.minimumHeightProperty, 'HeightSizable options should be set from a later mutate() call instead of the super constructor');
      assert && assert(value === null || typeof value === 'number' && isFinite(value));
      this.minimumHeightProperty.value = value;
    }
    get localMinimumHeight() {
      assert && assert(this.localMinimumHeightProperty, 'HeightSizable options should be set from a later mutate() call instead of the super constructor');
      return this.localMinimumHeightProperty.value;
    }
    set localMinimumHeight(value) {
      assert && assert(this.localMinimumHeightProperty, 'HeightSizable options should be set from a later mutate() call instead of the super constructor');
      assert && assert(value === null || typeof value === 'number' && isFinite(value));
      this.localMinimumHeightProperty.value = value;
    }
    get heightSizable() {
      assert && assert(this.isHeightResizableProperty, 'HeightSizable options should be set from a later mutate() call instead of the super constructor');
      return this.isHeightResizableProperty.value;
    }
    set heightSizable(value) {
      assert && assert(this.isHeightResizableProperty, 'HeightSizable options should be set from a later mutate() call instead of the super constructor');
      this.isHeightResizableProperty.value = value;
    }
    get extendsHeightSizable() {
      return true;
    }
    validateLocalPreferredHeight() {
      if (assert) {
        const currentHeight = this.localHeight;
        const effectiveMinimumHeight = this.localMinimumHeight === null ? currentHeight : this.localMinimumHeight;
        const idealHeight = this.localPreferredHeight === null ? effectiveMinimumHeight : this.localPreferredHeight;

        // Handle non-finite values with exact equality
        assert(idealHeight === currentHeight || Math.abs(idealHeight - currentHeight) < 1e-7);
      }
    }

    // This is provided to hook into the Sizable trait, so that we can update the opposite dimension
    // @mixin-protected - made public for use in the mixin only
    _calculateLocalPreferredHeight() {
      return this.matrix.isAligned() && this.preferredHeight !== null ? Math.abs(this.transform.inverseDeltaY(this.preferredHeight)) : null;
    }

    // Provides a hook to Sizable, since we'll need to cross-link this to also try updating the opposite dimension
    // @mixin-protected - made public for use in the mixin only
    _onReentrantPreferredHeight() {
      this._updateLocalPreferredHeightListener();
    }
    _updateLocalPreferredHeight() {
      assert && this.auditMaxDimensions();
      if (!this._preferredSizeChanging) {
        this._preferredSizeChanging = true;

        // Since the local "preferred" size is the one that we'll want to continue to update if we experience
        // reentrancy (since we treat the non-local version as the ground truth), we'll loop here until we didn't get
        // an attempt to change it. This will ensure that after changes, we'll have a consistent preferred and
        // localPreferred size.
        do {
          this._preferredSizeChangeAttemptDuringLock = false;
          const localPreferredHeight = this._calculateLocalPreferredHeight();
          if (this.localPreferredHeightProperty.value === null || localPreferredHeight === null || Math.abs(this.localPreferredHeightProperty.value - localPreferredHeight) > CHANGE_POSITION_THRESHOLD) {
            this.localPreferredHeightProperty.value = localPreferredHeight;
          }
        } while (this._preferredSizeChangeAttemptDuringLock);
        this._preferredSizeChanging = false;
      } else {
        this._preferredSizeChangeAttemptDuringLock = true;
      }
    }

    // This is provided to hook into the Sizable trait, so that we can update the opposite dimension
    // @mixin-protected - made public for use in the mixin only
    _calculatePreferredHeight() {
      return this.matrix.isAligned() && this.localPreferredHeight !== null ? Math.abs(this.transform.transformDeltaY(this.localPreferredHeight)) : null;
    }
    _updatePreferredHeight() {
      if (!this._preferredSizeChanging) {
        this._preferredSizeChanging = true;
        this._preferredSizeChangeAttemptDuringLock = false;
        const preferredHeight = this._calculatePreferredHeight();
        if (this.preferredHeightProperty.value === null || preferredHeight === null || Math.abs(this.preferredHeightProperty.value - preferredHeight) > CHANGE_POSITION_THRESHOLD) {
          this.preferredHeightProperty.value = preferredHeight;
        }
        this._preferredSizeChanging = false;

        // Here, in the case of reentrance, we'll actually want to switch to updating the local preferred size, since
        // given any other changes it should be the primary one to change.
        if (this._preferredSizeChangeAttemptDuringLock) {
          this._onReentrantPreferredHeight();
        }
      } else {
        this._preferredSizeChangeAttemptDuringLock = true;
      }
    }

    // This is provided to hook into the Sizable trait, so that we can update the opposite dimension
    // @mixin-protected - made public for use in the mixin only
    _calculateLocalMinimumHeight() {
      return this.matrix.isAligned() && this.minimumHeight !== null ? Math.abs(this.transform.inverseDeltaY(this.minimumHeight)) : null;
    }

    // @mixin-protected - made public for use in the mixin only
    _onReentrantLocalMinimumHeight() {
      this._updateMinimumHeight();
    }
    _updateLocalMinimumHeight() {
      if (!this._minimumSizeChanging) {
        this._minimumSizeChanging = true;
        this._minimumSizeChangeAttemptDuringLock = false;
        const localMinimumHeight = this._calculateLocalMinimumHeight();
        if (this.localMinimumHeightProperty.value === null || localMinimumHeight === null || Math.abs(this.localMinimumHeightProperty.value - localMinimumHeight) > CHANGE_POSITION_THRESHOLD) {
          this.localMinimumHeightProperty.value = localMinimumHeight;
        }
        this._minimumSizeChanging = false;

        // Here, in the case of reentrance, we'll actually want to switch to updating the non-local minimum size, since
        // given any other changes it should be the primary one to change.
        if (this._minimumSizeChangeAttemptDuringLock) {
          this._onReentrantLocalMinimumHeight();
        }
      } else {
        this._minimumSizeChangeAttemptDuringLock = true;
      }
    }

    // This is provided to hook into the Sizable trait, so that we can update the opposite dimension
    // @mixin-protected - made public for use in the mixin only
    _calculateMinimumHeight() {
      return this.matrix.isAligned() && this.localMinimumHeight !== null ? Math.abs(this.transform.transformDeltaY(this.localMinimumHeight)) : null;
    }
    _updateMinimumHeight() {
      if (!this._minimumSizeChanging) {
        this._minimumSizeChanging = true;

        // Since the non-local "minimum" size is the one that we'll want to continue to update if we experience
        // reentrancy (since we treat the local version as the ground truth), we'll loop here until we didn't get
        // an attempt to change it. This will ensure that after changes, we'll have a consistent minimum and
        // localMinimum size.
        do {
          this._minimumSizeChangeAttemptDuringLock = false;
          const minimumHeight = this._calculateMinimumHeight();
          if (this.minimumHeightProperty.value === null || minimumHeight === null || Math.abs(this.minimumHeightProperty.value - minimumHeight) > CHANGE_POSITION_THRESHOLD) {
            this.minimumHeightProperty.value = minimumHeight;
          }
        } while (this._minimumSizeChangeAttemptDuringLock);
        this._minimumSizeChanging = false;
      }
    }
    mutate(options) {
      return super.mutate(options);
    }
  });

  // If we're extending into a Node type, include option keys
  if (HeightSizableTrait.prototype._mutatorKeys) {
    const existingKeys = HeightSizableTrait.prototype._mutatorKeys;
    const newKeys = HEIGHT_SIZABLE_OPTION_KEYS;
    const indexOfBoundsBasedOptions = existingKeys.indexOf(REQUIRES_BOUNDS_OPTION_KEYS[0]);
    HeightSizableTrait.prototype._mutatorKeys = [...existingKeys.slice(0, indexOfBoundsBasedOptions), ...newKeys, ...existingKeys.slice(indexOfBoundsBasedOptions)];
  }
  return HeightSizableTrait;
});

// Some typescript gymnastics to provide a user-defined type guard that treats something as HeightSizable.
// We need to define an unused function with a concrete type, so that we can extract the return type of the function
// and provide a type for a Node that extends this type.

const isHeightSizable = node => {
  return node.heightSizable;
};
const extendsHeightSizable = node => {
  return node.extendsHeightSizable;
};
scenery.register('HeightSizable', HeightSizable);
export default HeightSizable;
export { isHeightSizable, extendsHeightSizable };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJUaW55UHJvcGVydHkiLCJtZW1vaXplIiwiRGVsYXllZE11dGF0ZSIsIlJFUVVJUkVTX0JPVU5EU19PUFRJT05fS0VZUyIsInNjZW5lcnkiLCJDSEFOR0VfUE9TSVRJT05fVEhSRVNIT0xEIiwiSEVJR0hUX1NJWkFCTEVfT1BUSU9OX0tFWVMiLCJIZWlnaHRTaXphYmxlIiwiVHlwZSIsIkhlaWdodFNpemFibGVUcmFpdCIsInByZWZlcnJlZEhlaWdodFByb3BlcnR5IiwibWluaW11bUhlaWdodFByb3BlcnR5IiwibG9jYWxQcmVmZXJyZWRIZWlnaHRQcm9wZXJ0eSIsImxvY2FsTWluaW11bUhlaWdodFByb3BlcnR5IiwiaXNIZWlnaHRSZXNpemFibGVQcm9wZXJ0eSIsIl9wcmVmZXJyZWRTaXplQ2hhbmdpbmciLCJfbWluaW11bVNpemVDaGFuZ2luZyIsIl9wcmVmZXJyZWRTaXplQ2hhbmdlQXR0ZW1wdER1cmluZ0xvY2siLCJfbWluaW11bVNpemVDaGFuZ2VBdHRlbXB0RHVyaW5nTG9jayIsImNvbnN0cnVjdG9yIiwiYXJncyIsIl91cGRhdGVQcmVmZXJyZWRIZWlnaHRMaXN0ZW5lciIsIl91cGRhdGVQcmVmZXJyZWRIZWlnaHQiLCJiaW5kIiwiX3VwZGF0ZUxvY2FsUHJlZmVycmVkSGVpZ2h0TGlzdGVuZXIiLCJfdXBkYXRlTG9jYWxQcmVmZXJyZWRIZWlnaHQiLCJfdXBkYXRlTWluaW11bUhlaWdodExpc3RlbmVyIiwiX3VwZGF0ZU1pbmltdW1IZWlnaHQiLCJfdXBkYXRlTG9jYWxNaW5pbXVtSGVpZ2h0TGlzdGVuZXIiLCJfdXBkYXRlTG9jYWxNaW5pbXVtSGVpZ2h0IiwibGF6eUxpbmsiLCJ0cmFuc2Zvcm1FbWl0dGVyIiwiYWRkTGlzdGVuZXIiLCJwcmVmZXJyZWRIZWlnaHQiLCJhc3NlcnQiLCJ2YWx1ZSIsImlzRmluaXRlIiwibG9jYWxQcmVmZXJyZWRIZWlnaHQiLCJtaW5pbXVtSGVpZ2h0IiwibG9jYWxNaW5pbXVtSGVpZ2h0IiwiaGVpZ2h0U2l6YWJsZSIsImV4dGVuZHNIZWlnaHRTaXphYmxlIiwidmFsaWRhdGVMb2NhbFByZWZlcnJlZEhlaWdodCIsImN1cnJlbnRIZWlnaHQiLCJsb2NhbEhlaWdodCIsImVmZmVjdGl2ZU1pbmltdW1IZWlnaHQiLCJpZGVhbEhlaWdodCIsIk1hdGgiLCJhYnMiLCJfY2FsY3VsYXRlTG9jYWxQcmVmZXJyZWRIZWlnaHQiLCJtYXRyaXgiLCJpc0FsaWduZWQiLCJ0cmFuc2Zvcm0iLCJpbnZlcnNlRGVsdGFZIiwiX29uUmVlbnRyYW50UHJlZmVycmVkSGVpZ2h0IiwiYXVkaXRNYXhEaW1lbnNpb25zIiwiX2NhbGN1bGF0ZVByZWZlcnJlZEhlaWdodCIsInRyYW5zZm9ybURlbHRhWSIsIl9jYWxjdWxhdGVMb2NhbE1pbmltdW1IZWlnaHQiLCJfb25SZWVudHJhbnRMb2NhbE1pbmltdW1IZWlnaHQiLCJfY2FsY3VsYXRlTWluaW11bUhlaWdodCIsIm11dGF0ZSIsIm9wdGlvbnMiLCJwcm90b3R5cGUiLCJfbXV0YXRvcktleXMiLCJleGlzdGluZ0tleXMiLCJuZXdLZXlzIiwiaW5kZXhPZkJvdW5kc0Jhc2VkT3B0aW9ucyIsImluZGV4T2YiLCJzbGljZSIsImlzSGVpZ2h0U2l6YWJsZSIsIm5vZGUiLCJyZWdpc3RlciJdLCJzb3VyY2VzIjpbIkhlaWdodFNpemFibGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCwgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXHJcblxyXG4vKipcclxuICogSGVpZ2h0U2l6YWJsZSBpcyBhIHRyYWl0IHRoYXQgcHJvdmlkZXMgYSBtaW5pbXVtIGFuZCBwcmVmZXJyZWQgaGVpZ2h0LiBUaGUgbWluaW11bSBoZWlnaHQgaXMgc2V0IGJ5IHRoZSBjb21wb25lbnQsXHJcbiAqIHNvIHRoYXQgbGF5b3V0IGNvbnRhaW5lcnMgY291bGQga25vdyBob3cgXCJzbWFsbFwiIHRoZSBjb21wb25lbnQgY2FuIGJlIG1hZGUuIFRoZSBwcmVmZXJyZWQgaGVpZ2h0IGlzIHNldCBieSB0aGVcclxuICogbGF5b3V0IGNvbnRhaW5lciwgYW5kIHRoZSBjb21wb25lbnQgc2hvdWxkIGFkanVzdCBpdHMgc2l6ZSBzbyB0aGF0IGl0IHRha2VzIHVwIHRoYXQgaGVpZ2h0LlxyXG4gKlxyXG4gKiBAYXV0aG9yIEpvbmF0aGFuIE9sc29uIDxqb25hdGhhbi5vbHNvbkBjb2xvcmFkby5lZHU+XHJcbiAqL1xyXG5cclxuaW1wb3J0IFRpbnlQcm9wZXJ0eSBmcm9tICcuLi8uLi8uLi9heG9uL2pzL1RpbnlQcm9wZXJ0eS5qcyc7XHJcbmltcG9ydCBtZW1vaXplIGZyb20gJy4uLy4uLy4uL3BoZXQtY29yZS9qcy9tZW1vaXplLmpzJztcclxuaW1wb3J0IHsgRGVsYXllZE11dGF0ZSwgTm9kZSwgUkVRVUlSRVNfQk9VTkRTX09QVElPTl9LRVlTLCBzY2VuZXJ5IH0gZnJvbSAnLi4vaW1wb3J0cy5qcyc7XHJcbmltcG9ydCBDb25zdHJ1Y3RvciBmcm9tICcuLi8uLi8uLi9waGV0LWNvcmUvanMvdHlwZXMvQ29uc3RydWN0b3IuanMnO1xyXG5pbXBvcnQgSW50ZW50aW9uYWxBbnkgZnJvbSAnLi4vLi4vLi4vcGhldC1jb3JlL2pzL3R5cGVzL0ludGVudGlvbmFsQW55LmpzJztcclxuXHJcbi8vIFBvc2l0aW9uIGNoYW5nZXMgc21hbGxlciB0aGFuIHRoaXMgd2lsbCBiZSBpZ25vcmVkXHJcbmNvbnN0IENIQU5HRV9QT1NJVElPTl9USFJFU0hPTEQgPSAxZS05O1xyXG5cclxuZXhwb3J0IGNvbnN0IEhFSUdIVF9TSVpBQkxFX09QVElPTl9LRVlTID0gW1xyXG4gICdwcmVmZXJyZWRIZWlnaHQnLFxyXG4gICdtaW5pbXVtSGVpZ2h0JyxcclxuICAnbG9jYWxQcmVmZXJyZWRIZWlnaHQnLFxyXG4gICdsb2NhbE1pbmltdW1IZWlnaHQnLFxyXG4gICdoZWlnaHRTaXphYmxlJ1xyXG5dO1xyXG5cclxuZXhwb3J0IHR5cGUgSGVpZ2h0U2l6YWJsZU9wdGlvbnMgPSB7XHJcbiAgLy8gU2V0cyB0aGUgcHJlZmVycmVkIGhlaWdodCBvZiB0aGUgTm9kZSBpbiB0aGUgcGFyZW50IGNvb3JkaW5hdGUgZnJhbWUuIE5vZGVzIHRoYXQgaW1wbGVtZW50IHRoaXMgd2lsbCBhdHRlbXB0IHRvIGtlZXBcclxuICAvLyB0aGVpciBgbm9kZS5oZWlnaHRgIGF0IHRoaXMgdmFsdWUuIElmIG51bGwsIHRoZSBub2RlIHdpbGwgbGlrZWx5IHNldCBpdHMgY29uZmlndXJhdGlvbiB0byB0aGUgbWluaW11bSBoZWlnaHQuXHJcbiAgLy8gTk9URTogY2hhbmdpbmcgdGhpcyBvciBsb2NhbFByZWZlcnJlZEhlaWdodCB3aWxsIGFkanVzdCB0aGUgb3RoZXIuXHJcbiAgLy8gTk9URTogcHJlZmVycmVkSGVpZ2h0IGlzIG5vdCBndWFyYW50ZWVkIGN1cnJlbnRseS4gVGhlIGNvbXBvbmVudCBtYXkgZW5kIHVwIGhhdmluZyBhIHNtYWxsZXIgb3IgbGFyZ2VyIHNpemVcclxuICBwcmVmZXJyZWRIZWlnaHQ/OiBudW1iZXIgfCBudWxsO1xyXG5cclxuICAvLyBTZXRzIHRoZSBtaW5pbXVtIGhlaWdodCBvZiB0aGUgTm9kZSBpbiB0aGUgcGFyZW50IGNvb3JkaW5hdGUgZnJhbWUuIFVzdWFsbHkgbm90IGRpcmVjdGx5IHNldCBieSBhIGNsaWVudC5cclxuICAvLyBVc3VhbGx5IGEgcmVzaXphYmxlIE5vZGUgd2lsbCBzZXQgaXRzIGxvY2FsTWluaW11bUhlaWdodCAoYW5kIHRoYXQgd2lsbCBnZXQgdHJhbnNmZXJyZWQgdG8gdGhpcyB2YWx1ZSBpbiB0aGVcclxuICAvLyBwYXJlbnQgY29vcmRpbmF0ZSBmcmFtZSkuXHJcbiAgLy8gTk9URTogY2hhbmdpbmcgdGhpcyBvciBsb2NhbE1pbmltdW1IZWlnaHQgd2lsbCBhZGp1c3QgdGhlIG90aGVyLlxyXG4gIC8vIE5PVEU6IHdoZW4gdGhlIE5vZGUncyB0cmFuc2Zvcm0gaXMgdXBkYXRlZCwgdGhpcyB2YWx1ZSBpcyByZWNvbXB1dGVkIGJhc2VkIG9uIGxvY2FsTWluaW11bUhlaWdodFxyXG4gIG1pbmltdW1IZWlnaHQ/OiBudW1iZXIgfCBudWxsO1xyXG5cclxuICAvLyBTZXRzIHRoZSBwcmVmZXJyZWQgaGVpZ2h0IG9mIHRoZSBOb2RlIGluIHRoZSBsb2NhbCBjb29yZGluYXRlIGZyYW1lLlxyXG4gIC8vIE5PVEU6IGNoYW5naW5nIHRoaXMgb3IgcHJlZmVycmVkSGVpZ2h0IHdpbGwgYWRqdXN0IHRoZSBvdGhlci5cclxuICAvLyBOT1RFOiB3aGVuIHRoZSBOb2RlJ3MgdHJhbnNmb3JtIGlzIHVwZGF0ZWQsIHRoaXMgdmFsdWUgaXMgcmVjb21wdXRlZCBiYXNlZCBvbiBwcmVmZXJyZWRIZWlnaHRcclxuICAvLyBOT1RFOiBsb2NhbFByZWZlcnJlZEhlaWdodCBpcyBub3QgZ3VhcmFudGVlZCBjdXJyZW50bHkuIFRoZSBjb21wb25lbnQgbWF5IGVuZCB1cCBoYXZpbmcgYSBzbWFsbGVyIG9yIGxhcmdlciBzaXplXHJcbiAgbG9jYWxQcmVmZXJyZWRIZWlnaHQ/OiBudW1iZXIgfCBudWxsO1xyXG5cclxuICAvLyBTZXRzIHRoZSBtaW5pbXVtIGhlaWdodCBvZiB0aGUgTm9kZSBpbiB0aGUgbG9jYWwgY29vcmRpbmF0ZSBmcmFtZS4gVXN1YWxseSBzZXQgYnkgdGhlIHJlc2l6YWJsZSBOb2RlIGl0c2VsZiB0b1xyXG4gIC8vIGluZGljYXRlIHdoYXQgcHJlZmVycmVkIHNpemVzIGFyZSBwb3NzaWJsZS5cclxuICAvLyBOT1RFOiBjaGFuZ2luZyB0aGlzIG9yIG1pbmltdW1IZWlnaHQgd2lsbCBhZGp1c3QgdGhlIG90aGVyLlxyXG4gIGxvY2FsTWluaW11bUhlaWdodD86IG51bWJlciB8IG51bGw7XHJcblxyXG4gIC8vIFdoZXRoZXIgdGhpcyBjb21wb25lbnQgd2lsbCBoYXZlIGl0cyBwcmVmZXJyZWQgc2l6ZSBzZXQgYnkgdGhpbmdzIGxpa2UgbGF5b3V0IGNvbnRhaW5lcnMuIElmIHRoaXMgaXMgc2V0IHRvIGZhbHNlLFxyXG4gIC8vIGl0J3MgcmVjb21tZW5kZWQgdG8gc2V0IHNvbWUgc29ydCBvZiBwcmVmZXJyZWQgc2l6ZSAoc28gdGhhdCBpdCB3b24ndCBnbyB0byAwKVxyXG4gIGhlaWdodFNpemFibGU/OiBib29sZWFuO1xyXG59O1xyXG5cclxuZXhwb3J0IHR5cGUgVEhlaWdodFNpemFibGUgPSB7XHJcblxyXG4gIHJlYWRvbmx5IHByZWZlcnJlZEhlaWdodFByb3BlcnR5OiBUaW55UHJvcGVydHk8bnVtYmVyIHwgbnVsbD47XHJcbiAgcmVhZG9ubHkgbWluaW11bUhlaWdodFByb3BlcnR5OiBUaW55UHJvcGVydHk8bnVtYmVyIHwgbnVsbD47XHJcbiAgcmVhZG9ubHkgbG9jYWxQcmVmZXJyZWRIZWlnaHRQcm9wZXJ0eTogVGlueVByb3BlcnR5PG51bWJlciB8IG51bGw+O1xyXG4gIHJlYWRvbmx5IGxvY2FsTWluaW11bUhlaWdodFByb3BlcnR5OiBUaW55UHJvcGVydHk8bnVtYmVyIHwgbnVsbD47XHJcbiAgcmVhZG9ubHkgaXNIZWlnaHRSZXNpemFibGVQcm9wZXJ0eTogVGlueVByb3BlcnR5PGJvb2xlYW4+O1xyXG4gIHByZWZlcnJlZEhlaWdodDogbnVtYmVyIHwgbnVsbDtcclxuICBsb2NhbFByZWZlcnJlZEhlaWdodDogbnVtYmVyIHwgbnVsbDtcclxuICBtaW5pbXVtSGVpZ2h0OiBudW1iZXIgfCBudWxsO1xyXG4gIGxvY2FsTWluaW11bUhlaWdodDogbnVtYmVyIHwgbnVsbDtcclxuICBoZWlnaHRTaXphYmxlOiBib29sZWFuO1xyXG4gIHZhbGlkYXRlTG9jYWxQcmVmZXJyZWRIZWlnaHQoKTogdm9pZDtcclxuXHJcbiAgLy8gQG1peGluLXByb3RlY3RlZCAtIG1hZGUgcHVibGljIGZvciB1c2UgaW4gdGhlIG1peGluIG9ubHlcclxuICBfcHJlZmVycmVkU2l6ZUNoYW5naW5nOiBib29sZWFuO1xyXG4gIF9taW5pbXVtU2l6ZUNoYW5naW5nOiBib29sZWFuO1xyXG4gIF9wcmVmZXJyZWRTaXplQ2hhbmdlQXR0ZW1wdER1cmluZ0xvY2s6IGJvb2xlYW47XHJcbiAgX21pbmltdW1TaXplQ2hhbmdlQXR0ZW1wdER1cmluZ0xvY2s6IGJvb2xlYW47XHJcbiAgX3VwZGF0ZVByZWZlcnJlZEhlaWdodExpc3RlbmVyOiAoKSA9PiB2b2lkO1xyXG4gIF91cGRhdGVMb2NhbFByZWZlcnJlZEhlaWdodExpc3RlbmVyOiAoKSA9PiB2b2lkO1xyXG4gIF91cGRhdGVNaW5pbXVtSGVpZ2h0TGlzdGVuZXI6ICgpID0+IHZvaWQ7XHJcbiAgX3VwZGF0ZUxvY2FsTWluaW11bUhlaWdodExpc3RlbmVyOiAoKSA9PiB2b2lkO1xyXG4gIF9jYWxjdWxhdGVMb2NhbFByZWZlcnJlZEhlaWdodCgpOiBudW1iZXIgfCBudWxsO1xyXG4gIF9vblJlZW50cmFudFByZWZlcnJlZEhlaWdodCgpOiB2b2lkO1xyXG4gIF9jYWxjdWxhdGVQcmVmZXJyZWRIZWlnaHQoKTogbnVtYmVyIHwgbnVsbDtcclxuICBfY2FsY3VsYXRlTG9jYWxNaW5pbXVtSGVpZ2h0KCk6IG51bWJlciB8IG51bGw7XHJcbiAgX29uUmVlbnRyYW50TG9jYWxNaW5pbXVtSGVpZ2h0KCk6IHZvaWQ7XHJcbiAgX2NhbGN1bGF0ZU1pbmltdW1IZWlnaHQoKTogbnVtYmVyIHwgbnVsbDtcclxufTtcclxuXHJcbi8vIElNUE9SVEFOVDogSWYgeW91J3JlIGNvbWJpbmluZyB0aGlzIGluLCB0eXBpY2FsbHkgZG9uJ3QgcGFzcyBvcHRpb25zIHRoYXQgSGVpZ2h0U2l6YWJsZSB3b3VsZCB0YWtlIHRocm91Z2ggdGhlXHJcbi8vIGNvbnN0cnVjdG9yLiBJdCB3aWxsIGhpdCBOb2RlJ3MgbXV0YXRlKCkgbGlrZWx5LCBhbmQgdGhlbiB3aWxsIGZhaWwgYmVjYXVzZSB3ZSBoYXZlbid0IGJlZW4gYWJsZSB0byBzZXQgdGhlXHJcbi8vIHZhbHVlcyB5ZXQuIElmIHlvdSdyZSBtYWtpbmcgc29tZXRoaW5nIEhlaWdodFNpemFibGUsIHBsZWFzZSB1c2UgYSBsYXRlciBtdXRhdGUoKSB0byBwYXNzIHRoZXNlIG9wdGlvbnMgdGhyb3VnaC5cclxuLy8gVGhleSBXSUxMIGJlIGNhdWdodCBieSBhc3NlcnRpb25zIGlmIHNvbWVvbmUgYWRkcyBvbmUgb2YgdGhvc2Ugb3B0aW9ucywgYnV0IGl0IGNvdWxkIGJlIGEgc2lsZW50IGJ1ZyBpZiBubyBvbmVcclxuLy8gaXMgeWV0IHBhc3NpbmcgdGhvc2Ugb3B0aW9ucyB0aHJvdWdoLlxyXG5jb25zdCBIZWlnaHRTaXphYmxlID0gbWVtb2l6ZSggPFN1cGVyVHlwZSBleHRlbmRzIENvbnN0cnVjdG9yPE5vZGU+PiggVHlwZTogU3VwZXJUeXBlICk6IFN1cGVyVHlwZSAmIENvbnN0cnVjdG9yPFRIZWlnaHRTaXphYmxlPiA9PiB7XHJcbiAgY29uc3QgSGVpZ2h0U2l6YWJsZVRyYWl0ID0gRGVsYXllZE11dGF0ZSggJ0hlaWdodFNpemFibGUnLCBIRUlHSFRfU0laQUJMRV9PUFRJT05fS0VZUyxcclxuICAgIGNsYXNzIEhlaWdodFNpemFibGVUcmFpdCBleHRlbmRzIFR5cGUgaW1wbGVtZW50cyBUSGVpZ2h0U2l6YWJsZSB7XHJcblxyXG4gICAgICAvLyBwYXJlbnQvbG9jYWwgcHJlZmVycmVkL21pbmltdW0gUHJvcGVydGllcy4gU2VlIHRoZSBvcHRpb25zIGFib3ZlIGZvciBtb3JlIGRvY3VtZW50YXRpb25cclxuICAgICAgcHVibGljIHJlYWRvbmx5IHByZWZlcnJlZEhlaWdodFByb3BlcnR5OiBUaW55UHJvcGVydHk8bnVtYmVyIHwgbnVsbD4gPSBuZXcgVGlueVByb3BlcnR5PG51bWJlciB8IG51bGw+KCBudWxsICk7XHJcbiAgICAgIHB1YmxpYyByZWFkb25seSBtaW5pbXVtSGVpZ2h0UHJvcGVydHk6IFRpbnlQcm9wZXJ0eTxudW1iZXIgfCBudWxsPiA9IG5ldyBUaW55UHJvcGVydHk8bnVtYmVyIHwgbnVsbD4oIG51bGwgKTtcclxuICAgICAgcHVibGljIHJlYWRvbmx5IGxvY2FsUHJlZmVycmVkSGVpZ2h0UHJvcGVydHk6IFRpbnlQcm9wZXJ0eTxudW1iZXIgfCBudWxsPiA9IG5ldyBUaW55UHJvcGVydHk8bnVtYmVyIHwgbnVsbD4oIG51bGwgKTtcclxuICAgICAgcHVibGljIHJlYWRvbmx5IGxvY2FsTWluaW11bUhlaWdodFByb3BlcnR5OiBUaW55UHJvcGVydHk8bnVtYmVyIHwgbnVsbD4gPSBuZXcgVGlueVByb3BlcnR5PG51bWJlciB8IG51bGw+KCBudWxsICk7XHJcbiAgICAgIHB1YmxpYyByZWFkb25seSBpc0hlaWdodFJlc2l6YWJsZVByb3BlcnR5OiBUaW55UHJvcGVydHk8Ym9vbGVhbj4gPSBuZXcgVGlueVByb3BlcnR5PGJvb2xlYW4+KCB0cnVlICk7XHJcblxyXG4gICAgICAvLyBGbGFncyBzbyB0aGF0IHdlIGNhbiBjaGFuZ2Ugb25lIChwYXJlbnQvbG9jYWwpIHZhbHVlIGFuZCBub3QgZW50ZXIgYW4gaW5maW5pdGUgbG9vcCBjaGFuZ2luZyB0aGUgb3RoZXJzLlxyXG4gICAgICAvLyBXZSB3YW50IHRvIGxvY2sgb3V0IGFsbCBvdGhlciBsb2NhbCBvciBub24tbG9jYWwgcHJlZmVycmVkIG1pbmltdW0gc2l6ZXMsIHdoZXRoZXIgaW4gSGVpZ2h0U2l6YWJsZSBvciBXaWR0aFNpemFibGVcclxuICAgICAgLy8gTk9URTogV2UgYXJlIG1lcmdpbmcgZGVjbGFyYXRpb25zIGJldHdlZW4gSGVpZ2h0U2l6YWJsZSBhbmQgV2lkdGhTaXphYmxlLiBJZiBTaXphYmxlIGlzIHVzZWQgdGhlc2UgZmxhZ3NcclxuICAgICAgLy8gd2lsbCBiZSBzaGFyZWQgYnkgYm90aCBIZWlnaHRTaXphYmxlIGFuZCBXaWR0aFNpemFibGUuXHJcbiAgICAgIC8vIEBtaXhpbi1wcm90ZWN0ZWQgLSBtYWRlIHB1YmxpYyBmb3IgdXNlIGluIHRoZSBtaXhpbiBvbmx5XHJcbiAgICAgIHB1YmxpYyBfcHJlZmVycmVkU2l6ZUNoYW5naW5nID0gZmFsc2U7XHJcbiAgICAgIC8vIEBtaXhpbi1wcm90ZWN0ZWQgLSBtYWRlIHB1YmxpYyBmb3IgdXNlIGluIHRoZSBtaXhpbiBvbmx5XHJcbiAgICAgIHB1YmxpYyBfbWluaW11bVNpemVDaGFuZ2luZyA9IGZhbHNlO1xyXG5cclxuICAgICAgLy8gV2UnbGwgbmVlZCB0byBkZXRlY3QgcmVlbnRyYW5jeSB3aGVuIHNldHRpbmcgdGhlIGR1YWwgb2YgdGhlIHByZWZlcnJlZC9taW5pbXVtIHByb3BlcnRpZXMgKGUuZy4gbG9jYWwgdnMgcGFyZW50KS5cclxuICAgICAgLy8gSWYgd2UgZ2V0IGEgcmVlbnRyYW50IGNhc2UsIHdlJ2xsIG5lZWQgdG8gZGV0ZWN0IGl0IGFuZCBjbGVhciB0aGluZ3MgdXAgYXQgdGhlIGVuZCAodXBkYXRpbmcgdGhlIG1pbmltdW0gc2l6ZVxyXG4gICAgICAvLyBpbiB0aGUgcGFyZW50IGNvb3JkaW5hdGUgZnJhbWUsIGFuZCB0aGUgcHJlZmVycmVkIHNpemUgaW4gdGhlIGxvY2FsIGNvb3JkaW5hdGUgZnJhbWUpLlxyXG4gICAgICAvLyBBbiBleGFtcGxlIGlzIGlmIHRoZSBtaW5pbXVtIHNpemUgaXMgc2V0LCBhbmQgdGhhdCB0cmlnZ2VycyBhIGxpc3RlbmVyIHRoYXQgVVBEQVRFUyBzb21ldGhpbmcgdGhhdCBjaGFuZ2VzIHRoZVxyXG4gICAgICAvLyBtaW5pbXVtIHNpemUsIHdlJ2xsIG5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIGxvY2FsIG1pbmltdW0gc2l6ZSBpcyB1cGRhdGVkIEFGVEVSIGV2ZXJ5dGhpbmcgaGFzIGhhcHBlbmVkLlxyXG4gICAgICAvLyBUaGVzZSBsb2NrcyBhcmUgdXNlZCB0byBkZXRlY3QgdGhlc2UgY2FzZXMsIGFuZCB0aGVuIHJ1biB0aGUgYXBwcm9wcmlhdGUgdXBkYXRlcyBhZnRlcndhcmQgdG8gbWFrZSBzdXJlIHRoYXQgdGhlXHJcbiAgICAgIC8vIGxvY2FsIGFuZCBwYXJlbnQgdmFsdWVzIGFyZSBpbiBzeW5jIChiYXNlZCBvbiB0aGUgdHJhbnNmb3JtIHVzZWQpLlxyXG4gICAgICAvLyBAbWl4aW4tcHJvdGVjdGVkIC0gbWFkZSBwdWJsaWMgZm9yIHVzZSBpbiB0aGUgbWl4aW4gb25seVxyXG4gICAgICBwdWJsaWMgX3ByZWZlcnJlZFNpemVDaGFuZ2VBdHRlbXB0RHVyaW5nTG9jayA9IGZhbHNlO1xyXG4gICAgICAvLyBAbWl4aW4tcHJvdGVjdGVkIC0gbWFkZSBwdWJsaWMgZm9yIHVzZSBpbiB0aGUgbWl4aW4gb25seVxyXG4gICAgICBwdWJsaWMgX21pbmltdW1TaXplQ2hhbmdlQXR0ZW1wdER1cmluZ0xvY2sgPSBmYWxzZTtcclxuXHJcbiAgICAgIC8vIEV4cG9zZSBsaXN0ZW5lcnMsIHNvIHRoYXQgd2UnbGwgYmUgYWJsZSB0byBob29rIHRoZW0gdXAgdG8gdGhlIG9wcG9zaXRlIGRpbWVuc2lvbiBpbiBTaXphYmxlXHJcbiAgICAgIC8vIEBtaXhpbi1wcm90ZWN0ZWQgLSBtYWRlIHB1YmxpYyBmb3IgdXNlIGluIHRoZSBtaXhpbiBvbmx5XHJcbiAgICAgIHB1YmxpYyBfdXBkYXRlUHJlZmVycmVkSGVpZ2h0TGlzdGVuZXI6ICgpID0+IHZvaWQ7XHJcbiAgICAgIC8vIEBtaXhpbi1wcm90ZWN0ZWQgLSBtYWRlIHB1YmxpYyBmb3IgdXNlIGluIHRoZSBtaXhpbiBvbmx5XHJcbiAgICAgIHB1YmxpYyBfdXBkYXRlTG9jYWxQcmVmZXJyZWRIZWlnaHRMaXN0ZW5lcjogKCkgPT4gdm9pZDtcclxuICAgICAgLy8gQG1peGluLXByb3RlY3RlZCAtIG1hZGUgcHVibGljIGZvciB1c2UgaW4gdGhlIG1peGluIG9ubHlcclxuICAgICAgcHVibGljIF91cGRhdGVNaW5pbXVtSGVpZ2h0TGlzdGVuZXI6ICgpID0+IHZvaWQ7XHJcbiAgICAgIC8vIEBtaXhpbi1wcm90ZWN0ZWQgLSBtYWRlIHB1YmxpYyBmb3IgdXNlIGluIHRoZSBtaXhpbiBvbmx5XHJcbiAgICAgIHB1YmxpYyBfdXBkYXRlTG9jYWxNaW5pbXVtSGVpZ2h0TGlzdGVuZXI6ICgpID0+IHZvaWQ7XHJcblxyXG4gICAgICAvLyBJTVBPUlRBTlQ6IElmIHlvdSdyZSBjb21iaW5pbmcgdGhpcyBpbiwgdHlwaWNhbGx5IGRvbid0IHBhc3Mgb3B0aW9ucyB0aGF0IEhlaWdodFNpemFibGUgd291bGQgdGFrZSB0aHJvdWdoIHRoZVxyXG4gICAgICAvLyBjb25zdHJ1Y3Rvci4gSXQgd2lsbCBoaXQgTm9kZSdzIG11dGF0ZSgpIGxpa2VseSwgYW5kIHRoZW4gd2lsbCBmYWlsIGJlY2F1c2Ugd2UgaGF2ZW4ndCBiZWVuIGFibGUgdG8gc2V0IHRoZVxyXG4gICAgICAvLyB2YWx1ZXMgeWV0LiBJZiB5b3UncmUgbWFraW5nIHNvbWV0aGluZyBIZWlnaHRTaXphYmxlLCBwbGVhc2UgdXNlIGEgbGF0ZXIgbXV0YXRlKCkgdG8gcGFzcyB0aGVzZSBvcHRpb25zIHRocm91Z2guXHJcbiAgICAgIC8vIFRoZXkgV0lMTCBiZSBjYXVnaHQgYnkgYXNzZXJ0aW9ucyBpZiBzb21lb25lIGFkZHMgb25lIG9mIHRob3NlIG9wdGlvbnMsIGJ1dCBpdCBjb3VsZCBiZSBhIHNpbGVudCBidWcgaWYgbm8gb25lXHJcbiAgICAgIC8vIGlzIHlldCBwYXNzaW5nIHRob3NlIG9wdGlvbnMgdGhyb3VnaC5cclxuICAgICAgcHVibGljIGNvbnN0cnVjdG9yKCAuLi5hcmdzOiBJbnRlbnRpb25hbEFueVtdICkge1xyXG4gICAgICAgIHN1cGVyKCAuLi5hcmdzICk7XHJcblxyXG4gICAgICAgIHRoaXMuX3VwZGF0ZVByZWZlcnJlZEhlaWdodExpc3RlbmVyID0gdGhpcy5fdXBkYXRlUHJlZmVycmVkSGVpZ2h0LmJpbmQoIHRoaXMgKTtcclxuICAgICAgICB0aGlzLl91cGRhdGVMb2NhbFByZWZlcnJlZEhlaWdodExpc3RlbmVyID0gdGhpcy5fdXBkYXRlTG9jYWxQcmVmZXJyZWRIZWlnaHQuYmluZCggdGhpcyApO1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZU1pbmltdW1IZWlnaHRMaXN0ZW5lciA9IHRoaXMuX3VwZGF0ZU1pbmltdW1IZWlnaHQuYmluZCggdGhpcyApO1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZUxvY2FsTWluaW11bUhlaWdodExpc3RlbmVyID0gdGhpcy5fdXBkYXRlTG9jYWxNaW5pbXVtSGVpZ2h0LmJpbmQoIHRoaXMgKTtcclxuXHJcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBvcHBvc2l0ZSBvZiBwYXJlbnQvbG9jYWwgd2hlbiBvbmUgY2hhbmdlc1xyXG4gICAgICAgIHRoaXMucHJlZmVycmVkSGVpZ2h0UHJvcGVydHkubGF6eUxpbmsoIHRoaXMuX3VwZGF0ZUxvY2FsUHJlZmVycmVkSGVpZ2h0TGlzdGVuZXIgKTtcclxuICAgICAgICB0aGlzLmxvY2FsUHJlZmVycmVkSGVpZ2h0UHJvcGVydHkubGF6eUxpbmsoIHRoaXMuX3VwZGF0ZVByZWZlcnJlZEhlaWdodExpc3RlbmVyICk7XHJcbiAgICAgICAgdGhpcy5taW5pbXVtSGVpZ2h0UHJvcGVydHkubGF6eUxpbmsoIHRoaXMuX3VwZGF0ZUxvY2FsTWluaW11bUhlaWdodExpc3RlbmVyICk7XHJcbiAgICAgICAgdGhpcy5sb2NhbE1pbmltdW1IZWlnaHRQcm9wZXJ0eS5sYXp5TGluayggdGhpcy5fdXBkYXRlTWluaW11bUhlaWdodExpc3RlbmVyICk7XHJcblxyXG4gICAgICAgIC8vIE9uIGEgdHJhbnNmb3JtIGNoYW5nZSwga2VlcCBvdXIgbG9jYWwgbWluaW11bSAocHJlc3VtYWJseSB1bmNoYW5nZWQpLCBhbmQgb3VyIHBhcmVudCBwcmVmZXJyZWQgc2l6ZVxyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtRW1pdHRlci5hZGRMaXN0ZW5lciggdGhpcy5fdXBkYXRlTG9jYWxQcmVmZXJyZWRIZWlnaHRMaXN0ZW5lciApO1xyXG4gICAgICAgIC8vIE9uIGEgdHJhbnNmb3JtIGNoYW5nZSB0aGlzIHNob3VsZCB1cGRhdGUgdGhlIG1pbmltdW1cclxuICAgICAgICB0aGlzLnRyYW5zZm9ybUVtaXR0ZXIuYWRkTGlzdGVuZXIoIHRoaXMuX3VwZGF0ZU1pbmltdW1IZWlnaHRMaXN0ZW5lciApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBwdWJsaWMgZ2V0IHByZWZlcnJlZEhlaWdodCgpOiBudW1iZXIgfCBudWxsIHtcclxuICAgICAgICBhc3NlcnQgJiYgYXNzZXJ0KCB0aGlzLnByZWZlcnJlZEhlaWdodFByb3BlcnR5LFxyXG4gICAgICAgICAgJ0hlaWdodFNpemFibGUgb3B0aW9ucyBzaG91bGQgYmUgc2V0IGZyb20gYSBsYXRlciBtdXRhdGUoKSBjYWxsIGluc3RlYWQgb2YgdGhlIHN1cGVyIGNvbnN0cnVjdG9yJyApO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnByZWZlcnJlZEhlaWdodFByb3BlcnR5LnZhbHVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBwdWJsaWMgc2V0IHByZWZlcnJlZEhlaWdodCggdmFsdWU6IG51bWJlciB8IG51bGwgKSB7XHJcbiAgICAgICAgYXNzZXJ0ICYmIGFzc2VydCggdGhpcy5wcmVmZXJyZWRIZWlnaHRQcm9wZXJ0eSxcclxuICAgICAgICAgICdIZWlnaHRTaXphYmxlIG9wdGlvbnMgc2hvdWxkIGJlIHNldCBmcm9tIGEgbGF0ZXIgbXV0YXRlKCkgY2FsbCBpbnN0ZWFkIG9mIHRoZSBzdXBlciBjb25zdHJ1Y3RvcicgKTtcclxuICAgICAgICBhc3NlcnQgJiYgYXNzZXJ0KCB2YWx1ZSA9PT0gbnVsbCB8fCAoIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUoIHZhbHVlICkgJiYgdmFsdWUgPj0gMCApLFxyXG4gICAgICAgICAgJ3ByZWZlcnJlZEhlaWdodCBzaG91bGQgYmUgbnVsbCBvciBhIG5vbi1uZWdhdGl2ZSBmaW5pdGUgbnVtYmVyJyApO1xyXG5cclxuICAgICAgICB0aGlzLnByZWZlcnJlZEhlaWdodFByb3BlcnR5LnZhbHVlID0gdmFsdWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHB1YmxpYyBnZXQgbG9jYWxQcmVmZXJyZWRIZWlnaHQoKTogbnVtYmVyIHwgbnVsbCB7XHJcbiAgICAgICAgYXNzZXJ0ICYmIGFzc2VydCggdGhpcy5sb2NhbFByZWZlcnJlZEhlaWdodFByb3BlcnR5LFxyXG4gICAgICAgICAgJ0hlaWdodFNpemFibGUgb3B0aW9ucyBzaG91bGQgYmUgc2V0IGZyb20gYSBsYXRlciBtdXRhdGUoKSBjYWxsIGluc3RlYWQgb2YgdGhlIHN1cGVyIGNvbnN0cnVjdG9yJyApO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsUHJlZmVycmVkSGVpZ2h0UHJvcGVydHkudmFsdWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHB1YmxpYyBzZXQgbG9jYWxQcmVmZXJyZWRIZWlnaHQoIHZhbHVlOiBudW1iZXIgfCBudWxsICkge1xyXG4gICAgICAgIGFzc2VydCAmJiBhc3NlcnQoIHRoaXMubG9jYWxQcmVmZXJyZWRIZWlnaHRQcm9wZXJ0eSxcclxuICAgICAgICAgICdIZWlnaHRTaXphYmxlIG9wdGlvbnMgc2hvdWxkIGJlIHNldCBmcm9tIGEgbGF0ZXIgbXV0YXRlKCkgY2FsbCBpbnN0ZWFkIG9mIHRoZSBzdXBlciBjb25zdHJ1Y3RvcicgKTtcclxuICAgICAgICBhc3NlcnQgJiYgYXNzZXJ0KCB2YWx1ZSA9PT0gbnVsbCB8fCAoIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUoIHZhbHVlICkgJiYgdmFsdWUgPj0gMCApLFxyXG4gICAgICAgICAgJ2xvY2FsUHJlZmVycmVkSGVpZ2h0IHNob3VsZCBiZSBudWxsIG9yIGEgbm9uLW5lZ2F0aXZlIGZpbml0ZSBudW1iZXInICk7XHJcblxyXG4gICAgICAgIHRoaXMubG9jYWxQcmVmZXJyZWRIZWlnaHRQcm9wZXJ0eS52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBwdWJsaWMgZ2V0IG1pbmltdW1IZWlnaHQoKTogbnVtYmVyIHwgbnVsbCB7XHJcbiAgICAgICAgYXNzZXJ0ICYmIGFzc2VydCggdGhpcy5taW5pbXVtSGVpZ2h0UHJvcGVydHksXHJcbiAgICAgICAgICAnSGVpZ2h0U2l6YWJsZSBvcHRpb25zIHNob3VsZCBiZSBzZXQgZnJvbSBhIGxhdGVyIG11dGF0ZSgpIGNhbGwgaW5zdGVhZCBvZiB0aGUgc3VwZXIgY29uc3RydWN0b3InICk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWluaW11bUhlaWdodFByb3BlcnR5LnZhbHVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBwdWJsaWMgc2V0IG1pbmltdW1IZWlnaHQoIHZhbHVlOiBudW1iZXIgfCBudWxsICkge1xyXG4gICAgICAgIGFzc2VydCAmJiBhc3NlcnQoIHRoaXMubWluaW11bUhlaWdodFByb3BlcnR5LFxyXG4gICAgICAgICAgJ0hlaWdodFNpemFibGUgb3B0aW9ucyBzaG91bGQgYmUgc2V0IGZyb20gYSBsYXRlciBtdXRhdGUoKSBjYWxsIGluc3RlYWQgb2YgdGhlIHN1cGVyIGNvbnN0cnVjdG9yJyApO1xyXG4gICAgICAgIGFzc2VydCAmJiBhc3NlcnQoIHZhbHVlID09PSBudWxsIHx8ICggdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZSggdmFsdWUgKSApICk7XHJcblxyXG4gICAgICAgIHRoaXMubWluaW11bUhlaWdodFByb3BlcnR5LnZhbHVlID0gdmFsdWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHB1YmxpYyBnZXQgbG9jYWxNaW5pbXVtSGVpZ2h0KCk6IG51bWJlciB8IG51bGwge1xyXG4gICAgICAgIGFzc2VydCAmJiBhc3NlcnQoIHRoaXMubG9jYWxNaW5pbXVtSGVpZ2h0UHJvcGVydHksXHJcbiAgICAgICAgICAnSGVpZ2h0U2l6YWJsZSBvcHRpb25zIHNob3VsZCBiZSBzZXQgZnJvbSBhIGxhdGVyIG11dGF0ZSgpIGNhbGwgaW5zdGVhZCBvZiB0aGUgc3VwZXIgY29uc3RydWN0b3InICk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxNaW5pbXVtSGVpZ2h0UHJvcGVydHkudmFsdWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHB1YmxpYyBzZXQgbG9jYWxNaW5pbXVtSGVpZ2h0KCB2YWx1ZTogbnVtYmVyIHwgbnVsbCApIHtcclxuICAgICAgICBhc3NlcnQgJiYgYXNzZXJ0KCB0aGlzLmxvY2FsTWluaW11bUhlaWdodFByb3BlcnR5LFxyXG4gICAgICAgICAgJ0hlaWdodFNpemFibGUgb3B0aW9ucyBzaG91bGQgYmUgc2V0IGZyb20gYSBsYXRlciBtdXRhdGUoKSBjYWxsIGluc3RlYWQgb2YgdGhlIHN1cGVyIGNvbnN0cnVjdG9yJyApO1xyXG4gICAgICAgIGFzc2VydCAmJiBhc3NlcnQoIHZhbHVlID09PSBudWxsIHx8ICggdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZSggdmFsdWUgKSApICk7XHJcblxyXG4gICAgICAgIHRoaXMubG9jYWxNaW5pbXVtSGVpZ2h0UHJvcGVydHkudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcHVibGljIG92ZXJyaWRlIGdldCBoZWlnaHRTaXphYmxlKCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIGFzc2VydCAmJiBhc3NlcnQoIHRoaXMuaXNIZWlnaHRSZXNpemFibGVQcm9wZXJ0eSxcclxuICAgICAgICAgICdIZWlnaHRTaXphYmxlIG9wdGlvbnMgc2hvdWxkIGJlIHNldCBmcm9tIGEgbGF0ZXIgbXV0YXRlKCkgY2FsbCBpbnN0ZWFkIG9mIHRoZSBzdXBlciBjb25zdHJ1Y3RvcicgKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5pc0hlaWdodFJlc2l6YWJsZVByb3BlcnR5LnZhbHVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBwdWJsaWMgb3ZlcnJpZGUgc2V0IGhlaWdodFNpemFibGUoIHZhbHVlOiBib29sZWFuICkge1xyXG4gICAgICAgIGFzc2VydCAmJiBhc3NlcnQoIHRoaXMuaXNIZWlnaHRSZXNpemFibGVQcm9wZXJ0eSxcclxuICAgICAgICAgICdIZWlnaHRTaXphYmxlIG9wdGlvbnMgc2hvdWxkIGJlIHNldCBmcm9tIGEgbGF0ZXIgbXV0YXRlKCkgY2FsbCBpbnN0ZWFkIG9mIHRoZSBzdXBlciBjb25zdHJ1Y3RvcicgKTtcclxuICAgICAgICB0aGlzLmlzSGVpZ2h0UmVzaXphYmxlUHJvcGVydHkudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcHVibGljIG92ZXJyaWRlIGdldCBleHRlbmRzSGVpZ2h0U2l6YWJsZSgpOiBib29sZWFuIHsgcmV0dXJuIHRydWU7IH1cclxuXHJcbiAgICAgIHB1YmxpYyB2YWxpZGF0ZUxvY2FsUHJlZmVycmVkSGVpZ2h0KCk6IHZvaWQge1xyXG4gICAgICAgIGlmICggYXNzZXJ0ICkge1xyXG4gICAgICAgICAgY29uc3QgY3VycmVudEhlaWdodCA9IHRoaXMubG9jYWxIZWlnaHQ7XHJcbiAgICAgICAgICBjb25zdCBlZmZlY3RpdmVNaW5pbXVtSGVpZ2h0ID0gdGhpcy5sb2NhbE1pbmltdW1IZWlnaHQgPT09IG51bGwgPyBjdXJyZW50SGVpZ2h0IDogdGhpcy5sb2NhbE1pbmltdW1IZWlnaHQ7XHJcbiAgICAgICAgICBjb25zdCBpZGVhbEhlaWdodCA9IHRoaXMubG9jYWxQcmVmZXJyZWRIZWlnaHQgPT09IG51bGwgPyBlZmZlY3RpdmVNaW5pbXVtSGVpZ2h0IDogdGhpcy5sb2NhbFByZWZlcnJlZEhlaWdodDtcclxuXHJcbiAgICAgICAgICAvLyBIYW5kbGUgbm9uLWZpbml0ZSB2YWx1ZXMgd2l0aCBleGFjdCBlcXVhbGl0eVxyXG4gICAgICAgICAgYXNzZXJ0KCBpZGVhbEhlaWdodCA9PT0gY3VycmVudEhlaWdodCB8fCBNYXRoLmFicyggaWRlYWxIZWlnaHQgLSBjdXJyZW50SGVpZ2h0ICkgPCAxZS03ICk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBUaGlzIGlzIHByb3ZpZGVkIHRvIGhvb2sgaW50byB0aGUgU2l6YWJsZSB0cmFpdCwgc28gdGhhdCB3ZSBjYW4gdXBkYXRlIHRoZSBvcHBvc2l0ZSBkaW1lbnNpb25cclxuICAgICAgLy8gQG1peGluLXByb3RlY3RlZCAtIG1hZGUgcHVibGljIGZvciB1c2UgaW4gdGhlIG1peGluIG9ubHlcclxuICAgICAgcHVibGljIF9jYWxjdWxhdGVMb2NhbFByZWZlcnJlZEhlaWdodCgpOiBudW1iZXIgfCBudWxsIHtcclxuXHJcbiAgICAgICAgcmV0dXJuICggdGhpcy5tYXRyaXguaXNBbGlnbmVkKCkgJiYgdGhpcy5wcmVmZXJyZWRIZWlnaHQgIT09IG51bGwgKVxyXG4gICAgICAgICAgICAgICA/IE1hdGguYWJzKCB0aGlzLnRyYW5zZm9ybS5pbnZlcnNlRGVsdGFZKCB0aGlzLnByZWZlcnJlZEhlaWdodCApIClcclxuICAgICAgICAgICAgICAgOiBudWxsO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBQcm92aWRlcyBhIGhvb2sgdG8gU2l6YWJsZSwgc2luY2Ugd2UnbGwgbmVlZCB0byBjcm9zcy1saW5rIHRoaXMgdG8gYWxzbyB0cnkgdXBkYXRpbmcgdGhlIG9wcG9zaXRlIGRpbWVuc2lvblxyXG4gICAgICAvLyBAbWl4aW4tcHJvdGVjdGVkIC0gbWFkZSBwdWJsaWMgZm9yIHVzZSBpbiB0aGUgbWl4aW4gb25seVxyXG4gICAgICBwdWJsaWMgX29uUmVlbnRyYW50UHJlZmVycmVkSGVpZ2h0KCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZUxvY2FsUHJlZmVycmVkSGVpZ2h0TGlzdGVuZXIoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcHJpdmF0ZSBfdXBkYXRlTG9jYWxQcmVmZXJyZWRIZWlnaHQoKTogdm9pZCB7XHJcbiAgICAgICAgYXNzZXJ0ICYmIHRoaXMuYXVkaXRNYXhEaW1lbnNpb25zKCk7XHJcblxyXG4gICAgICAgIGlmICggIXRoaXMuX3ByZWZlcnJlZFNpemVDaGFuZ2luZyApIHtcclxuICAgICAgICAgIHRoaXMuX3ByZWZlcnJlZFNpemVDaGFuZ2luZyA9IHRydWU7XHJcblxyXG4gICAgICAgICAgLy8gU2luY2UgdGhlIGxvY2FsIFwicHJlZmVycmVkXCIgc2l6ZSBpcyB0aGUgb25lIHRoYXQgd2UnbGwgd2FudCB0byBjb250aW51ZSB0byB1cGRhdGUgaWYgd2UgZXhwZXJpZW5jZVxyXG4gICAgICAgICAgLy8gcmVlbnRyYW5jeSAoc2luY2Ugd2UgdHJlYXQgdGhlIG5vbi1sb2NhbCB2ZXJzaW9uIGFzIHRoZSBncm91bmQgdHJ1dGgpLCB3ZSdsbCBsb29wIGhlcmUgdW50aWwgd2UgZGlkbid0IGdldFxyXG4gICAgICAgICAgLy8gYW4gYXR0ZW1wdCB0byBjaGFuZ2UgaXQuIFRoaXMgd2lsbCBlbnN1cmUgdGhhdCBhZnRlciBjaGFuZ2VzLCB3ZSdsbCBoYXZlIGEgY29uc2lzdGVudCBwcmVmZXJyZWQgYW5kXHJcbiAgICAgICAgICAvLyBsb2NhbFByZWZlcnJlZCBzaXplLlxyXG4gICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICB0aGlzLl9wcmVmZXJyZWRTaXplQ2hhbmdlQXR0ZW1wdER1cmluZ0xvY2sgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsUHJlZmVycmVkSGVpZ2h0ID0gdGhpcy5fY2FsY3VsYXRlTG9jYWxQcmVmZXJyZWRIZWlnaHQoKTtcclxuXHJcbiAgICAgICAgICAgIGlmICggdGhpcy5sb2NhbFByZWZlcnJlZEhlaWdodFByb3BlcnR5LnZhbHVlID09PSBudWxsIHx8XHJcbiAgICAgICAgICAgICAgICAgbG9jYWxQcmVmZXJyZWRIZWlnaHQgPT09IG51bGwgfHxcclxuICAgICAgICAgICAgICAgICBNYXRoLmFicyggdGhpcy5sb2NhbFByZWZlcnJlZEhlaWdodFByb3BlcnR5LnZhbHVlIC0gbG9jYWxQcmVmZXJyZWRIZWlnaHQgKSA+IENIQU5HRV9QT1NJVElPTl9USFJFU0hPTEQgKSB7XHJcbiAgICAgICAgICAgICAgdGhpcy5sb2NhbFByZWZlcnJlZEhlaWdodFByb3BlcnR5LnZhbHVlID0gbG9jYWxQcmVmZXJyZWRIZWlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHdoaWxlICggdGhpcy5fcHJlZmVycmVkU2l6ZUNoYW5nZUF0dGVtcHREdXJpbmdMb2NrICk7XHJcblxyXG4gICAgICAgICAgdGhpcy5fcHJlZmVycmVkU2l6ZUNoYW5naW5nID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgdGhpcy5fcHJlZmVycmVkU2l6ZUNoYW5nZUF0dGVtcHREdXJpbmdMb2NrID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFRoaXMgaXMgcHJvdmlkZWQgdG8gaG9vayBpbnRvIHRoZSBTaXphYmxlIHRyYWl0LCBzbyB0aGF0IHdlIGNhbiB1cGRhdGUgdGhlIG9wcG9zaXRlIGRpbWVuc2lvblxyXG4gICAgICAvLyBAbWl4aW4tcHJvdGVjdGVkIC0gbWFkZSBwdWJsaWMgZm9yIHVzZSBpbiB0aGUgbWl4aW4gb25seVxyXG4gICAgICBwdWJsaWMgX2NhbGN1bGF0ZVByZWZlcnJlZEhlaWdodCgpOiBudW1iZXIgfCBudWxsIHtcclxuXHJcbiAgICAgICAgcmV0dXJuICggdGhpcy5tYXRyaXguaXNBbGlnbmVkKCkgJiYgdGhpcy5sb2NhbFByZWZlcnJlZEhlaWdodCAhPT0gbnVsbCApXHJcbiAgICAgICAgICAgICAgID8gTWF0aC5hYnMoIHRoaXMudHJhbnNmb3JtLnRyYW5zZm9ybURlbHRhWSggdGhpcy5sb2NhbFByZWZlcnJlZEhlaWdodCApIClcclxuICAgICAgICAgICAgICAgOiBudWxsO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBwcml2YXRlIF91cGRhdGVQcmVmZXJyZWRIZWlnaHQoKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKCAhdGhpcy5fcHJlZmVycmVkU2l6ZUNoYW5naW5nICkge1xyXG4gICAgICAgICAgdGhpcy5fcHJlZmVycmVkU2l6ZUNoYW5naW5nID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICB0aGlzLl9wcmVmZXJyZWRTaXplQ2hhbmdlQXR0ZW1wdER1cmluZ0xvY2sgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICBjb25zdCBwcmVmZXJyZWRIZWlnaHQgPSB0aGlzLl9jYWxjdWxhdGVQcmVmZXJyZWRIZWlnaHQoKTtcclxuXHJcbiAgICAgICAgICBpZiAoIHRoaXMucHJlZmVycmVkSGVpZ2h0UHJvcGVydHkudmFsdWUgPT09IG51bGwgfHxcclxuICAgICAgICAgICAgICAgcHJlZmVycmVkSGVpZ2h0ID09PSBudWxsIHx8XHJcbiAgICAgICAgICAgICAgIE1hdGguYWJzKCB0aGlzLnByZWZlcnJlZEhlaWdodFByb3BlcnR5LnZhbHVlIC0gcHJlZmVycmVkSGVpZ2h0ICkgPiBDSEFOR0VfUE9TSVRJT05fVEhSRVNIT0xEICkge1xyXG4gICAgICAgICAgICB0aGlzLnByZWZlcnJlZEhlaWdodFByb3BlcnR5LnZhbHVlID0gcHJlZmVycmVkSGVpZ2h0O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgdGhpcy5fcHJlZmVycmVkU2l6ZUNoYW5naW5nID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgLy8gSGVyZSwgaW4gdGhlIGNhc2Ugb2YgcmVlbnRyYW5jZSwgd2UnbGwgYWN0dWFsbHkgd2FudCB0byBzd2l0Y2ggdG8gdXBkYXRpbmcgdGhlIGxvY2FsIHByZWZlcnJlZCBzaXplLCBzaW5jZVxyXG4gICAgICAgICAgLy8gZ2l2ZW4gYW55IG90aGVyIGNoYW5nZXMgaXQgc2hvdWxkIGJlIHRoZSBwcmltYXJ5IG9uZSB0byBjaGFuZ2UuXHJcbiAgICAgICAgICBpZiAoIHRoaXMuX3ByZWZlcnJlZFNpemVDaGFuZ2VBdHRlbXB0RHVyaW5nTG9jayApIHtcclxuICAgICAgICAgICAgdGhpcy5fb25SZWVudHJhbnRQcmVmZXJyZWRIZWlnaHQoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICB0aGlzLl9wcmVmZXJyZWRTaXplQ2hhbmdlQXR0ZW1wdER1cmluZ0xvY2sgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gVGhpcyBpcyBwcm92aWRlZCB0byBob29rIGludG8gdGhlIFNpemFibGUgdHJhaXQsIHNvIHRoYXQgd2UgY2FuIHVwZGF0ZSB0aGUgb3Bwb3NpdGUgZGltZW5zaW9uXHJcbiAgICAgIC8vIEBtaXhpbi1wcm90ZWN0ZWQgLSBtYWRlIHB1YmxpYyBmb3IgdXNlIGluIHRoZSBtaXhpbiBvbmx5XHJcbiAgICAgIHB1YmxpYyBfY2FsY3VsYXRlTG9jYWxNaW5pbXVtSGVpZ2h0KCk6IG51bWJlciB8IG51bGwge1xyXG4gICAgICAgIHJldHVybiAoIHRoaXMubWF0cml4LmlzQWxpZ25lZCgpICYmIHRoaXMubWluaW11bUhlaWdodCAhPT0gbnVsbCApXHJcbiAgICAgICAgICAgICAgID8gTWF0aC5hYnMoIHRoaXMudHJhbnNmb3JtLmludmVyc2VEZWx0YVkoIHRoaXMubWluaW11bUhlaWdodCApIClcclxuICAgICAgICAgICAgICAgOiBudWxsO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBAbWl4aW4tcHJvdGVjdGVkIC0gbWFkZSBwdWJsaWMgZm9yIHVzZSBpbiB0aGUgbWl4aW4gb25seVxyXG4gICAgICBwdWJsaWMgX29uUmVlbnRyYW50TG9jYWxNaW5pbXVtSGVpZ2h0KCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZU1pbmltdW1IZWlnaHQoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcHJpdmF0ZSBfdXBkYXRlTG9jYWxNaW5pbXVtSGVpZ2h0KCk6IHZvaWQge1xyXG4gICAgICAgIGlmICggIXRoaXMuX21pbmltdW1TaXplQ2hhbmdpbmcgKSB7XHJcbiAgICAgICAgICB0aGlzLl9taW5pbXVtU2l6ZUNoYW5naW5nID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICB0aGlzLl9taW5pbXVtU2l6ZUNoYW5nZUF0dGVtcHREdXJpbmdMb2NrID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgY29uc3QgbG9jYWxNaW5pbXVtSGVpZ2h0ID0gdGhpcy5fY2FsY3VsYXRlTG9jYWxNaW5pbXVtSGVpZ2h0KCk7XHJcblxyXG4gICAgICAgICAgaWYgKCB0aGlzLmxvY2FsTWluaW11bUhlaWdodFByb3BlcnR5LnZhbHVlID09PSBudWxsIHx8XHJcbiAgICAgICAgICAgICAgIGxvY2FsTWluaW11bUhlaWdodCA9PT0gbnVsbCB8fFxyXG4gICAgICAgICAgICAgICBNYXRoLmFicyggdGhpcy5sb2NhbE1pbmltdW1IZWlnaHRQcm9wZXJ0eS52YWx1ZSAtIGxvY2FsTWluaW11bUhlaWdodCApID4gQ0hBTkdFX1BPU0lUSU9OX1RIUkVTSE9MRCApIHtcclxuICAgICAgICAgICAgdGhpcy5sb2NhbE1pbmltdW1IZWlnaHRQcm9wZXJ0eS52YWx1ZSA9IGxvY2FsTWluaW11bUhlaWdodDtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHRoaXMuX21pbmltdW1TaXplQ2hhbmdpbmcgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAvLyBIZXJlLCBpbiB0aGUgY2FzZSBvZiByZWVudHJhbmNlLCB3ZSdsbCBhY3R1YWxseSB3YW50IHRvIHN3aXRjaCB0byB1cGRhdGluZyB0aGUgbm9uLWxvY2FsIG1pbmltdW0gc2l6ZSwgc2luY2VcclxuICAgICAgICAgIC8vIGdpdmVuIGFueSBvdGhlciBjaGFuZ2VzIGl0IHNob3VsZCBiZSB0aGUgcHJpbWFyeSBvbmUgdG8gY2hhbmdlLlxyXG4gICAgICAgICAgaWYgKCB0aGlzLl9taW5pbXVtU2l6ZUNoYW5nZUF0dGVtcHREdXJpbmdMb2NrICkge1xyXG4gICAgICAgICAgICB0aGlzLl9vblJlZW50cmFudExvY2FsTWluaW11bUhlaWdodCgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgIHRoaXMuX21pbmltdW1TaXplQ2hhbmdlQXR0ZW1wdER1cmluZ0xvY2sgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gVGhpcyBpcyBwcm92aWRlZCB0byBob29rIGludG8gdGhlIFNpemFibGUgdHJhaXQsIHNvIHRoYXQgd2UgY2FuIHVwZGF0ZSB0aGUgb3Bwb3NpdGUgZGltZW5zaW9uXHJcbiAgICAgIC8vIEBtaXhpbi1wcm90ZWN0ZWQgLSBtYWRlIHB1YmxpYyBmb3IgdXNlIGluIHRoZSBtaXhpbiBvbmx5XHJcbiAgICAgIHB1YmxpYyBfY2FsY3VsYXRlTWluaW11bUhlaWdodCgpOiBudW1iZXIgfCBudWxsIHtcclxuICAgICAgICByZXR1cm4gKCB0aGlzLm1hdHJpeC5pc0FsaWduZWQoKSAmJiB0aGlzLmxvY2FsTWluaW11bUhlaWdodCAhPT0gbnVsbCApXHJcbiAgICAgICAgICAgICAgID8gTWF0aC5hYnMoIHRoaXMudHJhbnNmb3JtLnRyYW5zZm9ybURlbHRhWSggdGhpcy5sb2NhbE1pbmltdW1IZWlnaHQgKSApXHJcbiAgICAgICAgICAgICAgIDogbnVsbDtcclxuICAgICAgfVxyXG5cclxuICAgICAgcHJpdmF0ZSBfdXBkYXRlTWluaW11bUhlaWdodCgpOiB2b2lkIHtcclxuICAgICAgICBpZiAoICF0aGlzLl9taW5pbXVtU2l6ZUNoYW5naW5nICkge1xyXG4gICAgICAgICAgdGhpcy5fbWluaW11bVNpemVDaGFuZ2luZyA9IHRydWU7XHJcblxyXG4gICAgICAgICAgLy8gU2luY2UgdGhlIG5vbi1sb2NhbCBcIm1pbmltdW1cIiBzaXplIGlzIHRoZSBvbmUgdGhhdCB3ZSdsbCB3YW50IHRvIGNvbnRpbnVlIHRvIHVwZGF0ZSBpZiB3ZSBleHBlcmllbmNlXHJcbiAgICAgICAgICAvLyByZWVudHJhbmN5IChzaW5jZSB3ZSB0cmVhdCB0aGUgbG9jYWwgdmVyc2lvbiBhcyB0aGUgZ3JvdW5kIHRydXRoKSwgd2UnbGwgbG9vcCBoZXJlIHVudGlsIHdlIGRpZG4ndCBnZXRcclxuICAgICAgICAgIC8vIGFuIGF0dGVtcHQgdG8gY2hhbmdlIGl0LiBUaGlzIHdpbGwgZW5zdXJlIHRoYXQgYWZ0ZXIgY2hhbmdlcywgd2UnbGwgaGF2ZSBhIGNvbnNpc3RlbnQgbWluaW11bSBhbmRcclxuICAgICAgICAgIC8vIGxvY2FsTWluaW11bSBzaXplLlxyXG4gICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICB0aGlzLl9taW5pbXVtU2l6ZUNoYW5nZUF0dGVtcHREdXJpbmdMb2NrID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBtaW5pbXVtSGVpZ2h0ID0gdGhpcy5fY2FsY3VsYXRlTWluaW11bUhlaWdodCgpO1xyXG5cclxuICAgICAgICAgICAgaWYgKCB0aGlzLm1pbmltdW1IZWlnaHRQcm9wZXJ0eS52YWx1ZSA9PT0gbnVsbCB8fFxyXG4gICAgICAgICAgICAgICAgIG1pbmltdW1IZWlnaHQgPT09IG51bGwgfHxcclxuICAgICAgICAgICAgICAgICBNYXRoLmFicyggdGhpcy5taW5pbXVtSGVpZ2h0UHJvcGVydHkudmFsdWUgLSBtaW5pbXVtSGVpZ2h0ICkgPiBDSEFOR0VfUE9TSVRJT05fVEhSRVNIT0xEICkge1xyXG4gICAgICAgICAgICAgIHRoaXMubWluaW11bUhlaWdodFByb3BlcnR5LnZhbHVlID0gbWluaW11bUhlaWdodDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgd2hpbGUgKCB0aGlzLl9taW5pbXVtU2l6ZUNoYW5nZUF0dGVtcHREdXJpbmdMb2NrICk7XHJcblxyXG4gICAgICAgICAgdGhpcy5fbWluaW11bVNpemVDaGFuZ2luZyA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcHVibGljIG92ZXJyaWRlIG11dGF0ZSggb3B0aW9ucz86IEhlaWdodFNpemFibGVPcHRpb25zICYgUGFyYW1ldGVyczxJbnN0YW5jZVR5cGU8U3VwZXJUeXBlPlsgJ211dGF0ZScgXT5bIDAgXSApOiB0aGlzIHtcclxuICAgICAgICByZXR1cm4gc3VwZXIubXV0YXRlKCBvcHRpb25zICk7XHJcbiAgICAgIH1cclxuICAgIH0gKTtcclxuXHJcbiAgLy8gSWYgd2UncmUgZXh0ZW5kaW5nIGludG8gYSBOb2RlIHR5cGUsIGluY2x1ZGUgb3B0aW9uIGtleXNcclxuICBpZiAoIEhlaWdodFNpemFibGVUcmFpdC5wcm90b3R5cGUuX211dGF0b3JLZXlzICkge1xyXG4gICAgY29uc3QgZXhpc3RpbmdLZXlzID0gSGVpZ2h0U2l6YWJsZVRyYWl0LnByb3RvdHlwZS5fbXV0YXRvcktleXM7XHJcbiAgICBjb25zdCBuZXdLZXlzID0gSEVJR0hUX1NJWkFCTEVfT1BUSU9OX0tFWVM7XHJcbiAgICBjb25zdCBpbmRleE9mQm91bmRzQmFzZWRPcHRpb25zID0gZXhpc3RpbmdLZXlzLmluZGV4T2YoIFJFUVVJUkVTX0JPVU5EU19PUFRJT05fS0VZU1sgMCBdICk7XHJcbiAgICBIZWlnaHRTaXphYmxlVHJhaXQucHJvdG90eXBlLl9tdXRhdG9yS2V5cyA9IFtcclxuICAgICAgLi4uZXhpc3RpbmdLZXlzLnNsaWNlKCAwLCBpbmRleE9mQm91bmRzQmFzZWRPcHRpb25zICksXHJcbiAgICAgIC4uLm5ld0tleXMsXHJcbiAgICAgIC4uLmV4aXN0aW5nS2V5cy5zbGljZSggaW5kZXhPZkJvdW5kc0Jhc2VkT3B0aW9ucyApXHJcbiAgICBdO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIEhlaWdodFNpemFibGVUcmFpdDtcclxufSApO1xyXG5cclxuLy8gU29tZSB0eXBlc2NyaXB0IGd5bW5hc3RpY3MgdG8gcHJvdmlkZSBhIHVzZXItZGVmaW5lZCB0eXBlIGd1YXJkIHRoYXQgdHJlYXRzIHNvbWV0aGluZyBhcyBIZWlnaHRTaXphYmxlLlxyXG4vLyBXZSBuZWVkIHRvIGRlZmluZSBhbiB1bnVzZWQgZnVuY3Rpb24gd2l0aCBhIGNvbmNyZXRlIHR5cGUsIHNvIHRoYXQgd2UgY2FuIGV4dHJhY3QgdGhlIHJldHVybiB0eXBlIG9mIHRoZSBmdW5jdGlvblxyXG4vLyBhbmQgcHJvdmlkZSBhIHR5cGUgZm9yIGEgTm9kZSB0aGF0IGV4dGVuZHMgdGhpcyB0eXBlLlxyXG5leHBvcnQgdHlwZSBIZWlnaHRTaXphYmxlTm9kZSA9IE5vZGUgJiBUSGVpZ2h0U2l6YWJsZTtcclxuXHJcbmNvbnN0IGlzSGVpZ2h0U2l6YWJsZSA9ICggbm9kZTogTm9kZSApOiBub2RlIGlzIEhlaWdodFNpemFibGVOb2RlID0+IHtcclxuICByZXR1cm4gbm9kZS5oZWlnaHRTaXphYmxlO1xyXG59O1xyXG5jb25zdCBleHRlbmRzSGVpZ2h0U2l6YWJsZSA9ICggbm9kZTogTm9kZSApOiBub2RlIGlzIEhlaWdodFNpemFibGVOb2RlID0+IHtcclxuICByZXR1cm4gbm9kZS5leHRlbmRzSGVpZ2h0U2l6YWJsZTtcclxufTtcclxuXHJcbnNjZW5lcnkucmVnaXN0ZXIoICdIZWlnaHRTaXphYmxlJywgSGVpZ2h0U2l6YWJsZSApO1xyXG5leHBvcnQgZGVmYXVsdCBIZWlnaHRTaXphYmxlO1xyXG5leHBvcnQgeyBpc0hlaWdodFNpemFibGUsIGV4dGVuZHNIZWlnaHRTaXphYmxlIH07Il0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPQSxZQUFZLE1BQU0sa0NBQWtDO0FBQzNELE9BQU9DLE9BQU8sTUFBTSxrQ0FBa0M7QUFDdEQsU0FBU0MsYUFBYSxFQUFRQywyQkFBMkIsRUFBRUMsT0FBTyxRQUFRLGVBQWU7QUFJekY7QUFDQSxNQUFNQyx5QkFBeUIsR0FBRyxJQUFJO0FBRXRDLE9BQU8sTUFBTUMsMEJBQTBCLEdBQUcsQ0FDeEMsaUJBQWlCLEVBQ2pCLGVBQWUsRUFDZixzQkFBc0IsRUFDdEIsb0JBQW9CLEVBQ3BCLGVBQWUsQ0FDaEI7QUErREQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU1DLGFBQWEsR0FBR04sT0FBTyxDQUF5Q08sSUFBZSxJQUErQztFQUNsSSxNQUFNQyxrQkFBa0IsR0FBR1AsYUFBYSxDQUFFLGVBQWUsRUFBRUksMEJBQTBCLEVBQ25GLE1BQU1HLGtCQUFrQixTQUFTRCxJQUFJLENBQTJCO0lBRTlEO0lBQ2dCRSx1QkFBdUIsR0FBZ0MsSUFBSVYsWUFBWSxDQUFpQixJQUFLLENBQUM7SUFDOUZXLHFCQUFxQixHQUFnQyxJQUFJWCxZQUFZLENBQWlCLElBQUssQ0FBQztJQUM1RlksNEJBQTRCLEdBQWdDLElBQUlaLFlBQVksQ0FBaUIsSUFBSyxD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