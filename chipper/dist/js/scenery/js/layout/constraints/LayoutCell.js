// Copyright 2022-2024, University of Colorado Boulder

/**
 * A configurable cell containing a Node used for more permanent layouts
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

import Orientation from '../../../../phet-core/js/Orientation.js';
import { LayoutProxyProperty, scenery } from '../../imports.js';

// NOTE: This would be an abstract class, but that is incompatible with how mixin constraints work in TypeScript
export default class LayoutCell {
  // We might need to notify the constraint it needs a layout

  // Our proxy will be dynamically computed and updated (based on whether there is a valid ancestorNode=>node trail)
  // Generally used to compute layout in the node's parent coordinate frame.

  // Called when layoutOptions changes for our Node

  // If we're not provided a (static) LayoutProxy in our constructor, we'll track and generate LayoutProxies with this.

  /**
   * NOTE: Consider this scenery-internal AND protected. It's effectively a protected constructor for an abstract type,
   * but cannot be due to how mixins constrain things (TypeScript doesn't work with private/protected things like this)
   *
   * NOTE: Methods can be marked as protected, however!
   *
   * (scenery-internal)
   *
   * @param constraint
   * @param node
   * @param proxy - If not provided, LayoutProxies will be computed and updated based on the ancestorNode of the
   *                constraint. This includes more work, and ideally should be avoided for things like FlowBox/GridBox
   *                (but will be needed by ManualConstraint or other direct LayoutConstraint usage)
   */
  constructor(constraint, node, proxy) {
    if (proxy) {
      this.layoutProxyProperty = null;
      this._proxy = proxy;
    } else {
      this._proxy = null;

      // If a LayoutProxy is not provided, we'll listen to (a) all the trails between our ancestor and this node,
      // (b) construct layout proxies for it (and assign here), and (c) listen to ancestor transforms to refresh
      // the layout when needed.
      this.layoutProxyProperty = new LayoutProxyProperty(constraint.ancestorNode, node, {
        onTransformChange: () => constraint.updateLayoutAutomatically()
      });
      this.layoutProxyProperty.link(proxy => {
        this._proxy = proxy;
        constraint.updateLayoutAutomatically();
      });
    }
    this._constraint = constraint;
    this._node = node;
    this.layoutOptionsListener = this.onLayoutOptionsChange.bind(this);
    this.node.layoutOptionsChangedEmitter.addListener(this.layoutOptionsListener);
  }

  // Can't be abstract, we're using mixins :(
  onLayoutOptionsChange() {
    // Lint rule not needed here
  }

  /**
   * (scenery-internal)
   */
  get node() {
    return this._node;
  }

  /**
   * (scenery-internal)
   */
  isConnected() {
    return this._proxy !== null;
  }

  /**
   * (scenery-internal)
   */
  get proxy() {
    assert && assert(this._proxy);
    return this._proxy;
  }

  /**
   * (scenery-internal)
   */
  isSizable(orientation) {
    return orientation === Orientation.HORIZONTAL ? this.proxy.widthSizable : this.proxy.heightSizable;
  }

  /**
   * Releases references
   */
  dispose() {
    this.layoutProxyProperty && this.layoutProxyProperty.dispose();
    this.node.layoutOptionsChangedEmitter.removeListener(this.layoutOptionsListener);
  }
}
scenery.register('LayoutCell', LayoutCell);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJPcmllbnRhdGlvbiIsIkxheW91dFByb3h5UHJvcGVydHkiLCJzY2VuZXJ5IiwiTGF5b3V0Q2VsbCIsImNvbnN0cnVjdG9yIiwiY29uc3RyYWludCIsIm5vZGUiLCJwcm94eSIsImxheW91dFByb3h5UHJvcGVydHkiLCJfcHJveHkiLCJhbmNlc3Rvck5vZGUiLCJvblRyYW5zZm9ybUNoYW5nZSIsInVwZGF0ZUxheW91dEF1dG9tYXRpY2FsbHkiLCJsaW5rIiwiX2NvbnN0cmFpbnQiLCJfbm9kZSIsImxheW91dE9wdGlvbnNMaXN0ZW5lciIsIm9uTGF5b3V0T3B0aW9uc0NoYW5nZSIsImJpbmQiLCJsYXlvdXRPcHRpb25zQ2hhbmdlZEVtaXR0ZXIiLCJhZGRMaXN0ZW5lciIsImlzQ29ubmVjdGVkIiwiYXNzZXJ0IiwiaXNTaXphYmxlIiwib3JpZW50YXRpb24iLCJIT1JJWk9OVEFMIiwid2lkdGhTaXphYmxlIiwiaGVpZ2h0U2l6YWJsZSIsImRpc3Bvc2UiLCJyZW1vdmVMaXN0ZW5lciIsInJlZ2lzdGVyIl0sInNvdXJjZXMiOlsiTGF5b3V0Q2VsbC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAyMi0yMDI0LCBVbml2ZXJzaXR5IG9mIENvbG9yYWRvIEJvdWxkZXJcclxuXHJcbi8qKlxyXG4gKiBBIGNvbmZpZ3VyYWJsZSBjZWxsIGNvbnRhaW5pbmcgYSBOb2RlIHVzZWQgZm9yIG1vcmUgcGVybWFuZW50IGxheW91dHNcclxuICpcclxuICogQGF1dGhvciBKb25hdGhhbiBPbHNvbiA8am9uYXRoYW4ub2xzb25AY29sb3JhZG8uZWR1PlxyXG4gKi9cclxuXHJcbmltcG9ydCBPcmllbnRhdGlvbiBmcm9tICcuLi8uLi8uLi8uLi9waGV0LWNvcmUvanMvT3JpZW50YXRpb24uanMnO1xyXG5pbXBvcnQgeyBMYXlvdXRDb25zdHJhaW50LCBMYXlvdXRQcm94eSwgTGF5b3V0UHJveHlQcm9wZXJ0eSwgTm9kZSwgc2NlbmVyeSB9IGZyb20gJy4uLy4uL2ltcG9ydHMuanMnO1xyXG5cclxuLy8gTk9URTogVGhpcyB3b3VsZCBiZSBhbiBhYnN0cmFjdCBjbGFzcywgYnV0IHRoYXQgaXMgaW5jb21wYXRpYmxlIHdpdGggaG93IG1peGluIGNvbnN0cmFpbnRzIHdvcmsgaW4gVHlwZVNjcmlwdFxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMYXlvdXRDZWxsIHtcclxuXHJcbiAgLy8gV2UgbWlnaHQgbmVlZCB0byBub3RpZnkgdGhlIGNvbnN0cmFpbnQgaXQgbmVlZHMgYSBsYXlvdXRcclxuICBwcml2YXRlIHJlYWRvbmx5IF9jb25zdHJhaW50OiBMYXlvdXRDb25zdHJhaW50O1xyXG5cclxuICBwcml2YXRlIHJlYWRvbmx5IF9ub2RlOiBOb2RlO1xyXG5cclxuICAvLyBPdXIgcHJveHkgd2lsbCBiZSBkeW5hbWljYWxseSBjb21wdXRlZCBhbmQgdXBkYXRlZCAoYmFzZWQgb24gd2hldGhlciB0aGVyZSBpcyBhIHZhbGlkIGFuY2VzdG9yTm9kZT0+bm9kZSB0cmFpbClcclxuICAvLyBHZW5lcmFsbHkgdXNlZCB0byBjb21wdXRlIGxheW91dCBpbiB0aGUgbm9kZSdzIHBhcmVudCBjb29yZGluYXRlIGZyYW1lLlxyXG4gIHByaXZhdGUgX3Byb3h5OiBMYXlvdXRQcm94eSB8IG51bGw7XHJcblxyXG4gIC8vIENhbGxlZCB3aGVuIGxheW91dE9wdGlvbnMgY2hhbmdlcyBmb3Igb3VyIE5vZGVcclxuICBwcml2YXRlIHJlYWRvbmx5IGxheW91dE9wdGlvbnNMaXN0ZW5lcjogKCkgPT4gdm9pZDtcclxuXHJcbiAgLy8gSWYgd2UncmUgbm90IHByb3ZpZGVkIGEgKHN0YXRpYykgTGF5b3V0UHJveHkgaW4gb3VyIGNvbnN0cnVjdG9yLCB3ZSdsbCB0cmFjayBhbmQgZ2VuZXJhdGUgTGF5b3V0UHJveGllcyB3aXRoIHRoaXMuXHJcbiAgcHJpdmF0ZSByZWFkb25seSBsYXlvdXRQcm94eVByb3BlcnR5OiBMYXlvdXRQcm94eVByb3BlcnR5IHwgbnVsbDtcclxuXHJcbiAgLyoqXHJcbiAgICogTk9URTogQ29uc2lkZXIgdGhpcyBzY2VuZXJ5LWludGVybmFsIEFORCBwcm90ZWN0ZWQuIEl0J3MgZWZmZWN0aXZlbHkgYSBwcm90ZWN0ZWQgY29uc3RydWN0b3IgZm9yIGFuIGFic3RyYWN0IHR5cGUsXHJcbiAgICogYnV0IGNhbm5vdCBiZSBkdWUgdG8gaG93IG1peGlucyBjb25zdHJhaW4gdGhpbmdzIChUeXBlU2NyaXB0IGRvZXNuJ3Qgd29yayB3aXRoIHByaXZhdGUvcHJvdGVjdGVkIHRoaW5ncyBsaWtlIHRoaXMpXHJcbiAgICpcclxuICAgKiBOT1RFOiBNZXRob2RzIGNhbiBiZSBtYXJrZWQgYXMgcHJvdGVjdGVkLCBob3dldmVyIVxyXG4gICAqXHJcbiAgICogKHNjZW5lcnktaW50ZXJuYWwpXHJcbiAgICpcclxuICAgKiBAcGFyYW0gY29uc3RyYWludFxyXG4gICAqIEBwYXJhbSBub2RlXHJcbiAgICogQHBhcmFtIHByb3h5IC0gSWYgbm90IHByb3ZpZGVkLCBMYXlvdXRQcm94aWVzIHdpbGwgYmUgY29tcHV0ZWQgYW5kIHVwZGF0ZWQgYmFzZWQgb24gdGhlIGFuY2VzdG9yTm9kZSBvZiB0aGVcclxuICAgKiAgICAgICAgICAgICAgICBjb25zdHJhaW50LiBUaGlzIGluY2x1ZGVzIG1vcmUgd29yaywgYW5kIGlkZWFsbHkgc2hvdWxkIGJlIGF2b2lkZWQgZm9yIHRoaW5ncyBsaWtlIEZsb3dCb3gvR3JpZEJveFxyXG4gICAqICAgICAgICAgICAgICAgIChidXQgd2lsbCBiZSBuZWVkZWQgYnkgTWFudWFsQ29uc3RyYWludCBvciBvdGhlciBkaXJlY3QgTGF5b3V0Q29uc3RyYWludCB1c2FnZSlcclxuICAgKi9cclxuICBwdWJsaWMgY29uc3RydWN0b3IoIGNvbnN0cmFpbnQ6IExheW91dENvbnN0cmFpbnQsIG5vZGU6IE5vZGUsIHByb3h5OiBMYXlvdXRQcm94eSB8IG51bGwgKSB7XHJcbiAgICBpZiAoIHByb3h5ICkge1xyXG4gICAgICB0aGlzLmxheW91dFByb3h5UHJvcGVydHkgPSBudWxsO1xyXG4gICAgICB0aGlzLl9wcm94eSA9IHByb3h5O1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcblxyXG4gICAgICB0aGlzLl9wcm94eSA9IG51bGw7XHJcblxyXG4gICAgICAvLyBJZiBhIExheW91dFByb3h5IGlzIG5vdCBwcm92aWRlZCwgd2UnbGwgbGlzdGVuIHRvIChhKSBhbGwgdGhlIHRyYWlscyBiZXR3ZWVuIG91ciBhbmNlc3RvciBhbmQgdGhpcyBub2RlLFxyXG4gICAgICAvLyAoYikgY29uc3RydWN0IGxheW91dCBwcm94aWVzIGZvciBpdCAoYW5kIGFzc2lnbiBoZXJlKSwgYW5kIChjKSBsaXN0ZW4gdG8gYW5jZXN0b3IgdHJhbnNmb3JtcyB0byByZWZyZXNoXHJcbiAgICAgIC8vIHRoZSBsYXlvdXQgd2hlbiBuZWVkZWQuXHJcbiAgICAgIHRoaXMubGF5b3V0UHJveHlQcm9wZXJ0eSA9IG5ldyBMYXlvdXRQcm94eVByb3BlcnR5KCBjb25zdHJhaW50LmFuY2VzdG9yTm9kZSwgbm9kZSwge1xyXG4gICAgICAgIG9uVHJhbnNmb3JtQ2hhbmdlOiAoKSA9PiBjb25zdHJhaW50LnVwZGF0ZUxheW91dEF1dG9tYXRpY2FsbHkoKVxyXG4gICAgICB9ICk7XHJcbiAgICAgIHRoaXMubGF5b3V0UHJveHlQcm9wZXJ0eS5saW5rKCBwcm94eSA9PiB7XHJcbiAgICAgICAgdGhpcy5fcHJveHkgPSBwcm94eTtcclxuXHJcbiAgICAgICAgY29uc3RyYWludC51cGRhdGVMYXlvdXRBdXRvbWF0aWNhbGx5KCk7XHJcbiAgICAgIH0gKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9jb25zdHJhaW50ID0gY29uc3RyYWludDtcclxuICAgIHRoaXMuX25vZGUgPSBub2RlO1xyXG5cclxuICAgIHRoaXMubGF5b3V0T3B0aW9uc0xpc3RlbmVyID0gdGhpcy5vbkxheW91dE9wdGlvbnNDaGFuZ2UuYmluZCggdGhpcyApO1xyXG4gICAgdGhpcy5ub2RlLmxheW91dE9wdGlvbnNDaGFuZ2VkRW1pdHRlci5hZGRMaXN0ZW5lciggdGhpcy5sYXlvdXRPcHRpb25zTGlzdGVuZXIgKTtcclxuICB9XHJcblxyXG4gIC8vIENhbid0IGJlIGFic3RyYWN0LCB3ZSdyZSB1c2luZyBtaXhpbnMgOihcclxuICBwcm90ZWN0ZWQgb25MYXlvdXRPcHRpb25zQ2hhbmdlKCk6IHZvaWQge1xyXG4gICAgLy8gTGludCBydWxlIG5vdCBuZWVkZWQgaGVyZVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogKHNjZW5lcnktaW50ZXJuYWwpXHJcbiAgICovXHJcbiAgcHVibGljIGdldCBub2RlKCk6IE5vZGUge1xyXG4gICAgcmV0dXJuIHRoaXMuX25vZGU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiAoc2NlbmVyeS1pbnRlcm5hbClcclxuICAgKi9cclxuICBwdWJsaWMgaXNDb25uZWN0ZWQoKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gdGhpcy5fcHJveHkgIT09IG51bGw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiAoc2NlbmVyeS1pbnRlcm5hbClcclxuICAgKi9cclxuICBwdWJsaWMgZ2V0IHByb3h5KCk6IExheW91dFByb3h5IHtcclxuICAgIGFzc2VydCAmJiBhc3NlcnQoIHRoaXMuX3Byb3h5ICk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuX3Byb3h5ITtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIChzY2VuZXJ5LWludGVybmFsKVxyXG4gICAqL1xyXG4gIHB1YmxpYyBpc1NpemFibGUoIG9yaWVudGF0aW9uOiBPcmllbnRhdGlvbiApOiBib29sZWFuIHtcclxuICAgIHJldHVybiBvcmllbnRhdGlvbiA9PT0gT3JpZW50YXRpb24uSE9SSVpPTlRBTCA/IHRoaXMucHJveHkud2lkdGhTaXphYmxlIDogdGhpcy5wcm94eS5oZWlnaHRTaXphYmxlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVsZWFzZXMgcmVmZXJlbmNlc1xyXG4gICAqL1xyXG4gIHB1YmxpYyBkaXNwb3NlKCk6IHZvaWQge1xyXG4gICAgdGhpcy5sYXlvdXRQcm94eVByb3BlcnR5ICYmIHRoaXMubGF5b3V0UHJveHlQcm9wZXJ0eS5kaXNwb3NlKCk7XHJcblxyXG4gICAgdGhpcy5ub2RlLmxheW91dE9wdGlvbnNDaGFuZ2VkRW1pdHRlci5yZW1vdmVMaXN0ZW5lciggdGhpcy5sYXlvdXRPcHRpb25zTGlzdGVuZXIgKTtcclxuICB9XHJcbn1cclxuXHJcbnNjZW5lcnkucmVnaXN0ZXIoICdMYXlvdXRDZWxsJywgTGF5b3V0Q2VsbCApOyJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPQSxXQUFXLE1BQU0seUNBQXlDO0FBQ2pFLFNBQXdDQyxtQkFBbUIsRUFBUUMsT0FBTyxRQUFRLGtCQUFrQjs7QUFFcEc7QUFDQSxlQUFlLE1BQU1DLFVBQVUsQ0FBQztFQUU5Qjs7RUFLQTtFQUNBOztFQUdBOztFQUdBOztFQUdBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDU0MsV0FBV0EsQ0FBRUMsVUFBNEIsRUFBRUMsSUFBVSxFQUFFQyxLQUF5QixFQUFHO0lBQ3hGLElBQUtBLEtBQUssRUFBRztNQUNYLElBQUksQ0FBQ0MsbUJBQW1CLEdBQUcsSUFBSTtNQUMvQixJQUFJLENBQUNDLE1BQU0sR0FBR0YsS0FBSztJQUNyQixDQUFDLE1BQ0k7TUFFSCxJQUFJLENBQUNFLE1BQU0sR0FBRyxJQUFJOztNQUVsQjtNQUNBO01BQ0E7TUFDQSxJQUFJLENBQUNELG1CQUFtQixHQUFHLElBQUlQLG1CQUFtQixDQUFFSSxVQUFVLENBQUNLLFlBQVksRUFBRUosSUFBSSxFQUFFO1FBQ2pGSyxpQkFBaUIsRUFBRUEsQ0FBQSxLQUFNTixVQUFVLENBQUNPLHlCQUF5QixDQUFDO01BQ2hFLENBQUUsQ0FBQztNQUNILElBQUksQ0FBQ0osbUJBQW1CLENBQUNLLElBQUksQ0FBRU4sS0FBSyxJQUFJO1FBQ3RDLElBQUksQ0FBQ0UsTUFBTSxHQUFHRixLQUFLO1FBRW5CRixVQUFVLENBQUNPLHlCQUF5QixDQUFDLENBQUM7TUFDeEMsQ0FBRSxDQUFDO0lBQ0w7SUFFQSxJQUFJLENBQUNFLFdBQVcsR0FBR1QsVUFBVTtJQUM3QixJQUFJLENBQUNVLEtBQUssR0FBR1QsSUFBSTtJQUVqQixJQUFJLENBQUNVLHFCQUFxQixHQUFHLElBQUksQ0FBQ0MscUJBQXFCLENBQUNDLElBQUksQ0FBRSxJQUFLLENBQUM7SUFDcEUsSUFBSSxDQUFDWixJQUFJLENBQUNhLDJCQUEyQixDQUFDQyxXQUFXLENBQUUsSUFBSSxDQUFDSixxQkFBc0IsQ0FBQztFQUNqRjs7RUFFQTtFQUNVQyxxQkFBcUJBLENBQUEsRUFBUztJQUN0QztFQUFBOztFQUdGO0FBQ0Y7QUFDQTtFQUNFLElBQVdYLElBQUlBLENBQUEsRUFBUztJQUN0QixPQUFPLElBQUksQ0FBQ1MsS0FBSztFQUNuQjs7RUFFQTtBQUNGO0FBQ0E7RUFDU00sV0FBV0EsQ0FBQSxFQUFZO0lBQzVCLE9BQU8sSUFBSSxDQUFDWixNQUFNLEtBQUssSUFBSTtFQUM3Qjs7RUFFQTtBQUNGO0FBQ0E7RUFDRSxJQUFXRixLQUFLQSxDQUFBLEVBQWdCO0lBQzlCZSxNQUFNLElBQUlBLE1BQU0sQ0FBRSxJQUFJLENBQUNiLE1BQU8sQ0FBQztJQUUvQixPQUFPLElBQUksQ0FBQ0EsTUFBTTtFQUNwQjs7RUFFQTtBQUNGO0FBQ0E7RUFDU2MsU0FBU0EsQ0FBRUMsV0FBd0IsRUFBWTtJQUNwRCxPQUFPQSxXQUFXLEtBQUt4QixXQUFXLENBQUN5QixVQUFVLEdBQUcsSUFBSSxDQUFDbEIsS0FBSyxDQUFDbUIsWUFBWSxHQUFHLElBQUksQ0FBQ25CLEtBQUssQ0FBQ29CLGFBQWE7RUFDcEc7O0VBRUE7QUFDRjtBQUNBO0VBQ1NDLE9BQU9BLENBQUEsRUFBUztJQUNyQixJQUFJLENBQUNwQixtQkFBbUIsSUFBSSxJQUFJLENBQUNBLG1CQUFtQixDQUFDb0IsT0FBTyxDQUFDLENBQUM7SUFFOUQsSUFBSSxDQUFDdEIsSUFBSSxDQUFDYSwyQkFBMkIsQ0FBQ1UsY0FBYyxDQUFFLElBQUksQ0FBQ2IscUJBQXNCLENBQUM7RUFDcEY7QUFDRjtBQUVBZCxPQUFPLENBQUM0QixRQUFRLENBQUUsWUFBWSxFQUFFM0IsVUFBVyxDQUFDIiwiaWdub3JlTGlzdCI6W119