// Copyright 2021-2024, University of Colorado Boulder

/**
 * WidthSizable is a trait that provides a minimum and preferred width. The minimum width is set by the component,
 * so that layout containers could know how "small" the component can be made. The preferred width is set by the
 * layout container, and the component should adjust its size so that it takes up that width.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

import TinyProperty from '../../../axon/js/TinyProperty.js';
import memoize from '../../../phet-core/js/memoize.js';
import { DelayedMutate, REQUIRES_BOUNDS_OPTION_KEYS, scenery } from '../imports.js';
// Position changes smaller than this will be ignored
const CHANGE_POSITION_THRESHOLD = 1e-9;
export const WIDTH_SIZABLE_OPTION_KEYS = ['preferredWidth', 'minimumWidth', 'localPreferredWidth', 'localMinimumWidth', 'widthSizable'];
// IMPORTANT: If you're combining this in, typically don't pass options that WidthSizable would take through the
// constructor. It will hit Node's mutate() likely, and then will fail because we haven't been able to set the
// values yet. If you're making something WidthSizable, please use a later mutate() to pass these options through.
// They WILL be caught by assertions if someone adds one of those options, but it could be a silent bug if no one
// is yet passing those options through.
const WidthSizable = memoize(Type => {
  const WidthSizableTrait = DelayedMutate('WidthSizable', WIDTH_SIZABLE_OPTION_KEYS, class WidthSizableTrait extends Type {
    // parent/local preferred/minimum Properties. See the options above for more documentation
    preferredWidthProperty = new TinyProperty(null);
    minimumWidthProperty = new TinyProperty(null);
    localPreferredWidthProperty = new TinyProperty(null);
    localMinimumWidthProperty = new TinyProperty(null);
    isWidthResizableProperty = new TinyProperty(true);

    // Flags so that we can change one (parent/local) value and not enter an infinite loop changing the others.
    // We want to lock out all other local or non-local preferred minimum sizes, whether in HeightSizable or WidthSizable
    // NOTE: We are merging declarations between HeightSizable and WidthSizable. If Sizable is used these flags
    // will be shared by both HeightSizable and WidthSizable.
    // @mixin-protected - made public for use in the mixin only
    _preferredSizeChanging = false;
    // @mixin-protected - made public for use in the mixin only
    _minimumSizeChanging = false;

    // We'll need to detect reentrancy when setting the dual of the preferred/minimum properties (e.g. local vs parent).
    // If we get a reentrant case, we'll need to detect it and clear things up at the end (updating the minimum size
    // in the parent coordinate frame, and the preferred size in the local coordinate frame).
    // An example is if the minimum size is set, and that triggers a listener that UPDATES something that changes the
    // minimum size, we'll need to make sure that the local minimum size is updated AFTER everything has happened.
    // These locks are used to detect these cases, and then run the appropriate updates afterward to make sure that the
    // local and parent values are in sync (based on the transform used).
    // @mixin-protected - made public for use in the mixin only
    _preferredSizeChangeAttemptDuringLock = false;
    // @mixin-protected - made public for use in the mixin only
    _minimumSizeChangeAttemptDuringLock = false;

    // Expose listeners, so that we'll be able to hook them up to the opposite dimension in Sizable
    // @mixin-protected - made public for use in the mixin only

    // @mixin-protected - made public for use in the mixin only

    // @mixin-protected - made public for use in the mixin only

    // @mixin-protected - made public for use in the mixin only

    // IMPORTANT: If you're combining this in, typically don't pass options that WidthSizable would take through the
    // constructor. It will hit Node's mutate() likely, and then will fail because we haven't been able to set the
    // values yet. If you're making something WidthSizable, please use a later mutate() to pass these options through.
    // They WILL be caught by assertions if someone adds one of those options, but it could be a silent bug if no one
    // is yet passing those options through.
    constructor(...args) {
      super(...args);
      this._updatePreferredWidthListener = this._updatePreferredWidth.bind(this);
      this._updateLocalPreferredWidthListener = this._updateLocalPreferredWidth.bind(this);
      this._updateMinimumWidthListener = this._updateMinimumWidth.bind(this);
      this._updateLocalMinimumWidthListener = this._updateLocalMinimumWidth.bind(this);

      // Update the opposite of parent/local when one changes
      this.preferredWidthProperty.lazyLink(this._updateLocalPreferredWidthListener);
      this.localPreferredWidthProperty.lazyLink(this._updatePreferredWidthListener);
      this.minimumWidthProperty.lazyLink(this._updateLocalMinimumWidthListener);
      this.localMinimumWidthProperty.lazyLink(this._updateMinimumWidthListener);

      // On a transform change, keep our local minimum (presumably unchanged), and our parent preferred size
      this.transformEmitter.addListener(this._updateLocalPreferredWidthListener);
      // On a transform change this should update the minimum
      this.transformEmitter.addListener(this._updateMinimumWidthListener);
    }
    get preferredWidth() {
      assert && assert(this.preferredWidthProperty, 'WidthSizable options should be set from a later mutate() call instead of the super constructor');
      return this.preferredWidthProperty.value;
    }
    set preferredWidth(value) {
      assert && assert(this.preferredWidthProperty, 'WidthSizable options should be set from a later mutate() call instead of the super constructor');
      assert && assert(value === null || typeof value === 'number' && isFinite(value) && value >= 0, 'preferredWidth should be null or a non-negative finite number');
      this.preferredWidthProperty.value = value;
    }
    get localPreferredWidth() {
      assert && assert(this.localPreferredWidthProperty, 'WidthSizable options should be set from a later mutate() call instead of the super constructor');
      return this.localPreferredWidthProperty.value;
    }
    set localPreferredWidth(value) {
      assert && assert(this.localPreferredWidthProperty, 'WidthSizable options should be set from a later mutate() call instead of the super constructor');
      assert && assert(value === null || typeof value === 'number' && isFinite(value) && value >= 0, 'localPreferredWidth should be null or a non-negative finite number');
      this.localPreferredWidthProperty.value = value;
    }
    get minimumWidth() {
      assert && assert(this.minimumWidthProperty, 'WidthSizable options should be set from a later mutate() call instead of the super constructor');
      return this.minimumWidthProperty.value;
    }
    set minimumWidth(value) {
      assert && assert(this.minimumWidthProperty, 'WidthSizable options should be set from a later mutate() call instead of the super constructor');
      assert && assert(value === null || typeof value === 'number' && isFinite(value));
      this.minimumWidthProperty.value = value;
    }
    get localMinimumWidth() {
      assert && assert(this.localMinimumWidthProperty, 'WidthSizable options should be set from a later mutate() call instead of the super constructor');
      return this.localMinimumWidthProperty.value;
    }
    set localMinimumWidth(value) {
      assert && assert(this.localMinimumWidthProperty, 'WidthSizable options should be set from a later mutate() call instead of the super constructor');
      assert && assert(value === null || typeof value === 'number' && isFinite(value));
      this.localMinimumWidthProperty.value = value;
    }
    get widthSizable() {
      assert && assert(this.isWidthResizableProperty, 'WidthSizable options should be set from a later mutate() call instead of the super constructor');
      return this.isWidthResizableProperty.value;
    }
    set widthSizable(value) {
      assert && assert(this.isWidthResizableProperty, 'WidthSizable options should be set from a later mutate() call instead of the super constructor');
      this.isWidthResizableProperty.value = value;
    }
    get extendsWidthSizable() {
      return true;
    }
    validateLocalPreferredWidth() {
      if (assert) {
        const currentWidth = this.localWidth;
        const effectiveMinimumWidth = this.localMinimumWidth === null ? currentWidth : this.localMinimumWidth;
        const idealWidth = this.localPreferredWidth === null ? effectiveMinimumWidth : this.localPreferredWidth;

        // Handle non-finite values with exact equality
        assert(idealWidth === currentWidth || Math.abs(idealWidth - currentWidth) < 1e-7);
      }
    }

    // This is provided to hook into the Sizable trait, so that we can update the opposite dimension
    // @mixin-protected - made public for use in the mixin only
    _calculateLocalPreferredWidth() {
      return this.matrix.isAligned() && this.preferredWidth !== null ? Math.abs(this.transform.inverseDeltaX(this.preferredWidth)) : null;
    }

    // Provides a hook to Sizable, since we'll need to cross-link this to also try updating the opposite dimension
    // @mixin-protected - made public for use in the mixin only
    _onReentrantPreferredWidth() {
      this._updateLocalPreferredWidthListener();
    }
    _updateLocalPreferredWidth() {
      assert && this.auditMaxDimensions();
      if (!this._preferredSizeChanging) {
        this._preferredSizeChanging = true;

        // Since the local "preferred" size is the one that we'll want to continue to update if we experience
        // reentrancy (since we treat the non-local version as the ground truth), we'll loop here until we didn't get
        // an attempt to change it. This will ensure that after changes, we'll have a consistent preferred and
        // localPreferred size.
        do {
          this._preferredSizeChangeAttemptDuringLock = false;
          const localPreferredWidth = this._calculateLocalPreferredWidth();
          if (this.localPreferredWidthProperty.value === null || localPreferredWidth === null || Math.abs(this.localPreferredWidthProperty.value - localPreferredWidth) > CHANGE_POSITION_THRESHOLD) {
            this.localPreferredWidthProperty.value = localPreferredWidth;
          }
        } while (this._preferredSizeChangeAttemptDuringLock);
        this._preferredSizeChanging = false;
      } else {
        this._preferredSizeChangeAttemptDuringLock = true;
      }
    }

    // This is provided to hook into the Sizable trait, so that we can update the opposite dimension
    // @mixin-protected - made public for use in the mixin only
    _calculatePreferredWidth() {
      return this.matrix.isAligned() && this.localPreferredWidth !== null ? Math.abs(this.transform.transformDeltaX(this.localPreferredWidth)) : null;
    }
    _updatePreferredWidth() {
      if (!this._preferredSizeChanging) {
        this._preferredSizeChanging = true;
        this._preferredSizeChangeAttemptDuringLock = false;
        const preferredWidth = this._calculatePreferredWidth();
        if (this.preferredWidthProperty.value === null || preferredWidth === null || Math.abs(this.preferredWidthProperty.value - preferredWidth) > CHANGE_POSITION_THRESHOLD) {
          this.preferredWidthProperty.value = preferredWidth;
        }
        this._preferredSizeChanging = false;

        // Here, in the case of reentrance, we'll actually want to switch to updating the local preferred size, since
        // given any other changes it should be the primary one to change.
        if (this._preferredSizeChangeAttemptDuringLock) {
          this._onReentrantPreferredWidth();
        }
      } else {
        this._preferredSizeChangeAttemptDuringLock = true;
      }
    }

    // This is provided to hook into the Sizable trait, so that we can update the opposite dimension
    // @mixin-protected - made public for use in the mixin only
    _calculateLocalMinimumWidth() {
      return this.matrix.isAligned() && this.minimumWidth !== null ? Math.abs(this.transform.inverseDeltaX(this.minimumWidth)) : null;
    }

    // @mixin-protected - made public for use in the mixin only
    _onReentrantLocalMinimumWidth() {
      this._updateMinimumWidthListener();
    }
    _updateLocalMinimumWidth() {
      if (!this._minimumSizeChanging) {
        this._minimumSizeChanging = true;
        const localMinimumWidth = this._calculateLocalMinimumWidth();
        this._minimumSizeChangeAttemptDuringLock = false;
        if (this.localMinimumWidthProperty.value === null || localMinimumWidth === null || Math.abs(this.localMinimumWidthProperty.value - localMinimumWidth) > CHANGE_POSITION_THRESHOLD) {
          this.localMinimumWidthProperty.value = localMinimumWidth;
        }
        this._minimumSizeChanging = false;

        // Here, in the case of reentrance, we'll actually want to switch to updating the non-local minimum size, since
        // given any other changes it should be the primary one to change.
        if (this._minimumSizeChangeAttemptDuringLock) {
          this._onReentrantLocalMinimumWidth();
        }
      } else {
        this._minimumSizeChangeAttemptDuringLock = true;
      }
    }

    // This is provided to hook into the Sizable trait, so that we can update the opposite dimension
    // @mixin-protected - made public for use in the mixin only
    _calculateMinimumWidth() {
      return this.matrix.isAligned() && this.localMinimumWidth !== null ? Math.abs(this.transform.transformDeltaX(this.localMinimumWidth)) : null;
    }
    _updateMinimumWidth() {
      if (!this._minimumSizeChanging) {
        this._minimumSizeChanging = true;

        // Since the non-local "minimum" size is the one that we'll want to continue to update if we experience
        // reentrancy (since we treat the local version as the ground truth), we'll loop here until we didn't get
        // an attempt to change it. This will ensure that after changes, we'll have a consistent minimum and
        // localMinimum size.
        do {
          this._minimumSizeChangeAttemptDuringLock = false;
          const minimumWidth = this._calculateMinimumWidth();
          if (this.minimumWidthProperty.value === null || minimumWidth === null || Math.abs(this.minimumWidthProperty.value - minimumWidth) > CHANGE_POSITION_THRESHOLD) {
            this.minimumWidthProperty.value = minimumWidth;
          }
        } while (this._minimumSizeChangeAttemptDuringLock);
        this._minimumSizeChanging = false;
      } else {
        this._minimumSizeChangeAttemptDuringLock = true;
      }
    }
    mutate(options) {
      return super.mutate(options);
    }
  });

  // If we're extending into a Node type, include option keys
  if (WidthSizableTrait.prototype._mutatorKeys) {
    const existingKeys = WidthSizableTrait.prototype._mutatorKeys;
    const newKeys = WIDTH_SIZABLE_OPTION_KEYS;
    const indexOfBoundsBasedOptions = existingKeys.indexOf(REQUIRES_BOUNDS_OPTION_KEYS[0]);
    WidthSizableTrait.prototype._mutatorKeys = [...existingKeys.slice(0, indexOfBoundsBasedOptions), ...newKeys, ...existingKeys.slice(indexOfBoundsBasedOptions)];
  }
  return WidthSizableTrait;
});
const isWidthSizable = node => {
  return node.widthSizable;
};
const extendsWidthSizable = node => {
  return node.extendsWidthSizable;
};

// Some typescript gymnastics to provide a user-defined type guard that treats something as widthSizable
// We need to define an unused function with a concrete type, so that we can extract the return type of the function
// and provide a type for a Node that extends this type.

scenery.register('WidthSizable', WidthSizable);
export default WidthSizable;
export { isWidthSizable, extendsWidthSizable };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJUaW55UHJvcGVydHkiLCJtZW1vaXplIiwiRGVsYXllZE11dGF0ZSIsIlJFUVVJUkVTX0JPVU5EU19PUFRJT05fS0VZUyIsInNjZW5lcnkiLCJDSEFOR0VfUE9TSVRJT05fVEhSRVNIT0xEIiwiV0lEVEhfU0laQUJMRV9PUFRJT05fS0VZUyIsIldpZHRoU2l6YWJsZSIsIlR5cGUiLCJXaWR0aFNpemFibGVUcmFpdCIsInByZWZlcnJlZFdpZHRoUHJvcGVydHkiLCJtaW5pbXVtV2lkdGhQcm9wZXJ0eSIsImxvY2FsUHJlZmVycmVkV2lkdGhQcm9wZXJ0eSIsImxvY2FsTWluaW11bVdpZHRoUHJvcGVydHkiLCJpc1dpZHRoUmVzaXphYmxlUHJvcGVydHkiLCJfcHJlZmVycmVkU2l6ZUNoYW5naW5nIiwiX21pbmltdW1TaXplQ2hhbmdpbmciLCJfcHJlZmVycmVkU2l6ZUNoYW5nZUF0dGVtcHREdXJpbmdMb2NrIiwiX21pbmltdW1TaXplQ2hhbmdlQXR0ZW1wdER1cmluZ0xvY2siLCJjb25zdHJ1Y3RvciIsImFyZ3MiLCJfdXBkYXRlUHJlZmVycmVkV2lkdGhMaXN0ZW5lciIsIl91cGRhdGVQcmVmZXJyZWRXaWR0aCIsImJpbmQiLCJfdXBkYXRlTG9jYWxQcmVmZXJyZWRXaWR0aExpc3RlbmVyIiwiX3VwZGF0ZUxvY2FsUHJlZmVycmVkV2lkdGgiLCJfdXBkYXRlTWluaW11bVdpZHRoTGlzdGVuZXIiLCJfdXBkYXRlTWluaW11bVdpZHRoIiwiX3VwZGF0ZUxvY2FsTWluaW11bVdpZHRoTGlzdGVuZXIiLCJfdXBkYXRlTG9jYWxNaW5pbXVtV2lkdGgiLCJsYXp5TGluayIsInRyYW5zZm9ybUVtaXR0ZXIiLCJhZGRMaXN0ZW5lciIsInByZWZlcnJlZFdpZHRoIiwiYXNzZXJ0IiwidmFsdWUiLCJpc0Zpbml0ZSIsImxvY2FsUHJlZmVycmVkV2lkdGgiLCJtaW5pbXVtV2lkdGgiLCJsb2NhbE1pbmltdW1XaWR0aCIsIndpZHRoU2l6YWJsZSIsImV4dGVuZHNXaWR0aFNpemFibGUiLCJ2YWxpZGF0ZUxvY2FsUHJlZmVycmVkV2lkdGgiLCJjdXJyZW50V2lkdGgiLCJsb2NhbFdpZHRoIiwiZWZmZWN0aXZlTWluaW11bVdpZHRoIiwiaWRlYWxXaWR0aCIsIk1hdGgiLCJhYnMiLCJfY2FsY3VsYXRlTG9jYWxQcmVmZXJyZWRXaWR0aCIsIm1hdHJpeCIsImlzQWxpZ25lZCIsInRyYW5zZm9ybSIsImludmVyc2VEZWx0YVgiLCJfb25SZWVudHJhbnRQcmVmZXJyZWRXaWR0aCIsImF1ZGl0TWF4RGltZW5zaW9ucyIsIl9jYWxjdWxhdGVQcmVmZXJyZWRXaWR0aCIsInRyYW5zZm9ybURlbHRhWCIsIl9jYWxjdWxhdGVMb2NhbE1pbmltdW1XaWR0aCIsIl9vblJlZW50cmFudExvY2FsTWluaW11bVdpZHRoIiwiX2NhbGN1bGF0ZU1pbmltdW1XaWR0aCIsIm11dGF0ZSIsIm9wdGlvbnMiLCJwcm90b3R5cGUiLCJfbXV0YXRvcktleXMiLCJleGlzdGluZ0tleXMiLCJuZXdLZXlzIiwiaW5kZXhPZkJvdW5kc0Jhc2VkT3B0aW9ucyIsImluZGV4T2YiLCJzbGljZSIsImlzV2lkdGhTaXphYmxlIiwibm9kZSIsInJlZ2lzdGVyIl0sInNvdXJjZXMiOlsiV2lkdGhTaXphYmxlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDIxLTIwMjQsIFVuaXZlcnNpdHkgb2YgQ29sb3JhZG8gQm91bGRlclxyXG5cclxuLyoqXHJcbiAqIFdpZHRoU2l6YWJsZSBpcyBhIHRyYWl0IHRoYXQgcHJvdmlkZXMgYSBtaW5pbXVtIGFuZCBwcmVmZXJyZWQgd2lkdGguIFRoZSBtaW5pbXVtIHdpZHRoIGlzIHNldCBieSB0aGUgY29tcG9uZW50LFxyXG4gKiBzbyB0aGF0IGxheW91dCBjb250YWluZXJzIGNvdWxkIGtub3cgaG93IFwic21hbGxcIiB0aGUgY29tcG9uZW50IGNhbiBiZSBtYWRlLiBUaGUgcHJlZmVycmVkIHdpZHRoIGlzIHNldCBieSB0aGVcclxuICogbGF5b3V0IGNvbnRhaW5lciwgYW5kIHRoZSBjb21wb25lbnQgc2hvdWxkIGFkanVzdCBpdHMgc2l6ZSBzbyB0aGF0IGl0IHRha2VzIHVwIHRoYXQgd2lkdGguXHJcbiAqXHJcbiAqIEBhdXRob3IgSm9uYXRoYW4gT2xzb24gPGpvbmF0aGFuLm9sc29uQGNvbG9yYWRvLmVkdT5cclxuICovXHJcblxyXG5pbXBvcnQgVGlueVByb3BlcnR5IGZyb20gJy4uLy4uLy4uL2F4b24vanMvVGlueVByb3BlcnR5LmpzJztcclxuaW1wb3J0IG1lbW9pemUgZnJvbSAnLi4vLi4vLi4vcGhldC1jb3JlL2pzL21lbW9pemUuanMnO1xyXG5pbXBvcnQgeyBEZWxheWVkTXV0YXRlLCBOb2RlLCBSRVFVSVJFU19CT1VORFNfT1BUSU9OX0tFWVMsIHNjZW5lcnkgfSBmcm9tICcuLi9pbXBvcnRzLmpzJztcclxuaW1wb3J0IENvbnN0cnVjdG9yIGZyb20gJy4uLy4uLy4uL3BoZXQtY29yZS9qcy90eXBlcy9Db25zdHJ1Y3Rvci5qcyc7XHJcbmltcG9ydCBJbnRlbnRpb25hbEFueSBmcm9tICcuLi8uLi8uLi9waGV0LWNvcmUvanMvdHlwZXMvSW50ZW50aW9uYWxBbnkuanMnO1xyXG5cclxuLy8gUG9zaXRpb24gY2hhbmdlcyBzbWFsbGVyIHRoYW4gdGhpcyB3aWxsIGJlIGlnbm9yZWRcclxuY29uc3QgQ0hBTkdFX1BPU0lUSU9OX1RIUkVTSE9MRCA9IDFlLTk7XHJcblxyXG5leHBvcnQgY29uc3QgV0lEVEhfU0laQUJMRV9PUFRJT05fS0VZUyA9IFtcclxuICAncHJlZmVycmVkV2lkdGgnLFxyXG4gICdtaW5pbXVtV2lkdGgnLFxyXG4gICdsb2NhbFByZWZlcnJlZFdpZHRoJyxcclxuICAnbG9jYWxNaW5pbXVtV2lkdGgnLFxyXG4gICd3aWR0aFNpemFibGUnXHJcbl07XHJcblxyXG5leHBvcnQgdHlwZSBXaWR0aFNpemFibGVPcHRpb25zID0ge1xyXG4gIC8vIFNldHMgdGhlIHByZWZlcnJlZCB3aWR0aCBvZiB0aGUgTm9kZSBpbiB0aGUgcGFyZW50IGNvb3JkaW5hdGUgZnJhbWUuIE5vZGVzIHRoYXQgaW1wbGVtZW50IHRoaXMgd2lsbCBhdHRlbXB0IHRvIGtlZXBcclxuICAvLyB0aGVpciBgbm9kZS53aWR0aGAgYXQgdGhpcyB2YWx1ZS4gSWYgbnVsbCwgdGhlIG5vZGUgd2lsbCBsaWtlbHkgc2V0IGl0cyBjb25maWd1cmF0aW9uIHRvIHRoZSBtaW5pbXVtIHdpZHRoLlxyXG4gIC8vIE5PVEU6IGNoYW5naW5nIHRoaXMgb3IgbG9jYWxQcmVmZXJyZWRXaWR0aCB3aWxsIGFkanVzdCB0aGUgb3RoZXIuXHJcbiAgLy8gTk9URTogcHJlZmVycmVkV2lkdGggaXMgbm90IGd1YXJhbnRlZWQgY3VycmVudGx5LiBUaGUgY29tcG9uZW50IG1heSBlbmQgdXAgaGF2aW5nIGEgc21hbGxlciBvciBsYXJnZXIgc2l6ZVxyXG4gIHByZWZlcnJlZFdpZHRoPzogbnVtYmVyIHwgbnVsbDtcclxuXHJcbiAgLy8gU2V0cyB0aGUgbWluaW11bSB3aWR0aCBvZiB0aGUgTm9kZSBpbiB0aGUgcGFyZW50IGNvb3JkaW5hdGUgZnJhbWUuIFVzdWFsbHkgbm90IGRpcmVjdGx5IHNldCBieSBhIGNsaWVudC5cclxuICAvLyBVc3VhbGx5IGEgcmVzaXphYmxlIE5vZGUgd2lsbCBzZXQgaXRzIGxvY2FsTWluaW11bVdpZHRoIChhbmQgdGhhdCB3aWxsIGdldCB0cmFuc2ZlcnJlZCB0byB0aGlzIHZhbHVlIGluIHRoZVxyXG4gIC8vIHBhcmVudCBjb29yZGluYXRlIGZyYW1lKS5cclxuICAvLyBOT1RFOiBjaGFuZ2luZyB0aGlzIG9yIGxvY2FsTWluaW11bVdpZHRoIHdpbGwgYWRqdXN0IHRoZSBvdGhlci5cclxuICAvLyBOT1RFOiB3aGVuIHRoZSBOb2RlJ3MgdHJhbnNmb3JtIGlzIHVwZGF0ZWQsIHRoaXMgdmFsdWUgaXMgcmVjb21wdXRlZCBiYXNlZCBvbiBsb2NhbE1pbmltdW1XaWR0aFxyXG4gIG1pbmltdW1XaWR0aD86IG51bWJlciB8IG51bGw7XHJcblxyXG4gIC8vIFNldHMgdGhlIHByZWZlcnJlZCB3aWR0aCBvZiB0aGUgTm9kZSBpbiB0aGUgbG9jYWwgY29vcmRpbmF0ZSBmcmFtZS5cclxuICAvLyBOT1RFOiBjaGFuZ2luZyB0aGlzIG9yIHByZWZlcnJlZFdpZHRoIHdpbGwgYWRqdXN0IHRoZSBvdGhlci5cclxuICAvLyBOT1RFOiB3aGVuIHRoZSBOb2RlJ3MgdHJhbnNmb3JtIGlzIHVwZGF0ZWQsIHRoaXMgdmFsdWUgaXMgcmVjb21wdXRlZCBiYXNlZCBvbiBwcmVmZXJyZWRXaWR0aFxyXG4gIC8vIE5PVEU6IGxvY2FsUHJlZmVycmVkV2lkdGggaXMgbm90IGd1YXJhbnRlZWQgY3VycmVudGx5LiBUaGUgY29tcG9uZW50IG1heSBlbmQgdXAgaGF2aW5nIGEgc21hbGxlciBvciBsYXJnZXIgc2l6ZVxyXG4gIGxvY2FsUHJlZmVycmVkV2lkdGg/OiBudW1iZXIgfCBudWxsO1xyXG5cclxuICAvLyBTZXRzIHRoZSBtaW5pbXVtIHdpZHRoIG9mIHRoZSBOb2RlIGluIHRoZSBsb2NhbCBjb29yZGluYXRlIGZyYW1lLiBVc3VhbGx5IHNldCBieSB0aGUgcmVzaXphYmxlIE5vZGUgaXRzZWxmIHRvXHJcbiAgLy8gaW5kaWNhdGUgd2hhdCBwcmVmZXJyZWQgc2l6ZXMgYXJlIHBvc3NpYmxlLlxyXG4gIC8vIE5PVEU6IGNoYW5naW5nIHRoaXMgb3IgbWluaW11bVdpZHRoIHdpbGwgYWRqdXN0IHRoZSBvdGhlci5cclxuICBsb2NhbE1pbmltdW1XaWR0aD86IG51bWJlciB8IG51bGw7XHJcblxyXG4gIC8vIFdoZXRoZXIgdGhpcyBjb21wb25lbnQgd2lsbCBoYXZlIGl0cyBwcmVmZXJyZWQgc2l6ZSBzZXQgYnkgdGhpbmdzIGxpa2UgbGF5b3V0IGNvbnRhaW5lcnMuIElmIHRoaXMgaXMgc2V0IHRvIGZhbHNlLFxyXG4gIC8vIGl0J3MgcmVjb21tZW5kZWQgdG8gc2V0IHNvbWUgc29ydCBvZiBwcmVmZXJyZWQgc2l6ZSAoc28gdGhhdCBpdCB3b24ndCBnbyB0byAwKVxyXG4gIHdpZHRoU2l6YWJsZT86IGJvb2xlYW47XHJcbn07XHJcblxyXG5leHBvcnQgdHlwZSBUV2lkdGhTaXphYmxlID0ge1xyXG4gIHJlYWRvbmx5IHByZWZlcnJlZFdpZHRoUHJvcGVydHk6IFRpbnlQcm9wZXJ0eTxudW1iZXIgfCBudWxsPjtcclxuICByZWFkb25seSBtaW5pbXVtV2lkdGhQcm9wZXJ0eTogVGlueVByb3BlcnR5PG51bWJlciB8IG51bGw+O1xyXG4gIHJlYWRvbmx5IGxvY2FsUHJlZmVycmVkV2lkdGhQcm9wZXJ0eTogVGlueVByb3BlcnR5PG51bWJlciB8IG51bGw+O1xyXG4gIHJlYWRvbmx5IGxvY2FsTWluaW11bVdpZHRoUHJvcGVydHk6IFRpbnlQcm9wZXJ0eTxudW1iZXIgfCBudWxsPjtcclxuICByZWFkb25seSBpc1dpZHRoUmVzaXphYmxlUHJvcGVydHk6IFRpbnlQcm9wZXJ0eTxib29sZWFuPjtcclxuICBwcmVmZXJyZWRXaWR0aDogbnVtYmVyIHwgbnVsbDtcclxuICBsb2NhbFByZWZlcnJlZFdpZHRoOiBudW1iZXIgfCBudWxsO1xyXG4gIG1pbmltdW1XaWR0aDogbnVtYmVyIHwgbnVsbDtcclxuICBsb2NhbE1pbmltdW1XaWR0aDogbnVtYmVyIHwgbnVsbDtcclxuICB3aWR0aFNpemFibGU6IGJvb2xlYW47XHJcbiAgZ2V0IGV4dGVuZHNXaWR0aFNpemFibGUoKTogYm9vbGVhbjtcclxuICB2YWxpZGF0ZUxvY2FsUHJlZmVycmVkV2lkdGgoKTogdm9pZDtcclxuXHJcbiAgLy8gQG1peGluLXByb3RlY3RlZCAtIG1hZGUgcHVibGljIGZvciB1c2UgaW4gdGhlIG1peGluIG9ubHlcclxuICBfcHJlZmVycmVkU2l6ZUNoYW5naW5nOiBib29sZWFuO1xyXG4gIF9taW5pbXVtU2l6ZUNoYW5naW5nOiBib29sZWFuO1xyXG4gIF9wcmVmZXJyZWRTaXplQ2hhbmdlQXR0ZW1wdER1cmluZ0xvY2s6IGJvb2xlYW47XHJcbiAgX21pbmltdW1TaXplQ2hhbmdlQXR0ZW1wdER1cmluZ0xvY2s6IGJvb2xlYW47XHJcbiAgX3VwZGF0ZVByZWZlcnJlZFdpZHRoTGlzdGVuZXI6ICgpID0+IHZvaWQ7XHJcbiAgX3VwZGF0ZUxvY2FsUHJlZmVycmVkV2lkdGhMaXN0ZW5lcjogKCkgPT4gdm9pZDtcclxuICBfdXBkYXRlTWluaW11bVdpZHRoTGlzdGVuZXI6ICgpID0+IHZvaWQ7XHJcbiAgX3VwZGF0ZUxvY2FsTWluaW11bVdpZHRoTGlzdGVuZXI6ICgpID0+IHZvaWQ7XHJcbiAgX2NhbGN1bGF0ZUxvY2FsUHJlZmVycmVkV2lkdGgoKTogbnVtYmVyIHwgbnVsbDtcclxuICBfb25SZWVudHJhbnRQcmVmZXJyZWRXaWR0aCgpOiB2b2lkO1xyXG4gIF9jYWxjdWxhdGVQcmVmZXJyZWRXaWR0aCgpOiBudW1iZXIgfCBudWxsO1xyXG4gIF9jYWxjdWxhdGVMb2NhbE1pbmltdW1XaWR0aCgpOiBudW1iZXIgfCBudWxsO1xyXG4gIF9vblJlZW50cmFudExvY2FsTWluaW11bVdpZHRoKCk6IHZvaWQ7XHJcbiAgX2NhbGN1bGF0ZU1pbmltdW1XaWR0aCgpOiBudW1iZXIgfCBudWxsO1xyXG59O1xyXG5cclxuLy8gSU1QT1JUQU5UOiBJZiB5b3UncmUgY29tYmluaW5nIHRoaXMgaW4sIHR5cGljYWxseSBkb24ndCBwYXNzIG9wdGlvbnMgdGhhdCBXaWR0aFNpemFibGUgd291bGQgdGFrZSB0aHJvdWdoIHRoZVxyXG4vLyBjb25zdHJ1Y3Rvci4gSXQgd2lsbCBoaXQgTm9kZSdzIG11dGF0ZSgpIGxpa2VseSwgYW5kIHRoZW4gd2lsbCBmYWlsIGJlY2F1c2Ugd2UgaGF2ZW4ndCBiZWVuIGFibGUgdG8gc2V0IHRoZVxyXG4vLyB2YWx1ZXMgeWV0LiBJZiB5b3UncmUgbWFraW5nIHNvbWV0aGluZyBXaWR0aFNpemFibGUsIHBsZWFzZSB1c2UgYSBsYXRlciBtdXRhdGUoKSB0byBwYXNzIHRoZXNlIG9wdGlvbnMgdGhyb3VnaC5cclxuLy8gVGhleSBXSUxMIGJlIGNhdWdodCBieSBhc3NlcnRpb25zIGlmIHNvbWVvbmUgYWRkcyBvbmUgb2YgdGhvc2Ugb3B0aW9ucywgYnV0IGl0IGNvdWxkIGJlIGEgc2lsZW50IGJ1ZyBpZiBubyBvbmVcclxuLy8gaXMgeWV0IHBhc3NpbmcgdGhvc2Ugb3B0aW9ucyB0aHJvdWdoLlxyXG5jb25zdCBXaWR0aFNpemFibGUgPSBtZW1vaXplKCA8U3VwZXJUeXBlIGV4dGVuZHMgQ29uc3RydWN0b3I8Tm9kZT4+KCBUeXBlOiBTdXBlclR5cGUgKTogU3VwZXJUeXBlICYgQ29uc3RydWN0b3I8VFdpZHRoU2l6YWJsZT4gPT4ge1xyXG4gIGNvbnN0IFdpZHRoU2l6YWJsZVRyYWl0ID0gRGVsYXllZE11dGF0ZSggJ1dpZHRoU2l6YWJsZScsIFdJRFRIX1NJWkFCTEVfT1BUSU9OX0tFWVMsXHJcbiAgICBjbGFzcyBXaWR0aFNpemFibGVUcmFpdCBleHRlbmRzIFR5cGUgaW1wbGVtZW50cyBUV2lkdGhTaXphYmxlIHtcclxuXHJcbiAgICAgIC8vIHBhcmVudC9sb2NhbCBwcmVmZXJyZWQvbWluaW11bSBQcm9wZXJ0aWVzLiBTZWUgdGhlIG9wdGlvbnMgYWJvdmUgZm9yIG1vcmUgZG9jdW1lbnRhdGlvblxyXG4gICAgICBwdWJsaWMgcmVhZG9ubHkgcHJlZmVycmVkV2lkdGhQcm9wZXJ0eTogVGlueVByb3BlcnR5PG51bWJlciB8IG51bGw+ID0gbmV3IFRpbnlQcm9wZXJ0eTxudW1iZXIgfCBudWxsPiggbnVsbCApO1xyXG4gICAgICBwdWJsaWMgcmVhZG9ubHkgbWluaW11bVdpZHRoUHJvcGVydHk6IFRpbnlQcm9wZXJ0eTxudW1iZXIgfCBudWxsPiA9IG5ldyBUaW55UHJvcGVydHk8bnVtYmVyIHwgbnVsbD4oIG51bGwgKTtcclxuICAgICAgcHVibGljIHJlYWRvbmx5IGxvY2FsUHJlZmVycmVkV2lkdGhQcm9wZXJ0eTogVGlueVByb3BlcnR5PG51bWJlciB8IG51bGw+ID0gbmV3IFRpbnlQcm9wZXJ0eTxudW1iZXIgfCBudWxsPiggbnVsbCApO1xyXG4gICAgICBwdWJsaWMgcmVhZG9ubHkgbG9jYWxNaW5pbXVtV2lkdGhQcm9wZXJ0eTogVGlueVByb3BlcnR5PG51bWJlciB8IG51bGw+ID0gbmV3IFRpbnlQcm9wZXJ0eTxudW1iZXIgfCBudWxsPiggbnVsbCApO1xyXG4gICAgICBwdWJsaWMgcmVhZG9ubHkgaXNXaWR0aFJlc2l6YWJsZVByb3BlcnR5OiBUaW55UHJvcGVydHk8Ym9vbGVhbj4gPSBuZXcgVGlueVByb3BlcnR5PGJvb2xlYW4+KCB0cnVlICk7XHJcblxyXG4gICAgICAvLyBGbGFncyBzbyB0aGF0IHdlIGNhbiBjaGFuZ2Ugb25lIChwYXJlbnQvbG9jYWwpIHZhbHVlIGFuZCBub3QgZW50ZXIgYW4gaW5maW5pdGUgbG9vcCBjaGFuZ2luZyB0aGUgb3RoZXJzLlxyXG4gICAgICAvLyBXZSB3YW50IHRvIGxvY2sgb3V0IGFsbCBvdGhlciBsb2NhbCBvciBub24tbG9jYWwgcHJlZmVycmVkIG1pbmltdW0gc2l6ZXMsIHdoZXRoZXIgaW4gSGVpZ2h0U2l6YWJsZSBvciBXaWR0aFNpemFibGVcclxuICAgICAgLy8gTk9URTogV2UgYXJlIG1lcmdpbmcgZGVjbGFyYXRpb25zIGJldHdlZW4gSGVpZ2h0U2l6YWJsZSBhbmQgV2lkdGhTaXphYmxlLiBJZiBTaXphYmxlIGlzIHVzZWQgdGhlc2UgZmxhZ3NcclxuICAgICAgLy8gd2lsbCBiZSBzaGFyZWQgYnkgYm90aCBIZWlnaHRTaXphYmxlIGFuZCBXaWR0aFNpemFibGUuXHJcbiAgICAgIC8vIEBtaXhpbi1wcm90ZWN0ZWQgLSBtYWRlIHB1YmxpYyBmb3IgdXNlIGluIHRoZSBtaXhpbiBvbmx5XHJcbiAgICAgIHB1YmxpYyBfcHJlZmVycmVkU2l6ZUNoYW5naW5nID0gZmFsc2U7XHJcbiAgICAgIC8vIEBtaXhpbi1wcm90ZWN0ZWQgLSBtYWRlIHB1YmxpYyBmb3IgdXNlIGluIHRoZSBtaXhpbiBvbmx5XHJcbiAgICAgIHB1YmxpYyBfbWluaW11bVNpemVDaGFuZ2luZyA9IGZhbHNlO1xyXG5cclxuICAgICAgLy8gV2UnbGwgbmVlZCB0byBkZXRlY3QgcmVlbnRyYW5jeSB3aGVuIHNldHRpbmcgdGhlIGR1YWwgb2YgdGhlIHByZWZlcnJlZC9taW5pbXVtIHByb3BlcnRpZXMgKGUuZy4gbG9jYWwgdnMgcGFyZW50KS5cclxuICAgICAgLy8gSWYgd2UgZ2V0IGEgcmVlbnRyYW50IGNhc2UsIHdlJ2xsIG5lZWQgdG8gZGV0ZWN0IGl0IGFuZCBjbGVhciB0aGluZ3MgdXAgYXQgdGhlIGVuZCAodXBkYXRpbmcgdGhlIG1pbmltdW0gc2l6ZVxyXG4gICAgICAvLyBpbiB0aGUgcGFyZW50IGNvb3JkaW5hdGUgZnJhbWUsIGFuZCB0aGUgcHJlZmVycmVkIHNpemUgaW4gdGhlIGxvY2FsIGNvb3JkaW5hdGUgZnJhbWUpLlxyXG4gICAgICAvLyBBbiBleGFtcGxlIGlzIGlmIHRoZSBtaW5pbXVtIHNpemUgaXMgc2V0LCBhbmQgdGhhdCB0cmlnZ2VycyBhIGxpc3RlbmVyIHRoYXQgVVBEQVRFUyBzb21ldGhpbmcgdGhhdCBjaGFuZ2VzIHRoZVxyXG4gICAgICAvLyBtaW5pbXVtIHNpemUsIHdlJ2xsIG5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIGxvY2FsIG1pbmltdW0gc2l6ZSBpcyB1cGRhdGVkIEFGVEVSIGV2ZXJ5dGhpbmcgaGFzIGhhcHBlbmVkLlxyXG4gICAgICAvLyBUaGVzZSBsb2NrcyBhcmUgdXNlZCB0byBkZXRlY3QgdGhlc2UgY2FzZXMsIGFuZCB0aGVuIHJ1biB0aGUgYXBwcm9wcmlhdGUgdXBkYXRlcyBhZnRlcndhcmQgdG8gbWFrZSBzdXJlIHRoYXQgdGhlXHJcbiAgICAgIC8vIGxvY2FsIGFuZCBwYXJlbnQgdmFsdWVzIGFyZSBpbiBzeW5jIChiYXNlZCBvbiB0aGUgdHJhbnNmb3JtIHVzZWQpLlxyXG4gICAgICAvLyBAbWl4aW4tcHJvdGVjdGVkIC0gbWFkZSBwdWJsaWMgZm9yIHVzZSBpbiB0aGUgbWl4aW4gb25seVxyXG4gICAgICBwdWJsaWMgX3ByZWZlcnJlZFNpemVDaGFuZ2VBdHRlbXB0RHVyaW5nTG9jayA9IGZhbHNlO1xyXG4gICAgICAvLyBAbWl4aW4tcHJvdGVjdGVkIC0gbWFkZSBwdWJsaWMgZm9yIHVzZSBpbiB0aGUgbWl4aW4gb25seVxyXG4gICAgICBwdWJsaWMgX21pbmltdW1TaXplQ2hhbmdlQXR0ZW1wdER1cmluZ0xvY2sgPSBmYWxzZTtcclxuXHJcbiAgICAgIC8vIEV4cG9zZSBsaXN0ZW5lcnMsIHNvIHRoYXQgd2UnbGwgYmUgYWJsZSB0byBob29rIHRoZW0gdXAgdG8gdGhlIG9wcG9zaXRlIGRpbWVuc2lvbiBpbiBTaXphYmxlXHJcbiAgICAgIC8vIEBtaXhpbi1wcm90ZWN0ZWQgLSBtYWRlIHB1YmxpYyBmb3IgdXNlIGluIHRoZSBtaXhpbiBvbmx5XHJcbiAgICAgIHB1YmxpYyBfdXBkYXRlUHJlZmVycmVkV2lkdGhMaXN0ZW5lcjogKCkgPT4gdm9pZDtcclxuICAgICAgLy8gQG1peGluLXByb3RlY3RlZCAtIG1hZGUgcHVibGljIGZvciB1c2UgaW4gdGhlIG1peGluIG9ubHlcclxuICAgICAgcHVibGljIF91cGRhdGVMb2NhbFByZWZlcnJlZFdpZHRoTGlzdGVuZXI6ICgpID0+IHZvaWQ7XHJcbiAgICAgIC8vIEBtaXhpbi1wcm90ZWN0ZWQgLSBtYWRlIHB1YmxpYyBmb3IgdXNlIGluIHRoZSBtaXhpbiBvbmx5XHJcbiAgICAgIHB1YmxpYyBfdXBkYXRlTWluaW11bVdpZHRoTGlzdGVuZXI6ICgpID0+IHZvaWQ7XHJcbiAgICAgIC8vIEBtaXhpbi1wcm90ZWN0ZWQgLSBtYWRlIHB1YmxpYyBmb3IgdXNlIGluIHRoZSBtaXhpbiBvbmx5XHJcbiAgICAgIHB1YmxpYyBfdXBkYXRlTG9jYWxNaW5pbXVtV2lkdGhMaXN0ZW5lcjogKCkgPT4gdm9pZDtcclxuXHJcbiAgICAgIC8vIElNUE9SVEFOVDogSWYgeW91J3JlIGNvbWJpbmluZyB0aGlzIGluLCB0eXBpY2FsbHkgZG9uJ3QgcGFzcyBvcHRpb25zIHRoYXQgV2lkdGhTaXphYmxlIHdvdWxkIHRha2UgdGhyb3VnaCB0aGVcclxuICAgICAgLy8gY29uc3RydWN0b3IuIEl0IHdpbGwgaGl0IE5vZGUncyBtdXRhdGUoKSBsaWtlbHksIGFuZCB0aGVuIHdpbGwgZmFpbCBiZWNhdXNlIHdlIGhhdmVuJ3QgYmVlbiBhYmxlIHRvIHNldCB0aGVcclxuICAgICAgLy8gdmFsdWVzIHlldC4gSWYgeW91J3JlIG1ha2luZyBzb21ldGhpbmcgV2lkdGhTaXphYmxlLCBwbGVhc2UgdXNlIGEgbGF0ZXIgbXV0YXRlKCkgdG8gcGFzcyB0aGVzZSBvcHRpb25zIHRocm91Z2guXHJcbiAgICAgIC8vIFRoZXkgV0lMTCBiZSBjYXVnaHQgYnkgYXNzZXJ0aW9ucyBpZiBzb21lb25lIGFkZHMgb25lIG9mIHRob3NlIG9wdGlvbnMsIGJ1dCBpdCBjb3VsZCBiZSBhIHNpbGVudCBidWcgaWYgbm8gb25lXHJcbiAgICAgIC8vIGlzIHlldCBwYXNzaW5nIHRob3NlIG9wdGlvbnMgdGhyb3VnaC5cclxuICAgICAgcHVibGljIGNvbnN0cnVjdG9yKCAuLi5hcmdzOiBJbnRlbnRpb25hbEFueVtdICkge1xyXG4gICAgICAgIHN1cGVyKCAuLi5hcmdzICk7XHJcblxyXG4gICAgICAgIHRoaXMuX3VwZGF0ZVByZWZlcnJlZFdpZHRoTGlzdGVuZXIgPSB0aGlzLl91cGRhdGVQcmVmZXJyZWRXaWR0aC5iaW5kKCB0aGlzICk7XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlTG9jYWxQcmVmZXJyZWRXaWR0aExpc3RlbmVyID0gdGhpcy5fdXBkYXRlTG9jYWxQcmVmZXJyZWRXaWR0aC5iaW5kKCB0aGlzICk7XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlTWluaW11bVdpZHRoTGlzdGVuZXIgPSB0aGlzLl91cGRhdGVNaW5pbXVtV2lkdGguYmluZCggdGhpcyApO1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZUxvY2FsTWluaW11bVdpZHRoTGlzdGVuZXIgPSB0aGlzLl91cGRhdGVMb2NhbE1pbmltdW1XaWR0aC5iaW5kKCB0aGlzICk7XHJcblxyXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgb3Bwb3NpdGUgb2YgcGFyZW50L2xvY2FsIHdoZW4gb25lIGNoYW5nZXNcclxuICAgICAgICB0aGlzLnByZWZlcnJlZFdpZHRoUHJvcGVydHkubGF6eUxpbmsoIHRoaXMuX3VwZGF0ZUxvY2FsUHJlZmVycmVkV2lkdGhMaXN0ZW5lciApO1xyXG4gICAgICAgIHRoaXMubG9jYWxQcmVmZXJyZWRXaWR0aFByb3BlcnR5LmxhenlMaW5rKCB0aGlzLl91cGRhdGVQcmVmZXJyZWRXaWR0aExpc3RlbmVyICk7XHJcbiAgICAgICAgdGhpcy5taW5pbXVtV2lkdGhQcm9wZXJ0eS5sYXp5TGluayggdGhpcy5fdXBkYXRlTG9jYWxNaW5pbXVtV2lkdGhMaXN0ZW5lciApO1xyXG4gICAgICAgIHRoaXMubG9jYWxNaW5pbXVtV2lkdGhQcm9wZXJ0eS5sYXp5TGluayggdGhpcy5fdXBkYXRlTWluaW11bVdpZHRoTGlzdGVuZXIgKTtcclxuXHJcbiAgICAgICAgLy8gT24gYSB0cmFuc2Zvcm0gY2hhbmdlLCBrZWVwIG91ciBsb2NhbCBtaW5pbXVtIChwcmVzdW1hYmx5IHVuY2hhbmdlZCksIGFuZCBvdXIgcGFyZW50IHByZWZlcnJlZCBzaXplXHJcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1FbWl0dGVyLmFkZExpc3RlbmVyKCB0aGlzLl91cGRhdGVMb2NhbFByZWZlcnJlZFdpZHRoTGlzdGVuZXIgKTtcclxuICAgICAgICAvLyBPbiBhIHRyYW5zZm9ybSBjaGFuZ2UgdGhpcyBzaG91bGQgdXBkYXRlIHRoZSBtaW5pbXVtXHJcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1FbWl0dGVyLmFkZExpc3RlbmVyKCB0aGlzLl91cGRhdGVNaW5pbXVtV2lkdGhMaXN0ZW5lciApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBwdWJsaWMgZ2V0IHByZWZlcnJlZFdpZHRoKCk6IG51bWJlciB8IG51bGwge1xyXG4gICAgICAgIGFzc2VydCAmJiBhc3NlcnQoIHRoaXMucHJlZmVycmVkV2lkdGhQcm9wZXJ0eSxcclxuICAgICAgICAgICdXaWR0aFNpemFibGUgb3B0aW9ucyBzaG91bGQgYmUgc2V0IGZyb20gYSBsYXRlciBtdXRhdGUoKSBjYWxsIGluc3RlYWQgb2YgdGhlIHN1cGVyIGNvbnN0cnVjdG9yJyApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5wcmVmZXJyZWRXaWR0aFByb3BlcnR5LnZhbHVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBwdWJsaWMgc2V0IHByZWZlcnJlZFdpZHRoKCB2YWx1ZTogbnVtYmVyIHwgbnVsbCApIHtcclxuICAgICAgICBhc3NlcnQgJiYgYXNzZXJ0KCB0aGlzLnByZWZlcnJlZFdpZHRoUHJvcGVydHksXHJcbiAgICAgICAgICAnV2lkdGhTaXphYmxlIG9wdGlvbnMgc2hvdWxkIGJlIHNldCBmcm9tIGEgbGF0ZXIgbXV0YXRlKCkgY2FsbCBpbnN0ZWFkIG9mIHRoZSBzdXBlciBjb25zdHJ1Y3RvcicgKTtcclxuICAgICAgICBhc3NlcnQgJiYgYXNzZXJ0KCB2YWx1ZSA9PT0gbnVsbCB8fCAoIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUoIHZhbHVlICkgJiYgdmFsdWUgPj0gMCApLFxyXG4gICAgICAgICAgJ3ByZWZlcnJlZFdpZHRoIHNob3VsZCBiZSBudWxsIG9yIGEgbm9uLW5lZ2F0aXZlIGZpbml0ZSBudW1iZXInICk7XHJcblxyXG4gICAgICAgIHRoaXMucHJlZmVycmVkV2lkdGhQcm9wZXJ0eS52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBwdWJsaWMgZ2V0IGxvY2FsUHJlZmVycmVkV2lkdGgoKTogbnVtYmVyIHwgbnVsbCB7XHJcbiAgICAgICAgYXNzZXJ0ICYmIGFzc2VydCggdGhpcy5sb2NhbFByZWZlcnJlZFdpZHRoUHJvcGVydHksXHJcbiAgICAgICAgICAnV2lkdGhTaXphYmxlIG9wdGlvbnMgc2hvdWxkIGJlIHNldCBmcm9tIGEgbGF0ZXIgbXV0YXRlKCkgY2FsbCBpbnN0ZWFkIG9mIHRoZSBzdXBlciBjb25zdHJ1Y3RvcicgKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbFByZWZlcnJlZFdpZHRoUHJvcGVydHkudmFsdWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHB1YmxpYyBzZXQgbG9jYWxQcmVmZXJyZWRXaWR0aCggdmFsdWU6IG51bWJlciB8IG51bGwgKSB7XHJcbiAgICAgICAgYXNzZXJ0ICYmIGFzc2VydCggdGhpcy5sb2NhbFByZWZlcnJlZFdpZHRoUHJvcGVydHksXHJcbiAgICAgICAgICAnV2lkdGhTaXphYmxlIG9wdGlvbnMgc2hvdWxkIGJlIHNldCBmcm9tIGEgbGF0ZXIgbXV0YXRlKCkgY2FsbCBpbnN0ZWFkIG9mIHRoZSBzdXBlciBjb25zdHJ1Y3RvcicgKTtcclxuICAgICAgICBhc3NlcnQgJiYgYXNzZXJ0KCB2YWx1ZSA9PT0gbnVsbCB8fCAoIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUoIHZhbHVlICkgJiYgdmFsdWUgPj0gMCApLFxyXG4gICAgICAgICAgJ2xvY2FsUHJlZmVycmVkV2lkdGggc2hvdWxkIGJlIG51bGwgb3IgYSBub24tbmVnYXRpdmUgZmluaXRlIG51bWJlcicgKTtcclxuXHJcbiAgICAgICAgdGhpcy5sb2NhbFByZWZlcnJlZFdpZHRoUHJvcGVydHkudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcHVibGljIGdldCBtaW5pbXVtV2lkdGgoKTogbnVtYmVyIHwgbnVsbCB7XHJcbiAgICAgICAgYXNzZXJ0ICYmIGFzc2VydCggdGhpcy5taW5pbXVtV2lkdGhQcm9wZXJ0eSxcclxuICAgICAgICAgICdXaWR0aFNpemFibGUgb3B0aW9ucyBzaG91bGQgYmUgc2V0IGZyb20gYSBsYXRlciBtdXRhdGUoKSBjYWxsIGluc3RlYWQgb2YgdGhlIHN1cGVyIGNvbnN0cnVjdG9yJyApO1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1pbmltdW1XaWR0aFByb3BlcnR5LnZhbHVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBwdWJsaWMgc2V0IG1pbmltdW1XaWR0aCggdmFsdWU6IG51bWJlciB8IG51bGwgKSB7XHJcbiAgICAgICAgYXNzZXJ0ICYmIGFzc2VydCggdGhpcy5taW5pbXVtV2lkdGhQcm9wZXJ0eSxcclxuICAgICAgICAgICdXaWR0aFNpemFibGUgb3B0aW9ucyBzaG91bGQgYmUgc2V0IGZyb20gYSBsYXRlciBtdXRhdGUoKSBjYWxsIGluc3RlYWQgb2YgdGhlIHN1cGVyIGNvbnN0cnVjdG9yJyApO1xyXG4gICAgICAgIGFzc2VydCAmJiBhc3NlcnQoIHZhbHVlID09PSBudWxsIHx8ICggdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZSggdmFsdWUgKSApICk7XHJcblxyXG4gICAgICAgIHRoaXMubWluaW11bVdpZHRoUHJvcGVydHkudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcHVibGljIGdldCBsb2NhbE1pbmltdW1XaWR0aCgpOiBudW1iZXIgfCBudWxsIHtcclxuICAgICAgICBhc3NlcnQgJiYgYXNzZXJ0KCB0aGlzLmxvY2FsTWluaW11bVdpZHRoUHJvcGVydHksXHJcbiAgICAgICAgICAnV2lkdGhTaXphYmxlIG9wdGlvbnMgc2hvdWxkIGJlIHNldCBmcm9tIGEgbGF0ZXIgbXV0YXRlKCkgY2FsbCBpbnN0ZWFkIG9mIHRoZSBzdXBlciBjb25zdHJ1Y3RvcicgKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbE1pbmltdW1XaWR0aFByb3BlcnR5LnZhbHVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBwdWJsaWMgc2V0IGxvY2FsTWluaW11bVdpZHRoKCB2YWx1ZTogbnVtYmVyIHwgbnVsbCApIHtcclxuICAgICAgICBhc3NlcnQgJiYgYXNzZXJ0KCB0aGlzLmxvY2FsTWluaW11bVdpZHRoUHJvcGVydHksXHJcbiAgICAgICAgICAnV2lkdGhTaXphYmxlIG9wdGlvbnMgc2hvdWxkIGJlIHNldCBmcm9tIGEgbGF0ZXIgbXV0YXRlKCkgY2FsbCBpbnN0ZWFkIG9mIHRoZSBzdXBlciBjb25zdHJ1Y3RvcicgKTtcclxuICAgICAgICBhc3NlcnQgJiYgYXNzZXJ0KCB2YWx1ZSA9PT0gbnVsbCB8fCAoIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUoIHZhbHVlICkgKSApO1xyXG5cclxuICAgICAgICB0aGlzLmxvY2FsTWluaW11bVdpZHRoUHJvcGVydHkudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcHVibGljIG92ZXJyaWRlIGdldCB3aWR0aFNpemFibGUoKTogYm9vbGVhbiB7XHJcbiAgICAgICAgYXNzZXJ0ICYmIGFzc2VydCggdGhpcy5pc1dpZHRoUmVzaXphYmxlUHJvcGVydHksXHJcbiAgICAgICAgICAnV2lkdGhTaXphYmxlIG9wdGlvbnMgc2hvdWxkIGJlIHNldCBmcm9tIGEgbGF0ZXIgbXV0YXRlKCkgY2FsbCBpbnN0ZWFkIG9mIHRoZSBzdXBlciBjb25zdHJ1Y3RvcicgKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5pc1dpZHRoUmVzaXphYmxlUHJvcGVydHkudmFsdWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHB1YmxpYyBvdmVycmlkZSBzZXQgd2lkdGhTaXphYmxlKCB2YWx1ZTogYm9vbGVhbiApIHtcclxuICAgICAgICBhc3NlcnQgJiYgYXNzZXJ0KCB0aGlzLmlzV2lkdGhSZXNpemFibGVQcm9wZXJ0eSxcclxuICAgICAgICAgICdXaWR0aFNpemFibGUgb3B0aW9ucyBzaG91bGQgYmUgc2V0IGZyb20gYSBsYXRlciBtdXRhdGUoKSBjYWxsIGluc3RlYWQgb2YgdGhlIHN1cGVyIGNvbnN0cnVjdG9yJyApO1xyXG4gICAgICAgIHRoaXMuaXNXaWR0aFJlc2l6YWJsZVByb3BlcnR5LnZhbHVlID0gdmFsdWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHB1YmxpYyBvdmVycmlkZSBnZXQgZXh0ZW5kc1dpZHRoU2l6YWJsZSgpOiBib29sZWFuIHsgcmV0dXJuIHRydWU7IH1cclxuXHJcbiAgICAgIHB1YmxpYyB2YWxpZGF0ZUxvY2FsUHJlZmVycmVkV2lkdGgoKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKCBhc3NlcnQgKSB7XHJcbiAgICAgICAgICBjb25zdCBjdXJyZW50V2lkdGggPSB0aGlzLmxvY2FsV2lkdGg7XHJcbiAgICAgICAgICBjb25zdCBlZmZlY3RpdmVNaW5pbXVtV2lkdGggPSB0aGlzLmxvY2FsTWluaW11bVdpZHRoID09PSBudWxsID8gY3VycmVudFdpZHRoIDogdGhpcy5sb2NhbE1pbmltdW1XaWR0aDtcclxuICAgICAgICAgIGNvbnN0IGlkZWFsV2lkdGggPSB0aGlzLmxvY2FsUHJlZmVycmVkV2lkdGggPT09IG51bGwgPyBlZmZlY3RpdmVNaW5pbXVtV2lkdGggOiB0aGlzLmxvY2FsUHJlZmVycmVkV2lkdGg7XHJcblxyXG4gICAgICAgICAgLy8gSGFuZGxlIG5vbi1maW5pdGUgdmFsdWVzIHdpdGggZXhhY3QgZXF1YWxpdHlcclxuICAgICAgICAgIGFzc2VydCggaWRlYWxXaWR0aCA9PT0gY3VycmVudFdpZHRoIHx8IE1hdGguYWJzKCBpZGVhbFdpZHRoIC0gY3VycmVudFdpZHRoICkgPCAxZS03ICk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBUaGlzIGlzIHByb3ZpZGVkIHRvIGhvb2sgaW50byB0aGUgU2l6YWJsZSB0cmFpdCwgc28gdGhhdCB3ZSBjYW4gdXBkYXRlIHRoZSBvcHBvc2l0ZSBkaW1lbnNpb25cclxuICAgICAgLy8gQG1peGluLXByb3RlY3RlZCAtIG1hZGUgcHVibGljIGZvciB1c2UgaW4gdGhlIG1peGluIG9ubHlcclxuICAgICAgcHVibGljIF9jYWxjdWxhdGVMb2NhbFByZWZlcnJlZFdpZHRoKCk6IG51bWJlciB8IG51bGwge1xyXG4gICAgICAgIHJldHVybiAoIHRoaXMubWF0cml4LmlzQWxpZ25lZCgpICYmIHRoaXMucHJlZmVycmVkV2lkdGggIT09IG51bGwgKVxyXG4gICAgICAgICAgICAgICA/IE1hdGguYWJzKCB0aGlzLnRyYW5zZm9ybS5pbnZlcnNlRGVsdGFYKCB0aGlzLnByZWZlcnJlZFdpZHRoICkgKVxyXG4gICAgICAgICAgICAgICA6IG51bGw7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFByb3ZpZGVzIGEgaG9vayB0byBTaXphYmxlLCBzaW5jZSB3ZSdsbCBuZWVkIHRvIGNyb3NzLWxpbmsgdGhpcyB0byBhbHNvIHRyeSB1cGRhdGluZyB0aGUgb3Bwb3NpdGUgZGltZW5zaW9uXHJcbiAgICAgIC8vIEBtaXhpbi1wcm90ZWN0ZWQgLSBtYWRlIHB1YmxpYyBmb3IgdXNlIGluIHRoZSBtaXhpbiBvbmx5XHJcbiAgICAgIHB1YmxpYyBfb25SZWVudHJhbnRQcmVmZXJyZWRXaWR0aCgpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLl91cGRhdGVMb2NhbFByZWZlcnJlZFdpZHRoTGlzdGVuZXIoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcHJpdmF0ZSBfdXBkYXRlTG9jYWxQcmVmZXJyZWRXaWR0aCgpOiB2b2lkIHtcclxuICAgICAgICBhc3NlcnQgJiYgdGhpcy5hdWRpdE1heERpbWVuc2lvbnMoKTtcclxuXHJcbiAgICAgICAgaWYgKCAhdGhpcy5fcHJlZmVycmVkU2l6ZUNoYW5naW5nICkge1xyXG4gICAgICAgICAgdGhpcy5fcHJlZmVycmVkU2l6ZUNoYW5naW5nID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAvLyBTaW5jZSB0aGUgbG9jYWwgXCJwcmVmZXJyZWRcIiBzaXplIGlzIHRoZSBvbmUgdGhhdCB3ZSdsbCB3YW50IHRvIGNvbnRpbnVlIHRvIHVwZGF0ZSBpZiB3ZSBleHBlcmllbmNlXHJcbiAgICAgICAgICAvLyByZWVudHJhbmN5IChzaW5jZSB3ZSB0cmVhdCB0aGUgbm9uLWxvY2FsIHZlcnNpb24gYXMgdGhlIGdyb3VuZCB0cnV0aCksIHdlJ2xsIGxvb3AgaGVyZSB1bnRpbCB3ZSBkaWRuJ3QgZ2V0XHJcbiAgICAgICAgICAvLyBhbiBhdHRlbXB0IHRvIGNoYW5nZSBpdC4gVGhpcyB3aWxsIGVuc3VyZSB0aGF0IGFmdGVyIGNoYW5nZXMsIHdlJ2xsIGhhdmUgYSBjb25zaXN0ZW50IHByZWZlcnJlZCBhbmRcclxuICAgICAgICAgIC8vIGxvY2FsUHJlZmVycmVkIHNpemUuXHJcbiAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgIHRoaXMuX3ByZWZlcnJlZFNpemVDaGFuZ2VBdHRlbXB0RHVyaW5nTG9jayA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgbG9jYWxQcmVmZXJyZWRXaWR0aCA9IHRoaXMuX2NhbGN1bGF0ZUxvY2FsUHJlZmVycmVkV2lkdGgoKTtcclxuXHJcbiAgICAgICAgICAgIGlmICggdGhpcy5sb2NhbFByZWZlcnJlZFdpZHRoUHJvcGVydHkudmFsdWUgPT09IG51bGwgfHxcclxuICAgICAgICAgICAgICAgICBsb2NhbFByZWZlcnJlZFdpZHRoID09PSBudWxsIHx8XHJcbiAgICAgICAgICAgICAgICAgTWF0aC5hYnMoIHRoaXMubG9jYWxQcmVmZXJyZWRXaWR0aFByb3BlcnR5LnZhbHVlIC0gbG9jYWxQcmVmZXJyZWRXaWR0aCApID4gQ0hBTkdFX1BPU0lUSU9OX1RIUkVTSE9MRCApIHtcclxuICAgICAgICAgICAgICB0aGlzLmxvY2FsUHJlZmVycmVkV2lkdGhQcm9wZXJ0eS52YWx1ZSA9IGxvY2FsUHJlZmVycmVkV2lkdGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHdoaWxlICggdGhpcy5fcHJlZmVycmVkU2l6ZUNoYW5nZUF0dGVtcHREdXJpbmdMb2NrICk7XHJcblxyXG4gICAgICAgICAgdGhpcy5fcHJlZmVycmVkU2l6ZUNoYW5naW5nID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgdGhpcy5fcHJlZmVycmVkU2l6ZUNoYW5nZUF0dGVtcHREdXJpbmdMb2NrID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFRoaXMgaXMgcHJvdmlkZWQgdG8gaG9vayBpbnRvIHRoZSBTaXphYmxlIHRyYWl0LCBzbyB0aGF0IHdlIGNhbiB1cGRhdGUgdGhlIG9wcG9zaXRlIGRpbWVuc2lvblxyXG4gICAgICAvLyBAbWl4aW4tcHJvdGVjdGVkIC0gbWFkZSBwdWJsaWMgZm9yIHVzZSBpbiB0aGUgbWl4aW4gb25seVxyXG4gICAgICBwdWJsaWMgX2NhbGN1bGF0ZVByZWZlcnJlZFdpZHRoKCk6IG51bWJlciB8IG51bGwge1xyXG4gICAgICAgIHJldHVybiAoIHRoaXMubWF0cml4LmlzQWxpZ25lZCgpICYmIHRoaXMubG9jYWxQcmVmZXJyZWRXaWR0aCAhPT0gbnVsbCApXHJcbiAgICAgICAgICAgICAgID8gTWF0aC5hYnMoIHRoaXMudHJhbnNmb3JtLnRyYW5zZm9ybURlbHRhWCggdGhpcy5sb2NhbFByZWZlcnJlZFdpZHRoICkgKVxyXG4gICAgICAgICAgICAgICA6IG51bGw7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHByaXZhdGUgX3VwZGF0ZVByZWZlcnJlZFdpZHRoKCk6IHZvaWQge1xyXG4gICAgICAgIGlmICggIXRoaXMuX3ByZWZlcnJlZFNpemVDaGFuZ2luZyApIHtcclxuICAgICAgICAgIHRoaXMuX3ByZWZlcnJlZFNpemVDaGFuZ2luZyA9IHRydWU7XHJcblxyXG4gICAgICAgICAgdGhpcy5fcHJlZmVycmVkU2l6ZUNoYW5nZUF0dGVtcHREdXJpbmdMb2NrID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgY29uc3QgcHJlZmVycmVkV2lkdGggPSB0aGlzLl9jYWxjdWxhdGVQcmVmZXJyZWRXaWR0aCgpO1xyXG5cclxuICAgICAgICAgIGlmICggdGhpcy5wcmVmZXJyZWRXaWR0aFByb3BlcnR5LnZhbHVlID09PSBudWxsIHx8XHJcbiAgICAgICAgICAgICAgIHByZWZlcnJlZFdpZHRoID09PSBudWxsIHx8XHJcbiAgICAgICAgICAgICAgIE1hdGguYWJzKCB0aGlzLnByZWZlcnJlZFdpZHRoUHJvcGVydHkudmFsdWUgLSBwcmVmZXJyZWRXaWR0aCApID4gQ0hBTkdFX1BPU0lUSU9OX1RIUkVTSE9MRCApIHtcclxuICAgICAgICAgICAgdGhpcy5wcmVmZXJyZWRXaWR0aFByb3BlcnR5LnZhbHVlID0gcHJlZmVycmVkV2lkdGg7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB0aGlzLl9wcmVmZXJyZWRTaXplQ2hhbmdpbmcgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAvLyBIZXJlLCBpbiB0aGUgY2FzZSBvZiByZWVudHJhbmNlLCB3ZSdsbCBhY3R1YWxseSB3YW50IHRvIHN3aXRjaCB0byB1cGRhdGluZyB0aGUgbG9jYWwgcHJlZmVycmVkIHNpemUsIHNpbmNlXHJcbiAgICAgICAgICAvLyBnaXZlbiBhbnkgb3RoZXIgY2hhbmdlcyBpdCBzaG91bGQgYmUgdGhlIHByaW1hcnkgb25lIHRvIGNoYW5nZS5cclxuICAgICAgICAgIGlmICggdGhpcy5fcHJlZmVycmVkU2l6ZUNoYW5nZUF0dGVtcHREdXJpbmdMb2NrICkge1xyXG4gICAgICAgICAgICB0aGlzLl9vblJlZW50cmFudFByZWZlcnJlZFdpZHRoKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgdGhpcy5fcHJlZmVycmVkU2l6ZUNoYW5nZUF0dGVtcHREdXJpbmdMb2NrID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFRoaXMgaXMgcHJvdmlkZWQgdG8gaG9vayBpbnRvIHRoZSBTaXphYmxlIHRyYWl0LCBzbyB0aGF0IHdlIGNhbiB1cGRhdGUgdGhlIG9wcG9zaXRlIGRpbWVuc2lvblxyXG4gICAgICAvLyBAbWl4aW4tcHJvdGVjdGVkIC0gbWFkZSBwdWJsaWMgZm9yIHVzZSBpbiB0aGUgbWl4aW4gb25seVxyXG4gICAgICBwdWJsaWMgX2NhbGN1bGF0ZUxvY2FsTWluaW11bVdpZHRoKCk6IG51bWJlciB8IG51bGwge1xyXG4gICAgICAgIHJldHVybiAoIHRoaXMubWF0cml4LmlzQWxpZ25lZCgpICYmIHRoaXMubWluaW11bVdpZHRoICE9PSBudWxsIClcclxuICAgICAgICAgICAgICAgPyBNYXRoLmFicyggdGhpcy50cmFuc2Zvcm0uaW52ZXJzZURlbHRhWCggdGhpcy5taW5pbXVtV2lkdGggKSApXHJcbiAgICAgICAgICAgICAgIDogbnVsbDtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQG1peGluLXByb3RlY3RlZCAtIG1hZGUgcHVibGljIGZvciB1c2UgaW4gdGhlIG1peGluIG9ubHlcclxuICAgICAgcHVibGljIF9vblJlZW50cmFudExvY2FsTWluaW11bVdpZHRoKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZU1pbmltdW1XaWR0aExpc3RlbmVyKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHByaXZhdGUgX3VwZGF0ZUxvY2FsTWluaW11bVdpZHRoKCk6IHZvaWQge1xyXG4gICAgICAgIGlmICggIXRoaXMuX21pbmltdW1TaXplQ2hhbmdpbmcgKSB7XHJcbiAgICAgICAgICB0aGlzLl9taW5pbXVtU2l6ZUNoYW5naW5nID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICBjb25zdCBsb2NhbE1pbmltdW1XaWR0aCA9IHRoaXMuX2NhbGN1bGF0ZUxvY2FsTWluaW11bVdpZHRoKCk7XHJcblxyXG4gICAgICAgICAgdGhpcy5fbWluaW11bVNpemVDaGFuZ2VBdHRlbXB0RHVyaW5nTG9jayA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgIGlmICggdGhpcy5sb2NhbE1pbmltdW1XaWR0aFByb3BlcnR5LnZhbHVlID09PSBudWxsIHx8XHJcbiAgICAgICAgICAgICAgIGxvY2FsTWluaW11bVdpZHRoID09PSBudWxsIHx8XHJcbiAgICAgICAgICAgICAgIE1hdGguYWJzKCB0aGlzLmxvY2FsTWluaW11bVdpZHRoUHJvcGVydHkudmFsdWUgLSBsb2NhbE1pbmltdW1XaWR0aCApID4gQ0hBTkdFX1BPU0lUSU9OX1RIUkVTSE9MRCApIHtcclxuICAgICAgICAgICAgdGhpcy5sb2NhbE1pbmltdW1XaWR0aFByb3BlcnR5LnZhbHVlID0gbG9jYWxNaW5pbXVtV2lkdGg7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB0aGlzLl9taW5pbXVtU2l6ZUNoYW5naW5nID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgLy8gSGVyZSwgaW4gdGhlIGNhc2Ugb2YgcmVlbnRyYW5jZSwgd2UnbGwgYWN0dWFsbHkgd2FudCB0byBzd2l0Y2ggdG8gdXBkYXRpbmcgdGhlIG5vbi1sb2NhbCBtaW5pbXVtIHNpemUsIHNpbmNlXHJcbiAgICAgICAgICAvLyBnaXZlbiBhbnkgb3RoZXIgY2hhbmdlcyBpdCBzaG91bGQgYmUgdGhlIHByaW1hcnkgb25lIHRvIGNoYW5nZS5cclxuICAgICAgICAgIGlmICggdGhpcy5fbWluaW11bVNpemVDaGFuZ2VBdHRlbXB0RHVyaW5nTG9jayApIHtcclxuICAgICAgICAgICAgdGhpcy5fb25SZWVudHJhbnRMb2NhbE1pbmltdW1XaWR0aCgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgIHRoaXMuX21pbmltdW1TaXplQ2hhbmdlQXR0ZW1wdER1cmluZ0xvY2sgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gVGhpcyBpcyBwcm92aWRlZCB0byBob29rIGludG8gdGhlIFNpemFibGUgdHJhaXQsIHNvIHRoYXQgd2UgY2FuIHVwZGF0ZSB0aGUgb3Bwb3NpdGUgZGltZW5zaW9uXHJcbiAgICAgIC8vIEBtaXhpbi1wcm90ZWN0ZWQgLSBtYWRlIHB1YmxpYyBmb3IgdXNlIGluIHRoZSBtaXhpbiBvbmx5XHJcbiAgICAgIHB1YmxpYyBfY2FsY3VsYXRlTWluaW11bVdpZHRoKCk6IG51bWJlciB8IG51bGwge1xyXG4gICAgICAgIHJldHVybiAoIHRoaXMubWF0cml4LmlzQWxpZ25lZCgpICYmIHRoaXMubG9jYWxNaW5pbXVtV2lkdGggIT09IG51bGwgKVxyXG4gICAgICAgICAgICAgICA/IE1hdGguYWJzKCB0aGlzLnRyYW5zZm9ybS50cmFuc2Zvcm1EZWx0YVgoIHRoaXMubG9jYWxNaW5pbXVtV2lkdGggKSApXHJcbiAgICAgICAgICAgICAgIDogbnVsbDtcclxuICAgICAgfVxyXG5cclxuICAgICAgcHJpdmF0ZSBfdXBkYXRlTWluaW11bVdpZHRoKCk6IHZvaWQge1xyXG4gICAgICAgIGlmICggIXRoaXMuX21pbmltdW1TaXplQ2hhbmdpbmcgKSB7XHJcbiAgICAgICAgICB0aGlzLl9taW5pbXVtU2l6ZUNoYW5naW5nID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAvLyBTaW5jZSB0aGUgbm9uLWxvY2FsIFwibWluaW11bVwiIHNpemUgaXMgdGhlIG9uZSB0aGF0IHdlJ2xsIHdhbnQgdG8gY29udGludWUgdG8gdXBkYXRlIGlmIHdlIGV4cGVyaWVuY2VcclxuICAgICAgICAgIC8vIHJlZW50cmFuY3kgKHNpbmNlIHdlIHRyZWF0IHRoZSBsb2NhbCB2ZXJzaW9uIGFzIHRoZSBncm91bmQgdHJ1dGgpLCB3ZSdsbCBsb29wIGhlcmUgdW50aWwgd2UgZGlkbid0IGdldFxyXG4gICAgICAgICAgLy8gYW4gYXR0ZW1wdCB0byBjaGFuZ2UgaXQuIFRoaXMgd2lsbCBlbnN1cmUgdGhhdCBhZnRlciBjaGFuZ2VzLCB3ZSdsbCBoYXZlIGEgY29uc2lzdGVudCBtaW5pbXVtIGFuZFxyXG4gICAgICAgICAgLy8gbG9jYWxNaW5pbXVtIHNpemUuXHJcbiAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgIHRoaXMuX21pbmltdW1TaXplQ2hhbmdlQXR0ZW1wdER1cmluZ0xvY2sgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IG1pbmltdW1XaWR0aCA9IHRoaXMuX2NhbGN1bGF0ZU1pbmltdW1XaWR0aCgpO1xyXG5cclxuICAgICAgICAgICAgaWYgKCB0aGlzLm1pbmltdW1XaWR0aFByb3BlcnR5LnZhbHVlID09PSBudWxsIHx8XHJcbiAgICAgICAgICAgICAgICAgbWluaW11bVdpZHRoID09PSBudWxsIHx8XHJcbiAgICAgICAgICAgICAgICAgTWF0aC5hYnMoIHRoaXMubWluaW11bVdpZHRoUHJvcGVydHkudmFsdWUgLSBtaW5pbXVtV2lkdGggKSA+IENIQU5HRV9QT1NJVElPTl9USFJFU0hPTEQgKSB7XHJcbiAgICAgICAgICAgICAgdGhpcy5taW5pbXVtV2lkdGhQcm9wZXJ0eS52YWx1ZSA9IG1pbmltdW1XaWR0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgd2hpbGUgKCB0aGlzLl9taW5pbXVtU2l6ZUNoYW5nZUF0dGVtcHREdXJpbmdMb2NrICk7XHJcblxyXG4gICAgICAgICAgdGhpcy5fbWluaW11bVNpemVDaGFuZ2luZyA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgIHRoaXMuX21pbmltdW1TaXplQ2hhbmdlQXR0ZW1wdER1cmluZ0xvY2sgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcHVibGljIG92ZXJyaWRlIG11dGF0ZSggb3B0aW9ucz86IFdpZHRoU2l6YWJsZU9wdGlvbnMgJiBQYXJhbWV0ZXJzPEluc3RhbmNlVHlwZTxTdXBlclR5cGU+WyAnbXV0YXRlJyBdPlsgMCBdICk6IHRoaXMge1xyXG4gICAgICAgIHJldHVybiBzdXBlci5tdXRhdGUoIG9wdGlvbnMgKTtcclxuICAgICAgfVxyXG4gICAgfSApO1xyXG5cclxuICAvLyBJZiB3ZSdyZSBleHRlbmRpbmcgaW50byBhIE5vZGUgdHlwZSwgaW5jbHVkZSBvcHRpb24ga2V5c1xyXG4gIGlmICggV2lkdGhTaXphYmxlVHJhaXQucHJvdG90eXBlLl9tdXRhdG9yS2V5cyApIHtcclxuICAgIGNvbnN0IGV4aXN0aW5nS2V5cyA9IFdpZHRoU2l6YWJsZVRyYWl0LnByb3RvdHlwZS5fbXV0YXRvcktleXM7XHJcbiAgICBjb25zdCBuZXdLZXlzID0gV0lEVEhfU0laQUJMRV9PUFRJT05fS0VZUztcclxuICAgIGNvbnN0IGluZGV4T2ZCb3VuZHNCYXNlZE9wdGlvbnMgPSBleGlzdGluZ0tleXMuaW5kZXhPZiggUkVRVUlSRVNfQk9VTkRTX09QVElPTl9LRVlTWyAwIF0gKTtcclxuICAgIFdpZHRoU2l6YWJsZVRyYWl0LnByb3RvdHlwZS5fbXV0YXRvcktleXMgPSBbXHJcbiAgICAgIC4uLmV4aXN0aW5nS2V5cy5zbGljZSggMCwgaW5kZXhPZkJvdW5kc0Jhc2VkT3B0aW9ucyApLFxyXG4gICAgICAuLi5uZXdLZXlzLFxyXG4gICAgICAuLi5leGlzdGluZ0tleXMuc2xpY2UoIGluZGV4T2ZCb3VuZHNCYXNlZE9wdGlvbnMgKVxyXG4gICAgXTtcclxuICB9XHJcblxyXG4gIHJldHVybiBXaWR0aFNpemFibGVUcmFpdDtcclxufSApO1xyXG5cclxuY29uc3QgaXNXaWR0aFNpemFibGUgPSAoIG5vZGU6IE5vZGUgKTogbm9kZSBpcyBXaWR0aFNpemFibGVOb2RlID0+IHtcclxuICByZXR1cm4gbm9kZS53aWR0aFNpemFibGU7XHJcbn07XHJcbmNvbnN0IGV4dGVuZHNXaWR0aFNpemFibGUgPSAoIG5vZGU6IE5vZGUgKTogbm9kZSBpcyBXaWR0aFNpemFibGVOb2RlID0+IHtcclxuICByZXR1cm4gbm9kZS5leHRlbmRzV2lkdGhTaXphYmxlO1xyXG59O1xyXG5cclxuLy8gU29tZSB0eXBlc2NyaXB0IGd5bW5hc3RpY3MgdG8gcHJvdmlkZSBhIHVzZXItZGVmaW5lZCB0eXBlIGd1YXJkIHRoYXQgdHJlYXRzIHNvbWV0aGluZyBhcyB3aWR0aFNpemFibGVcclxuLy8gV2UgbmVlZCB0byBkZWZpbmUgYW4gdW51c2VkIGZ1bmN0aW9uIHdpdGggYSBjb25jcmV0ZSB0eXBlLCBzbyB0aGF0IHdlIGNhbiBleHRyYWN0IHRoZSByZXR1cm4gdHlwZSBvZiB0aGUgZnVuY3Rpb25cclxuLy8gYW5kIHByb3ZpZGUgYSB0eXBlIGZvciBhIE5vZGUgdGhhdCBleHRlbmRzIHRoaXMgdHlwZS5cclxuZXhwb3J0IHR5cGUgV2lkdGhTaXphYmxlTm9kZSA9IE5vZGUgJiBUV2lkdGhTaXphYmxlO1xyXG5cclxuc2NlbmVyeS5yZWdpc3RlciggJ1dpZHRoU2l6YWJsZScsIFdpZHRoU2l6YWJsZSApO1xyXG5leHBvcnQgZGVmYXVsdCBXaWR0aFNpemFibGU7XHJcbmV4cG9ydCB7IGlzV2lkdGhTaXphYmxlLCBleHRlbmRzV2lkdGhTaXphYmxlIH07Il0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPQSxZQUFZLE1BQU0sa0NBQWtDO0FBQzNELE9BQU9DLE9BQU8sTUFBTSxrQ0FBa0M7QUFDdEQsU0FBU0MsYUFBYSxFQUFRQywyQkFBMkIsRUFBRUMsT0FBTyxRQUFRLGVBQWU7QUFJekY7QUFDQSxNQUFNQyx5QkFBeUIsR0FBRyxJQUFJO0FBRXRDLE9BQU8sTUFBTUMseUJBQXlCLEdBQUcsQ0FDdkMsZ0JBQWdCLEVBQ2hCLGNBQWMsRUFDZCxxQkFBcUIsRUFDckIsbUJBQW1CLEVBQ25CLGNBQWMsQ0FDZjtBQStERDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTUMsWUFBWSxHQUFHTixPQUFPLENBQXlDTyxJQUFlLElBQThDO0VBQ2hJLE1BQU1DLGlCQUFpQixHQUFHUCxhQUFhLENBQUUsY0FBYyxFQUFFSSx5QkFBeUIsRUFDaEYsTUFBTUcsaUJBQWlCLFNBQVNELElBQUksQ0FBMEI7SUFFNUQ7SUFDZ0JFLHNCQUFzQixHQUFnQyxJQUFJVixZQUFZLENBQWlCLElBQUssQ0FBQztJQUM3Rlcsb0JBQW9CLEdBQWdDLElBQUlYLFlBQVksQ0FBaUIsSUFBSyxDQUFDO0lBQzNGWSwyQkFBMkIsR0FBZ0MsSUFBSVosWUFBWSxDQUFpQixJQUFLLENBQUM7SUFDbEdhLHlCQUF5QixHQUFnQyxJQUFJYixZQUFZLENBQWlCLElBQUssQ0FBQztJQUNoR2Msd0JBQXdCLEdBQTBCLElBQUlkLFlBQVksQ0FBVyxJQUFLLENBQUM7O0lBRW5HO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFD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