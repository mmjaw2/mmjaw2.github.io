// Copyright 2017-2023, University of Colorado Boulder

/**
 * A MultiListener that is designed to pan and zoom a target Node, where you can provide limiting and
 * describing bounds so that the targetNode is limited to a region.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 * @author Jesse Greenberg (PhET Interactive Simulations)
 */

import Property from '../../../axon/js/Property.js';
import Bounds2 from '../../../dot/js/Bounds2.js';
import Matrix3 from '../../../dot/js/Matrix3.js';
import ModelViewTransform2 from '../../../phetcommon/js/view/ModelViewTransform2.js';
import isSettingPhetioStateProperty from '../../../tandem/js/isSettingPhetioStateProperty.js';
import Tandem from '../../../tandem/js/Tandem.js';
import { MultiListener, scenery } from '../imports.js';
import optionize from '../../../phet-core/js/optionize.js';

// constants
// Reusable Matrix3 instance to avoid creating lots of them
const SCRATCH_MATRIX = new Matrix3();
class PanZoomListener extends MultiListener {
  // Only needed for PhET-iO instrumented. The pan bounds of the source so if the destination bounds are different due
  // to a differently sized iframe or window, this can be used to determine a correction for the destination
  // targetNode transform. This could be removed by work recommended in

  /**
   * @param targetNode - The Node that should be transformed by this PanZoomListener.
   * @param [providedOptions].
   */
  constructor(targetNode, providedOptions) {
    const options = optionize()({
      panBounds: Bounds2.NOTHING,
      targetBounds: null,
      targetScale: 1,
      // by default, the PanZoomListener does now allow rotation
      allowRotation: false
    }, providedOptions);
    super(targetNode, options);
    this._panBounds = options.panBounds;
    this._targetBounds = options.targetBounds || targetNode.globalBounds.copy();
    this._targetScale = options.targetScale;

    // When generating a PhET-iO API, the specific bounds of the window should be excluded from the initial state
    // so that the initial state part of the API doesn't depend on the window size.
    this.sourceFramePanBoundsProperty = new Property(Tandem.API_GENERATION ? new Bounds2(0, 0, 0, 0) : this._panBounds, {
      tandem: options.tandem?.createTandem('sourceFramePanBoundsProperty'),
      phetioReadOnly: true,
      phetioValueType: Bounds2.Bounds2IO
    });
    this.sourceFramePanBoundsProperty.lazyLink(() => {
      if (isSettingPhetioStateProperty.value) {
        // The matrixProperty has transformations relative to the global view coordinates of the source simulation,
        // so it will not be correct if source and destination frames are different sizes. This will map transforamtions
        // if destination frame has different size.
        const sourceDestinationTransform = ModelViewTransform2.createRectangleMapping(this.sourceFramePanBoundsProperty.get(), this._panBounds);
        const newTranslation = this._targetNode.matrix.translation.componentMultiply(sourceDestinationTransform.matrix.getScaleVector());
        const scale = this.matrixProperty.get().getScaleVector();
        this.matrixProperty.set(Matrix3.translationFromVector(newTranslation).timesMatrix(Matrix3.scaling(scale.x, scale.y)));
      }
    }, {
      // so that the listener will be called only after the matrixProperty is up to date in the downstream sim
      phetioDependencies: [this.matrixProperty]
    });
  }

  /**
   * If the targetNode is larger than the panBounds specified, keep the panBounds completely filled with
   * targetNode content.
   */
  correctReposition() {
    // Save values of the current matrix, so that we only do certain work when the matrix actually changes
    SCRATCH_MATRIX.set(this._targetNode.matrix);

    // the targetBounds transformed by the targetNode's transform, to determine if targetBounds are out of panBounds
    const transformedBounds = this._targetBounds.transformed(this._targetNode.getMatrix());

    // Don't let panning go through if the node is fully contained by the panBounds
    if (transformedBounds.left > this._panBounds.left) {
      this._targetNode.left = this._panBounds.left - (transformedBounds.left - this._targetNode.left);
    }
    if (transformedBounds.top > this._panBounds.top) {
      this._targetNode.top = this._panBounds.top - (transformedBounds.top - this._targetNode.top);
    }
    if (transformedBounds.right < this._panBounds.right) {
      this._targetNode.right = this._panBounds.right + (this._targetNode.right - transformedBounds.right);
    }
    if (transformedBounds.bottom < this._panBounds.bottom) {
      this._targetNode.bottom = this._panBounds.bottom + (this._targetNode.bottom - transformedBounds.bottom);
    }

    // Update Property with matrix once position has been corrected to notify listeners and set PhET-iO state, but
    // only notify when there has been an actual change.
    if (!SCRATCH_MATRIX.equals(this._targetNode.matrix)) {
      this.matrixProperty.set(this._targetNode.matrix.copy());
    }
  }

  /**
   * If the transformed targetBounds are equal to the panBounds, there is no space for us to pan so do not change
   * the pointer cursor.
   */
  addPress(press) {
    super.addPress(press);

    // don't show the pressCursor if our bounds are limited by pan bounds, and we cannot pan anywhere
    const transformedBounds = this._targetBounds.transformed(this._targetNode.getMatrix());
    const boundsLimited = transformedBounds.equalsEpsilon(this._panBounds, 1E-8);
    press.pointer.cursor = boundsLimited ? null : this._pressCursor;
  }

  /**
   * Reposition but keep content within this._panBounds.
   */
  reposition() {
    super.reposition();
    this.correctReposition();
  }

  /**
   * Reset the transform on the targetNode and follow up by making sure that the content is still within panBounds.
   */
  resetTransform() {
    super.resetTransform();
    this.correctReposition();
  }

  /**
   * Set the containing panBounds and then make sure that the targetBounds fully fill the new panBounds.
   */
  setPanBounds(panBounds) {
    this._panBounds = panBounds;

    // When generating a PhET-iO API, the specific bounds of the window should be excluded from the initial state
    // so that the initial state part of the API doesn't depend on the window size.
    if (!Tandem.API_GENERATION) {
      this.sourceFramePanBoundsProperty.set(this._panBounds);
    }
    this.correctReposition();
  }

  /**
   * Set the targetBounds which should totally fill the panBounds at all times. Useful if the targetNode has bounds
   * which don't accurately describe the node. For instance, if an overlay plane is on top of the node and extends
   * beyond the dimensions of the visible node.
   *
   * targetBounds - in the global coordinate frame
   */
  setTargetBounds(targetBounds) {
    this._targetBounds = targetBounds;
    this.correctReposition();
  }

  /**
   * Set the representative scale of the target Node. If the targetBounds are different from the targetNode.bounds
   * it may be useful to correct changes to panning and zooming by a scale that is different from the
   * actual scale applied to the targetNode during panning.
   */
  setTargetScale(scale) {
    this._targetScale = scale;
  }

  /**
   * Get the targetBounds, in the global coordinate frame.
   */
  getTargetBounds() {
    return this._targetBounds;
  }
}
scenery.register('PanZoomListener', PanZoomListener);
export default PanZoomListener;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJQcm9wZXJ0eSIsIkJvdW5kczIiLCJNYXRyaXgzIiwiTW9kZWxWaWV3VHJhbnNmb3JtMiIsImlzU2V0dGluZ1BoZXRpb1N0YXRlUHJvcGVydHkiLCJUYW5kZW0iLCJNdWx0aUxpc3RlbmVyIiwic2NlbmVyeSIsIm9wdGlvbml6ZSIsIlNDUkFUQ0hfTUFUUklYIiwiUGFuWm9vbUxpc3RlbmVyIiwiY29uc3RydWN0b3IiLCJ0YXJnZXROb2RlIiwicHJvdmlkZWRPcHRpb25zIiwib3B0aW9ucyIsInBhbkJvdW5kcyIsIk5PVEhJTkciLCJ0YXJnZXRCb3VuZHMiLCJ0YXJnZXRTY2FsZSIsImFsbG93Um90YXRpb24iLCJfcGFuQm91bmRzIiwiX3RhcmdldEJvdW5kcyIsImdsb2JhbEJvdW5kcyIsImNvcHkiLCJfdGFyZ2V0U2NhbGUiLCJzb3VyY2VGcmFtZVBhbkJvdW5kc1Byb3BlcnR5IiwiQVBJX0dFTkVSQVRJT04iLCJ0YW5kZW0iLCJjcmVhdGVUYW5kZW0iLCJwaGV0aW9SZWFkT25seSIsInBoZXRpb1ZhbHVlVHlwZSIsIkJvdW5kczJJTyIsImxhenlMaW5rIiwidmFsdWUiLCJzb3VyY2VEZXN0aW5hdGlvblRyYW5zZm9ybSIsImNyZWF0ZVJlY3RhbmdsZU1hcHBpbmciLCJnZXQiLCJuZXdUcmFuc2xhdGlvbiIsIl90YXJnZXROb2RlIiwibWF0cml4IiwidHJhbnNsYXRpb24iLCJjb21wb25lbnRNdWx0aXBseSIsImdldFNjYWxlVmVjdG9yIiwic2NhbGUiLCJtYXRyaXhQcm9wZXJ0eSIsInNldCIsInRyYW5zbGF0aW9uRnJvbVZlY3RvciIsInRpbWVzTWF0cml4Iiwic2NhbGluZyIsIngiLCJ5IiwicGhldGlvRGVwZW5kZW5jaWVzIiwiY29ycmVjdFJlcG9zaXRpb24iLCJ0cmFuc2Zvcm1lZEJvdW5kcyIsInRyYW5zZm9ybWVkIiwiZ2V0TWF0cml4IiwibGVmdCIsInRvcCIsInJpZ2h0IiwiYm90dG9tIiwiZXF1YWxzIiwiYWRkUHJlc3MiLCJwcmVzcyIsImJvdW5kc0xpbWl0ZWQiLCJlcXVhbHNFcHNpbG9uIiwicG9pbnRlciIsImN1cnNvciIsIl9wcmVzc0N1cnNvciIsInJlcG9zaXRpb24iLCJyZXNldFRyYW5zZm9ybSIsInNldFBhbkJvdW5kcyIsInNldFRhcmdldEJvdW5kcyIsInNldFRhcmdldFNjYWxlIiwiZ2V0VGFyZ2V0Qm91bmRzIiwicmVnaXN0ZXIiXSwic291cmNlcyI6WyJQYW5ab29tTGlzdGVuZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTctMjAyMywgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXHJcblxyXG4vKipcclxuICogQSBNdWx0aUxpc3RlbmVyIHRoYXQgaXMgZGVzaWduZWQgdG8gcGFuIGFuZCB6b29tIGEgdGFyZ2V0IE5vZGUsIHdoZXJlIHlvdSBjYW4gcHJvdmlkZSBsaW1pdGluZyBhbmRcclxuICogZGVzY3JpYmluZyBib3VuZHMgc28gdGhhdCB0aGUgdGFyZ2V0Tm9kZSBpcyBsaW1pdGVkIHRvIGEgcmVnaW9uLlxyXG4gKlxyXG4gKiBAYXV0aG9yIEpvbmF0aGFuIE9sc29uIDxqb25hdGhhbi5vbHNvbkBjb2xvcmFkby5lZHU+XHJcbiAqIEBhdXRob3IgSmVzc2UgR3JlZW5iZXJnIChQaEVUIEludGVyYWN0aXZlIFNpbXVsYXRpb25zKVxyXG4gKi9cclxuXHJcbmltcG9ydCBQcm9wZXJ0eSBmcm9tICcuLi8uLi8uLi9heG9uL2pzL1Byb3BlcnR5LmpzJztcclxuaW1wb3J0IEJvdW5kczIgZnJvbSAnLi4vLi4vLi4vZG90L2pzL0JvdW5kczIuanMnO1xyXG5pbXBvcnQgTWF0cml4MyBmcm9tICcuLi8uLi8uLi9kb3QvanMvTWF0cml4My5qcyc7XHJcbmltcG9ydCBNb2RlbFZpZXdUcmFuc2Zvcm0yIGZyb20gJy4uLy4uLy4uL3BoZXRjb21tb24vanMvdmlldy9Nb2RlbFZpZXdUcmFuc2Zvcm0yLmpzJztcclxuaW1wb3J0IGlzU2V0dGluZ1BoZXRpb1N0YXRlUHJvcGVydHkgZnJvbSAnLi4vLi4vLi4vdGFuZGVtL2pzL2lzU2V0dGluZ1BoZXRpb1N0YXRlUHJvcGVydHkuanMnO1xyXG5pbXBvcnQgVGFuZGVtIGZyb20gJy4uLy4uLy4uL3RhbmRlbS9qcy9UYW5kZW0uanMnO1xyXG5pbXBvcnQgeyBNdWx0aUxpc3RlbmVyLCBNdWx0aUxpc3RlbmVyT3B0aW9ucywgTXVsdGlMaXN0ZW5lclByZXNzLCBOb2RlLCBzY2VuZXJ5IH0gZnJvbSAnLi4vaW1wb3J0cy5qcyc7XHJcbmltcG9ydCBvcHRpb25pemUgZnJvbSAnLi4vLi4vLi4vcGhldC1jb3JlL2pzL29wdGlvbml6ZS5qcyc7XHJcblxyXG4vLyBjb25zdGFudHNcclxuLy8gUmV1c2FibGUgTWF0cml4MyBpbnN0YW5jZSB0byBhdm9pZCBjcmVhdGluZyBsb3RzIG9mIHRoZW1cclxuY29uc3QgU0NSQVRDSF9NQVRSSVggPSBuZXcgTWF0cml4MygpO1xyXG5cclxudHlwZSBTZWxmT3B0aW9ucyA9IHtcclxuXHJcbiAgLy8gdGhlc2UgYm91bmRzIHNob3VsZCBiZSBmdWxseSBmaWxsZWQgd2l0aCBjb250ZW50IGF0IGFsbCB0aW1lcywgaW4gdGhlIGdsb2JhbCBjb29yZGluYXRlIGZyYW1lXHJcbiAgcGFuQm91bmRzPzogQm91bmRzMjtcclxuXHJcbiAgLy8gQm91bmRzIGZvciB0aGUgdGFyZ2V0IG5vZGUgdGhhdCBnZXQgdHJhbnNmb3JtZWQgd2l0aCB0aGlzIGxpc3RlbmVyIGFuZCBmaWxsIHBhbkJvdW5kcyxcclxuICAvLyB1c2VmdWwgaWYgdGhlIHRhcmdldE5vZGUgYm91bmRzIGRvIG5vdCBhY2N1cmF0ZWx5IGRlc2NyaWJlIHRoZSB0YXJnZXROb2RlIChsaWtlIGlmIGludmlzaWJsZSBjb250ZW50XHJcbiAgLy8gZXh0ZW5kcyBvZmYgc2NyZWVuKS4gRGVmYXVsdHMgdG8gdGFyZ2V0Tm9kZSBib3VuZHMgaWYgbnVsbC4gQm91bmRzIGluIHRoZSBnbG9iYWwgY29vcmRpbmF0ZSBmcmFtZSBvZiB0aGVcclxuICAvLyB0YXJnZXQgTm9kZS5cclxuICB0YXJnZXRCb3VuZHM/OiBCb3VuZHMyIHwgbnVsbDtcclxuXHJcbiAgLy8gU2NhbGUgdGhhdCBhY2N1cmF0ZWx5IGRlc2NyaWJlcyBzY2FsZSBvZiB0aGUgdGFyZ2V0Tm9kZSwgYnV0IGlzIGRpZmZlcmVudCBmcm9tIHRoZSBhY3R1YWwgc2NhbGUgb2YgdGhlXHJcbiAgLy8gdGFyZ2V0Tm9kZSdzIHRyYW5zZm9ybS4gVGhpcyBzY2FsZSBpcyBhcHBsaWVkIHRvIHRyYW5zbGF0aW9uIFZlY3RvcnMgZm9yIHRoZSBUYXJnZXROb2RlIGR1cmluZyBwYW5uaW5nLiBJZlxyXG4gIC8vIHRhcmdldE5vZGUgY2hpbGRyZW4gZ2V0IHNjYWxlZCB1bmlmb3JtbHkgKHN1Y2ggYXMgaW4gcmVzcG9uc2UgdG8gd2luZG93IHJlc2l6aW5nIG9yIG5hdGl2ZSBicm93c2VyIHpvb20pLCB5b3VcclxuICAvLyBsaWtlbHkgd2FudCB0aGF0IHNjYWxlIHRvIGJlIGFwcGxpZWQgZHVyaW5nIHRyYW5zbGF0aW9uIG9wZXJhdGlvbnMgc28gdGhhdCBwYW4vem9vbSBiZWhhdmVzXHJcbiAgLy8gdGhlIHNhbWUgcmVnYXJkbGVzcyBvZiB3aW5kb3cgc2l6ZSBvciBuYXRpdmUgYnJvd3NlciB6b29tLlxyXG4gIHRhcmdldFNjYWxlPzogbnVtYmVyO1xyXG59O1xyXG5leHBvcnQgdHlwZSBQYW5ab29tTGlzdGVuZXJPcHRpb25zID0gU2VsZk9wdGlvbnMgJiBNdWx0aUxpc3RlbmVyT3B0aW9ucztcclxuXHJcbmNsYXNzIFBhblpvb21MaXN0ZW5lciBleHRlbmRzIE11bHRpTGlzdGVuZXIge1xyXG5cclxuICBwcm90ZWN0ZWQgX3BhbkJvdW5kczogQm91bmRzMjtcclxuICBwcm90ZWN0ZWQgX3RhcmdldEJvdW5kczogQm91bmRzMjtcclxuICBwcm90ZWN0ZWQgX3RhcmdldFNjYWxlOiBudW1iZXI7XHJcblxyXG4gIC8vIE9ubHkgbmVlZGVkIGZvciBQaEVULWlPIGluc3RydW1lbnRlZC4gVGhlIHBhbiBib3VuZHMgb2YgdGhlIHNvdXJjZSBzbyBpZiB0aGUgZGVzdGluYXRpb24gYm91bmRzIGFyZSBkaWZmZXJlbnQgZHVlXHJcbiAgLy8gdG8gYSBkaWZmZXJlbnRseSBzaXplZCBpZnJhbWUgb3Igd2luZG93LCB0aGlzIGNhbiBiZSB1c2VkIHRvIGRldGVybWluZSBhIGNvcnJlY3Rpb24gZm9yIHRoZSBkZXN0aW5hdGlvblxyXG4gIC8vIHRhcmdldE5vZGUgdHJhbnNmb3JtLiBUaGlzIGNvdWxkIGJlIHJlbW92ZWQgYnkgd29yayByZWNvbW1lbmRlZCBpblxyXG4gIHByb3RlY3RlZCBzb3VyY2VGcmFtZVBhbkJvdW5kc1Byb3BlcnR5OiBQcm9wZXJ0eTxCb3VuZHMyPjtcclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHRhcmdldE5vZGUgLSBUaGUgTm9kZSB0aGF0IHNob3VsZCBiZSB0cmFuc2Zvcm1lZCBieSB0aGlzIFBhblpvb21MaXN0ZW5lci5cclxuICAgKiBAcGFyYW0gW3Byb3ZpZGVkT3B0aW9uc10uXHJcbiAgICovXHJcbiAgcHVibGljIGNvbnN0cnVjdG9yKCB0YXJnZXROb2RlOiBOb2RlLCBwcm92aWRlZE9wdGlvbnM/OiBQYW5ab29tTGlzdGVuZXJPcHRpb25zICkge1xyXG5cclxuICAgIGNvbnN0IG9wdGlvbnMgPSBvcHRpb25pemU8UGFuWm9vbUxpc3RlbmVyT3B0aW9ucywgU2VsZk9wdGlvbnMsIFBhblpvb21MaXN0ZW5lck9wdGlvbnM+KCkoIHtcclxuICAgICAgcGFuQm91bmRzOiBCb3VuZHMyLk5PVEhJTkcsXHJcbiAgICAgIHRhcmdldEJvdW5kczogbnVsbCxcclxuICAgICAgdGFyZ2V0U2NhbGU6IDEsXHJcblxyXG4gICAgICAvLyBieSBkZWZhdWx0LCB0aGUgUGFuWm9vbUxpc3RlbmVyIGRvZXMgbm93IGFsbG93IHJvdGF0aW9uXHJcbiAgICAgIGFsbG93Um90YXRpb246IGZhbHNlXHJcbiAgICB9LCBwcm92aWRlZE9wdGlvbnMgKTtcclxuXHJcbiAgICBzdXBlciggdGFyZ2V0Tm9kZSwgb3B0aW9ucyApO1xyXG5cclxuICAgIHRoaXMuX3BhbkJvdW5kcyA9IG9wdGlvbnMucGFuQm91bmRzO1xyXG4gICAgdGhpcy5fdGFyZ2V0Qm91bmRzID0gb3B0aW9ucy50YXJnZXRCb3VuZHMgfHwgdGFyZ2V0Tm9kZS5nbG9iYWxCb3VuZHMuY29weSgpO1xyXG4gICAgdGhpcy5fdGFyZ2V0U2NhbGUgPSBvcHRpb25zLnRhcmdldFNjYWxlO1xyXG5cclxuICAgIC8vIFdoZW4gZ2VuZXJhdGluZyBhIFBoRVQtaU8gQVBJLCB0aGUgc3BlY2lmaWMgYm91bmRzIG9mIHRoZSB3aW5kb3cgc2hvdWxkIGJlIGV4Y2x1ZGVkIGZyb20gdGhlIGluaXRpYWwgc3RhdGVcclxuICAgIC8vIHNvIHRoYXQgdGhlIGluaXRpYWwgc3RhdGUgcGFydCBvZiB0aGUgQVBJIGRvZXNuJ3QgZGVwZW5kIG9uIHRoZSB3aW5kb3cgc2l6ZS5cclxuICAgIHRoaXMuc291cmNlRnJhbWVQYW5Cb3VuZHNQcm9wZXJ0eSA9IG5ldyBQcm9wZXJ0eSggVGFuZGVtLkFQSV9HRU5FUkFUSU9OID8gbmV3IEJvdW5kczIoIDAsIDAsIDAsIDAgKSA6IHRoaXMuX3BhbkJvdW5kcywge1xyXG4gICAgICB0YW5kZW06IG9wdGlvbnMudGFuZGVtPy5jcmVhdGVUYW5kZW0oICdzb3VyY2VGcmFtZVBhbkJvdW5kc1Byb3BlcnR5JyApLFxyXG4gICAgICBwaGV0aW9SZWFkT25seTogdHJ1ZSxcclxuICAgICAgcGhldGlvVmFsdWVUeXBlOiBCb3VuZHMyLkJvdW5kczJJT1xyXG4gICAgfSApO1xyXG5cclxuICAgIHRoaXMuc291cmNlRnJhbWVQYW5Cb3VuZHNQcm9wZXJ0eS5sYXp5TGluayggKCkgPT4ge1xyXG4gICAgICBpZiAoIGlzU2V0dGluZ1BoZXRpb1N0YXRlUHJvcGVydHkudmFsdWUgKSB7XHJcblxyXG4gICAgICAgIC8vIFRoZSBtYXRyaXhQcm9wZXJ0eSBoYXMgdHJhbnNmb3JtYXRpb25zIHJlbGF0aXZlIHRvIHRoZSBnbG9iYWwgdmlldyBjb29yZGluYXRlcyBvZiB0aGUgc291cmNlIHNpbXVsYXRpb24sXHJcbiAgICAgICAgLy8gc28gaXQgd2lsbCBub3QgYmUgY29ycmVjdCBpZiBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGZyYW1lcyBhcmUgZGlmZmVyZW50IHNpemVzLiBUaGlzIHdpbGwgbWFwIHRyYW5zZm9yYW10aW9uc1xyXG4gICAgICAgIC8vIGlmIGRlc3RpbmF0aW9uIGZyYW1lIGhhcyBkaWZmZXJlbnQgc2l6ZS5cclxuICAgICAgICBjb25zdCBzb3VyY2VEZXN0aW5hdGlvblRyYW5zZm9ybSA9IE1vZGVsVmlld1RyYW5zZm9ybTIuY3JlYXRlUmVjdGFuZ2xlTWFwcGluZyggdGhpcy5zb3VyY2VGcmFtZVBhbkJvdW5kc1Byb3BlcnR5LmdldCgpLCB0aGlzLl9wYW5Cb3VuZHMgKTtcclxuXHJcbiAgICAgICAgY29uc3QgbmV3VHJhbnNsYXRpb24gPSB0aGlzLl90YXJnZXROb2RlLm1hdHJpeC50cmFuc2xhdGlvbi5jb21wb25lbnRNdWx0aXBseSggc291cmNlRGVzdGluYXRpb25UcmFuc2Zvcm0ubWF0cml4LmdldFNjYWxlVmVjdG9yKCkgKTtcclxuICAgICAgICBjb25zdCBzY2FsZSA9IHRoaXMubWF0cml4UHJvcGVydHkuZ2V0KCkuZ2V0U2NhbGVWZWN0b3IoKTtcclxuICAgICAgICB0aGlzLm1hdHJpeFByb3BlcnR5LnNldCggTWF0cml4My50cmFuc2xhdGlvbkZyb21WZWN0b3IoIG5ld1RyYW5zbGF0aW9uICkudGltZXNNYXRyaXgoIE1hdHJpeDMuc2NhbGluZyggc2NhbGUueCwgc2NhbGUueSApICkgKTtcclxuICAgICAgfVxyXG4gICAgfSwge1xyXG5cclxuICAgICAgLy8gc28gdGhhdCB0aGUgbGlzdGVuZXIgd2lsbCBiZSBjYWxsZWQgb25seSBhZnRlciB0aGUgbWF0cml4UHJvcGVydHkgaXMgdXAgdG8gZGF0ZSBpbiB0aGUgZG93bnN0cmVhbSBzaW1cclxuICAgICAgcGhldGlvRGVwZW5kZW5jaWVzOiBbIHRoaXMubWF0cml4UHJvcGVydHkgXVxyXG4gICAgfSApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSWYgdGhlIHRhcmdldE5vZGUgaXMgbGFyZ2VyIHRoYW4gdGhlIHBhbkJvdW5kcyBzcGVjaWZpZWQsIGtlZXAgdGhlIHBhbkJvdW5kcyBjb21wbGV0ZWx5IGZpbGxlZCB3aXRoXHJcbiAgICogdGFyZ2V0Tm9kZSBjb250ZW50LlxyXG4gICAqL1xyXG4gIHByb3RlY3RlZCBjb3JyZWN0UmVwb3NpdGlvbigpOiB2b2lkIHtcclxuXHJcbiAgICAvLyBTYXZlIHZhbHVlcyBvZiB0aGUgY3VycmVudCBtYXRyaXgsIHNvIHRoYXQgd2Ugb25seSBkbyBjZXJ0YWluIHdvcmsgd2hlbiB0aGUgbWF0cml4IGFjdHVhbGx5IGNoYW5nZXNcclxuICAgIFNDUkFUQ0hfTUFUUklYLnNldCggdGhpcy5fdGFyZ2V0Tm9kZS5tYXRyaXggKTtcclxuXHJcbiAgICAvLyB0aGUgdGFyZ2V0Qm91bmRzIHRyYW5zZm9ybWVkIGJ5IHRoZSB0YXJnZXROb2RlJ3MgdHJhbnNmb3JtLCB0byBkZXRlcm1pbmUgaWYgdGFyZ2V0Qm91bmRzIGFyZSBvdXQgb2YgcGFuQm91bmRzXHJcbiAgICBjb25zdCB0cmFuc2Zvcm1lZEJvdW5kcyA9IHRoaXMuX3RhcmdldEJvdW5kcy50cmFuc2Zvcm1lZCggdGhpcy5fdGFyZ2V0Tm9kZS5nZXRNYXRyaXgoKSApO1xyXG5cclxuICAgIC8vIERvbid0IGxldCBwYW5uaW5nIGdvIHRocm91Z2ggaWYgdGhlIG5vZGUgaXMgZnVsbHkgY29udGFpbmVkIGJ5IHRoZSBwYW5Cb3VuZHNcclxuICAgIGlmICggdHJhbnNmb3JtZWRCb3VuZHMubGVmdCA+IHRoaXMuX3BhbkJvdW5kcy5sZWZ0ICkge1xyXG4gICAgICB0aGlzLl90YXJnZXROb2RlLmxlZnQgPSB0aGlzLl9wYW5Cb3VuZHMubGVmdCAtICggdHJhbnNmb3JtZWRCb3VuZHMubGVmdCAtIHRoaXMuX3RhcmdldE5vZGUubGVmdCApO1xyXG4gICAgfVxyXG4gICAgaWYgKCB0cmFuc2Zvcm1lZEJvdW5kcy50b3AgPiB0aGlzLl9wYW5Cb3VuZHMudG9wICkge1xyXG4gICAgICB0aGlzLl90YXJnZXROb2RlLnRvcCA9IHRoaXMuX3BhbkJvdW5kcy50b3AgLSAoIHRyYW5zZm9ybWVkQm91bmRzLnRvcCAtIHRoaXMuX3RhcmdldE5vZGUudG9wICk7XHJcbiAgICB9XHJcbiAgICBpZiAoIHRyYW5zZm9ybWVkQm91bmRzLnJpZ2h0IDwgdGhpcy5fcGFuQm91bmRzLnJpZ2h0ICkge1xyXG4gICAgICB0aGlzLl90YXJnZXROb2RlLnJpZ2h0ID0gdGhpcy5fcGFuQm91bmRzLnJpZ2h0ICsgKCB0aGlzLl90YXJnZXROb2RlLnJpZ2h0IC0gdHJhbnNmb3JtZWRCb3VuZHMucmlnaHQgKTtcclxuICAgIH1cclxuICAgIGlmICggdHJhbnNmb3JtZWRCb3VuZHMuYm90dG9tIDwgdGhpcy5fcGFuQm91bmRzLmJvdHRvbSApIHtcclxuICAgICAgdGhpcy5fdGFyZ2V0Tm9kZS5ib3R0b20gPSB0aGlzLl9wYW5Cb3VuZHMuYm90dG9tICsgKCB0aGlzLl90YXJnZXROb2RlLmJvdHRvbSAtIHRyYW5zZm9ybWVkQm91bmRzLmJvdHRvbSApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFVwZGF0ZSBQcm9wZXJ0eSB3aXRoIG1hdHJpeCBvbmNlIHBvc2l0aW9uIGhhcyBiZWVuIGNvcnJlY3RlZCB0byBub3RpZnkgbGlzdGVuZXJzIGFuZCBzZXQgUGhFVC1pTyBzdGF0ZSwgYnV0XHJcbiAgICAvLyBvbmx5IG5vdGlmeSB3aGVuIHRoZXJlIGhhcyBiZWVuIGFuIGFjdHVhbCBjaGFuZ2UuXHJcbiAgICBpZiAoICFTQ1JBVENIX01BVFJJWC5lcXVhbHMoIHRoaXMuX3RhcmdldE5vZGUubWF0cml4ICkgKSB7XHJcbiAgICAgIHRoaXMubWF0cml4UHJvcGVydHkuc2V0KCB0aGlzLl90YXJnZXROb2RlLm1hdHJpeC5jb3B5KCkgKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIElmIHRoZSB0cmFuc2Zvcm1lZCB0YXJnZXRCb3VuZHMgYXJlIGVxdWFsIHRvIHRoZSBwYW5Cb3VuZHMsIHRoZXJlIGlzIG5vIHNwYWNlIGZvciB1cyB0byBwYW4gc28gZG8gbm90IGNoYW5nZVxyXG4gICAqIHRoZSBwb2ludGVyIGN1cnNvci5cclxuICAgKi9cclxuICBwcm90ZWN0ZWQgb3ZlcnJpZGUgYWRkUHJlc3MoIHByZXNzOiBNdWx0aUxpc3RlbmVyUHJlc3MgKTogdm9pZCB7XHJcbiAgICBzdXBlci5hZGRQcmVzcyggcHJlc3MgKTtcclxuXHJcbiAgICAvLyBkb24ndCBzaG93IHRoZSBwcmVzc0N1cnNvciBpZiBvdXIgYm91bmRzIGFyZSBsaW1pdGVkIGJ5IHBhbiBib3VuZHMsIGFuZCB3ZSBjYW5ub3QgcGFuIGFueXdoZXJlXHJcbiAgICBjb25zdCB0cmFuc2Zvcm1lZEJvdW5kcyA9IHRoaXMuX3RhcmdldEJvdW5kcy50cmFuc2Zvcm1lZCggdGhpcy5fdGFyZ2V0Tm9kZS5nZXRNYXRyaXgoKSApO1xyXG4gICAgY29uc3QgYm91bmRzTGltaXRlZCA9IHRyYW5zZm9ybWVkQm91bmRzLmVxdWFsc0Vwc2lsb24oIHRoaXMuX3BhbkJvdW5kcywgMUUtOCApO1xyXG4gICAgcHJlc3MucG9pbnRlci5jdXJzb3IgPSBib3VuZHNMaW1pdGVkID8gbnVsbCA6IHRoaXMuX3ByZXNzQ3Vyc29yO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVwb3NpdGlvbiBidXQga2VlcCBjb250ZW50IHdpdGhpbiB0aGlzLl9wYW5Cb3VuZHMuXHJcbiAgICovXHJcbiAgcHJvdGVjdGVkIG92ZXJyaWRlIHJlcG9zaXRpb24oKTogdm9pZCB7XHJcbiAgICBzdXBlci5yZXBvc2l0aW9uKCk7XHJcbiAgICB0aGlzLmNvcnJlY3RSZXBvc2l0aW9uKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXNldCB0aGUgdHJhbnNmb3JtIG9uIHRoZSB0YXJnZXROb2RlIGFuZCBmb2xsb3cgdXAgYnkgbWFraW5nIHN1cmUgdGhhdCB0aGUgY29udGVudCBpcyBzdGlsbCB3aXRoaW4gcGFuQm91bmRzLlxyXG4gICAqL1xyXG4gIHB1YmxpYyBvdmVycmlkZSByZXNldFRyYW5zZm9ybSgpOiB2b2lkIHtcclxuICAgIHN1cGVyLnJlc2V0VHJhbnNmb3JtKCk7XHJcbiAgICB0aGlzLmNvcnJlY3RSZXBvc2l0aW9uKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXQgdGhlIGNvbnRhaW5pbmcgcGFuQm91bmRzIGFuZCB0aGVuIG1ha2Ugc3VyZSB0aGF0IHRoZSB0YXJnZXRCb3VuZHMgZnVsbHkgZmlsbCB0aGUgbmV3IHBhbkJvdW5kcy5cclxuICAgKi9cclxuICBwdWJsaWMgc2V0UGFuQm91bmRzKCBwYW5Cb3VuZHM6IEJvdW5kczIgKTogdm9pZCB7XHJcbiAgICB0aGlzLl9wYW5Cb3VuZHMgPSBwYW5Cb3VuZHM7XHJcblxyXG4gICAgLy8gV2hlbiBnZW5lcmF0aW5nIGEgUGhFVC1pTyBBUEksIHRoZSBzcGVjaWZpYyBib3VuZHMgb2YgdGhlIHdpbmRvdyBzaG91bGQgYmUgZXhjbHVkZWQgZnJvbSB0aGUgaW5pdGlhbCBzdGF0ZVxyXG4gICAgLy8gc28gdGhhdCB0aGUgaW5pdGlhbCBzdGF0ZSBwYXJ0IG9mIHRoZSBBUEkgZG9lc24ndCBkZXBlbmQgb24gdGhlIHdpbmRvdyBzaXplLlxyXG4gICAgaWYgKCAhVGFuZGVtLkFQSV9HRU5FUkFUSU9OICkge1xyXG4gICAgICB0aGlzLnNvdXJjZUZyYW1lUGFuQm91bmRzUHJvcGVydHkuc2V0KCB0aGlzLl9wYW5Cb3VuZHMgKTtcclxuICAgIH1cclxuICAgIHRoaXMuY29ycmVjdFJlcG9zaXRpb24oKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldCB0aGUgdGFyZ2V0Qm91bmRzIHdoaWNoIHNob3VsZCB0b3RhbGx5IGZpbGwgdGhlIHBhbkJvdW5kcyBhdCBhbGwgdGltZXMuIFVzZWZ1bCBpZiB0aGUgdGFyZ2V0Tm9kZSBoYXMgYm91bmRzXHJcbiAgICogd2hpY2ggZG9uJ3QgYWNjdXJhdGVseSBkZXNjcmliZSB0aGUgbm9kZS4gRm9yIGluc3RhbmNlLCBpZiBhbiBvdmVybGF5IHBsYW5lIGlzIG9uIHRvcCBvZiB0aGUgbm9kZSBhbmQgZXh0ZW5kc1xyXG4gICAqIGJleW9uZCB0aGUgZGltZW5zaW9ucyBvZiB0aGUgdmlzaWJsZSBub2RlLlxyXG4gICAqXHJcbiAgICogdGFyZ2V0Qm91bmRzIC0gaW4gdGhlIGdsb2JhbCBjb29yZGluYXRlIGZyYW1lXHJcbiAgICovXHJcbiAgcHVibGljIHNldFRhcmdldEJvdW5kcyggdGFyZ2V0Qm91bmRzOiBCb3VuZHMyICk6IHZvaWQge1xyXG4gICAgdGhpcy5fdGFyZ2V0Qm91bmRzID0gdGFyZ2V0Qm91bmRzO1xyXG4gICAgdGhpcy5jb3JyZWN0UmVwb3NpdGlvbigpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0IHRoZSByZXByZXNlbnRhdGl2ZSBzY2FsZSBvZiB0aGUgdGFyZ2V0IE5vZGUuIElmIHRoZSB0YXJnZXRCb3VuZHMgYXJlIGRpZmZlcmVudCBmcm9tIHRoZSB0YXJnZXROb2RlLmJvdW5kc1xyXG4gICAqIGl0IG1heSBiZSB1c2VmdWwgdG8gY29ycmVjdCBjaGFuZ2VzIHRvIHBhbm5pbmcgYW5kIHpvb21pbmcgYnkgYSBzY2FsZSB0aGF0IGlzIGRpZmZlcmVudCBmcm9tIHRoZVxyXG4gICAqIGFjdHVhbCBzY2FsZSBhcHBsaWVkIHRvIHRoZSB0YXJnZXROb2RlIGR1cmluZyBwYW5uaW5nLlxyXG4gICAqL1xyXG4gIHB1YmxpYyBzZXRUYXJnZXRTY2FsZSggc2NhbGU6IG51bWJlciApOiB2b2lkIHtcclxuICAgIHRoaXMuX3RhcmdldFNjYWxlID0gc2NhbGU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgdGhlIHRhcmdldEJvdW5kcywgaW4gdGhlIGdsb2JhbCBjb29yZGluYXRlIGZyYW1lLlxyXG4gICAqL1xyXG4gIHB1YmxpYyBnZXRUYXJnZXRCb3VuZHMoKTogQm91bmRzMiB7XHJcbiAgICByZXR1cm4gdGhpcy5fdGFyZ2V0Qm91bmRzO1xyXG4gIH1cclxufVxyXG5cclxuc2NlbmVyeS5yZWdpc3RlciggJ1Bhblpvb21MaXN0ZW5lcicsIFBhblpvb21MaXN0ZW5lciApO1xyXG5leHBvcnQgZGVmYXVsdCBQYW5ab29tTGlzdGVuZXI7Il0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPQSxRQUFRLE1BQU0sOEJBQThCO0FBQ25ELE9BQU9DLE9BQU8sTUFBTSw0QkFBNEI7QUFDaEQsT0FBT0MsT0FBTyxNQUFNLDRCQUE0QjtBQUNoRCxPQUFPQyxtQkFBbUIsTUFBTSxvREFBb0Q7QUFDcEYsT0FBT0MsNEJBQTRCLE1BQU0sb0RBQW9EO0FBQzdGLE9BQU9DLE1BQU0sTUFBTSw4QkFBOEI7QUFDakQsU0FBU0MsYUFBYSxFQUFrREMsT0FBTyxRQUFRLGVBQWU7QUFDdEcsT0FBT0MsU0FBUyxNQUFNLG9DQUFvQzs7QUFFMUQ7QUFDQTtBQUNBLE1BQU1DLGNBQWMsR0FBRyxJQUFJUCxPQUFPLENBQUMsQ0FBQztBQXNCcEMsTUFBTVEsZUFBZSxTQUFTSixhQUFhLENBQUM7RUFNMUM7RUFDQTtFQUNBOztFQUdBO0FBQ0Y7QUFDQTtBQUNBO0VBQ1NLLFdBQVdBLENBQUVDLFVBQWdCLEVBQUVDLGVBQXdDLEVBQUc7SUFFL0UsTUFBTUMsT0FBTyxHQUFHTixTQUFTLENBQThELENBQUMsQ0FBRTtNQUN4Rk8sU0FBUyxFQUFFZCxPQUFPLENBQUNlLE9BQU87TUFDMUJDLFlBQVksRUFBRSxJQUFJO01BQ2xCQyxXQUFXLEVBQUUsQ0FBQztNQUVkO01BQ0FDLGFBQWEsRUFBRTtJQUNqQixDQUFDLEVBQUVOLGVBQWdCLENBQUM7SUFFcEIsS0FBSyxDQUFFRCxVQUFVLEVBQUVFLE9BQVEsQ0FBQztJQUU1QixJQUFJLENBQUNNLFVBQVUsR0FBR04sT0FBTyxDQUFDQyxTQUFTO0lBQ25DLElBQUksQ0FBQ00sYUFBYSxHQUFHUCxPQUFPLENBQUNHLFlBQVksSUFBSUws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