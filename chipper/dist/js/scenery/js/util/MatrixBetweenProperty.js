// Copyright 2023-2024, University of Colorado Boulder

/**
 * A Property that, if there is a unique path from one Node to another (A => root => B, or A => B, or B => A), will
 * contain the transformation matrix from A to B's coordinate frame (local coordinate frames by default).
 *
 * If there is no unique path, the value will be null.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

import TinyProperty from '../../../axon/js/TinyProperty.js';
import Matrix3 from '../../../dot/js/Matrix3.js';
import arrayDifference from '../../../phet-core/js/arrayDifference.js';
import optionize from '../../../phet-core/js/optionize.js';
import { AncestorNodesProperty, scenery } from '../imports.js';
export default class MatrixBetweenProperty extends TinyProperty {
  // When we have a unique connection with trails, this will contain the root node common to both.
  // NOTE: This might be one of the actual nodes itself.
  rootNode = null;

  // When we have a unique connection with trails, these will contain the trail to the root node
  fromTrail = null;
  toTrail = null;
  // A set of nodes where we are listening to whether their transforms change
  listenedNodeSet = new Set();
  constructor(from, to, providedOptions) {
    const options = optionize()({
      fromCoordinateFrame: 'local',
      toCoordinateFrame: 'local'
    }, providedOptions);
    super(Matrix3.IDENTITY);
    this.from = from;
    this.to = to;
    this.fromCoordinateFrame = options.fromCoordinateFrame;
    this.toCoordinateFrame = options.toCoordinateFrame;

    // Identical matrices shouldn't trigger notifications
    this.valueComparisonStrategy = 'equalsFunction';
    this.fromAncestorsProperty = new AncestorNodesProperty(from);
    this.toAncestorsProperty = new AncestorNodesProperty(to);
    const updateListener = this.update.bind(this);
    this._nodeTransformListener = this.updateMatrix.bind(this);

    // We'll only trigger a full update when parents/ancestors change anywhere. Otherwise, we'll just do transform
    // changes with updateMatrix()
    this.fromAncestorsProperty.updateEmitter.addListener(updateListener);
    this.toAncestorsProperty.updateEmitter.addListener(updateListener);
    this.update();
  }
  update() {
    // Track nodes (not just ancestors) here, in case one is an ancestor of the other
    // REVIEW: would it be more performant for below opperations if these were Sets?
    const fromNodes = [...this.fromAncestorsProperty.value, this.from];
    const toNodes = [...this.toAncestorsProperty.value, this.to];

    // Intersection (ancestors of from/to)
    const commonNodes = fromNodes.filter(a => toNodes.includes(a));
    let hasDAG = false;

    // We'll want to find all nodes that are common ancestors of both, BUT aren't superfluous (an ancestor of another
    // common ancestor, with no other paths).
    const rootNodes = commonNodes.filter(node => {
      const fromChildren = fromNodes.filter(aNode => node.hasChild(aNode));
      const toChildren = toNodes.filter(bNode => node.hasChild(bNode));
      const fromOnly = [];
      const toOnly = [];
      const both = [];
      arrayDifference(fromChildren, toChildren, fromOnly, toOnly, both);
      const hasMultipleChildren = fromChildren.length > 1 || toChildren.length > 1;
      const hasUnsharedChild = fromOnly.length || toOnly.length;

      // If either has multiple children, AND we're not just a trivial ancestor of the root, we're in a DAG case
      if (hasMultipleChildren && hasUnsharedChild) {
        hasDAG = true;
      }
      const hasFromExclusive = fromOnly.length > 0 || this.from === node;
      const hasToExclusive = toOnly.length > 0 || this.to === node;
      return hasFromExclusive && hasToExclusive;
    });
    if (!hasDAG && rootNodes.length === 1) {
      // We have a root node, and should have unique trails!
      this.rootNode = rootNodes[0];

      // These should assert-error out if there is no unique trail for either
      this.fromTrail = this.from.getUniqueTrailTo(this.rootNode);
      this.toTrail = this.to.getUniqueTrailTo(this.rootNode);
    } else {
      this.rootNode = null;
      this.fromTrail = null;
      this.toTrail = null;
    }

    // Take note of the nodes we are listening to
    const nodeSet = new Set();
    this.fromTrail && this.fromTrail.nodes.forEach(node => nodeSet.add(node));
    this.toTrail && this.toTrail.nodes.forEach(node => nodeSet.add(node));

    // Add in new needed listeners
    nodeSet.forEach(node => {
      if (!this.listenedNodeSet.has(node)) {
        this.addNodeListener(node);
      }
    });

    // Remove listeners not needed anymore
    this.listenedNodeSet.forEach(node => {
      if (!nodeSet.has(node) && node !== this.from && node !== this.to) {
        this.removeNodeListener(node);
      }
    });
    this.updateMatrix();
  }
  updateMatrix() {
    if (this.rootNode && this.fromTrail && this.toTrail) {
      // If one of these is an ancestor of the other AND the ancestor requests a "parent" coordinate frame, we'll need
      // to compute things to the next level up. Otherwise, we can ignore the root node's transform. This is NOT
      // just an optimization, since if we multiply in the root node's transform into both the fromMatrix and toMatrix,
      // we'll lead to numerical imprecision that could be avoided. With this, we can get precise/exact results, even
      // if there is a scale on the rootNode (imagine a ScreenView's transform).
      const fromSelf = this.fromTrail.nodes.length === 1;
      const toSelf = this.toTrail.nodes.length === 1;
      const useAncestorMatrix = fromSelf && this.fromCoordinateFrame === 'parent' || toSelf && this.toCoordinateFrame === 'parent';

      // Instead of switching between 4 different matrix functions, we use the general form.
      const fromMatrix = this.fromTrail.getMatrixConcatenation(useAncestorMatrix ? 0 : 1, this.fromTrail.nodes.length - (this.fromCoordinateFrame === 'parent' ? 1 : 0));
      const toMatrix = this.toTrail.getMatrixConcatenation(useAncestorMatrix ? 0 : 1, this.toTrail.nodes.length - (this.toCoordinateFrame === 'parent' ? 1 : 0));

      // toPoint = toMatrix^-1 * fromMatrix * fromPoint
      this.value = toMatrix.inverted().timesMatrix(fromMatrix);
    } else {
      this.value = null;
    }
  }
  addNodeListener(node) {
    this.listenedNodeSet.add(node);
    node.transformEmitter.addListener(this._nodeTransformListener);
  }
  removeNodeListener(node) {
    this.listenedNodeSet.delete(node);
    node.transformEmitter.removeListener(this._nodeTransformListener);
  }
  dispose() {
    this.fromAncestorsProperty.dispose();
    this.toAncestorsProperty.dispose();
    super.dispose();
  }
}
scenery.register('MatrixBetweenProperty', MatrixBetweenProperty);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJUaW55UHJvcGVydHkiLCJNYXRyaXgzIiwiYXJyYXlEaWZmZXJlbmNlIiwib3B0aW9uaXplIiwiQW5jZXN0b3JOb2Rlc1Byb3BlcnR5Iiwic2NlbmVyeSIsIk1hdHJpeEJldHdlZW5Qcm9wZXJ0eSIsInJvb3ROb2RlIiwiZnJvbVRyYWlsIiwidG9UcmFpbCIsImxpc3RlbmVkTm9kZVNldCIsIlNldCIsImNvbnN0cnVjdG9yIiwiZnJvbSIsInRvIiwicHJvdmlkZWRPcHRpb25zIiwib3B0aW9ucyIsImZyb21Db29yZGluYXRlRnJhbWUiLCJ0b0Nvb3JkaW5hdGVGcmFtZSIsIklERU5USVRZIiwidmFsdWVDb21wYXJpc29uU3RyYXRlZ3kiLCJmcm9tQW5jZXN0b3JzUHJvcGVydHkiLCJ0b0FuY2VzdG9yc1Byb3BlcnR5IiwidXBkYXRlTGlzdGVuZXIiLCJ1cGRhdGUiLCJiaW5kIiwiX25vZGVUcmFuc2Zvcm1MaXN0ZW5lciIsInVwZGF0ZU1hdHJpeCIsInVwZGF0ZUVtaXR0ZXIiLCJhZGRMaXN0ZW5lciIsImZyb21Ob2RlcyIsInZhbHVlIiwidG9Ob2RlcyIsImNvbW1vbk5vZGVzIiwiZmlsdGVyIiwiYSIsImluY2x1ZGVzIiwiaGFzREFHIiwicm9vdE5vZGVzIiwibm9kZSIsImZyb21DaGlsZHJlbiIsImFOb2RlIiwiaGFzQ2hpbGQiLCJ0b0NoaWxkcmVuIiwiYk5vZGUiLCJmcm9tT25seSIsInRvT25seSIsImJvdGgiLCJoYXNNdWx0aXBsZUNoaWxkcmVuIiwibGVuZ3RoIiwiaGFzVW5zaGFyZWRDaGlsZCIsImhhc0Zyb21FeGNsdXNpdmUiLCJoYXNUb0V4Y2x1c2l2ZSIsImdldFVuaXF1ZVRyYWlsVG8iLCJub2RlU2V0Iiwibm9kZXMiLCJmb3JFYWNoIiwiYWRkIiwiaGFzIiwiYWRkTm9kZUxpc3RlbmVyIiwicmVtb3ZlTm9kZUxpc3RlbmVyIiwiZnJvbVNlbGYiLCJ0b1NlbGYiLCJ1c2VBbmNlc3Rvck1hdHJpeCIsImZyb21NYXRyaXgiLCJnZXRNYXRyaXhDb25jYXRlbmF0aW9uIiwidG9NYXRyaXgiLCJpbnZlcnRlZCIsInRpbWVzTWF0cml4IiwidHJhbnNmb3JtRW1pdHRlciIsImRlbGV0ZSIsInJlbW92ZUxpc3RlbmVyIiwiZGlzcG9zZSIsInJlZ2lzdGVyIl0sInNvdXJjZXMiOlsiTWF0cml4QmV0d2VlblByb3BlcnR5LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDIzLTIwMjQsIFVuaXZlcnNpdHkgb2YgQ29sb3JhZG8gQm91bGRlclxyXG5cclxuLyoqXHJcbiAqIEEgUHJvcGVydHkgdGhhdCwgaWYgdGhlcmUgaXMgYSB1bmlxdWUgcGF0aCBmcm9tIG9uZSBOb2RlIHRvIGFub3RoZXIgKEEgPT4gcm9vdCA9PiBCLCBvciBBID0+IEIsIG9yIEIgPT4gQSksIHdpbGxcclxuICogY29udGFpbiB0aGUgdHJhbnNmb3JtYXRpb24gbWF0cml4IGZyb20gQSB0byBCJ3MgY29vcmRpbmF0ZSBmcmFtZSAobG9jYWwgY29vcmRpbmF0ZSBmcmFtZXMgYnkgZGVmYXVsdCkuXHJcbiAqXHJcbiAqIElmIHRoZXJlIGlzIG5vIHVuaXF1ZSBwYXRoLCB0aGUgdmFsdWUgd2lsbCBiZSBudWxsLlxyXG4gKlxyXG4gKiBAYXV0aG9yIEpvbmF0aGFuIE9sc29uIDxqb25hdGhhbi5vbHNvbkBjb2xvcmFkby5lZHU+XHJcbiAqL1xyXG5cclxuaW1wb3J0IFRpbnlQcm9wZXJ0eSBmcm9tICcuLi8uLi8uLi9heG9uL2pzL1RpbnlQcm9wZXJ0eS5qcyc7XHJcbmltcG9ydCBNYXRyaXgzIGZyb20gJy4uLy4uLy4uL2RvdC9qcy9NYXRyaXgzLmpzJztcclxuaW1wb3J0IGFycmF5RGlmZmVyZW5jZSBmcm9tICcuLi8uLi8uLi9waGV0LWNvcmUvanMvYXJyYXlEaWZmZXJlbmNlLmpzJztcclxuaW1wb3J0IG9wdGlvbml6ZSBmcm9tICcuLi8uLi8uLi9waGV0LWNvcmUvanMvb3B0aW9uaXplLmpzJztcclxuaW1wb3J0IHsgQW5jZXN0b3JOb2Rlc1Byb3BlcnR5LCBOb2RlLCBzY2VuZXJ5LCBUcmFpbCB9IGZyb20gJy4uL2ltcG9ydHMuanMnO1xyXG5cclxudHlwZSBDb29yZGluYXRlRnJhbWUgPSAncGFyZW50JyB8ICdsb2NhbCc7XHJcblxyXG5leHBvcnQgdHlwZSBNYXRyaXhCZXR3ZWVuUHJvcGVydHlPcHRpb25zID0ge1xyXG4gIC8vIFdoaWNoIGNvb3JkaW5hdGUgZnJhbWVzIHdlIHdhbnQgdG8gYmUgY29udmVydGluZyBmcm9tL3RvLCBmb3IgZWFjaCBub2RlXHJcbiAgZnJvbUNvb3JkaW5hdGVGcmFtZT86IENvb3JkaW5hdGVGcmFtZTtcclxuICB0b0Nvb3JkaW5hdGVGcmFtZT86IENvb3JkaW5hdGVGcmFtZTtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1hdHJpeEJldHdlZW5Qcm9wZXJ0eSBleHRlbmRzIFRpbnlQcm9wZXJ0eTxNYXRyaXgzIHwgbnVsbD4ge1xyXG5cclxuICBwcml2YXRlIHJlYWRvbmx5IGZyb21BbmNlc3RvcnNQcm9wZXJ0eTogQW5jZXN0b3JOb2Rlc1Byb3BlcnR5O1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgdG9BbmNlc3RvcnNQcm9wZXJ0eTogQW5jZXN0b3JOb2Rlc1Byb3BlcnR5O1xyXG5cclxuICAvLyBXaGVuIHdlIGhhdmUgYSB1bmlxdWUgY29ubmVjdGlvbiB3aXRoIHRyYWlscywgdGhpcyB3aWxsIGNvbnRhaW4gdGhlIHJvb3Qgbm9kZSBjb21tb24gdG8gYm90aC5cclxuICAvLyBOT1RFOiBUaGlzIG1pZ2h0IGJlIG9uZSBvZiB0aGUgYWN0dWFsIG5vZGVzIGl0c2VsZi5cclxuICBwcml2YXRlIHJvb3ROb2RlOiBOb2RlIHwgbnVsbCA9IG51bGw7XHJcblxyXG4gIC8vIFdoZW4gd2UgaGF2ZSBhIHVuaXF1ZSBjb25uZWN0aW9uIHdpdGggdHJhaWxzLCB0aGVzZSB3aWxsIGNvbnRhaW4gdGhlIHRyYWlsIHRvIHRoZSByb290IG5vZGVcclxuICBwcml2YXRlIGZyb21UcmFpbDogVHJhaWwgfCBudWxsID0gbnVsbDtcclxuICBwcml2YXRlIHRvVHJhaWw6IFRyYWlsIHwgbnVsbCA9IG51bGw7XHJcblxyXG4gIHByaXZhdGUgcmVhZG9ubHkgZnJvbUNvb3JkaW5hdGVGcmFtZTogQ29vcmRpbmF0ZUZyYW1lO1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgdG9Db29yZGluYXRlRnJhbWU6IENvb3JkaW5hdGVGcmFtZTtcclxuXHJcbiAgLy8gQSBzZXQgb2Ygbm9kZXMgd2hlcmUgd2UgYXJlIGxpc3RlbmluZyB0byB3aGV0aGVyIHRoZWlyIHRyYW5zZm9ybXMgY2hhbmdlXHJcbiAgcHJpdmF0ZSByZWFkb25seSBsaXN0ZW5lZE5vZGVTZXQ6IFNldDxOb2RlPiA9IG5ldyBTZXQ8Tm9kZT4oKTtcclxuICBwcml2YXRlIHJlYWRvbmx5IF9ub2RlVHJhbnNmb3JtTGlzdGVuZXI6ICgpID0+IHZvaWQ7XHJcblxyXG4gIHB1YmxpYyBjb25zdHJ1Y3RvciggcHVibGljIHJlYWRvbmx5IGZyb206IE5vZGUsIHB1YmxpYyByZWFkb25seSB0bzogTm9kZSwgcHJvdmlkZWRPcHRpb25zPzogTWF0cml4QmV0d2VlblByb3BlcnR5T3B0aW9ucyApIHtcclxuXHJcbiAgICBjb25zdCBvcHRpb25zID0gb3B0aW9uaXplPE1hdHJpeEJldHdlZW5Qcm9wZXJ0eU9wdGlvbnM+KCkoIHtcclxuICAgICAgZnJvbUNvb3JkaW5hdGVGcmFtZTogJ2xvY2FsJyxcclxuICAgICAgdG9Db29yZGluYXRlRnJhbWU6ICdsb2NhbCdcclxuICAgIH0sIHByb3ZpZGVkT3B0aW9ucyApO1xyXG5cclxuICAgIHN1cGVyKCBNYXRyaXgzLklERU5USVRZICk7XHJcblxyXG4gICAgdGhpcy5mcm9tQ29vcmRpbmF0ZUZyYW1lID0gb3B0aW9ucy5mcm9tQ29vcmRpbmF0ZUZyYW1lO1xyXG4gICAgdGhpcy50b0Nvb3JkaW5hdGVGcmFtZSA9IG9wdGlvbnMudG9Db29yZGluYXRlRnJhbWU7XHJcblxyXG4gICAgLy8gSWRlbnRpY2FsIG1hdHJpY2VzIHNob3VsZG4ndCB0cmlnZ2VyIG5vdGlmaWNhdGlvbnNcclxuICAgIHRoaXMudmFsdWVDb21wYXJpc29uU3RyYXRlZ3kgPSAnZXF1YWxzRnVuY3Rpb24nO1xyXG5cclxuICAgIHRoaXMuZnJvbUFuY2VzdG9yc1Byb3BlcnR5ID0gbmV3IEFuY2VzdG9yTm9kZXNQcm9wZXJ0eSggZnJvbSApO1xyXG4gICAgdGhpcy50b0FuY2VzdG9yc1Byb3BlcnR5ID0gbmV3IEFuY2VzdG9yTm9kZXNQcm9wZXJ0eSggdG8gKTtcclxuXHJcbiAgICBjb25zdCB1cGRhdGVMaXN0ZW5lciA9IHRoaXMudXBkYXRlLmJpbmQoIHRoaXMgKTtcclxuICAgIHRoaXMuX25vZGVUcmFuc2Zvcm1MaXN0ZW5lciA9IHRoaXMudXBkYXRlTWF0cml4LmJpbmQoIHRoaXMgKTtcclxuXHJcbiAgICAvLyBXZSdsbCBvbmx5IHRyaWdnZXIgYSBmdWxsIHVwZGF0ZSB3aGVuIHBhcmVudHMvYW5jZXN0b3JzIGNoYW5nZSBhbnl3aGVyZS4gT3RoZXJ3aXNlLCB3ZSdsbCBqdXN0IGRvIHRyYW5zZm9ybVxyXG4gICAgLy8gY2hhbmdlcyB3aXRoIHVwZGF0ZU1hdHJpeCgpXHJcbiAgICB0aGlzLmZyb21BbmNlc3RvcnNQcm9wZXJ0eS51cGRhdGVFbWl0dGVyLmFkZExpc3RlbmVyKCB1cGRhdGVMaXN0ZW5lciApO1xyXG4gICAgdGhpcy50b0FuY2VzdG9yc1Byb3BlcnR5LnVwZGF0ZUVtaXR0ZXIuYWRkTGlzdGVuZXIoIHVwZGF0ZUxpc3RlbmVyICk7XHJcblxyXG4gICAgdGhpcy51cGRhdGUoKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgdXBkYXRlKCk6IHZvaWQge1xyXG4gICAgLy8gVHJhY2sgbm9kZXMgKG5vdCBqdXN0IGFuY2VzdG9ycykgaGVyZSwgaW4gY2FzZSBvbmUgaXMgYW4gYW5jZXN0b3Igb2YgdGhlIG90aGVyXHJcbiAgICAvLyBSRVZJRVc6IHdvdWxkIGl0IGJlIG1vcmUgcGVyZm9ybWFudCBmb3IgYmVsb3cgb3BwZXJhdGlvbnMgaWYgdGhlc2Ugd2VyZSBTZXRzP1xyXG4gICAgY29uc3QgZnJvbU5vZGVzID0gWyAuLi50aGlzLmZyb21BbmNlc3RvcnNQcm9wZXJ0eS52YWx1ZSwgdGhpcy5mcm9tIF07XHJcbiAgICBjb25zdCB0b05vZGVzID0gWyAuLi50aGlzLnRvQW5jZXN0b3JzUHJvcGVydHkudmFsdWUsIHRoaXMudG8gXTtcclxuXHJcbiAgICAvLyBJbnRlcnNlY3Rpb24gKGFuY2VzdG9ycyBvZiBmcm9tL3RvKVxyXG4gICAgY29uc3QgY29tbW9uTm9kZXMgPSBmcm9tTm9kZXMuZmlsdGVyKCBhID0+IHRvTm9kZXMuaW5jbHVkZXMoIGEgKSApO1xyXG5cclxuICAgIGxldCBoYXNEQUcgPSBmYWxzZTtcclxuXHJcbiAgICAvLyBXZSdsbCB3YW50IHRvIGZpbmQgYWxsIG5vZGVzIHRoYXQgYXJlIGNvbW1vbiBhbmNlc3RvcnMgb2YgYm90aCwgQlVUIGFyZW4ndCBzdXBlcmZsdW91cyAoYW4gYW5jZXN0b3Igb2YgYW5vdGhlclxyXG4gICAgLy8gY29tbW9uIGFuY2VzdG9yLCB3aXRoIG5vIG90aGVyIHBhdGhzKS5cclxuICAgIGNvbnN0IHJvb3ROb2RlcyA9IGNvbW1vbk5vZGVzLmZpbHRlciggbm9kZSA9PiB7XHJcbiAgICAgIGNvbnN0IGZyb21DaGlsZHJlbiA9IGZyb21Ob2Rlcy5maWx0ZXIoIGFOb2RlID0+IG5vZGUuaGFzQ2hpbGQoIGFOb2RlICkgKTtcclxuICAgICAgY29uc3QgdG9DaGlsZHJlbiA9IHRvTm9kZXMuZmlsdGVyKCBiTm9kZSA9PiBub2RlLmhhc0NoaWxkKCBiTm9kZSApICk7XHJcblxyXG4gICAgICBjb25zdCBmcm9tT25seTogTm9kZVtdID0gW107XHJcbiAgICAgIGNvbnN0IHRvT25seTogTm9kZVtdID0gW107XHJcbiAgICAgIGNvbnN0IGJvdGg6IE5vZGVbXSA9IFtdO1xyXG4gICAgICBhcnJheURpZmZlcmVuY2UoIGZyb21DaGlsZHJlbiwgdG9DaGlsZHJlbiwgZnJvbU9ubHksIHRvT25seSwgYm90aCApO1xyXG5cclxuICAgICAgY29uc3QgaGFzTXVsdGlwbGVDaGlsZHJlbiA9IGZyb21DaGlsZHJlbi5sZW5ndGggPiAxIHx8IHRvQ2hpbGRyZW4ubGVuZ3RoID4gMTtcclxuICAgICAgY29uc3QgaGFzVW5zaGFyZWRDaGlsZCA9IGZyb21Pbmx5Lmxlbmd0aCB8fCB0b09ubHkubGVuZ3RoO1xyXG5cclxuICAgICAgLy8gSWYgZWl0aGVyIGhhcyBtdWx0aXBsZSBjaGlsZHJlbiwgQU5EIHdlJ3JlIG5vdCBqdXN0IGEgdHJpdmlhbCBhbmNlc3RvciBvZiB0aGUgcm9vdCwgd2UncmUgaW4gYSBEQUcgY2FzZVxyXG4gICAgICBpZiAoIGhhc011bHRpcGxlQ2hpbGRyZW4gJiYgaGFzVW5zaGFyZWRDaGlsZCApIHtcclxuICAgICAgICBoYXNEQUcgPSB0cnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBoYXNGcm9tRXhjbHVzaXZlID0gZnJvbU9ubHkubGVuZ3RoID4gMCB8fCB0aGlzLmZyb20gPT09IG5vZGU7XHJcbiAgICAgIGNvbnN0IGhhc1RvRXhjbHVzaXZlID0gdG9Pbmx5Lmxlbmd0aCA+IDAgfHwgdGhpcy50byA9PT0gbm9kZTtcclxuXHJcbiAgICAgIHJldHVybiBoYXNGcm9tRXhjbHVzaXZlICYmIGhhc1RvRXhjbHVzaXZlO1xyXG4gICAgfSApO1xyXG5cclxuICAgIGlmICggIWhhc0RBRyAmJiByb290Tm9kZXMubGVuZ3RoID09PSAxICkge1xyXG4gICAgICAvLyBXZSBoYXZlIGEgcm9vdCBub2RlLCBhbmQgc2hvdWxkIGhhdmUgdW5pcXVlIHRyYWlscyFcclxuICAgICAgdGhpcy5yb290Tm9kZSA9IHJvb3ROb2Rlc1sgMCBdO1xyXG5cclxuICAgICAgLy8gVGhlc2Ugc2hvdWxkIGFzc2VydC1lcnJvciBvdXQgaWYgdGhlcmUgaXMgbm8gdW5pcXVlIHRyYWlsIGZvciBlaXRoZXJcclxuICAgICAgdGhpcy5mcm9tVHJhaWwgPSB0aGlzLmZyb20uZ2V0VW5pcXVlVHJhaWxUbyggdGhpcy5yb290Tm9kZSApO1xyXG4gICAgICB0aGlzLnRvVHJhaWwgPSB0aGlzLnRvLmdldFVuaXF1ZVRyYWlsVG8oIHRoaXMucm9vdE5vZGUgKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICB0aGlzLnJvb3ROb2RlID0gbnVsbDtcclxuICAgICAgdGhpcy5mcm9tVHJhaWwgPSBudWxsO1xyXG4gICAgICB0aGlzLnRvVHJhaWwgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRha2Ugbm90ZSBvZiB0aGUgbm9kZXMgd2UgYXJlIGxpc3RlbmluZyB0b1xyXG4gICAgY29uc3Qgbm9kZVNldCA9IG5ldyBTZXQ8Tm9kZT4oKTtcclxuICAgIHRoaXMuZnJvbVRyYWlsICYmIHRoaXMuZnJvbVRyYWlsLm5vZGVzLmZvckVhY2goIG5vZGUgPT4gbm9kZVNldC5hZGQoIG5vZGUgKSApO1xyXG4gICAgdGhpcy50b1RyYWlsICYmIHRoaXMudG9UcmFpbC5ub2Rlcy5mb3JFYWNoKCBub2RlID0+IG5vZGVTZXQuYWRkKCBub2RlICkgKTtcclxuXHJcbiAgICAvLyBBZGQgaW4gbmV3IG5lZWRlZCBsaXN0ZW5lcnNcclxuICAgIG5vZGVTZXQuZm9yRWFjaCggbm9kZSA9PiB7XHJcbiAgICAgIGlmICggIXRoaXMubGlzdGVuZWROb2RlU2V0Lmhhcyggbm9kZSApICkge1xyXG4gICAgICAgIHRoaXMuYWRkTm9kZUxpc3RlbmVyKCBub2RlICk7XHJcbiAgICAgIH1cclxuICAgIH0gKTtcclxuXHJcbiAgICAvLyBSZW1vdmUgbGlzdGVuZXJzIG5vdCBuZWVkZWQgYW55bW9yZVxyXG4gICAgdGhpcy5saXN0ZW5lZE5vZGVTZXQuZm9yRWFjaCggbm9kZSA9PiB7XHJcbiAgICAgIGlmICggIW5vZGVTZXQuaGFzKCBub2RlICkgJiYgbm9kZSAhPT0gdGhpcy5mcm9tICYmIG5vZGUgIT09IHRoaXMudG8gKSB7XHJcbiAgICAgICAgdGhpcy5yZW1vdmVOb2RlTGlzdGVuZXIoIG5vZGUgKTtcclxuICAgICAgfVxyXG4gICAgfSApO1xyXG5cclxuICAgIHRoaXMudXBkYXRlTWF0cml4KCk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHVwZGF0ZU1hdHJpeCgpOiB2b2lkIHtcclxuICAgIGlmICggdGhpcy5yb290Tm9kZSAmJiB0aGlzLmZyb21UcmFpbCAmJiB0aGlzLnRvVHJhaWwgKSB7XHJcblxyXG4gICAgICAvLyBJZiBvbmUgb2YgdGhlc2UgaXMgYW4gYW5jZXN0b3Igb2YgdGhlIG90aGVyIEFORCB0aGUgYW5jZXN0b3IgcmVxdWVzdHMgYSBcInBhcmVudFwiIGNvb3JkaW5hdGUgZnJhbWUsIHdlJ2xsIG5lZWRcclxuICAgICAgLy8gdG8gY29tcHV0ZSB0aGluZ3MgdG8gdGhlIG5leHQgbGV2ZWwgdXAuIE90aGVyd2lzZSwgd2UgY2FuIGlnbm9yZSB0aGUgcm9vdCBub2RlJ3MgdHJhbnNmb3JtLiBUaGlzIGlzIE5PVFxyXG4gICAgICAvLyBqdXN0IGFuIG9wdGltaXphdGlvbiwgc2luY2UgaWYgd2UgbXVsdGlwbHkgaW4gdGhlIHJvb3Qgbm9kZSdzIHRyYW5zZm9ybSBpbnRvIGJvdGggdGhlIGZyb21NYXRyaXggYW5kIHRvTWF0cml4LFxyXG4gICAgICAvLyB3ZSdsbCBsZWFkIHRvIG51bWVyaWNhbCBpbXByZWNpc2lvbiB0aGF0IGNvdWxkIGJlIGF2b2lkZWQuIFdpdGggdGhpcywgd2UgY2FuIGdldCBwcmVjaXNlL2V4YWN0IHJlc3VsdHMsIGV2ZW5cclxuICAgICAgLy8gaWYgdGhlcmUgaXMgYSBzY2FsZSBvbiB0aGUgcm9vdE5vZGUgKGltYWdpbmUgYSBTY3JlZW5WaWV3J3MgdHJhbnNmb3JtKS5cclxuICAgICAgY29uc3QgZnJvbVNlbGYgPSB0aGlzLmZyb21UcmFpbC5ub2Rlcy5sZW5ndGggPT09IDE7XHJcbiAgICAgIGNvbnN0IHRvU2VsZiA9IHRoaXMudG9UcmFpbC5ub2Rlcy5sZW5ndGggPT09IDE7XHJcbiAgICAgIGNvbnN0IHVzZUFuY2VzdG9yTWF0cml4ID0gKCBmcm9tU2VsZiAmJiB0aGlzLmZyb21Db29yZGluYXRlRnJhbWUgPT09ICdwYXJlbnQnICkgfHwgKCB0b1NlbGYgJiYgdGhpcy50b0Nvb3JkaW5hdGVGcmFtZSA9PT0gJ3BhcmVudCcgKTtcclxuXHJcbiAgICAgIC8vIEluc3RlYWQgb2Ygc3dpdGNoaW5nIGJldHdlZW4gNCBkaWZmZXJlbnQgbWF0cml4IGZ1bmN0aW9ucywgd2UgdXNlIHRoZSBnZW5lcmFsIGZvcm0uXHJcbiAgICAgIGNvbnN0IGZyb21NYXRyaXggPSB0aGlzLmZyb21UcmFpbC5nZXRNYXRyaXhDb25jYXRlbmF0aW9uKFxyXG4gICAgICAgIHVzZUFuY2VzdG9yTWF0cml4ID8gMCA6IDEsXHJcbiAgICAgICAgdGhpcy5mcm9tVHJhaWwubm9kZXMubGVuZ3RoIC0gKCB0aGlzLmZyb21Db29yZGluYXRlRnJhbWUgPT09ICdwYXJlbnQnID8gMSA6IDAgKVxyXG4gICAgICApO1xyXG4gICAgICBjb25zdCB0b01hdHJpeCA9IHRoaXMudG9UcmFpbC5nZXRNYXRyaXhDb25jYXRlbmF0aW9uKFxyXG4gICAgICAgIHVzZUFuY2VzdG9yTWF0cml4ID8gMCA6IDEsXHJcbiAgICAgICAgdGhpcy50b1RyYWlsLm5vZGVzLmxlbmd0aCAtICggdGhpcy50b0Nvb3JkaW5hdGVGcmFtZSA9PT0gJ3BhcmVudCcgPyAxIDogMCApXHJcbiAgICAgICk7XHJcblxyXG4gICAgICAvLyB0b1BvaW50ID0gdG9NYXRyaXheLTEgKiBmcm9tTWF0cml4ICogZnJvbVBvaW50XHJcbiAgICAgIHRoaXMudmFsdWUgPSB0b01hdHJpeC5pbnZlcnRlZCgpLnRpbWVzTWF0cml4KCBmcm9tTWF0cml4ICk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgdGhpcy52YWx1ZSA9IG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFkZE5vZGVMaXN0ZW5lciggbm9kZTogTm9kZSApOiB2b2lkIHtcclxuICAgIHRoaXMubGlzdGVuZWROb2RlU2V0LmFkZCggbm9kZSApO1xyXG4gICAgbm9kZS50cmFuc2Zvcm1FbWl0dGVyLmFkZExpc3RlbmVyKCB0aGlzLl9ub2RlVHJhbnNmb3JtTGlzdGVuZXIgKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgcmVtb3ZlTm9kZUxpc3RlbmVyKCBub2RlOiBOb2RlICk6IHZvaWQge1xyXG4gICAgdGhpcy5saXN0ZW5lZE5vZGVTZXQuZGVsZXRlKCBub2RlICk7XHJcbiAgICBub2RlLnRyYW5zZm9ybUVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoIHRoaXMuX25vZGVUcmFuc2Zvcm1MaXN0ZW5lciApO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIG92ZXJyaWRlIGRpc3Bvc2UoKTogdm9pZCB7XHJcbiAgICB0aGlzLmZyb21BbmNlc3RvcnNQcm9wZXJ0eS5kaXNwb3NlKCk7XHJcbiAgICB0aGlzLnRvQW5jZXN0b3JzUHJvcGVydHkuZGlzcG9zZSgpO1xyXG5cclxuICAgIHN1cGVyLmRpc3Bvc2UoKTtcclxuICB9XHJcbn1cclxuXHJcbnNjZW5lcnkucmVnaXN0ZXIoICdNYXRyaXhCZXR3ZWVuUHJvcGVydHknLCBNYXRyaXhCZXR3ZWVuUHJvcGVydHkgKTsiXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBT0EsWUFBWSxNQUFNLGtDQUFrQztBQUMzRCxPQUFPQyxPQUFPLE1BQU0sNEJBQTRCO0FBQ2hELE9BQU9DLGVBQWUsTUFBTSwwQ0FBMEM7QUFDdEUsT0FBT0MsU0FBUyxNQUFNLG9DQUFvQztBQUMxRCxTQUFTQyxxQkFBcUIsRUFBUUMsT0FBTyxRQUFlLGVBQWU7QUFVM0UsZUFBZSxNQUFNQyxxQkFBcUIsU0FBU04sWUFBWSxDQUFpQjtFQUs5RTtFQUNBO0VBQ1FPLFFBQVEsR0FBZ0IsSUFBSTs7RUFFcEM7RUFDUUMsU0FBUyxHQUFpQixJQUFJO0VBQzlCQyxPQUFPLEdBQWlCLElBQUk7RUFLcEM7RUFDaUJDLGVBQWUsR0FBYyxJQUFJQyxHQUFHLENBQU8sQ0FBQztFQUd0REMsV0FBV0EsQ0FBa0JDLElBQVUsRUFBa0JDLEVBQVEsRUFBRUMsZUFBOEMsRUFBRztJQUV6SCxNQUFNQyxPQUFPLEdBQUdiLFNBQVMsQ0FBK0IsQ0FBQyxDQUFFO01BQ3pEYyxtQkFBbUIsRUFBRSxPQUFPO01BQzVCQyxpQkFBaUIsRUFBRTtJQUNyQixDQUFDLEVBQUVILGVBQWdCLENBQUM7SUFFcEIsS0FBSyxDQUFFZCxPQUFPLENBQUNrQixRQUFTLENBQUM7SUFBQyxLQVBRTixJQUFVLEdBQVZBLElBQVU7SUFBQSxLQUFrQkMsRUFBUSxHQUFSQSxFQUFRO0lBU3RFLElBQUksQ0FBQ0csbUJBQW1CLEdBQUdELE9BQU8sQ0FBQ0MsbUJBQW1CO0lBQ3RELElBQUksQ0FBQ0MsaUJBQWlCLEdBQUdGLE9BQU8sQ0FBQ0UsaUJBQWlCOztJQUVsRDtJQUNBLElBQUksQ0FBQ0UsdUJBQXVCLEdBQUcsZ0JBQWdCO0lBRS9DLElBQUksQ0FBQ0MscUJBQXFCLEdBQUcsSUFBSWpCLHFCQUFxQixDQUFFUyxJQUFLLENBQUM7SUFDOUQsSUFBSSxDQUFDUyxtQkFBbUIsR0FBRyxJQUFJbEIscUJBQXFCLENBQUVVLEVBQUcsQ0FBQztJQUUxRCxNQUFNUyxjQUFjLEdBQUcsSUFBSSxDQUFDQyxNQUFNLENBQUNDLElBQUksQ0FBRSxJQUFLLENBQUM7SUFDL0MsSUFBSSxDQUFDQyxzQkFBc0IsR0FBRyxJQUFJLENBQUNDLFlBQVksQ0FBQ0YsSUFBSSxDQUFFLElBQUssQ0FBQzs7SUFFNUQ7SUFDQTtJQUNBLElBQUksQ0FBQ0oscUJBQXFCLENBQUNPLGFBQWEsQ0FBQ0MsV0FBVyxDQUFFTixjQUFlLENBQUM7SUFDdEUsSUFBSSxDQUFDRCxtQkFBbUIsQ0FBQ00sYUFBYSxDQUFDQyxXQUFXLENBQUVOLGNBQWUsQ0FBQztJQUVwRSxJQUFJLENBQUNDLE1BQU0sQ0FBQyxDQUFDO0VBQ2Y7RUFFUUEsTUFBTUEsQ0FBQSxFQUFTO0lBQ3JCO0lBQ0E7SUFDQSxNQUFNTSxTQUFTLEdBQUcsQ0FBRSxHQUFHLElBQUksQ0FBQ1QscUJBQXFCLENBQUNVLEtBQUssRUFBRSxJQUFJLENBQUNsQixJQUFJLENBQUU7SUFDcEUsTUFBTW1CLE9BQU8sR0FBRyxDQUFFLEdBQUcsSUFBSSxDQUFDVixtQkFBbUIsQ0FBQ1MsS0FBSyxFQUFFLElBQUksQ0FBQ2pCLEVBQUUsQ0FBRTs7SUFFOUQ7SUFDQSxNQUFNbUIsV0FBVyxHQUFHSCxTQUFTLENBQUNJLE1BQU0sQ0FBRUMsQ0FBQyxJQUFJSCxPQUFPLENBQUNJLFFBQVEsQ0FBRUQsQ0FBRSxDQUFFLENBQUM7SUFFbEUsSUFBSUUsTUFBTSxHQUFHLEtBQUs7O0lBRWxCO0lBQ0E7SUFDQSxNQUFNQyxTQUFTLEdBQUdMLFdBQVcsQ0FBQ0MsTUFBTSxDQUFFSyxJQUFJLElBQUk7TUFDNUMsTUFBTUMsWUFBWSxHQUFHVixTQUFTLENBQUNJLE1BQU0sQ0FBRU8sS0FBSyxJQUFJRixJQUFJLENBQUNHLFFBQVEsQ0FBRUQsS0FBTSxDQUFFLENBQUM7TUFDeEUsTUFBTUUsVUFBVSxHQUFHWCxPQUFPLENBQUNFLE1BQU0sQ0FBRVUsS0FBSyxJQUFJTCxJQUFJLENBQUNHLFFBQVEsQ0FBRUUsS0FBTSxDQUFFLENBQUM7TUFFcEUsTUFBTUMsUUFBZ0IsR0FBRyxFQUFFO01BQzNCLE1BQU1DLE1BQWMsR0FBRyxFQUFFO01BQ3pCLE1BQU1DLElBQVksR0FBRyxFQUFFO01BQ3ZCN0MsZUFBZSxDQUFFc0MsWUFBWSxFQUFFRyxVQUFVLEVBQUVFLFFBQVEsRUFBRUMsTUFBTSxFQUFFQyxJQUFLLENBQUM7TUFFbkUsTUFBTUMsbUJBQW1CLEdBQUdSLFlBQVksQ0FBQ1MsTUFBTSxHQUFHLENBQUMsSUFBSU4sVUFBVSxDQUFDTSxNQUFNLEdBQUcsQ0FBQztNQUM1RSxNQUFNQyxnQkFBZ0IsR0FBR0wsUUFBUSxDQUFDSSxNQUFNLElBQUlILE1BQU0sQ0FBQ0csTUFBTTs7TUFFekQ7TUFDQSxJQUFLRCxtQkFBbUIsSUFBSUUsZ0JBQWdCLEVBQUc7UUFDN0NiLE1BQU0sR0FBRyxJQUFJO01BQ2Y7TUFFQSxNQUFNYyxnQkFBZ0IsR0FBR04sUUFBUSxDQUFDSSxNQUFNLEdBQUcsQ0FBQyxJQUFJLElBQUksQ0FBQ3BDLElBQUksS0FBSzBCLElBQUk7TUFDbEUsTUFBTWEsY0FBYyxHQUFHTixNQUFNLENBQUNHLE1BQU0sR0FBRyxDQUFDLElBQUksSUFBSSxDQUFDbkMsRUFBRSxLQUFLeUIsSUFBSTtNQUU1RCxPQUFPWSxnQkFBZ0IsSUFBSUMsY0FBYztJQUMzQyxDQUFFLENBQUM7SUFFSCxJQUFLLENBQUNmLE1BQU0sSUFBSUMsU0FBUyxDQUFDVyxNQUFNLEtBQUssQ0FBQyxFQUFHO01BQ3ZDO01BQ0EsSUFBSSxDQUFDMUMsUUFBUSxHQUFHK0IsU0FBUyxDQUFFLENBQUMsQ0FBRTs7TUFFOUI7TUFDQSxJQUFJLENBQUM5QixTQUFTLEdBQUcsSUFBSSxDQUFDSyxJQUFJLENBQUN3QyxnQkFBZ0IsQ0FBRSxJQUFJLENBQUM5QyxRQUFTLENBQUM7TUFDNUQsSUFBSSxDQUFDRSxPQUFPLEdBQUcsSUFBSSxDQUFDSyxFQUFFLENBQUN1QyxnQkFBZ0IsQ0FBRSxJQUFJLENBQUM5QyxRQUFTLENBQUM7SUFDMUQsQ0FBQyxNQUNJO01BQ0gsSUFBSSxDQUFDQSxRQUFRLEdBQUcsSUFBSTtNQUNwQixJQUFJLENBQUNDLFNBQVMsR0FBRyxJQUFJO01BQ3JCLElBQUksQ0FBQ0MsT0FBTyxHQUFHLElBQUk7SUFDckI7O0lBRUE7SUFDQSxNQUFNNkMsT0FBTyxHQUFHLElBQUkzQyxHQUFHLENBQU8sQ0FBQztJQUMvQixJQUFJLENBQUNILFNBQVMsSUFBSSxJQUFJLENBQUNBLFNBQVMsQ0FBQytDLEtBQUssQ0FBQ0MsT0FBTyxDQUFFakIsSUFBSSxJQUFJZSxPQUFPLENBQUNHLEdBQUcsQ0FBRWxCLElBQUssQ0FBRSxDQUFDO0lBQzdFLElBQUksQ0FBQzlCLE9BQU8sSUFBSSxJQUFJLENBQUNBLE9BQU8sQ0FBQzhDLEtBQUssQ0FBQ0MsT0FBTyxDQUFFakIsSUFBSSxJQUFJZSxPQUFPLENBQUNHLEdBQUcsQ0FBRWxCLElBQUssQ0FBRSxDQUFDOztJQUV6RTtJQUNBZSxPQUFPLENBQUNFLE9BQU8sQ0FBRWpCLElBQUksSUFBSTtNQUN2QixJQUFLLENBQUMsSUFBSSxDQUFDN0IsZUFBZSxDQUFDZ0QsR0FBRyxDQUFFbkIsSUFBSyxDQUFDLEVBQUc7UUFDdkMsSUFBSSxDQUFDb0IsZUFBZSxDQUFFcEIsSUFBSyxDQUFDO01BQzlCO0lBQ0YsQ0FBRSxDQUFDOztJQUVIO0lBQ0EsSUFBSSxDQUFDN0IsZUFBZSxDQUFDOEMsT0FBTyxDQUFFakIsSUFBSSxJQUFJO01BQ3BDLElBQUssQ0FBQ2UsT0FBTyxDQUFDSSxHQUFHLENBQUVuQixJQUFLLENBQUMsSUFBSUEsSUFBSSxLQUFLLElBQUksQ0FBQzFCLElBQUksSUFBSTBCLElBQUksS0FBSyxJQUFJLENBQUN6QixFQUFFLEVBQUc7UUFDcEUsSUFBSSxDQUFDOEMsa0JBQWtCLENBQUVyQixJQUFLLENBQUM7TUFDakM7SUFDRixDQUFFLENBQUM7SUFFSCxJQUFJLENBQUNaLFlBQVksQ0FBQyxDQUFDO0VBQ3JCO0VBRVFBLFlBQVlBLENBQUEsRUFBUztJQUMzQixJQUFLLElBQUksQ0FBQ3BCLFFBQVEsSUFBSSxJQUFJLENBQUNDLFNBQVMsSUFBSSxJQUFJLENBQUNDLE9BQU8sRUFBRztNQUVyRDtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0EsTUFBTW9ELFFBQVEsR0FBRyxJQUFJLENBQUNyRCxTQUFTLENBQUMrQyxLQUFLLENBQUNOLE1BQU0sS0FBSyxDQUFDO01BQ2xELE1BQU1hLE1BQU0sR0FBRyxJQUFJLENBQUNyRCxPQUFPLENBQUM4QyxLQUFLLENBQUNOLE1BQU0sS0FBSyxDQUFDO01BQzlDLE1BQU1jLGlCQUFpQixHQUFLRixRQUFRLElBQUksSUFBSSxDQUFDNUMsbUJBQW1CLEtBQUssUUFBUSxJQUFRNkMsTUFBTSxJQUFJLElBQUksQ0FBQzVDLGlCQUFpQixLQUFLLFFBQVU7O01BRXBJO01BQ0EsTUFBTThDLFVBQVUsR0FBRyxJQUFJLENBQUN4RCxTQUFTLENBQUN5RCxzQkFBc0IsQ0FDdERGLGlCQUFpQixHQUFHLENBQUMsR0FBRyxDQUFDLEVBQ3pCLElBQUksQ0FBQ3ZELFNBQVMsQ0FBQytDLEtBQUssQ0FBQ04sTUFBTSxJQUFLLElBQUksQ0FBQ2hDLG1CQUFtQixLQUFLLFFBQVEsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUMvRSxDQUFDO01BQ0QsTUFBTWlELFFBQVEsR0FBRyxJQUFJLENBQUN6RCxPQUFPLENBQUN3RCxzQkFBc0IsQ0FDbERGLGlCQUFpQixHQUFHLENBQUMsR0FBRyxDQUFDLEVBQ3pCLElBQUksQ0FBQ3RELE9BQU8sQ0FBQzhDLEtBQUssQ0FBQ04sTUFBTSxJQUFLLElBQUksQ0FBQy9CLGlCQUFpQixLQUFLLFFBQVEsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUMzRSxDQUFDOztNQUVEO01BQ0EsSUFBSSxDQUFDYSxLQUFLLEdBQUdtQyxRQUFRLENBQUNDLFFBQVEsQ0FBQyxDQUFDLENBQUNDLFdBQVcsQ0FBRUosVUFBVyxDQUFDO0lBQzVELENBQUMsTUFDSTtNQUNILElBQUksQ0FBQ2pDLEtBQUssR0FBRyxJQUFJO0lBQ25CO0VBQ0Y7RUFFUTRCLGVBQWVBLENBQUVwQixJQUFVLEVBQVM7SUFDMUMsSUFBSSxDQUFDN0IsZUFBZSxDQUFDK0MsR0FBRyxDQUFFbEIsSUFBSyxDQUFDO0lBQ2hDQSxJQUFJLENBQUM4QixnQkFBZ0IsQ0FBQ3hDLFdBQVcsQ0FBRSxJQUFJLENBQUNILHNCQUF1QixDQUFDO0VBQ2xFO0VBRVFrQyxrQkFBa0JBLENBQUVyQixJQUFVLEVBQVM7SUFDN0MsSUFBSSxDQUFDN0IsZUFBZSxDQUFDNEQsTUFBTSxDQUFFL0IsSUFBSyxDQUFDO0lBQ25DQSxJQUFJLENBQUM4QixnQkFBZ0IsQ0FBQ0UsY0FBYyxDQUFFLElBQUksQ0FBQzdDLHNCQUF1QixDQUFDO0VBQ3JFO0VBRWdCOEMsT0FBT0EsQ0FBQSxFQUFTO0lBQzlCLElBQUksQ0FBQ25ELHFCQUFxQixDQUFDbUQsT0FBTyxDQUFDLENBQUM7SUFDcEMsSUFBSSxDQUFDbEQsbUJBQW1CLENBQUNrRCxPQUFPLENBQUMsQ0FBQztJQUVsQyxLQUFLLENBQUNBLE9BQU8sQ0FBQyxDQUFDO0VBQ2pCO0FBQ0Y7QUFFQW5FLE9BQU8sQ0FBQ29FLFFBQVEsQ0FBRSx1QkFBdUIsRUFBRW5FLHFCQUFzQixDQUFDIiwiaWdub3JlTGlzdCI6W119