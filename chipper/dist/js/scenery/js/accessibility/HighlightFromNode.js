// Copyright 2017-2024, University of Colorado Boulder

/**
 * A HighlightPath subtype that is based around a Node. The focusHighlight is constructed based on the bounds of
 * the node. The focusHighlight will update as the Node's bounds changes. Handles transformations so that when the
 * source node is transformed, the HighlightFromNode will
 * updated be as well.
 *
 * @author Michael Kauzmann (PhET Interactive Simulations)
 * @author Jesse Greenberg (PhET Interactive Simulations)
 */

import { Shape } from '../../../kite/js/imports.js';
import optionize from '../../../phet-core/js/optionize.js';
import { HighlightPath, scenery } from '../imports.js';

// The transformSourceNode for this highlight will be the provided Node.

class HighlightFromNode extends HighlightPath {
  // See options for documentation.

  // Property for a Node's bounds which are currently being observed with the boundsListener. Referenced so that
  // we can remove the listener later.
  observedBoundsProperty = null;

  // Listener that sets the shape of this highlight when the Node bounds change. Referenced so it can be removed later.
  boundsListener = null;
  constructor(node, providedOptions) {
    const options = optionize()({
      useLocalBounds: true,
      dilationCoefficient: null,
      useGroupDilation: false
    }, providedOptions);
    options.transformSourceNode = node;
    super(null, options);
    this.useLocalBounds = options.useLocalBounds;
    this.useGroupDilation = options.useGroupDilation;
    this.dilationCoefficient = options.dilationCoefficient;
    if (node) {
      this.setShapeFromNode(node);
    }
  }

  /**
   * Update the focusHighlight shape on the path given the node passed in. Depending on options supplied to this
   * HighlightFromNode, the shape will surround the node's bounds or its local bounds, dilated by an amount
   * that is dependent on whether or not this highlight is for group content or for the node itself. See
   * ParallelDOM.setGroupFocusHighlight() for more information on group highlights.
   *
   * node - The Node with a highlight to surround.
   * [trail] - A Trail to use to describe the Node in the global coordinate frame.
   *           Provided by the HighlightOverlay, to support DAG.
   */
  setShapeFromNode(node, trail) {
    // cleanup the previous listener
    if (this.observedBoundsProperty) {
      assert && assert(this.boundsListener, 'should be a listener if there is a previous focusHighlightNode');
      this.observedBoundsProperty.unlink(this.boundsListener);
    }

    // The HighlightOverlay updates highlight positioning with a TransformTracker so the local bounds accurately
    // describe the highlight shape. NOTE: This does not update with changes to visible bounds - scenery
    // does not have support for that at this time (requires a visibleBoundsProperty).
    this.observedBoundsProperty = node.localBoundsProperty;
    this.boundsListener = localBounds => {
      // Ignore setting the shape if we don't yet have finite bounds.
      if (!localBounds.isFinite()) {
        return;
      }
      let dilationCoefficient = this.dilationCoefficient;

      // Get the matrix that will transform the node's local bounds to global coordinates.
      // Then apply a pan/zoom correction so that the highlight looks appropriately
      // sized from pan/zoom transformation but other transformations are not applied.
      assert && assert(trail || node.getTrails().length < 2, 'HighlightFromNode requires a unique Trail if using DAG.');
      const trailToUse = trail || node.getUniqueTrail();
      const matrix = trailToUse.getMatrix().timesMatrix(HighlightPath.getCorrectiveScalingMatrix());

      // Figure out how much dilation to apply to the focus highlight around the node, calculated unless specified
      // with options
      if (this.dilationCoefficient === null) {
        dilationCoefficient = this.useGroupDilation ? HighlightPath.getGroupDilationCoefficient(matrix) : HighlightPath.getDilationCoefficient(matrix);
      }
      const visibleBounds = this.useLocalBounds ? node.getVisibleLocalBounds() : node.getVisibleBounds();
      const dilatedVisibleBounds = visibleBounds.dilated(dilationCoefficient);

      // Update the line width of the focus highlight based on the transform of the node
      this.setShape(Shape.bounds(dilatedVisibleBounds));
    };
    this.observedBoundsProperty.link(this.boundsListener);
  }

  /**
   * Remove the listener from the observedBoundsProperty (which belongs to a provided Node).
   */
  dispose() {
    if (this.observedBoundsProperty) {
      assert && assert(this.boundsListener, 'should be a listener if there is a previous focusHighlightNode');
      this.observedBoundsProperty.unlink(this.boundsListener);
    }
    super.dispose();
  }
}
scenery.register('HighlightFromNode', HighlightFromNode);
export default HighlightFromNode;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJTaGFwZSIsIm9wdGlvbml6ZSIsIkhpZ2hsaWdodFBhdGgiLCJzY2VuZXJ5IiwiSGlnaGxpZ2h0RnJvbU5vZGUiLCJvYnNlcnZlZEJvdW5kc1Byb3BlcnR5IiwiYm91bmRzTGlzdGVuZXIiLCJjb25zdHJ1Y3RvciIsIm5vZGUiLCJwcm92aWRlZE9wdGlvbnMiLCJvcHRpb25zIiwidXNlTG9jYWxCb3VuZHMiLCJkaWxhdGlvbkNvZWZmaWNpZW50IiwidXNlR3JvdXBEaWxhdGlvbiIsInRyYW5zZm9ybVNvdXJjZU5vZGUiLCJzZXRTaGFwZUZyb21Ob2RlIiwidHJhaWwiLCJhc3NlcnQiLCJ1bmxpbmsiLCJsb2NhbEJvdW5kc1Byb3BlcnR5IiwibG9jYWxCb3VuZHMiLCJpc0Zpbml0ZSIsImdldFRyYWlscyIsImxlbmd0aCIsInRyYWlsVG9Vc2UiLCJnZXRVbmlxdWVUcmFpbCIsIm1hdHJpeCIsImdldE1hdHJpeCIsInRpbWVzTWF0cml4IiwiZ2V0Q29ycmVjdGl2ZVNjYWxpbmdNYXRyaXgiLCJnZXRHcm91cERpbGF0aW9uQ29lZmZpY2llbnQiLCJnZXREaWxhdGlvbkNvZWZmaWNpZW50IiwidmlzaWJsZUJvdW5kcyIsImdldFZpc2libGVMb2NhbEJvdW5kcyIsImdldFZpc2libGVCb3VuZHMiLCJkaWxhdGVkVmlzaWJsZUJvdW5kcyIsImRpbGF0ZWQiLCJzZXRTaGFwZSIsImJvdW5kcyIsImxpbmsiLCJkaXNwb3NlIiwicmVnaXN0ZXIiXSwic291cmNlcyI6WyJIaWdobGlnaHRGcm9tTm9kZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAxNy0yMDI0LCBVbml2ZXJzaXR5IG9mIENvbG9yYWRvIEJvdWxkZXJcclxuXHJcbi8qKlxyXG4gKiBBIEhpZ2hsaWdodFBhdGggc3VidHlwZSB0aGF0IGlzIGJhc2VkIGFyb3VuZCBhIE5vZGUuIFRoZSBmb2N1c0hpZ2hsaWdodCBpcyBjb25zdHJ1Y3RlZCBiYXNlZCBvbiB0aGUgYm91bmRzIG9mXHJcbiAqIHRoZSBub2RlLiBUaGUgZm9jdXNIaWdobGlnaHQgd2lsbCB1cGRhdGUgYXMgdGhlIE5vZGUncyBib3VuZHMgY2hhbmdlcy4gSGFuZGxlcyB0cmFuc2Zvcm1hdGlvbnMgc28gdGhhdCB3aGVuIHRoZVxyXG4gKiBzb3VyY2Ugbm9kZSBpcyB0cmFuc2Zvcm1lZCwgdGhlIEhpZ2hsaWdodEZyb21Ob2RlIHdpbGxcclxuICogdXBkYXRlZCBiZSBhcyB3ZWxsLlxyXG4gKlxyXG4gKiBAYXV0aG9yIE1pY2hhZWwgS2F1em1hbm4gKFBoRVQgSW50ZXJhY3RpdmUgU2ltdWxhdGlvbnMpXHJcbiAqIEBhdXRob3IgSmVzc2UgR3JlZW5iZXJnIChQaEVUIEludGVyYWN0aXZlIFNpbXVsYXRpb25zKVxyXG4gKi9cclxuXHJcbmltcG9ydCBUUHJvcGVydHkgZnJvbSAnLi4vLi4vLi4vYXhvbi9qcy9UUHJvcGVydHkuanMnO1xyXG5pbXBvcnQgU3RyaWN0T21pdCBmcm9tICcuLi8uLi8uLi9waGV0LWNvcmUvanMvdHlwZXMvU3RyaWN0T21pdC5qcyc7XHJcbmltcG9ydCBCb3VuZHMyIGZyb20gJy4uLy4uLy4uL2RvdC9qcy9Cb3VuZHMyLmpzJztcclxuaW1wb3J0IHsgU2hhcGUgfSBmcm9tICcuLi8uLi8uLi9raXRlL2pzL2ltcG9ydHMuanMnO1xyXG5pbXBvcnQgb3B0aW9uaXplIGZyb20gJy4uLy4uLy4uL3BoZXQtY29yZS9qcy9vcHRpb25pemUuanMnO1xyXG5pbXBvcnQgeyBIaWdobGlnaHRQYXRoLCBIaWdobGlnaHRQYXRoT3B0aW9ucywgTm9kZSwgc2NlbmVyeSwgVHJhaWwgfSBmcm9tICcuLi9pbXBvcnRzLmpzJztcclxuXHJcbnR5cGUgU2VsZk9wdGlvbnMgPSB7XHJcblxyXG4gIC8vIGlmIHRydWUsIGhpZ2hsaWdodCB3aWxsIHN1cnJvdW5kIGxvY2FsIGJvdW5kcyBpbnN0ZWFkIG9mIHBhcmVudCBib3VuZHNcclxuICB1c2VMb2NhbEJvdW5kcz86IGJvb2xlYW47XHJcblxyXG4gIC8vIGRlZmF1bHQgdmFsdWUgaXMgZnVuY3Rpb24gb2Ygbm9kZSB0cmFuc2Zvcm0gKG1pbnVzIHRyYW5zbGF0aW9uKSwgYnV0IGNhbiBiZSBzZXQgZXhwbGljaXRseS5cclxuICAvLyBzZWUgSGlnaGxpZ2h0UGF0aC5nZXREaWxhdGlvbkNvZWZmaWNpZW50KCkuIEEgbnVtYmVyIGhlcmUgcmVmZXJzIHRvIHRoZSBhbW91bnQgaW4gZ2xvYmFsIGNvb3JkaW5hdGVzIHRvXHJcbiAgLy8gZGlsYXRlIHRoZSBmb2N1cyBoaWdobGlnaHQuXHJcbiAgZGlsYXRpb25Db2VmZmljaWVudD86IG51bWJlciB8IG51bGw7XHJcblxyXG4gIC8vIGlmIHRydWUsIGRpbGF0aW9uIGZvciBib3VuZHMgYXJvdW5kIG5vZGUgd2lsbCBpbmNyZWFzZSwgc2VlIHNldFNoYXBlRnJvbU5vZGUoKVxyXG4gIHVzZUdyb3VwRGlsYXRpb24/OiBib29sZWFuO1xyXG59O1xyXG5cclxuLy8gVGhlIHRyYW5zZm9ybVNvdXJjZU5vZGUgZm9yIHRoaXMgaGlnaGxpZ2h0IHdpbGwgYmUgdGhlIHByb3ZpZGVkIE5vZGUuXHJcbmV4cG9ydCB0eXBlIEhpZ2hsaWdodEZyb21Ob2RlT3B0aW9ucyA9IFNlbGZPcHRpb25zICYgU3RyaWN0T21pdDxIaWdobGlnaHRQYXRoT3B0aW9ucywgJ3RyYW5zZm9ybVNvdXJjZU5vZGUnPjtcclxuXHJcbmNsYXNzIEhpZ2hsaWdodEZyb21Ob2RlIGV4dGVuZHMgSGlnaGxpZ2h0UGF0aCB7XHJcblxyXG4gIC8vIFNlZSBvcHRpb25zIGZvciBkb2N1bWVudGF0aW9uLlxyXG4gIHByaXZhdGUgcmVhZG9ubHkgdXNlTG9jYWxCb3VuZHM6IGJvb2xlYW47XHJcbiAgcHJpdmF0ZSByZWFkb25seSB1c2VHcm91cERpbGF0aW9uOiBib29sZWFuO1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgZGlsYXRpb25Db2VmZmljaWVudDogbnVtYmVyIHwgbnVsbDtcclxuXHJcbiAgLy8gUHJvcGVydHkgZm9yIGEgTm9kZSdzIGJvdW5kcyB3aGljaCBhcmUgY3VycmVudGx5IGJlaW5nIG9ic2VydmVkIHdpdGggdGhlIGJvdW5kc0xpc3RlbmVyLiBSZWZlcmVuY2VkIHNvIHRoYXRcclxuICAvLyB3ZSBjYW4gcmVtb3ZlIHRoZSBsaXN0ZW5lciBsYXRlci5cclxuICBwcml2YXRlIG9ic2VydmVkQm91bmRzUHJvcGVydHk6IG51bGwgfCBUUHJvcGVydHk8Qm91bmRzMj4gPSBudWxsO1xyXG5cclxuICAvLyBMaXN0ZW5lciB0aGF0IHNldHMgdGhlIHNoYXBlIG9mIHRoaXMgaGlnaGxpZ2h0IHdoZW4gdGhlIE5vZGUgYm91bmRzIGNoYW5nZS4gUmVmZXJlbmNlZCBzbyBpdCBjYW4gYmUgcmVtb3ZlZCBsYXRlci5cclxuICBwcml2YXRlIGJvdW5kc0xpc3RlbmVyOiBudWxsIHwgKCAoIGJvdW5kczogQm91bmRzMiApID0+IHZvaWQgKSA9IG51bGw7XHJcblxyXG4gIHB1YmxpYyBjb25zdHJ1Y3Rvciggbm9kZTogTm9kZSB8IG51bGwsIHByb3ZpZGVkT3B0aW9ucz86IEhpZ2hsaWdodEZyb21Ob2RlT3B0aW9ucyApIHtcclxuXHJcbiAgICBjb25zdCBvcHRpb25zID0gb3B0aW9uaXplPEhpZ2hsaWdodEZyb21Ob2RlT3B0aW9ucywgU2VsZk9wdGlvbnMsIEhpZ2hsaWdodFBhdGhPcHRpb25zPigpKCB7XHJcbiAgICAgIHVzZUxvY2FsQm91bmRzOiB0cnVlLFxyXG4gICAgICBkaWxhdGlvbkNvZWZmaWNpZW50OiBudWxsLFxyXG4gICAgICB1c2VHcm91cERpbGF0aW9uOiBmYWxzZVxyXG4gICAgfSwgcHJvdmlkZWRPcHRpb25zICk7XHJcblxyXG4gICAgb3B0aW9ucy50cmFuc2Zvcm1Tb3VyY2VOb2RlID0gbm9kZTtcclxuXHJcbiAgICBzdXBlciggbnVsbCwgb3B0aW9ucyApO1xyXG5cclxuICAgIHRoaXMudXNlTG9jYWxCb3VuZHMgPSBvcHRpb25zLnVzZUxvY2FsQm91bmRzO1xyXG4gICAgdGhpcy51c2VHcm91cERpbGF0aW9uID0gb3B0aW9ucy51c2VHcm91cERpbGF0aW9uO1xyXG4gICAgdGhpcy5kaWxhdGlvbkNvZWZmaWNpZW50ID0gb3B0aW9ucy5kaWxhdGlvbkNvZWZmaWNpZW50O1xyXG5cclxuICAgIGlmICggbm9kZSApIHtcclxuICAgICAgdGhpcy5zZXRTaGFwZUZyb21Ob2RlKCBub2RlICk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGUgdGhlIGZvY3VzSGlnaGxpZ2h0IHNoYXBlIG9uIHRoZSBwYXRoIGdpdmVuIHRoZSBub2RlIHBhc3NlZCBpbi4gRGVwZW5kaW5nIG9uIG9wdGlvbnMgc3VwcGxpZWQgdG8gdGhpc1xyXG4gICAqIEhpZ2hsaWdodEZyb21Ob2RlLCB0aGUgc2hhcGUgd2lsbCBzdXJyb3VuZCB0aGUgbm9kZSdzIGJvdW5kcyBvciBpdHMgbG9jYWwgYm91bmRzLCBkaWxhdGVkIGJ5IGFuIGFtb3VudFxyXG4gICAqIHRoYXQgaXMgZGVwZW5kZW50IG9uIHdoZXRoZXIgb3Igbm90IHRoaXMgaGlnaGxpZ2h0IGlzIGZvciBncm91cCBjb250ZW50IG9yIGZvciB0aGUgbm9kZSBpdHNlbGYuIFNlZVxyXG4gICAqIFBhcmFsbGVsRE9NLnNldEdyb3VwRm9jdXNIaWdobGlnaHQoKSBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBncm91cCBoaWdobGlnaHRzLlxyXG4gICAqXHJcbiAgICogbm9kZSAtIFRoZSBOb2RlIHdpdGggYSBoaWdobGlnaHQgdG8gc3Vycm91bmQuXHJcbiAgICogW3RyYWlsXSAtIEEgVHJhaWwgdG8gdXNlIHRvIGRlc2NyaWJlIHRoZSBOb2RlIGluIHRoZSBnbG9iYWwgY29vcmRpbmF0ZSBmcmFtZS5cclxuICAgKiAgICAgICAgICAgUHJvdmlkZWQgYnkgdGhlIEhpZ2hsaWdodE92ZXJsYXksIHRvIHN1cHBvcnQgREFHLlxyXG4gICAqL1xyXG4gIHB1YmxpYyBzZXRTaGFwZUZyb21Ob2RlKCBub2RlOiBOb2RlLCB0cmFpbD86IFRyYWlsICk6IHZvaWQge1xyXG5cclxuICAgIC8vIGNsZWFudXAgdGhlIHByZXZpb3VzIGxpc3RlbmVyXHJcbiAgICBpZiAoIHRoaXMub2JzZXJ2ZWRCb3VuZHNQcm9wZXJ0eSApIHtcclxuICAgICAgYXNzZXJ0ICYmIGFzc2VydCggdGhpcy5ib3VuZHNMaXN0ZW5lciwgJ3Nob3VsZCBiZSBhIGxpc3RlbmVyIGlmIHRoZXJlIGlzIGEgcHJldmlvdXMgZm9jdXNIaWdobGlnaHROb2RlJyApO1xyXG4gICAgICB0aGlzLm9ic2VydmVkQm91bmRzUHJvcGVydHkudW5saW5rKCB0aGlzLmJvdW5kc0xpc3RlbmVyISApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRoZSBIaWdobGlnaHRPdmVybGF5IHVwZGF0ZXMgaGlnaGxpZ2h0IHBvc2l0aW9uaW5nIHdpdGggYSBUcmFuc2Zvcm1UcmFja2VyIHNvIHRoZSBsb2NhbCBib3VuZHMgYWNjdXJhdGVseVxyXG4gICAgLy8gZGVzY3JpYmUgdGhlIGhpZ2hsaWdodCBzaGFwZS4gTk9URTogVGhpcyBkb2VzIG5vdCB1cGRhdGUgd2l0aCBjaGFuZ2VzIHRvIHZpc2libGUgYm91bmRzIC0gc2NlbmVyeVxyXG4gICAgLy8gZG9lcyBub3QgaGF2ZSBzdXBwb3J0IGZvciB0aGF0IGF0IHRoaXMgdGltZSAocmVxdWlyZXMgYSB2aXNpYmxlQm91bmRzUHJvcGVydHkpLlxyXG4gICAgdGhpcy5vYnNlcnZlZEJvdW5kc1Byb3BlcnR5ID0gbm9kZS5sb2NhbEJvdW5kc1Byb3BlcnR5O1xyXG4gICAgdGhpcy5ib3VuZHNMaXN0ZW5lciA9IGxvY2FsQm91bmRzID0+IHtcclxuXHJcbiAgICAgIC8vIElnbm9yZSBzZXR0aW5nIHRoZSBzaGFwZSBpZiB3ZSBkb24ndCB5ZXQgaGF2ZSBmaW5pdGUgYm91bmRzLlxyXG4gICAgICBpZiAoICFsb2NhbEJvdW5kcy5pc0Zpbml0ZSgpICkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgbGV0IGRpbGF0aW9uQ29lZmZpY2llbnQgPSB0aGlzLmRpbGF0aW9uQ29lZmZpY2llbnQ7XHJcblxyXG4gICAgICAvLyBHZXQgdGhlIG1hdHJpeCB0aGF0IHdpbGwgdHJhbnNmb3JtIHRoZSBub2RlJ3MgbG9jYWwgYm91bmRzIHRvIGdsb2JhbCBjb29yZGluYXRlcy5cclxuICAgICAgLy8gVGhlbiBhcHBseSBhIHBhbi96b29tIGNvcnJlY3Rpb24gc28gdGhhdCB0aGUgaGlnaGxpZ2h0IGxvb2tzIGFwcHJvcHJpYXRlbHlcclxuICAgICAgLy8gc2l6ZWQgZnJvbSBwYW4vem9vbSB0cmFuc2Zvcm1hdGlvbiBidXQgb3RoZXIgdHJhbnNmb3JtYXRpb25zIGFyZSBub3QgYXBwbGllZC5cclxuICAgICAgYXNzZXJ0ICYmIGFzc2VydCggdHJhaWwgfHwgbm9kZS5nZXRUcmFpbHMoKS5sZW5ndGggPCAyLCAnSGlnaGxpZ2h0RnJvbU5vZGUgcmVxdWlyZXMgYSB1bmlxdWUgVHJhaWwgaWYgdXNpbmcgREFHLicgKTtcclxuICAgICAgY29uc3QgdHJhaWxUb1VzZSA9IHRyYWlsIHx8IG5vZGUuZ2V0VW5pcXVlVHJhaWwoKTtcclxuICAgICAgY29uc3QgbWF0cml4ID0gdHJhaWxUb1VzZS5nZXRNYXRyaXgoKVxyXG4gICAgICAgIC50aW1lc01hdHJpeCggSGlnaGxpZ2h0UGF0aC5nZXRDb3JyZWN0aXZlU2NhbGluZ01hdHJpeCgpICk7XHJcblxyXG4gICAgICAvLyBGaWd1cmUgb3V0IGhvdyBtdWNoIGRpbGF0aW9uIHRvIGFwcGx5IHRvIHRoZSBmb2N1cyBoaWdobGlnaHQgYXJvdW5kIHRoZSBub2RlLCBjYWxjdWxhdGVkIHVubGVzcyBzcGVjaWZpZWRcclxuICAgICAgLy8gd2l0aCBvcHRpb25zXHJcbiAgICAgIGlmICggdGhpcy5kaWxhdGlvbkNvZWZmaWNpZW50ID09PSBudWxsICkge1xyXG4gICAgICAgIGRpbGF0aW9uQ29lZmZpY2llbnQgPSAoIHRoaXMudXNlR3JvdXBEaWxhdGlvbiA/IEhpZ2hsaWdodFBhdGguZ2V0R3JvdXBEaWxhdGlvbkNvZWZmaWNpZW50KCBtYXRyaXggKSA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSGlnaGxpZ2h0UGF0aC5nZXREaWxhdGlvbkNvZWZmaWNpZW50KCBtYXRyaXggKSApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCB2aXNpYmxlQm91bmRzID0gdGhpcy51c2VMb2NhbEJvdW5kcyA/IG5vZGUuZ2V0VmlzaWJsZUxvY2FsQm91bmRzKCkgOiBub2RlLmdldFZpc2libGVCb3VuZHMoKTtcclxuICAgICAgY29uc3QgZGlsYXRlZFZpc2libGVCb3VuZHMgPSB2aXNpYmxlQm91bmRzLmRpbGF0ZWQoIGRpbGF0aW9uQ29lZmZpY2llbnQhICk7XHJcblxyXG4gICAgICAvLyBVcGRhdGUgdGhlIGxpbmUgd2lkdGggb2YgdGhlIGZvY3VzIGhpZ2hsaWdodCBiYXNlZCBvbiB0aGUgdHJhbnNmb3JtIG9mIHRoZSBub2RlXHJcbiAgICAgIHRoaXMuc2V0U2hhcGUoIFNoYXBlLmJvdW5kcyggZGlsYXRlZFZpc2libGVCb3VuZHMgKSApO1xyXG4gICAgfTtcclxuICAgIHRoaXMub2JzZXJ2ZWRCb3VuZHNQcm9wZXJ0eS5saW5rKCB0aGlzLmJvdW5kc0xpc3RlbmVyICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZW1vdmUgdGhlIGxpc3RlbmVyIGZyb20gdGhlIG9ic2VydmVkQm91bmRzUHJvcGVydHkgKHdoaWNoIGJlbG9uZ3MgdG8gYSBwcm92aWRlZCBOb2RlKS5cclxuICAgKi9cclxuICBwdWJsaWMgb3ZlcnJpZGUgZGlzcG9zZSgpOiB2b2lkIHtcclxuICAgIGlmICggdGhpcy5vYnNlcnZlZEJvdW5kc1Byb3BlcnR5ICkge1xyXG4gICAgICBhc3NlcnQgJiYgYXNzZXJ0KCB0aGlzLmJvdW5kc0xpc3RlbmVyLCAnc2hvdWxkIGJlIGEgbGlzdGVuZXIgaWYgdGhlcmUgaXMgYSBwcmV2aW91cyBmb2N1c0hpZ2hsaWdodE5vZGUnICk7XHJcbiAgICAgIHRoaXMub2JzZXJ2ZWRCb3VuZHNQcm9wZXJ0eS51bmxpbmsoIHRoaXMuYm91bmRzTGlzdGVuZXIhICk7XHJcbiAgICB9XHJcblxyXG4gICAgc3VwZXIuZGlzcG9zZSgpO1xyXG4gIH1cclxufVxyXG5cclxuc2NlbmVyeS5yZWdpc3RlciggJ0hpZ2hsaWdodEZyb21Ob2RlJywgSGlnaGxpZ2h0RnJvbU5vZGUgKTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IEhpZ2hsaWdodEZyb21Ob2RlOyJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUtBLFNBQVNBLEtBQUssUUFBUSw2QkFBNkI7QUFDbkQsT0FBT0MsU0FBUyxNQUFNLG9DQUFvQztBQUMxRCxTQUFTQyxhQUFhLEVBQThCQyxPQUFPLFFBQWUsZUFBZTs7QUFnQnpGOztBQUdBLE1BQU1DLGlCQUFpQixTQUFTRixhQUFhLENBQUM7RUFFNUM7O0VBS0E7RUFDQTtFQUNRRyxzQkFBc0IsR0FBOEIsSUFBSTs7RUFFaEU7RUFDUUMsY0FBYyxHQUEyQyxJQUFJO0VBRTlEQyxXQUFXQSxDQUFFQyxJQUFpQixFQUFFQyxlQUEwQyxFQUFHO0lBRWxGLE1BQU1DLE9BQU8sR0FBR1QsU0FBUyxDQUE4RCxDQUFDLENBQUU7TUFDeEZVLGNBQWMsRUFBRSxJQUFJO01BQ3BCQyxtQkFBbUIsRUFBRSxJQUFJO01BQ3pCQyxnQkFBZ0IsRUFBRTtJQUNwQixDQUFDLEVBQUVKLGVBQWdCLENBQUM7SUFFcEJDLE9BQU8sQ0FBQ0ksbUJBQW1CLEdBQUdOLElBQUk7SUFFbEMsS0FBSyxDQUFFLElBQUksRUFBRUUsT0FBUSxDQUFDO0lBRXRCLElBQUksQ0FBQ0MsY0FBYyxHQUFHRCxPQUFPLENBQUNDLGNBQWM7SUFDNUMsSUFBSSxDQUFDRSxnQkFBZ0IsR0FBR0gsT0FBTyxDQUFDRyxnQkFBZ0I7SUFDaEQsSUFBSSxDQUFDRCxtQkFBbUIsR0FBR0YsT0FBTyxDQUFDRSxtQkFBbUI7SUFFdEQsSUFBS0osSUFBSSxFQUFHO01BQ1YsSUFBSSxDQUFDTyxnQkFBZ0IsQ0FBRVAsSUFBSyxDQUFDO0lB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