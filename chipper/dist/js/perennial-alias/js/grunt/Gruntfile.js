// Copyright 2002-2015, University of Colorado Boulder

/**
 * Grunt configuration file for tasks that have no dependencies on other repos.
 * In particular, grunt checkout-shas and grunt checkout-main can be run from here
 * without worrying about an older version of chipper being checked out.
 *
 * In general when possible, modules are imported lazily in their task
 * declaration to save on overall load time of this file. The pattern is to require all modules needed at the top of the
 * grunt task registration. If a module is used in multiple tasks, it is best to lazily require in each
 * task.
 */

///////////////////////////
// NOTE: to improve performance, the vast majority of modules are lazily imported in task registrations. Even duplicating
// require statements improves the load time of this file noticeably. For details, see https://github.com/phetsims/chipper/issues/1107
const assertIsValidRepoName = require('../common/assertIsValidRepoName');
const assert = require('assert');
const _ = require('lodash');
require('./checkNodeVersion');
///////////////////////////

module.exports = function (grunt) {
  if (grunt.option('debug')) {
    const winston = require('../../../../../../perennial-alias/node_modules/winston');
    winston.default.transports.console.level = 'debug';
  }

  // If true, will skip most prompts, but will fail out on things that should not be done in an automated manner.
  const noninteractive = !!grunt.option('noninteractive');

  /**
   * Wraps a promise's completion with grunt's asynchronous handling, with added helpful failure messages (including stack traces, regardless of whether --stack was provided).
   * @public
   *
   * @param {Promise} promise
   */
  async function wrap(promise) {
    const done = grunt.task.current.async();
    try {
      await promise;
    } catch (e) {
      if (e.stack) {
        grunt.fail.fatal(`Perennial task failed:\n${e.stack}\nFull Error details:\n${e}`);
      } else if (typeof e === 'string') {
        grunt.fail.fatal(`Perennial task failed: ${e}`);
      } else {
        grunt.fail.fatal(`Perennial task failed with unknown error: ${e}`);
      }
    }
    done();
  }

  /**
   * Wraps an async function for a grunt task. Will run the async function when the task should be executed. Will properly handle grunt's async handling, and provides improved
   * error reporting.
   * @public
   *
   * @param {async function} asyncTaskFunction
   */
  function wrapTask(asyncTaskFunction) {
    return () => {
      wrap(asyncTaskFunction());
    };
  }
  grunt.registerTask('checkout-shas', 'Check out shas for a project, as specified in dependencies.json\n' + '--repo : repository name where package.json should be read from\n' + '--skipNpmUpdate : If provided, will prevent the usual npm update\n' + '--buildServer : If provided, it will read dependencies from the build-server temporary location (and will skip npm update)', wrapTask(async () => {
    assert(grunt.option('repo'), 'Requires specifying a repository with --repo={{REPOSITORY}}');
    const checkoutDependencies = require('../common/checkoutDependencies');
    const buildServer = !!grunt.option('buildServer');
    const repo = grunt.option('repo');
    assertIsValidRepoName(repo);
    const dependencies = grunt.file.readJSON(buildServer ? '../perennial/js/build-server/tmp/dependencies.json' : `../${repo}/dependencies.json`);
    const includeNpmUpdate = !grunt.option('skipNpmUpdate') && !buildServer;
    await checkoutDependencies(repo, dependencies, includeNpmUpdate);
  }));
  grunt.registerTask('checkout-target', 'Check out a specific branch/SHA for a simulation and all of its declared dependencies\n' + '--repo : repository name where package.json should be read from\n' + '--target : the branch/SHA to check out\n' + '--branch : alias for --target\n' + '--skipNpmUpdate : If provided, will prevent the usual npm update', wrapTask(async () => {
    const repo = grunt.option('repo');
    assert(repo, 'Requires specifying a repository with --repo={{REPOSITORY}}');
    assert(!(grunt.option('target') && grunt.option('branch')), '--target and --branch are the same option, only use one.');
    const target = grunt.option('target') || grunt.option('branch');
    assert(target, 'Requires specifying a branch/SHA with --target={{BRANCH}}');
    assertIsValidRepoName(repo);
    const checkoutTarget = require('../common/checkoutTarget');
    await checkoutTarget(repo, target, !grunt.option('skipNpmUpdate'));
  }));
  grunt.registerTask('checkout-release', 'Check out the latest deployed production release branch for a simulation and all of its declared dependencies\n' + '--repo : repository name where package.json should be read from\n' + '--skipNpmUpdate : If provided, will prevent the usual npm update', wrapTask(async () => {
    const checkoutRelease = require('../common/checkoutRelease');
    const repo = grunt.option('repo');
    assert(repo, 'Requires specifying a repository with --repo={{REPOSITORY}}');
    assertIsValidRepoName(repo);
    await checkoutRelease(repo, !grunt.option('skipNpmUpdate'));
  }));
  grunt.registerTask('checkout-timestamp', 'Check out a specific timestamp for a simulation and all of its declared dependencies\n' + '--repo : repository name where package.json should be read from\n' + '--timestamp : the timestamp to check things out for, e.g. --timestamp="Jan 08 2018"\n' + '--skipNpmUpdate : If provided, will prevent the usual npm update', wrapTask(async () => {
    const repo = grunt.option('repo');
    assert(repo, 'Requires specifying a repository with --repo={{REPOSITORY}}');
    assert(grunt.option('timestamp'), 'Requires specifying a timestamp with --timestamp={{BRANCH}}');
    assertIsValidRepoName(repo);
    const checkoutTimestamp = require('../common/checkoutTimestamp');
    await checkoutTimestamp(repo, grunt.option('timestamp'), !grunt.option('skipNpmUpdate'));
  }));
  grunt.registerTask('checkout-main', 'Check out main branch for all dependencies, as specified in dependencies.json\n' + '--repo : repository name where package.json should be read from\n' + '--skipNpmUpdate : If provided, will prevent the usual npm update', wrapTask(async () => {
    const repo = grunt.option('repo');
    assert(repo, 'Requires specifying a repository with --repo={{REPOSITORY}}');
    const checkoutMain = require('../common/checkoutMain');
    assertIsValidRepoName(repo);
    await checkoutMain(repo, !grunt.option('skipNpmUpdate'));
  }));
  grunt.registerTask('checkout-main-all', 'Check out main branch for all repos in git root', wrapTask(async () => {
    const checkoutMainAll = require('./checkoutMainAll');
    checkoutMainAll();
  }));
  grunt.registerTask('sha-check', 'Checks which simulations\' latest release version includes the given common-code SHA in its git tree.\n' + '--repo : repository to check for the SHA\n' + '--sha : git SHA', wrapTask(async () => {
    const repo = grunt.option('repo');
    assertIsValidRepoName(repo);
    const shaCheck = require('./shaCheck');
    await shaCheck(repo, grunt.option('sha'));
  }));
  grunt.registerTask('print-phet-io-links', 'Print the current list of all phet-io sims\' links', wrapTask(async () => {
    const getPhetioLinks = require('../common/getPhetioLinks');
    const phetioLinks = await getPhetioLinks();
    console.log('Latest Links:');
    console.log(`\n${phetioLinks.join('\n')}`);
  }));
  grunt.registerTask('update-gh-pages', 'Updates the gh-pages branches for various repos, including building of dot/kite/scenery', wrapTask(async () => {
    const updateGithubPages = require('../common/updateGithubPages');
    await updateGithubPages();
  }));
  grunt.registerTask('sim-list', 'Prints out a list of live production HTML sims to stderr (can be filtered from other stdout output)\n' + '--versions : Outputs the sim version after its name.', wrapTask(async () => {
    const simMetadata = require('../common/simMetadata');
    const winston = require('../../../../../../perennial-alias/node_modules/winston');
    winston.default.transports.console.level = 'error';
    const data = await simMetadata({
      type: 'html'
    });
    console.error(data.projects.map(project => {
      const name = project.name.slice(project.name.indexOf('/') + 1);
      let result = name;
      if (grunt.option('versions')) {
        result += ` ${project.version.major}.${project.version.minor}.${project.version.dev}`;
      }
      return result;
    }).join('\n'));
  }));
  grunt.registerTask('release-branch-list', 'Prints out a list of all release branches that would need maintenance patches\n' + '--repo : Only show branches for a specific repository\n' + '--order=<ORDER> : alphabetical|date', wrapTask(async () => {
    const Maintenance = require('../common/Maintenance');
    const winston = require('../../../../../../perennial-alias/node_modules/winston');
    winston.default.transports.console.level = 'error';
    const repo = grunt.option('repo');
    const order = grunt.option('order') || 'alphabetical';
    if (repo) {
      assertIsValidRepoName(repo);
    }
    assert(order === 'alphabetical' || order === 'date');
    const branches = await Maintenance.getMaintenanceBranches(releaseBranch => !repo || releaseBranch.repo === repo, true, true);
    let structures = [];
    for (const branch of branches) {
      structures.push({
        branch: branch,
        timestamp: await branch.getDivergingTimestamp()
      });
    }
    if (order === 'date') {
      structures = _.sortBy(structures, struct => struct.timestamp);
    }
    console.log('\nRelease branches:\n{repo} {branch} {brand[,brand]+} {date}\n');
    for (const struct of structures) {
      console.log(`${struct.branch.toString()} ${new Date(struct.timestamp).toISOString().split('T')[0]}`);
    }
  }));
  grunt.registerTask('npm-update', 'Runs npm update/prune for chipper, perennial-alias and the given repository\n' + '--repo : The repository to update', wrapTask(async () => {
    const npmUpdate = require('../common/npmUpdate');
    const repo = grunt.option('repo');
    assert(repo, 'Requires specifying a repository with --repo={{REPOSITORY}}');
    assertIsValidRepoName(repo);
    await npmUpdate(repo).then(() => npmUpdate('chipper')).then(() => npmUpdate('perennial-alias'));
  }));
  grunt.registerTask('create-release', 'Creates a new release branch for a given simulation\n' + '--repo : The repository to add the release branch to\n' + '--branch : The branch name, which should be {{MAJOR}}.{{MINOR}}, e.g. 1.0\n' + '--brands : The supported brands for the release, comma separated.\n' + '--message : An optional message that will be appended on version-change commits.', wrapTask(async () => {
    const createRelease = require('./createRelease');
    const repo = grunt.option('repo');
    assertIsValidRepoName(repo);
    const branch = grunt.option('branch');
    const message = grunt.option('message');
    const brands = grunt.option('brands');
    assert(repo, 'Requires specifying a repository with --repo={{REPOSITORY}}');
    assert(brands, 'Requires specifying brands with --brands={{BRANDS}} (comma separated)');
    assert(branch, 'Requires specifying a branch with --branch={{BRANCH}}');
    assert(branch.split('.').length === 2, 'Branch should be {{MAJOR}}.{{MINOR}}');
    await createRelease(repo, branch, brands.split(','), message);
  }));
  grunt.registerTask('create-one-off', 'Creates a new release branch for a given simulation\n' + '--repo : The repository to add the release branch to\n' + '--branch : The branch/one-off name, which should be anything without dashes or periods\n' + '--message : An optional message that will be appended on version-change commits.', wrapTask(async () => {
    const createOneOff = require('./createOneOff');
    const repo = grunt.option('repo');
    assertIsValidRepoName(repo);
    const branch = grunt.option('branch');
    const message = grunt.option('message');
    assert(repo, 'Requires specifying a repository with --repo={{REPOSITORY}}');
    assert(branch, 'Requires specifying a branch with --branch={{BRANCH}}');
    assert(!branch.includes('-') && !branch.includes('.'), 'Branch should not contain dashes or periods');
    await createOneOff(repo, branch, message);
  }));
  grunt.registerTask('cherry-pick', 'Runs cherry-pick on a list of SHAs until one works. Reports success or failure\n' + '--repo : The repository to cherry-pick on\n' + '--shas : Comma-separated list of SHAs to try', wrapTask(async () => {
    const cherryPick = require('./cherryPick');
    const repo = grunt.option('repo');
    assert(repo, 'Requires specifying a repository with --repo={{REPOSITORY}}');
    assert(grunt.option('shas'), 'Requires specifying a comma-separated list of SHAs with --shas={{SHAS}}');
    assertIsValidRepoName(repo);
    const shas = grunt.option('shas').split(',');
    await cherryPick(repo, shas);
  }));
  grunt.registerTask('lint', 'Lints this repository only', wrapTask(async () => {
    const execute = require('../common/execute');
    const gruntCommand = require('../common/gruntCommand');
    const index = process.argv.indexOf('lint');
    assert && assert(index >= 0, 'lint command does not appear');
    const tail = process.argv.slice(index + 1);
    if (!grunt.option('repos')) {
      tail.push('--repos=perennial');
    }

    // Forward to chipper, supporting all of the options
    grunt.log.writeln((await execute(gruntCommand, ['lint', ...tail], '../chipper', {
      errors: 'resolve'
    })).stdout);
  }));
  grunt.registerTask('dev', 'Deploys a dev version of the simulation\n' + '--repo : The name of the repository to deploy\n' + '--brands : A comma-separated list of brand names to deploy\n' + '--noninteractive : If specified, prompts will be skipped. Some prompts that should not be automated will fail out\n' + '--message : An optional message that will be appended on version-change commits.', wrapTask(async () => {
    const dev = require('./dev');
    assert(grunt.option('repo'), 'Requires specifying a repository with --repo={{REPOSITORY}}');
    assert(grunt.option('brands'), 'Requires specifying brands (comma-separated) with --brands={{BRANDS}}');
    const repo = grunt.option('repo');
    assertIsValidRepoName(repo);
    await dev(repo, grunt.option('brands').split(','), noninteractive, 'main', grunt.option('message'));
  }));
  grunt.registerTask('deploy-images', 'Rebuilds all images\n' + '--simulation : Optional. If present, only the given simulation will receive images from main. If absent, all sims' + 'will receive images from main.', wrapTask(async () => {
    console.log(grunt.option('simulation'));
    const simulation = grunt.option('simulation') || null;
    const deployImages = require('./deployImages');
    await deployImages({
      simulation: simulation
    });
  }));
  grunt.registerTask('one-off', 'Deploys a one-off version of the simulation (using the current or specified branch)\n' + '--repo : The name of the repository to deploy\n' + '--branch : The name of the one-off branch (the name of the one-off)\n' + '--brands : A comma-separated list of brand names to deploy\n' + '--noninteractive : If specified, prompts will be skipped. Some prompts that should not be automated will fail out\n' + '--message : An optional message that will be appended on version-change commits.', wrapTask(async () => {
    const getBranch = require('../common/getBranch');
    const dev = require('./dev');
    const repo = grunt.option('repo');
    assertIsValidRepoName(repo);
    const brands = grunt.option('brands');
    assert(repo, 'Requires specifying a repository with --repo={{REPOSITORY}}');
    assert(brands, 'Requires specifying brands (comma-separated) with --brands={{BRANDS}}');
    let branch = grunt.option('branch');
    if (!branch) {
      branch = await getBranch(repo);
      console.log(`--branch not provided, using ${branch} detected from ${repo}`);
    }
    assert(branch !== 'main', 'One-off deploys for main are unsupported.');
    await dev(repo, brands.split(','), noninteractive, branch, grunt.option('message'));
  }));
  grunt.registerTask('rc', 'Deploys an rc version of the simulation\n' + '--repo : The name of the repository to deploy\n' + '--branch : The release branch name (e.g. "1.7") that should be used for deployment\n' + '--brands : A comma-separated list of brand names to deploy\n' + '--noninteractive : If specified, prompts will be skipped. Some prompts that should not be automated will fail out\n' + '--message : An optional message that will be appended on version-change commits.', wrapTask(async () => {
    assert(grunt.option('repo'), 'Requires specifying a repository with --repo={{REPOSITORY}}');
    assert(grunt.option('branch'), 'Requires specifying a branch with --branch={{BRANCH}}');
    assert(grunt.option('brands'), 'Requires specifying brands (comma-separated) with --brands={{BRANDS}}');
    const repo = grunt.option('repo');
    assertIsValidRepoName(repo);
    const rc = require('./rc');
    await rc(repo, grunt.option('branch'), grunt.option('brands').split(','), noninteractive, grunt.option('message'));
  }));
  grunt.registerTask('production', 'Marks a simulation as published, and deploys a production version of the simulation\n' + '--repo : The name of the repository to deploy\n' + '--branch : The release branch name (e.g. "1.7") that should be used for deployment\n' + '--brands : A comma-separated list of brand names to deploy\n' + '--noninteractive : If specified, prompts will be skipped. Some prompts that should not be automated will fail out\n' + '--redeploy: If specified with noninteractive, allow the production deploy to have the same version as the previous deploy\n' + '--message : An optional message that will be appended on version-change commits.', wrapTask(async () => {
    const production = require('./production');
    const markSimAsPublished = require('../common/markSimAsPublished');
    assert(grunt.option('repo'), 'Requires specifying a repository with --repo={{REPOSITORY}}');
    assert(grunt.option('branch'), 'Requires specifying a branch with --branch={{BRANCH}}');
    assert(grunt.option('brands'), 'Requires specifying brands (comma-separated) with --brands={{BRANDS}}');
    const repo = grunt.option('repo');
    assertIsValidRepoName(repo);
    await markSimAsPublished(repo);
    await production(repo, grunt.option('branch'), grunt.option('brands').split(','), noninteractive, grunt.option('redeploy'), grunt.option('message'));
  }));
  grunt.registerTask('prototype', 'Deploys a production (prototype) version of the simulation\n' + '--repo : The name of the repository to deploy\n' + '--branch : The release branch name (e.g. "1.7") that should be used for deployment\n' + '--brands : A comma-separated list of brand names to deploy\n' + '--noninteractive : If specified, prompts will be skipped. Some prompts that should not be automated will fail out\n' + '--redeploy: If specified with noninteractive, allow the production deploy to have the same version as the previous deploy\n' + '--message : An optional message that will be appended on version-change commits.', wrapTask(async () => {
    const production = require('./production');
    assert(grunt.option('repo'), 'Requires specifying a repository with --repo={{REPOSITORY}}');
    assert(grunt.option('branch'), 'Requires specifying a branch with --branch={{BRANCH}}');
    assert(grunt.option('brands'), 'Requires specifying brands (comma-separated) with --brands={{BRANDS}}');
    const repo = grunt.option('repo');
    assertIsValidRepoName(repo);
    await production(repo, grunt.option('branch'), grunt.option('brands').split(','), noninteractive, grunt.option('redeploy'), grunt.option('message'));
  }));
  grunt.registerTask('deploy-decaf', 'Deploys a decaf version of the simulation\n' + '--project : The name of the project to deploy', wrapTask(async () => {
    const deployDecaf = require('./decaf/deployDecaf');
    assert(grunt.option('project'), 'Requires specifying a repository with --project={{PROJECT}}');
    assert(grunt.option('dev') || grunt.option('production'), 'Requires at least one of --dev or --production');
    await deployDecaf(grunt.option('project'), !!grunt.option('dev'), !!grunt.option('production'));
  }));
  grunt.registerTask('build-decaf', 'Builds a decaf version of the simulation\n' + '--project : The name of the project to deploy', wrapTask(async () => {
    const buildDecaf = require('./decaf/buildDecaf');
    assert(grunt.option('project'), 'Requires specifying a repository with --project={{PROJECT}}');
    await buildDecaf(grunt.option('project'), grunt.option('preloadResources'));
  }));
  grunt.registerTask('create-sim', 'Creates a sim based on the simula-rasa template.\n' + '--repo="string" : the repository name\n' + '--author="string" : the author name\n' + '--title="string" : (optional) the simulation title\n' + '--clean=true : (optional) deletes the repository directory if it exists', wrapTask(async () => {
    const createSim = require('./createSim');
    const repo = grunt.option('repo');
    assertIsValidRepoName(repo);
    const author = grunt.option('author');
    const title = grunt.option('title');
    const clean = grunt.option('clean');
    assert(repo, 'Requires specifying a repository name with --repo={{REPO}}');
    assert(grunt.option('author'), 'Requires specifying a author with --author={{AUTHOR}}');
    await createSim(repo, author, {
      title: title,
      clean: clean
    });
  }));
  grunt.registerTask('lint-everything', 'lint all js files for all repos', wrapTask(async () => {
    const getDataFile = require('../common/getDataFile');

    // --disable-eslint-cache disables the cache, useful for developing rules
    const cache = !grunt.option('disable-eslint-cache');
    const activeRepos = getDataFile('active-repos').filter(repo => repo !== 'perennial-alias'); // remove duplicate perennial copy
    const fix = grunt.option('fix');
    const chipAway = grunt.option('chip-away');
    const showProgressBar = !grunt.option('hide-progress-bar');
    let lint;
    try {
      lint = require('../../../chipper/js/grunt/lint');
    } catch (e) {
      console.log('lint process not found, is your chipper repo up to date?');
      lint = {};
    }

    // The APIs are the same for these two versions of lint support
    if (lint.chipperAPIVersion === 'promisesPerRepo1' || lint.chipperAPIVersion === 'npx') {
      const lintReturnValue = await lint(activeRepos, {
        cache: cache,
        fix: fix,
        chipAway: chipAway,
        showProgressBar: showProgressBar
      });

      // Output results on errors.
      if (!lintReturnValue.ok) {
        grunt.fail.fatal('Lint failed');
      }
    }
  }));
  grunt.registerTask('generate-data', 'Generates the lists under perennial/data/, and if there were changes, will commit and push.', wrapTask(async () => {
    const generateData = require('./generateData');
    await generateData(grunt);
  }));
  grunt.registerTask('clone-missing-repos', 'Clones missing repos', wrapTask(async () => {
    const cloneMissingRepos = require('../common/cloneMissingRepos');
    await cloneMissingRepos();
  }));
  grunt.registerTask('maintenance', 'Starts a maintenance REPL', wrapTask(async () => {
    const Maintenance = require('../common/Maintenance');
    await Maintenance.startREPL();
  }));
  grunt.registerTask('maintenance-check-branch-status', 'Reports out on release branch statuses', wrapTask(async () => {
    const Maintenance = require('../common/Maintenance');
    const winston = require('../../../../../../perennial-alias/node_modules/winston');
    winston.default.transports.console.level = 'error';
    await Maintenance.checkBranchStatus();
  }));
  grunt.registerTask('maintenance-list', 'Lists out the current maintenance process state', wrapTask(async () => {
    const Maintenance = require('../common/Maintenance');
    await Maintenance.list();
  }));
  grunt.registerTask('maintenance-create-patch', 'Adds a patch to the maintenance process', wrapTask(async () => {
    const Maintenance = require('../common/Maintenance');
    const repo = grunt.option('repo');
    assertIsValidRepoName(repo);
    const message = grunt.option('message');
    assert(repo, 'Requires specifying a repo that will need to be patched with --repo={{REPO}}');
    assert(grunt.option('message'), 'Requires specifying a message (included with commits) with --message={{MESSAGE}}');
    await Maintenance.createPatch(repo, message);
  }));
  grunt.registerTask('reopen-issues-from-todos', 'If there is a TODO in the project pointing to a closed issue, reopen it.', wrapTask(async () => {
    await require('./reopenIssuesFromTODOs')();
  }));
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJhc3NlcnRJc1ZhbGlkUmVwb05hbWUiLCJyZXF1aXJlIiwiYXNzZXJ0IiwiXyIsIm1vZHVsZSIsImV4cG9ydHMiLCJncnVudCIsIm9wdGlvbiIsIndpbnN0b24iLCJkZWZhdWx0IiwidHJhbnNwb3J0cyIsImNvbnNvbGUiLCJsZXZlbCIsIm5vbmludGVyYWN0aXZlIiwid3JhcCIsInByb21pc2UiLCJkb25lIiwidGFzayIsImN1cnJlbnQiLCJhc3luYyIsImUiLCJzdGFjayIsImZhaWwiLCJmYXRhbCIsIndyYXBUYXNrIiwiYXN5bmNUYXNrRnVuY3Rpb24iLCJyZWdpc3RlclRhc2siLCJjaGVja291dERlcGVuZGVuY2llcyIsImJ1aWxkU2VydmVyIiwicmVwbyIsImRlcGVuZGVuY2llcyIsImZpbGUiLCJyZWFkSlNPTiIsImluY2x1ZGVOcG1VcGRhdGUiLCJ0YXJnZXQiLCJjaGVja291dFRhcmdldCIsImNoZWNrb3V0UmVsZWFzZSIsImNoZWNrb3V0VGltZXN0YW1wIiwiY2hlY2tvdXRNYWluIiwiY2hlY2tvdXRNYWluQWxsIiwic2hhQ2hlY2siLCJnZXRQaGV0aW9MaW5rcyIsInBoZXRpb0xpbmtzIiwibG9nIiwiam9pbiIsInVwZGF0ZUdpdGh1YlBhZ2VzIiwic2ltTWV0YWRhdGEiLCJkYXRhIiwidHlwZSIsImVycm9yIiwicHJvamVjdHMiLCJtYXAiLCJwcm9qZWN0IiwibmFtZSIsInNsaWNlIiwiaW5kZXhPZiIsInJlc3VsdCIsInZlcnNpb24iLCJtYWpvciIsIm1pbm9yIiwiZGV2IiwiTWFpbnRlbmFuY2UiLCJvcmRlciIsImJyYW5jaGVzIiwiZ2V0TWFpbnRlbmFuY2VCcmFuY2hlcyIsInJlbGVhc2VCcmFuY2giLCJzdHJ1Y3R1cmVzIiwiYnJhbmNoIiwicHVzaCIsInRpbWVzdGFtcCIsImdldERpdmVyZ2luZ1RpbWVzdGFtcCIsInNvcnRCeSIsInN0cnVjdCIsInRvU3RyaW5nIiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwic3BsaXQiLCJucG1VcGRhdGUiLCJ0aGVuIiwiY3JlYXRlUmVsZWFzZSIsIm1lc3NhZ2UiLCJicmFuZHMiLCJsZW5ndGgiLCJjcmVhdGVPbmVPZmYiLCJpbmNsdWRlcyIsImNoZXJyeVBpY2siLCJzaGFzIiwiZXhlY3V0ZSIsImdydW50Q29tbWFuZCIsImluZGV4IiwicHJvY2VzcyIsImFyZ3YiLCJ0YWlsIiwid3JpdGVsbiIsImVycm9ycyIsInN0ZG91dCIsInNpbXVsYXRpb24iLCJkZXBsb3lJbWFnZXMiLCJnZXRCcmFuY2giLCJyYyIsInByb2R1Y3Rpb24iLCJtYXJrU2ltQXNQdWJsaXNoZWQiLCJkZXBsb3lEZWNhZiIsImJ1aWxkRGVjYWYiLCJjcmVhdGVTaW0iLCJhdXRob3IiLCJ0aXRsZSIsImNsZWFuIiwiZ2V0RGF0YUZpbGUiLCJjYWNoZSIsImFjdGl2ZVJlcG9zIiwiZmlsdGVyIiwiZml4IiwiY2hpcEF3YXkiLCJzaG93UHJvZ3Jlc3NCYXIiLCJsaW50IiwiY2hpcHBlckFQSVZlcnNpb24iLCJsaW50UmV0dXJuVmFsdWUiLCJvayIsImdlbmVyYXRlRGF0YSIsImNsb25lTWlzc2luZ1JlcG9zIiwic3RhcnRSRVBMIiwiY2hlY2tCcmFuY2hTdGF0dXMiLCJsaXN0IiwiY3JlYXRlUGF0Y2giXSwic291cmNlcyI6WyJHcnVudGZpbGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMDItMjAxNSwgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXHJcblxyXG4vKipcclxuICogR3J1bnQgY29uZmlndXJhdGlvbiBmaWxlIGZvciB0YXNrcyB0aGF0IGhhdmUgbm8gZGVwZW5kZW5jaWVzIG9uIG90aGVyIHJlcG9zLlxyXG4gKiBJbiBwYXJ0aWN1bGFyLCBncnVudCBjaGVja291dC1zaGFzIGFuZCBncnVudCBjaGVja291dC1tYWluIGNhbiBiZSBydW4gZnJvbSBoZXJlXHJcbiAqIHdpdGhvdXQgd29ycnlpbmcgYWJvdXQgYW4gb2xkZXIgdmVyc2lvbiBvZiBjaGlwcGVyIGJlaW5nIGNoZWNrZWQgb3V0LlxyXG4gKlxyXG4gKiBJbiBnZW5lcmFsIHdoZW4gcG9zc2libGUsIG1vZHVsZXMgYXJlIGltcG9ydGVkIGxhemlseSBpbiB0aGVpciB0YXNrXHJcbiAqIGRlY2xhcmF0aW9uIHRvIHNhdmUgb24gb3ZlcmFsbCBsb2FkIHRpbWUgb2YgdGhpcyBmaWxlLiBUaGUgcGF0dGVybiBpcyB0byByZXF1aXJlIGFsbCBtb2R1bGVzIG5lZWRlZCBhdCB0aGUgdG9wIG9mIHRoZVxyXG4gKiBncnVudCB0YXNrIHJlZ2lzdHJhdGlvbi4gSWYgYSBtb2R1bGUgaXMgdXNlZCBpbiBtdWx0aXBsZSB0YXNrcywgaXQgaXMgYmVzdCB0byBsYXppbHkgcmVxdWlyZSBpbiBlYWNoXHJcbiAqIHRhc2suXHJcbiAqL1xyXG5cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbi8vIE5PVEU6IHRvIGltcHJvdmUgcGVyZm9ybWFuY2UsIHRoZSB2YXN0IG1ham9yaXR5IG9mIG1vZHVsZXMgYXJlIGxhemlseSBpbXBvcnRlZCBpbiB0YXNrIHJlZ2lzdHJhdGlvbnMuIEV2ZW4gZHVwbGljYXRpbmdcclxuLy8gcmVxdWlyZSBzdGF0ZW1lbnRzIGltcHJvdmVzIHRoZSBsb2FkIHRpbWUgb2YgdGhpcyBmaWxlIG5vdGljZWFibHkuIEZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL2NoaXBwZXIvaXNzdWVzLzExMDdcclxuY29uc3QgYXNzZXJ0SXNWYWxpZFJlcG9OYW1lID0gcmVxdWlyZSggJy4uL2NvbW1vbi9hc3NlcnRJc1ZhbGlkUmVwb05hbWUnICk7XHJcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoICdhc3NlcnQnICk7XHJcbmNvbnN0IF8gPSByZXF1aXJlKCAnbG9kYXNoJyApO1xyXG5yZXF1aXJlKCAnLi9jaGVja05vZGVWZXJzaW9uJyApO1xyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oIGdydW50ICkge1xyXG5cclxuICBpZiAoIGdydW50Lm9wdGlvbiggJ2RlYnVnJyApICkge1xyXG4gICAgY29uc3Qgd2luc3RvbiA9IHJlcXVpcmUoICd3aW5zdG9uJyApO1xyXG5cclxuICAgIHdpbnN0b24uZGVmYXVsdC50cmFuc3BvcnRzLmNvbnNvbGUubGV2ZWwgPSAnZGVidWcnO1xyXG4gIH1cclxuXHJcbiAgLy8gSWYgdHJ1ZSwgd2lsbCBza2lwIG1vc3QgcHJvbXB0cywgYnV0IHdpbGwgZmFpbCBvdXQgb24gdGhpbmdzIHRoYXQgc2hvdWxkIG5vdCBiZSBkb25lIGluIGFuIGF1dG9tYXRlZCBtYW5uZXIuXHJcbiAgY29uc3Qgbm9uaW50ZXJhY3RpdmUgPSAhIWdydW50Lm9wdGlvbiggJ25vbmludGVyYWN0aXZlJyApO1xyXG5cclxuICAvKipcclxuICAgKiBXcmFwcyBhIHByb21pc2UncyBjb21wbGV0aW9uIHdpdGggZ3J1bnQncyBhc3luY2hyb25vdXMgaGFuZGxpbmcsIHdpdGggYWRkZWQgaGVscGZ1bCBmYWlsdXJlIG1lc3NhZ2VzIChpbmNsdWRpbmcgc3RhY2sgdHJhY2VzLCByZWdhcmRsZXNzIG9mIHdoZXRoZXIgLS1zdGFjayB3YXMgcHJvdmlkZWQpLlxyXG4gICAqIEBwdWJsaWNcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7UHJvbWlzZX0gcHJvbWlzZVxyXG4gICAqL1xyXG4gIGFzeW5jIGZ1bmN0aW9uIHdyYXAoIHByb21pc2UgKSB7XHJcbiAgICBjb25zdCBkb25lID0gZ3J1bnQudGFzay5jdXJyZW50LmFzeW5jKCk7XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgYXdhaXQgcHJvbWlzZTtcclxuICAgIH1cclxuICAgIGNhdGNoKCBlICkge1xyXG4gICAgICBpZiAoIGUuc3RhY2sgKSB7XHJcbiAgICAgICAgZ3J1bnQuZmFpbC5mYXRhbCggYFBlcmVubmlhbCB0YXNrIGZhaWxlZDpcXG4ke2Uuc3RhY2t9XFxuRnVsbCBFcnJvciBkZXRhaWxzOlxcbiR7ZX1gICk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSBpZiAoIHR5cGVvZiBlID09PSAnc3RyaW5nJyApIHtcclxuICAgICAgICBncnVudC5mYWlsLmZhdGFsKCBgUGVyZW5uaWFsIHRhc2sgZmFpbGVkOiAke2V9YCApO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIGdydW50LmZhaWwuZmF0YWwoIGBQZXJlbm5pYWwgdGFzayBmYWlsZWQgd2l0aCB1bmtub3duIGVycm9yOiAke2V9YCApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZG9uZSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogV3JhcHMgYW4gYXN5bmMgZnVuY3Rpb24gZm9yIGEgZ3J1bnQgdGFzay4gV2lsbCBydW4gdGhlIGFzeW5jIGZ1bmN0aW9uIHdoZW4gdGhlIHRhc2sgc2hvdWxkIGJlIGV4ZWN1dGVkLiBXaWxsIHByb3Blcmx5IGhhbmRsZSBncnVudCdzIGFzeW5jIGhhbmRsaW5nLCBhbmQgcHJvdmlkZXMgaW1wcm92ZWRcclxuICAgKiBlcnJvciByZXBvcnRpbmcuXHJcbiAgICogQHB1YmxpY1xyXG4gICAqXHJcbiAgICogQHBhcmFtIHthc3luYyBmdW5jdGlvbn0gYXN5bmNUYXNrRnVuY3Rpb25cclxuICAgKi9cclxuICBmdW5jdGlvbiB3cmFwVGFzayggYXN5bmNUYXNrRnVuY3Rpb24gKSB7XHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICB3cmFwKCBhc3luY1Rhc2tGdW5jdGlvbigpICk7XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgZ3J1bnQucmVnaXN0ZXJUYXNrKCAnY2hlY2tvdXQtc2hhcycsXHJcbiAgICAnQ2hlY2sgb3V0IHNoYXMgZm9yIGEgcHJvamVjdCwgYXMgc3BlY2lmaWVkIGluIGRlcGVuZGVuY2llcy5qc29uXFxuJyArXHJcbiAgICAnLS1yZXBvIDogcmVwb3NpdG9yeSBuYW1lIHdoZXJlIHBhY2thZ2UuanNvbiBzaG91bGQgYmUgcmVhZCBmcm9tXFxuJyArXHJcbiAgICAnLS1za2lwTnBtVXBkYXRlIDogSWYgcHJvdmlkZWQsIHdpbGwgcHJldmVudCB0aGUgdXN1YWwgbnBtIHVwZGF0ZVxcbicgK1xyXG4gICAgJy0tYnVpbGRTZXJ2ZXIgOiBJZiBwcm92aWRlZCwgaXQgd2lsbCByZWFkIGRlcGVuZGVuY2llcyBmcm9tIHRoZSBidWlsZC1zZXJ2ZXIgdGVtcG9yYXJ5IGxvY2F0aW9uIChhbmQgd2lsbCBza2lwIG5wbSB1cGRhdGUpJyxcclxuICAgIHdyYXBUYXNrKCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIGFzc2VydCggZ3J1bnQub3B0aW9uKCAncmVwbycgKSwgJ1JlcXVpcmVzIHNwZWNpZnlpbmcgYSByZXBvc2l0b3J5IHdpdGggLS1yZXBvPXt7UkVQT1NJVE9SWX19JyApO1xyXG5cclxuICAgICAgY29uc3QgY2hlY2tvdXREZXBlbmRlbmNpZXMgPSByZXF1aXJlKCAnLi4vY29tbW9uL2NoZWNrb3V0RGVwZW5kZW5jaWVzJyApO1xyXG5cclxuICAgICAgY29uc3QgYnVpbGRTZXJ2ZXIgPSAhIWdydW50Lm9wdGlvbiggJ2J1aWxkU2VydmVyJyApO1xyXG5cclxuICAgICAgY29uc3QgcmVwbyA9IGdydW50Lm9wdGlvbiggJ3JlcG8nICk7XHJcbiAgICAgIGFzc2VydElzVmFsaWRSZXBvTmFtZSggcmVwbyApO1xyXG5cclxuICAgICAgY29uc3QgZGVwZW5kZW5jaWVzID0gZ3J1bnQuZmlsZS5yZWFkSlNPTiggYnVpbGRTZXJ2ZXIgPyAnLi4vcGVyZW5uaWFsL2pzL2J1aWxkLXNlcnZlci90bXAvZGVwZW5kZW5jaWVzLmpzb24nIDogYC4uLyR7cmVwb30vZGVwZW5kZW5jaWVzLmpzb25gICk7XHJcbiAgICAgIGNvbnN0IGluY2x1ZGVOcG1VcGRhdGUgPSAhZ3J1bnQub3B0aW9uKCAnc2tpcE5wbVVwZGF0ZScgKSAmJiAhYnVpbGRTZXJ2ZXI7XHJcblxyXG4gICAgICBhd2FpdCBjaGVja291dERlcGVuZGVuY2llcyggcmVwbywgZGVwZW5kZW5jaWVzLCBpbmNsdWRlTnBtVXBkYXRlICk7XHJcbiAgICB9ICkgKTtcclxuXHJcbiAgZ3J1bnQucmVnaXN0ZXJUYXNrKCAnY2hlY2tvdXQtdGFyZ2V0JyxcclxuICAgICdDaGVjayBvdXQgYSBzcGVjaWZpYyBicmFuY2gvU0hBIGZvciBhIHNpbXVsYXRpb24gYW5kIGFsbCBvZiBpdHMgZGVjbGFyZWQgZGVwZW5kZW5jaWVzXFxuJyArXHJcbiAgICAnLS1yZXBvIDogcmVwb3NpdG9yeSBuYW1lIHdoZXJlIHBhY2thZ2UuanNvbiBzaG91bGQgYmUgcmVhZCBmcm9tXFxuJyArXHJcbiAgICAnLS10YXJnZXQgOiB0aGUgYnJhbmNoL1NIQSB0byBjaGVjayBvdXRcXG4nICtcclxuICAgICctLWJyYW5jaCA6IGFsaWFzIGZvciAtLXRhcmdldFxcbicgK1xyXG4gICAgJy0tc2tpcE5wbVVwZGF0ZSA6IElmIHByb3ZpZGVkLCB3aWxsIHByZXZlbnQgdGhlIHVzdWFsIG5wbSB1cGRhdGUnLFxyXG4gICAgd3JhcFRhc2soIGFzeW5jICgpID0+IHtcclxuICAgICAgY29uc3QgcmVwbyA9IGdydW50Lm9wdGlvbiggJ3JlcG8nICk7XHJcblxyXG4gICAgICBhc3NlcnQoIHJlcG8sICdSZXF1aXJlcyBzcGVjaWZ5aW5nIGEgcmVwb3NpdG9yeSB3aXRoIC0tcmVwbz17e1JFUE9TSVRPUll9fScgKTtcclxuICAgICAgYXNzZXJ0KCAhKCBncnVudC5vcHRpb24oICd0YXJnZXQnICkgJiYgZ3J1bnQub3B0aW9uKCAnYnJhbmNoJyApICksICctLXRhcmdldCBhbmQgLS1icmFuY2ggYXJlIHRoZSBzYW1lIG9wdGlvbiwgb25seSB1c2Ugb25lLicgKTtcclxuICAgICAgY29uc3QgdGFyZ2V0ID0gZ3J1bnQub3B0aW9uKCAndGFyZ2V0JyApIHx8IGdydW50Lm9wdGlvbiggJ2JyYW5jaCcgKTtcclxuICAgICAgYXNzZXJ0KCB0YXJnZXQsICdSZXF1aXJlcyBzcGVjaWZ5aW5nIGEgYnJhbmNoL1NIQSB3aXRoIC0tdGFyZ2V0PXt7QlJBTkNIfX0nICk7XHJcblxyXG4gICAgICBhc3NlcnRJc1ZhbGlkUmVwb05hbWUoIHJlcG8gKTtcclxuXHJcbiAgICAgIGNvbnN0IGNoZWNrb3V0VGFyZ2V0ID0gcmVxdWlyZSggJy4uL2NvbW1vbi9jaGVja291dFRhcmdldCcgKTtcclxuXHJcbiAgICAgIGF3YWl0IGNoZWNrb3V0VGFyZ2V0KCByZXBvLCB0YXJnZXQsICFncnVudC5vcHRpb24oICdza2lwTnBtVXBkYXRlJyApICk7XHJcbiAgICB9ICkgKTtcclxuXHJcbiAgZ3J1bnQucmVnaXN0ZXJUYXNrKCAnY2hlY2tvdXQtcmVsZWFzZScsXHJcbiAgICAnQ2hlY2sgb3V0IHRoZSBsYXRlc3QgZGVwbG95ZWQgcHJvZHVjdGlvbiByZWxlYXNlIGJyYW5jaCBmb3IgYSBzaW11bGF0aW9uIGFuZCBhbGwgb2YgaXRzIGRlY2xhcmVkIGRlcGVuZGVuY2llc1xcbicgK1xyXG4gICAgJy0tcmVwbyA6IHJlcG9zaXRvcnkgbmFtZSB3aGVyZSBwYWNrYWdlLmpzb24gc2hvdWxkIGJlIHJlYWQgZnJvbVxcbicgK1xyXG4gICAgJy0tc2tpcE5wbVVwZGF0ZSA6IElmIHByb3ZpZGVkLCB3aWxsIHByZXZlbnQgdGhlIHVzdWFsIG5wbSB1cGRhdGUnLFxyXG4gICAgd3JhcFRhc2soIGFzeW5jICgpID0+IHtcclxuICAgICAgY29uc3QgY2hlY2tvdXRSZWxlYXNlID0gcmVxdWlyZSggJy4uL2NvbW1vbi9jaGVja291dFJlbGVhc2UnICk7XHJcblxyXG4gICAgICBjb25zdCByZXBvID0gZ3J1bnQub3B0aW9uKCAncmVwbycgKTtcclxuXHJcbiAgICAgIGFzc2VydCggcmVwbywgJ1JlcXVpcmVzIHNwZWNpZnlpbmcgYSByZXBvc2l0b3J5IHdpdGggLS1yZXBvPXt7UkVQT1NJVE9SWX19JyApO1xyXG4gICAgICBhc3NlcnRJc1ZhbGlkUmVwb05hbWUoIHJlcG8gKTtcclxuXHJcbiAgICAgIGF3YWl0IGNoZWNrb3V0UmVsZWFzZSggcmVwbywgIWdydW50Lm9wdGlvbiggJ3NraXBOcG1VcGRhdGUnICkgKTtcclxuICAgIH0gKSApO1xyXG5cclxuICBncnVudC5yZWdpc3RlclRhc2soICdjaGVja291dC10aW1lc3RhbXAnLFxyXG4gICAgJ0NoZWNrIG91dCBhIHNwZWNpZmljIHRpbWVzdGFtcCBmb3IgYSBzaW11bGF0aW9uIGFuZCBhbGwgb2YgaXRzIGRlY2xhcmVkIGRlcGVuZGVuY2llc1xcbicgK1xyXG4gICAgJy0tcmVwbyA6IHJlcG9zaXRvcnkgbmFtZSB3aGVyZSBwYWNrYWdlLmpzb24gc2hvdWxkIGJlIHJlYWQgZnJvbVxcbicgK1xyXG4gICAgJy0tdGltZXN0YW1wIDogdGhlIHRpbWVzdGFtcCB0byBjaGVjayB0aGluZ3Mgb3V0IGZvciwgZS5nLiAtLXRpbWVzdGFtcD1cIkphbiAwOCAyMDE4XCJcXG4nICtcclxuICAgICctLXNraXBOcG1VcGRhdGUgOiBJZiBwcm92aWRlZCwgd2lsbCBwcmV2ZW50IHRoZSB1c3VhbCBucG0gdXBkYXRlJyxcclxuICAgIHdyYXBUYXNrKCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IHJlcG8gPSBncnVudC5vcHRpb24oICdyZXBvJyApO1xyXG5cclxuICAgICAgYXNzZXJ0KCByZXBvLCAnUmVxdWlyZXMgc3BlY2lmeWluZyBhIHJlcG9zaXRvcnkgd2l0aCAtLXJlcG89e3tSRVBPU0lUT1JZfX0nICk7XHJcbiAgICAgIGFzc2VydCggZ3J1bnQub3B0aW9uKCAndGltZXN0YW1wJyApLCAnUmVxdWlyZXMgc3BlY2lmeWluZyBhIHRpbWVzdGFtcCB3aXRoIC0tdGltZXN0YW1wPXt7QlJBTkNIfX0nICk7XHJcblxyXG4gICAgICBhc3NlcnRJc1ZhbGlkUmVwb05hbWUoIHJlcG8gKTtcclxuXHJcbiAgICAgIGNvbnN0IGNoZWNrb3V0VGltZXN0YW1wID0gcmVxdWlyZSggJy4uL2NvbW1vbi9jaGVja291dFRpbWVzdGFtcCcgKTtcclxuXHJcbiAgICAgIGF3YWl0IGNoZWNrb3V0VGltZXN0YW1wKCByZXBvLCBncnVudC5vcHRpb24oICd0aW1lc3RhbXAnICksICFncnVudC5vcHRpb24oICdza2lwTnBtVXBkYXRlJyApICk7XHJcbiAgICB9ICkgKTtcclxuXHJcbiAgZ3J1bnQucmVnaXN0ZXJUYXNrKCAnY2hlY2tvdXQtbWFpbicsXHJcbiAgICAnQ2hlY2sgb3V0IG1haW4gYnJhbmNoIGZvciBhbGwgZGVwZW5kZW5jaWVzLCBhcyBzcGVjaWZpZWQgaW4gZGVwZW5kZW5jaWVzLmpzb25cXG4nICtcclxuICAgICctLXJlcG8gOiByZXBvc2l0b3J5IG5hbWUgd2hlcmUgcGFja2FnZS5qc29uIHNob3VsZCBiZSByZWFkIGZyb21cXG4nICtcclxuICAgICctLXNraXBOcG1VcGRhdGUgOiBJZiBwcm92aWRlZCwgd2lsbCBwcmV2ZW50IHRoZSB1c3VhbCBucG0gdXBkYXRlJyxcclxuICAgIHdyYXBUYXNrKCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IHJlcG8gPSBncnVudC5vcHRpb24oICdyZXBvJyApO1xyXG5cclxuICAgICAgYXNzZXJ0KCByZXBvLCAnUmVxdWlyZXMgc3BlY2lmeWluZyBhIHJlcG9zaXRvcnkgd2l0aCAtLXJlcG89e3tSRVBPU0lUT1JZfX0nICk7XHJcblxyXG4gICAgICBjb25zdCBjaGVja291dE1haW4gPSByZXF1aXJlKCAnLi4vY29tbW9uL2NoZWNrb3V0TWFpbicgKTtcclxuXHJcbiAgICAgIGFzc2VydElzVmFsaWRSZXBvTmFtZSggcmVwbyApO1xyXG5cclxuICAgICAgYXdhaXQgY2hlY2tvdXRNYWluKCByZXBvLCAhZ3J1bnQub3B0aW9uKCAnc2tpcE5wbVVwZGF0ZScgKSApO1xyXG4gICAgfSApICk7XHJcblxyXG4gIGdydW50LnJlZ2lzdGVyVGFzayggJ2NoZWNrb3V0LW1haW4tYWxsJyxcclxuICAgICdDaGVjayBvdXQgbWFpbiBicmFuY2ggZm9yIGFsbCByZXBvcyBpbiBnaXQgcm9vdCcsXHJcbiAgICB3cmFwVGFzayggYXN5bmMgKCkgPT4ge1xyXG4gICAgICBjb25zdCBjaGVja291dE1haW5BbGwgPSByZXF1aXJlKCAnLi9jaGVja291dE1haW5BbGwnICk7XHJcblxyXG4gICAgICBjaGVja291dE1haW5BbGwoKTtcclxuICAgIH0gKSApO1xyXG5cclxuICBncnVudC5yZWdpc3RlclRhc2soICdzaGEtY2hlY2snLFxyXG4gICAgJ0NoZWNrcyB3aGljaCBzaW11bGF0aW9uc1xcJyBsYXRlc3QgcmVsZWFzZSB2ZXJzaW9uIGluY2x1ZGVzIHRoZSBnaXZlbiBjb21tb24tY29kZSBTSEEgaW4gaXRzIGdpdCB0cmVlLlxcbicgK1xyXG4gICAgJy0tcmVwbyA6IHJlcG9zaXRvcnkgdG8gY2hlY2sgZm9yIHRoZSBTSEFcXG4nICtcclxuICAgICctLXNoYSA6IGdpdCBTSEEnLFxyXG4gICAgd3JhcFRhc2soIGFzeW5jICgpID0+IHtcclxuICAgICAgY29uc3QgcmVwbyA9IGdydW50Lm9wdGlvbiggJ3JlcG8nICk7XHJcbiAgICAgIGFzc2VydElzVmFsaWRSZXBvTmFtZSggcmVwbyApO1xyXG5cclxuICAgICAgY29uc3Qgc2hhQ2hlY2sgPSByZXF1aXJlKCAnLi9zaGFDaGVjaycgKTtcclxuXHJcbiAgICAgIGF3YWl0IHNoYUNoZWNrKCByZXBvLCBncnVudC5vcHRpb24oICdzaGEnICkgKTtcclxuICAgIH0gKSApO1xyXG5cclxuICBncnVudC5yZWdpc3RlclRhc2soICdwcmludC1waGV0LWlvLWxpbmtzJyxcclxuICAgICdQcmludCB0aGUgY3VycmVudCBsaXN0IG9mIGFsbCBwaGV0LWlvIHNpbXNcXCcgbGlua3MnLFxyXG4gICAgd3JhcFRhc2soIGFzeW5jICgpID0+IHtcclxuICAgICAgY29uc3QgZ2V0UGhldGlvTGlua3MgPSByZXF1aXJlKCAnLi4vY29tbW9uL2dldFBoZXRpb0xpbmtzJyApO1xyXG4gICAgICBjb25zdCBwaGV0aW9MaW5rcyA9IGF3YWl0IGdldFBoZXRpb0xpbmtzKCk7XHJcblxyXG4gICAgICBjb25zb2xlLmxvZyggJ0xhdGVzdCBMaW5rczonICk7XHJcbiAgICAgIGNvbnNvbGUubG9nKCBgXFxuJHtwaGV0aW9MaW5rcy5qb2luKCAnXFxuJyApfWAgKTtcclxuICAgIH0gKSApO1xyXG5cclxuICBncnVudC5yZWdpc3RlclRhc2soICd1cGRhdGUtZ2gtcGFnZXMnLFxyXG4gICAgJ1VwZGF0ZXMgdGhlIGdoLXBhZ2VzIGJyYW5jaGVzIGZvciB2YXJpb3VzIHJlcG9zLCBpbmNsdWRpbmcgYnVpbGRpbmcgb2YgZG90L2tpdGUvc2NlbmVyeScsXHJcbiAgICB3cmFwVGFzayggYXN5bmMgKCkgPT4ge1xyXG4gICAgICBjb25zdCB1cGRhdGVHaXRodWJQYWdlcyA9IHJlcXVpcmUoICcuLi9jb21tb24vdXBkYXRlR2l0aHViUGFnZXMnICk7XHJcblxyXG4gICAgICBhd2FpdCB1cGRhdGVHaXRodWJQYWdlcygpO1xyXG4gICAgfSApICk7XHJcblxyXG4gIGdydW50LnJlZ2lzdGVyVGFzayggJ3NpbS1saXN0JyxcclxuICAgICdQcmludHMgb3V0IGEgbGlzdCBvZiBsaXZlIHByb2R1Y3Rpb24gSFRNTCBzaW1zIHRvIHN0ZGVyciAoY2FuIGJlIGZpbHRlcmVkIGZyb20gb3RoZXIgc3Rkb3V0IG91dHB1dClcXG4nICtcclxuICAgICctLXZlcnNpb25zIDogT3V0cHV0cyB0aGUgc2ltIHZlcnNpb24gYWZ0ZXIgaXRzIG5hbWUuJyxcclxuICAgIHdyYXBUYXNrKCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IHNpbU1ldGFkYXRhID0gcmVxdWlyZSggJy4uL2NvbW1vbi9zaW1NZXRhZGF0YScgKTtcclxuICAgICAgY29uc3Qgd2luc3RvbiA9IHJlcXVpcmUoICd3aW5zdG9uJyApO1xyXG5cclxuICAgICAgd2luc3Rvbi5kZWZhdWx0LnRyYW5zcG9ydHMuY29uc29sZS5sZXZlbCA9ICdlcnJvcic7XHJcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBzaW1NZXRhZGF0YSgge1xyXG4gICAgICAgIHR5cGU6ICdodG1sJ1xyXG4gICAgICB9ICk7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoIGRhdGEucHJvamVjdHMubWFwKCBwcm9qZWN0ID0+IHtcclxuICAgICAgICBjb25zdCBuYW1lID0gcHJvamVjdC5uYW1lLnNsaWNlKCBwcm9qZWN0Lm5hbWUuaW5kZXhPZiggJy8nICkgKyAxICk7XHJcblxyXG4gICAgICAgIGxldCByZXN1bHQgPSBuYW1lO1xyXG4gICAgICAgIGlmICggZ3J1bnQub3B0aW9uKCAndmVyc2lvbnMnICkgKSB7XHJcbiAgICAgICAgICByZXN1bHQgKz0gYCAke3Byb2plY3QudmVyc2lvbi5tYWpvcn0uJHtwcm9qZWN0LnZlcnNpb24ubWlub3J9LiR7cHJvamVjdC52ZXJzaW9uLmRldn1gO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICB9ICkuam9pbiggJ1xcbicgKSApO1xyXG4gICAgfSApICk7XHJcblxyXG4gIGdydW50LnJlZ2lzdGVyVGFzayggJ3JlbGVhc2UtYnJhbmNoLWxpc3QnLFxyXG4gICAgJ1ByaW50cyBvdXQgYSBsaXN0IG9mIGFsbCByZWxlYXNlIGJyYW5jaGVzIHRoYXQgd291bGQgbmVlZCBtYWludGVuYW5jZSBwYXRjaGVzXFxuJyArXHJcbiAgICAnLS1yZXBvIDogT25seSBzaG93IGJyYW5jaGVzIGZvciBhIHNwZWNpZmljIHJlcG9zaXRvcnlcXG4nICtcclxuICAgICctLW9yZGVyPTxPUkRFUj4gOiBhbHBoYWJldGljYWx8ZGF0ZScsXHJcbiAgICB3cmFwVGFzayggYXN5bmMgKCkgPT4ge1xyXG4gICAgICBjb25zdCBNYWludGVuYW5jZSA9IHJlcXVpcmUoICcuLi9jb21tb24vTWFpbnRlbmFuY2UnICk7XHJcbiAgICAgIGNvbnN0IHdpbnN0b24gPSByZXF1aXJlKCAnd2luc3RvbicgKTtcclxuXHJcbiAgICAgIHdpbnN0b24uZGVmYXVsdC50cmFuc3BvcnRzLmNvbnNvbGUubGV2ZWwgPSAnZXJyb3InO1xyXG5cclxuICAgICAgY29uc3QgcmVwbyA9IGdydW50Lm9wdGlvbiggJ3JlcG8nICk7XHJcbiAgICAgIGNvbnN0IG9yZGVyID0gZ3J1bnQub3B0aW9uKCAnb3JkZXInICkgfHwgJ2FscGhhYmV0aWNhbCc7XHJcblxyXG4gICAgICBpZiAoIHJlcG8gKSB7XHJcbiAgICAgICAgYXNzZXJ0SXNWYWxpZFJlcG9OYW1lKCByZXBvICk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGFzc2VydCggb3JkZXIgPT09ICdhbHBoYWJldGljYWwnIHx8IG9yZGVyID09PSAnZGF0ZScgKTtcclxuXHJcbiAgICAgIGNvbnN0IGJyYW5jaGVzID0gYXdhaXQgTWFpbnRlbmFuY2UuZ2V0TWFpbnRlbmFuY2VCcmFuY2hlcyggcmVsZWFzZUJyYW5jaCA9PiAhcmVwbyB8fCByZWxlYXNlQnJhbmNoLnJlcG8gPT09IHJlcG8sIHRydWUsIHRydWUgKTtcclxuXHJcbiAgICAgIGxldCBzdHJ1Y3R1cmVzID0gW107XHJcbiAgICAgIGZvciAoIGNvbnN0IGJyYW5jaCBvZiBicmFuY2hlcyApIHtcclxuICAgICAgICBzdHJ1Y3R1cmVzLnB1c2goIHtcclxuICAgICAgICAgIGJyYW5jaDogYnJhbmNoLFxyXG4gICAgICAgICAgdGltZXN0YW1wOiBhd2FpdCBicmFuY2guZ2V0RGl2ZXJnaW5nVGltZXN0YW1wKClcclxuICAgICAgICB9ICk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICggb3JkZXIgPT09ICdkYXRlJyApIHtcclxuICAgICAgICBzdHJ1Y3R1cmVzID0gXy5zb3J0QnkoIHN0cnVjdHVyZXMsIHN0cnVjdCA9PiBzdHJ1Y3QudGltZXN0YW1wICk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnNvbGUubG9nKCAnXFxuUmVsZWFzZSBicmFuY2hlczpcXG57cmVwb30ge2JyYW5jaH0ge2JyYW5kWyxicmFuZF0rfSB7ZGF0ZX1cXG4nICk7XHJcbiAgICAgIGZvciAoIGNvbnN0IHN0cnVjdCBvZiBzdHJ1Y3R1cmVzICkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCBgJHtzdHJ1Y3QuYnJhbmNoLnRvU3RyaW5nKCl9ICR7bmV3IERhdGUoIHN0cnVjdC50aW1lc3RhbXAgKS50b0lTT1N0cmluZygpLnNwbGl0KCAnVCcgKVsgMCBdfWAgKTtcclxuICAgICAgfVxyXG4gICAgfSApICk7XHJcblxyXG4gIGdydW50LnJlZ2lzdGVyVGFzayggJ25wbS11cGRhdGUnLFxyXG4gICAgJ1J1bnMgbnBtIHVwZGF0ZS9wcnVuZSBmb3IgY2hpcHBlciwgcGVyZW5uaWFsLWFsaWFzIGFuZCB0aGUgZ2l2ZW4gcmVwb3NpdG9yeVxcbicgK1xyXG4gICAgJy0tcmVwbyA6IFRoZSByZXBvc2l0b3J5IHRvIHVwZGF0ZScsXHJcbiAgICB3cmFwVGFzayggYXN5bmMgKCkgPT4ge1xyXG4gICAgICBjb25zdCBucG1VcGRhdGUgPSByZXF1aXJlKCAnLi4vY29tbW9uL25wbVVwZGF0ZScgKTtcclxuXHJcbiAgICAgIGNvbnN0IHJlcG8gPSBncnVudC5vcHRpb24oICdyZXBvJyApO1xyXG4gICAgICBhc3NlcnQoIHJlcG8sICdSZXF1aXJlcyBzcGVjaWZ5aW5nIGEgcmVwb3NpdG9yeSB3aXRoIC0tcmVwbz17e1JFUE9TSVRPUll9fScgKTtcclxuXHJcbiAgICAgIGFzc2VydElzVmFsaWRSZXBvTmFtZSggcmVwbyApO1xyXG5cclxuICAgICAgYXdhaXQgbnBtVXBkYXRlKCByZXBvICkudGhlbiggKCkgPT4gbnBtVXBkYXRlKCAnY2hpcHBlcicgKSApLnRoZW4oICgpID0+IG5wbVVwZGF0ZSggJ3BlcmVubmlhbC1hbGlhcycgKSApO1xyXG4gICAgfSApICk7XHJcblxyXG4gIGdydW50LnJlZ2lzdGVyVGFzayggJ2NyZWF0ZS1yZWxlYXNlJyxcclxuICAgICdDcmVhdGVzIGEgbmV3IHJlbGVhc2UgYnJhbmNoIGZvciBhIGdpdmVuIHNpbXVsYXRpb25cXG4nICtcclxuICAgICctLXJlcG8gOiBUaGUgcmVwb3NpdG9yeSB0byBhZGQgdGhlIHJlbGVhc2UgYnJhbmNoIHRvXFxuJyArXHJcbiAgICAnLS1icmFuY2ggOiBUaGUgYnJhbmNoIG5hbWUsIHdoaWNoIHNob3VsZCBiZSB7e01BSk9SfX0ue3tNSU5PUn19LCBlLmcuIDEuMFxcbicgK1xyXG4gICAgJy0tYnJhbmRzIDogVGhlIHN1cHBvcnRlZCBicmFuZHMgZm9yIHRoZSByZWxlYXNlLCBjb21tYSBzZXBhcmF0ZWQuXFxuJyArXHJcbiAgICAnLS1tZXNzYWdlIDogQW4gb3B0aW9uYWwgbWVzc2FnZSB0aGF0IHdpbGwgYmUgYXBwZW5kZWQgb24gdmVyc2lvbi1jaGFuZ2UgY29tbWl0cy4nLFxyXG4gICAgd3JhcFRhc2soIGFzeW5jICgpID0+IHtcclxuICAgICAgY29uc3QgY3JlYXRlUmVsZWFzZSA9IHJlcXVpcmUoICcuL2NyZWF0ZVJlbGVhc2UnICk7XHJcblxyXG4gICAgICBjb25zdCByZXBvID0gZ3J1bnQub3B0aW9uKCAncmVwbycgKTtcclxuICAgICAgYXNzZXJ0SXNWYWxpZFJlcG9OYW1lKCByZXBvICk7XHJcblxyXG4gICAgICBjb25zdCBicmFuY2ggPSBncnVudC5vcHRpb24oICdicmFuY2gnICk7XHJcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBncnVudC5vcHRpb24oICdtZXNzYWdlJyApO1xyXG4gICAgICBjb25zdCBicmFuZHMgPSBncnVudC5vcHRpb24oICdicmFuZHMnICk7XHJcblxyXG4gICAgICBhc3NlcnQoIHJlcG8sICdSZXF1aXJlcyBzcGVjaWZ5aW5nIGEgcmVwb3NpdG9yeSB3aXRoIC0tcmVwbz17e1JFUE9TSVRPUll9fScgKTtcclxuICAgICAgYXNzZXJ0KCBicmFuZHMsICdSZXF1aXJlcyBzcGVjaWZ5aW5nIGJyYW5kcyB3aXRoIC0tYnJhbmRzPXt7QlJBTkRTfX0gKGNvbW1hIHNlcGFyYXRlZCknICk7XHJcbiAgICAgIGFzc2VydCggYnJhbmNoLCAnUmVxdWlyZXMgc3BlY2lmeWluZyBhIGJyYW5jaCB3aXRoIC0tYnJhbmNoPXt7QlJBTkNIfX0nICk7XHJcbiAgICAgIGFzc2VydCggYnJhbmNoLnNwbGl0KCAnLicgKS5sZW5ndGggPT09IDIsICdCcmFuY2ggc2hvdWxkIGJlIHt7TUFKT1J9fS57e01JTk9SfX0nICk7XHJcblxyXG4gICAgICBhd2FpdCBjcmVhdGVSZWxlYXNlKCByZXBvLCBicmFuY2gsIGJyYW5kcy5zcGxpdCggJywnICksIG1lc3NhZ2UgKTtcclxuICAgIH0gKSApO1xyXG5cclxuICBncnVudC5yZWdpc3RlclRhc2soICdjcmVhdGUtb25lLW9mZicsXHJcbiAgICAnQ3JlYXRlcyBhIG5ldyByZWxlYXNlIGJyYW5jaCBmb3IgYSBnaXZlbiBzaW11bGF0aW9uXFxuJyArXHJcbiAgICAnLS1yZXBvIDogVGhlIHJlcG9zaXRvcnkgdG8gYWRkIHRoZSByZWxlYXNlIGJyYW5jaCB0b1xcbicgK1xyXG4gICAgJy0tYnJhbmNoIDogVGhlIGJyYW5jaC9vbmUtb2ZmIG5hbWUsIHdoaWNoIHNob3VsZCBiZSBhbnl0aGluZyB3aXRob3V0IGRhc2hlcyBvciBwZXJpb2RzXFxuJyArXHJcbiAgICAnLS1tZXNzYWdlIDogQW4gb3B0aW9uYWwgbWVzc2FnZSB0aGF0IHdpbGwgYmUgYXBwZW5kZWQgb24gdmVyc2lvbi1jaGFuZ2UgY29tbWl0cy4nLFxyXG4gICAgd3JhcFRhc2soIGFzeW5jICgpID0+IHtcclxuICAgICAgY29uc3QgY3JlYXRlT25lT2ZmID0gcmVxdWlyZSggJy4vY3JlYXRlT25lT2ZmJyApO1xyXG5cclxuICAgICAgY29uc3QgcmVwbyA9IGdydW50Lm9wdGlvbiggJ3JlcG8nICk7XHJcbiAgICAgIGFzc2VydElzVmFsaWRSZXBvTmFtZSggcmVwbyApO1xyXG5cclxuICAgICAgY29uc3QgYnJhbmNoID0gZ3J1bnQub3B0aW9uKCAnYnJhbmNoJyApO1xyXG4gICAgICBjb25zdCBtZXNzYWdlID0gZ3J1bnQub3B0aW9uKCAnbWVzc2FnZScgKTtcclxuICAgICAgYXNzZXJ0KCByZXBvLCAnUmVxdWlyZXMgc3BlY2lmeWluZyBhIHJlcG9zaXRvcnkgd2l0aCAtLXJlcG89e3tSRVBPU0lUT1JZfX0nICk7XHJcbiAgICAgIGFzc2VydCggYnJhbmNoLCAnUmVxdWlyZXMgc3BlY2lmeWluZyBhIGJyYW5jaCB3aXRoIC0tYnJhbmNoPXt7QlJBTkNIfX0nICk7XHJcbiAgICAgIGFzc2VydCggIWJyYW5jaC5pbmNsdWRlcyggJy0nICkgJiYgIWJyYW5jaC5pbmNsdWRlcyggJy4nICksICdCcmFuY2ggc2hvdWxkIG5vdCBjb250YWluIGRhc2hlcyBvciBwZXJpb2RzJyApO1xyXG5cclxuICAgICAgYXdhaXQgY3JlYXRlT25lT2ZmKCByZXBvLCBicmFuY2gsIG1lc3NhZ2UgKTtcclxuICAgIH0gKSApO1xyXG5cclxuICBncnVudC5yZWdpc3RlclRhc2soICdjaGVycnktcGljaycsXHJcbiAgICAnUnVucyBjaGVycnktcGljayBvbiBhIGxpc3Qgb2YgU0hBcyB1bnRpbCBvbmUgd29ya3MuIFJlcG9ydHMgc3VjY2VzcyBvciBmYWlsdXJlXFxuJyArXHJcbiAgICAnLS1yZXBvIDogVGhlIHJlcG9zaXRvcnkgdG8gY2hlcnJ5LXBpY2sgb25cXG4nICtcclxuICAgICctLXNoYXMgOiBDb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBTSEFzIHRvIHRyeScsXHJcbiAgICB3cmFwVGFzayggYXN5bmMgKCkgPT4ge1xyXG4gICAgICBjb25zdCBjaGVycnlQaWNrID0gcmVxdWlyZSggJy4vY2hlcnJ5UGljaycgKTtcclxuXHJcbiAgICAgIGNvbnN0IHJlcG8gPSBncnVudC5vcHRpb24oICdyZXBvJyApO1xyXG5cclxuICAgICAgYXNzZXJ0KCByZXBvLCAnUmVxdWlyZXMgc3BlY2lmeWluZyBhIHJlcG9zaXRvcnkgd2l0aCAtLXJlcG89e3tSRVBPU0lUT1JZfX0nICk7XHJcbiAgICAgIGFzc2VydCggZ3J1bnQub3B0aW9uKCAnc2hhcycgKSwgJ1JlcXVpcmVzIHNwZWNpZnlpbmcgYSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBTSEFzIHdpdGggLS1zaGFzPXt7U0hBU319JyApO1xyXG5cclxuICAgICAgYXNzZXJ0SXNWYWxpZFJlcG9OYW1lKCByZXBvICk7XHJcblxyXG4gICAgICBjb25zdCBzaGFzID0gZ3J1bnQub3B0aW9uKCAnc2hhcycgKS5zcGxpdCggJywnICk7XHJcblxyXG4gICAgICBhd2FpdCBjaGVycnlQaWNrKCByZXBvLCBzaGFzICk7XHJcbiAgICB9ICkgKTtcclxuXHJcbiAgZ3J1bnQucmVnaXN0ZXJUYXNrKCAnbGludCcsICdMaW50cyB0aGlzIHJlcG9zaXRvcnkgb25seScsIHdyYXBUYXNrKCBhc3luYyAoKSA9PiB7XHJcbiAgICBjb25zdCBleGVjdXRlID0gcmVxdWlyZSggJy4uL2NvbW1vbi9leGVjdXRlJyApO1xyXG4gICAgY29uc3QgZ3J1bnRDb21tYW5kID0gcmVxdWlyZSggJy4uL2NvbW1vbi9ncnVudENvbW1hbmQnICk7XHJcblxyXG4gICAgY29uc3QgaW5kZXggPSBwcm9jZXNzLmFyZ3YuaW5kZXhPZiggJ2xpbnQnICk7XHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCBpbmRleCA+PSAwLCAnbGludCBjb21tYW5kIGRvZXMgbm90IGFwcGVhcicgKTtcclxuICAgIGNvbnN0IHRhaWwgPSBwcm9jZXNzLmFyZ3Yuc2xpY2UoIGluZGV4ICsgMSApO1xyXG5cclxuICAgIGlmICggIWdydW50Lm9wdGlvbiggJ3JlcG9zJyApICkge1xyXG4gICAgICB0YWlsLnB1c2goICctLXJlcG9zPXBlcmVubmlhbCcgKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBGb3J3YXJkIHRvIGNoaXBwZXIsIHN1cHBvcnRpbmcgYWxsIG9mIHRoZSBvcHRpb25zXHJcbiAgICBncnVudC5sb2cud3JpdGVsbiggKCBhd2FpdCBleGVjdXRlKCBncnVudENvbW1hbmQsIFsgJ2xpbnQnLCAuLi50YWlsIF0sICcuLi9jaGlwcGVyJywgeyBlcnJvcnM6ICdyZXNvbHZlJyB9ICkgKS5zdGRvdXQgKTtcclxuICB9ICkgKTtcclxuXHJcbiAgZ3J1bnQucmVnaXN0ZXJUYXNrKCAnZGV2JyxcclxuICAgICdEZXBsb3lzIGEgZGV2IHZlcnNpb24gb2YgdGhlIHNpbXVsYXRpb25cXG4nICtcclxuICAgICctLXJlcG8gOiBUaGUgbmFtZSBvZiB0aGUgcmVwb3NpdG9yeSB0byBkZXBsb3lcXG4nICtcclxuICAgICctLWJyYW5kcyA6IEEgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgYnJhbmQgbmFtZXMgdG8gZGVwbG95XFxuJyArXHJcbiAgICAnLS1ub25pbnRlcmFjdGl2ZSA6IElmIHNwZWNpZmllZCwgcHJvbXB0cyB3aWxsIGJlIHNraXBwZWQuIFNvbWUgcHJvbXB0cyB0aGF0IHNob3VsZCBub3QgYmUgYXV0b21hdGVkIHdpbGwgZmFpbCBvdXRcXG4nICtcclxuICAgICctLW1lc3NhZ2UgOiBBbiBvcHRpb25hbCBtZXNzYWdlIHRoYXQgd2lsbCBiZSBhcHBlbmRlZCBvbiB2ZXJzaW9uLWNoYW5nZSBjb21taXRzLicsXHJcbiAgICB3cmFwVGFzayggYXN5bmMgKCkgPT4ge1xyXG4gICAgICBjb25zdCBkZXYgPSByZXF1aXJlKCAnLi9kZXYnICk7XHJcbiAgICAgIGFzc2VydCggZ3J1bnQub3B0aW9uKCAncmVwbycgKSwgJ1JlcXVpcmVzIHNwZWNpZnlpbmcgYSByZXBvc2l0b3J5IHdpdGggLS1yZXBvPXt7UkVQT1NJVE9SWX19JyApO1xyXG4gICAgICBhc3NlcnQoIGdydW50Lm9wdGlvbiggJ2JyYW5kcycgKSwgJ1JlcXVpcmVzIHNwZWNpZnlpbmcgYnJhbmRzIChjb21tYS1zZXBhcmF0ZWQpIHdpdGggLS1icmFuZHM9e3tCUkFORFN9fScgKTtcclxuXHJcbiAgICAgIGNvbnN0IHJlcG8gPSBncnVudC5vcHRpb24oICdyZXBvJyApO1xyXG4gICAgICBhc3NlcnRJc1ZhbGlkUmVwb05hbWUoIHJlcG8gKTtcclxuXHJcbiAgICAgIGF3YWl0IGRldiggcmVwbywgZ3J1bnQub3B0aW9uKCAnYnJhbmRzJyApLnNwbGl0KCAnLCcgKSwgbm9uaW50ZXJhY3RpdmUsICdtYWluJywgZ3J1bnQub3B0aW9uKCAnbWVzc2FnZScgKSApO1xyXG4gICAgfSApICk7XHJcblxyXG4gIGdydW50LnJlZ2lzdGVyVGFzayggJ2RlcGxveS1pbWFnZXMnLFxyXG4gICAgJ1JlYnVpbGRzIGFsbCBpbWFnZXNcXG4nICtcclxuICAgICctLXNpbXVsYXRpb24gOiBPcHRpb25hbC4gSWYgcHJlc2VudCwgb25seSB0aGUgZ2l2ZW4gc2ltdWxhdGlvbiB3aWxsIHJlY2VpdmUgaW1hZ2VzIGZyb20gbWFpbi4gSWYgYWJzZW50LCBhbGwgc2ltcycgK1xyXG4gICAgJ3dpbGwgcmVjZWl2ZSBpbWFnZXMgZnJvbSBtYWluLicsXHJcblxyXG4gICAgd3JhcFRhc2soIGFzeW5jICgpID0+IHtcclxuICAgICAgY29uc29sZS5sb2coIGdydW50Lm9wdGlvbiggJ3NpbXVsYXRpb24nICkgKTtcclxuICAgICAgY29uc3Qgc2ltdWxhdGlvbiA9IGdydW50Lm9wdGlvbiggJ3NpbXVsYXRpb24nICkgfHwgbnVsbDtcclxuICAgICAgY29uc3QgZGVwbG95SW1hZ2VzID0gcmVxdWlyZSggJy4vZGVwbG95SW1hZ2VzJyApO1xyXG4gICAgICBhd2FpdCBkZXBsb3lJbWFnZXMoIHsgc2ltdWxhdGlvbjogc2ltdWxhdGlvbiB9ICk7XHJcbiAgICB9ICkgKTtcclxuXHJcbiAgZ3J1bnQucmVnaXN0ZXJUYXNrKCAnb25lLW9mZicsXHJcbiAgICAnRGVwbG95cyBhIG9uZS1vZmYgdmVyc2lvbiBvZiB0aGUgc2ltdWxhdGlvbiAodXNpbmcgdGhlIGN1cnJlbnQgb3Igc3BlY2lmaWVkIGJyYW5jaClcXG4nICtcclxuICAgICctLXJlcG8gOiBUaGUgbmFtZSBvZiB0aGUgcmVwb3NpdG9yeSB0byBkZXBsb3lcXG4nICtcclxuICAgICctLWJyYW5jaCA6IFRoZSBuYW1lIG9mIHRoZSBvbmUtb2ZmIGJyYW5jaCAodGhlIG5hbWUgb2YgdGhlIG9uZS1vZmYpXFxuJyArXHJcbiAgICAnLS1icmFuZHMgOiBBIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIGJyYW5kIG5hbWVzIHRvIGRlcGxveVxcbicgK1xyXG4gICAgJy0tbm9uaW50ZXJhY3RpdmUgOiBJZiBzcGVjaWZpZWQsIHByb21wdHMgd2lsbCBiZSBza2lwcGVkLiBTb21lIHByb21wdHMgdGhhdCBzaG91bGQgbm90IGJlIGF1dG9tYXRlZCB3aWxsIGZhaWwgb3V0XFxuJyArXHJcbiAgICAnLS1tZXNzYWdlIDogQW4gb3B0aW9uYWwgbWVzc2FnZSB0aGF0IHdpbGwgYmUgYXBwZW5kZWQgb24gdmVyc2lvbi1jaGFuZ2UgY29tbWl0cy4nLFxyXG4gICAgd3JhcFRhc2soIGFzeW5jICgpID0+IHtcclxuXHJcbiAgICAgIGNvbnN0IGdldEJyYW5jaCA9IHJlcXVpcmUoICcuLi9jb21tb24vZ2V0QnJhbmNoJyApO1xyXG4gICAgICBjb25zdCBkZXYgPSByZXF1aXJlKCAnLi9kZXYnICk7XHJcblxyXG4gICAgICBjb25zdCByZXBvID0gZ3J1bnQub3B0aW9uKCAncmVwbycgKTtcclxuICAgICAgYXNzZXJ0SXNWYWxpZFJlcG9OYW1lKCByZXBvICk7XHJcblxyXG4gICAgICBjb25zdCBicmFuZHMgPSBncnVudC5vcHRpb24oICdicmFuZHMnICk7XHJcblxyXG4gICAgICBhc3NlcnQoIHJlcG8sICdSZXF1aXJlcyBzcGVjaWZ5aW5nIGEgcmVwb3NpdG9yeSB3aXRoIC0tcmVwbz17e1JFUE9TSVRPUll9fScgKTtcclxuICAgICAgYXNzZXJ0KCBicmFuZHMsICdSZXF1aXJlcyBzcGVjaWZ5aW5nIGJyYW5kcyAoY29tbWEtc2VwYXJhdGVkKSB3aXRoIC0tYnJhbmRzPXt7QlJBTkRTfX0nICk7XHJcblxyXG4gICAgICBsZXQgYnJhbmNoID0gZ3J1bnQub3B0aW9uKCAnYnJhbmNoJyApO1xyXG4gICAgICBpZiAoICFicmFuY2ggKSB7XHJcbiAgICAgICAgYnJhbmNoID0gYXdhaXQgZ2V0QnJhbmNoKCByZXBvICk7XHJcbiAgICAgICAgY29uc29sZS5sb2coIGAtLWJyYW5jaCBub3QgcHJvdmlkZWQsIHVzaW5nICR7YnJhbmNofSBkZXRlY3RlZCBmcm9tICR7cmVwb31gICk7XHJcbiAgICAgIH1cclxuICAgICAgYXNzZXJ0KCBicmFuY2ggIT09ICdtYWluJywgJ09uZS1vZmYgZGVwbG95cyBmb3IgbWFpbiBhcmUgdW5zdXBwb3J0ZWQuJyApO1xyXG5cclxuICAgICAgYXdhaXQgZGV2KCByZXBvLCBicmFuZHMuc3BsaXQoICcsJyApLCBub25pbnRlcmFjdGl2ZSwgYnJhbmNoLCBncnVudC5vcHRpb24oICdtZXNzYWdlJyApICk7XHJcbiAgICB9ICkgKTtcclxuXHJcbiAgZ3J1bnQucmVnaXN0ZXJUYXNrKCAncmMnLFxyXG4gICAgJ0RlcGxveXMgYW4gcmMgdmVyc2lvbiBvZiB0aGUgc2ltdWxhdGlvblxcbicgK1xyXG4gICAgJy0tcmVwbyA6IFRoZSBuYW1lIG9mIHRoZSByZXBvc2l0b3J5IHRvIGRlcGxveVxcbicgK1xyXG4gICAgJy0tYnJhbmNoIDogVGhlIHJlbGVhc2UgYnJhbmNoIG5hbWUgKGUuZy4gXCIxLjdcIikgdGhhdCBzaG91bGQgYmUgdXNlZCBmb3IgZGVwbG95bWVudFxcbicgK1xyXG4gICAgJy0tYnJhbmRzIDogQSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBicmFuZCBuYW1lcyB0byBkZXBsb3lcXG4nICtcclxuICAgICctLW5vbmludGVyYWN0aXZlIDogSWYgc3BlY2lmaWVkLCBwcm9tcHRzIHdpbGwgYmUgc2tpcHBlZC4gU29tZSBwcm9tcHRzIHRoYXQgc2hvdWxkIG5vdCBiZSBhdXRvbWF0ZWQgd2lsbCBmYWlsIG91dFxcbicgK1xyXG4gICAgJy0tbWVzc2FnZSA6IEFuIG9wdGlvbmFsIG1lc3NhZ2UgdGhhdCB3aWxsIGJlIGFwcGVuZGVkIG9uIHZlcnNpb24tY2hhbmdlIGNvbW1pdHMuJyxcclxuICAgIHdyYXBUYXNrKCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIGFzc2VydCggZ3J1bnQub3B0aW9uKCAncmVwbycgKSwgJ1JlcXVpcmVzIHNwZWNpZnlpbmcgYSByZXBvc2l0b3J5IHdpdGggLS1yZXBvPXt7UkVQT1NJVE9SWX19JyApO1xyXG4gICAgICBhc3NlcnQoIGdydW50Lm9wdGlvbiggJ2JyYW5jaCcgKSwgJ1JlcXVpcmVzIHNwZWNpZnlpbmcgYSBicmFuY2ggd2l0aCAtLWJyYW5jaD17e0JSQU5DSH19JyApO1xyXG4gICAgICBhc3NlcnQoIGdydW50Lm9wdGlvbiggJ2JyYW5kcycgKSwgJ1JlcXVpcmVzIHNwZWNpZnlpbmcgYnJhbmRzIChjb21tYS1zZXBhcmF0ZWQpIHdpdGggLS1icmFuZHM9e3tCUkFORFN9fScgKTtcclxuXHJcbiAgICAgIGNvbnN0IHJlcG8gPSBncnVudC5vcHRpb24oICdyZXBvJyApO1xyXG4gICAgICBhc3NlcnRJc1ZhbGlkUmVwb05hbWUoIHJlcG8gKTtcclxuXHJcbiAgICAgIGNvbnN0IHJjID0gcmVxdWlyZSggJy4vcmMnICk7XHJcblxyXG4gICAgICBhd2FpdCByYyggcmVwbywgZ3J1bnQub3B0aW9uKCAnYnJhbmNoJyApLCBncnVudC5vcHRpb24oICdicmFuZHMnICkuc3BsaXQoICcsJyApLCBub25pbnRlcmFjdGl2ZSwgZ3J1bnQub3B0aW9uKCAnbWVzc2FnZScgKSApO1xyXG4gICAgfSApICk7XHJcblxyXG4gIGdydW50LnJlZ2lzdGVyVGFzayggJ3Byb2R1Y3Rpb24nLFxyXG4gICAgJ01hcmtzIGEgc2ltdWxhdGlvbiBhcyBwdWJsaXNoZWQsIGFuZCBkZXBsb3lzIGEgcHJvZHVjdGlvbiB2ZXJzaW9uIG9mIHRoZSBzaW11bGF0aW9uXFxuJyArXHJcbiAgICAnLS1yZXBvIDogVGhlIG5hbWUgb2YgdGhlIHJlcG9zaXRvcnkgdG8gZGVwbG95XFxuJyArXHJcbiAgICAnLS1icmFuY2ggOiBUaGUgcmVsZWFzZSBicmFuY2ggbmFtZSAoZS5nLiBcIjEuN1wiKSB0aGF0IHNob3VsZCBiZSB1c2VkIGZvciBkZXBsb3ltZW50XFxuJyArXHJcbiAgICAnLS1icmFuZHMgOiBBIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIGJyYW5kIG5hbWVzIHRvIGRlcGxveVxcbicgK1xyXG4gICAgJy0tbm9uaW50ZXJhY3RpdmUgOiBJZiBzcGVjaWZpZWQsIHByb21wdHMgd2lsbCBiZSBza2lwcGVkLiBTb21lIHByb21wdHMgdGhhdCBzaG91bGQgbm90IGJlIGF1dG9tYXRlZCB3aWxsIGZhaWwgb3V0XFxuJyArXHJcbiAgICAnLS1yZWRlcGxveTogSWYgc3BlY2lmaWVkIHdpdGggbm9uaW50ZXJhY3RpdmUsIGFsbG93IHRoZSBwcm9kdWN0aW9uIGRlcGxveSB0byBoYXZlIHRoZSBzYW1lIHZlcnNpb24gYXMgdGhlIHByZXZpb3VzIGRlcGxveVxcbicgK1xyXG4gICAgJy0tbWVzc2FnZSA6IEFuIG9wdGlvbmFsIG1lc3NhZ2UgdGhhdCB3aWxsIGJlIGFwcGVuZGVkIG9uIHZlcnNpb24tY2hhbmdlIGNvbW1pdHMuJyxcclxuICAgIHdyYXBUYXNrKCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IHByb2R1Y3Rpb24gPSByZXF1aXJlKCAnLi9wcm9kdWN0aW9uJyApO1xyXG4gICAgICBjb25zdCBtYXJrU2ltQXNQdWJsaXNoZWQgPSByZXF1aXJlKCAnLi4vY29tbW9uL21hcmtTaW1Bc1B1Ymxpc2hlZCcgKTtcclxuXHJcbiAgICAgIGFzc2VydCggZ3J1bnQub3B0aW9uKCAncmVwbycgKSwgJ1JlcXVpcmVzIHNwZWNpZnlpbmcgYSByZXBvc2l0b3J5IHdpdGggLS1yZXBvPXt7UkVQT1NJVE9SWX19JyApO1xyXG4gICAgICBhc3NlcnQoIGdydW50Lm9wdGlvbiggJ2JyYW5jaCcgKSwgJ1JlcXVpcmVzIHNwZWNpZnlpbmcgYSBicmFuY2ggd2l0aCAtLWJyYW5jaD17e0JSQU5DSH19JyApO1xyXG4gICAgICBhc3NlcnQoIGdydW50Lm9wdGlvbiggJ2JyYW5kcycgKSwgJ1JlcXVpcmVzIHNwZWNpZnlpbmcgYnJhbmRzIChjb21tYS1zZXBhcmF0ZWQpIHdpdGggLS1icmFuZHM9e3tCUkFORFN9fScgKTtcclxuXHJcbiAgICAgIGNvbnN0IHJlcG8gPSBncnVudC5vcHRpb24oICdyZXBvJyApO1xyXG4gICAgICBhc3NlcnRJc1ZhbGlkUmVwb05hbWUoIHJlcG8gKTtcclxuXHJcbiAgICAgIGF3YWl0IG1hcmtTaW1Bc1B1Ymxpc2hlZCggcmVwbyApO1xyXG5cclxuICAgICAgYXdhaXQgcHJvZHVjdGlvbiggcmVwbywgZ3J1bnQub3B0aW9uKCAnYnJhbmNoJyApLCBncnVudC5vcHRpb24oICdicmFuZHMnICkuc3BsaXQoICcsJyApLCBub25pbnRlcmFjdGl2ZSxcclxuICAgICAgICBncnVudC5vcHRpb24oICdyZWRlcGxveScgKSwgZ3J1bnQub3B0aW9uKCAnbWVzc2FnZScgKSApO1xyXG4gICAgfSApICk7XHJcblxyXG4gIGdydW50LnJlZ2lzdGVyVGFzayggJ3Byb3RvdHlwZScsXHJcbiAgICAnRGVwbG95cyBhIHByb2R1Y3Rpb24gKHByb3RvdHlwZSkgdmVyc2lvbiBvZiB0aGUgc2ltdWxhdGlvblxcbicgK1xyXG4gICAgJy0tcmVwbyA6IFRoZSBuYW1lIG9mIHRoZSByZXBvc2l0b3J5IHRvIGRlcGxveVxcbicgK1xyXG4gICAgJy0tYnJhbmNoIDogVGhlIHJlbGVhc2UgYnJhbmNoIG5hbWUgKGUuZy4gXCIxLjdcIikgdGhhdCBzaG91bGQgYmUgdXNlZCBmb3IgZGVwbG95bWVudFxcbicgK1xyXG4gICAgJy0tYnJhbmRzIDogQSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBicmFuZCBuYW1lcyB0byBkZXBsb3lcXG4nICtcclxuICAgICctLW5vbmludGVyYWN0aXZlIDogSWYgc3BlY2lmaWVkLCBwcm9tcHRzIHdpbGwgYmUgc2tpcHBlZC4gU29tZSBwcm9tcHRzIHRoYXQgc2hvdWxkIG5vdCBiZSBhdXRvbWF0ZWQgd2lsbCBmYWlsIG91dFxcbicgK1xyXG4gICAgJy0tcmVkZXBsb3k6IElmIHNwZWNpZmllZCB3aXRoIG5vbmludGVyYWN0aXZlLCBhbGxvdyB0aGUgcHJvZHVjdGlvbiBkZXBsb3kgdG8gaGF2ZSB0aGUgc2FtZSB2ZXJzaW9uIGFzIHRoZSBwcmV2aW91cyBkZXBsb3lcXG4nICtcclxuICAgICctLW1lc3NhZ2UgOiBBbiBvcHRpb25hbCBtZXNzYWdlIHRoYXQgd2lsbCBiZSBhcHBlbmRlZCBvbiB2ZXJzaW9uLWNoYW5nZSBjb21taXRzLicsXHJcbiAgICB3cmFwVGFzayggYXN5bmMgKCkgPT4ge1xyXG4gICAgICBjb25zdCBwcm9kdWN0aW9uID0gcmVxdWlyZSggJy4vcHJvZHVjdGlvbicgKTtcclxuXHJcbiAgICAgIGFzc2VydCggZ3J1bnQub3B0aW9uKCAncmVwbycgKSwgJ1JlcXVpcmVzIHNwZWNpZnlpbmcgYSByZXBvc2l0b3J5IHdpdGggLS1yZXBvPXt7UkVQT1NJVE9SWX19JyApO1xyXG4gICAgICBhc3NlcnQoIGdydW50Lm9wdGlvbiggJ2JyYW5jaCcgKSwgJ1JlcXVpcmVzIHNwZWNpZnlpbmcgYSBicmFuY2ggd2l0aCAtLWJyYW5jaD17e0JSQU5DSH19JyApO1xyXG4gICAgICBhc3NlcnQoIGdydW50Lm9wdGlvbiggJ2JyYW5kcycgKSwgJ1JlcXVpcmVzIHNwZWNpZnlpbmcgYnJhbmRzIChjb21tYS1zZXBhcmF0ZWQpIHdpdGggLS1icmFuZHM9e3tCUkFORFN9fScgKTtcclxuXHJcbiAgICAgIGNvbnN0IHJlcG8gPSBncnVudC5vcHRpb24oICdyZXBvJyApO1xyXG4gICAgICBhc3NlcnRJc1ZhbGlkUmVwb05hbWUoIHJlcG8gKTtcclxuXHJcbiAgICAgIGF3YWl0IHByb2R1Y3Rpb24oIHJlcG8sIGdydW50Lm9wdGlvbiggJ2JyYW5jaCcgKSwgZ3J1bnQub3B0aW9uKCAnYnJhbmRzJyApLnNwbGl0KCAnLCcgKSwgbm9uaW50ZXJhY3RpdmUsXHJcbiAgICAgICAgZ3J1bnQub3B0aW9uKCAncmVkZXBsb3knICksIGdydW50Lm9wdGlvbiggJ21lc3NhZ2UnICkgKTtcclxuICAgIH0gKSApO1xyXG5cclxuICBncnVudC5yZWdpc3RlclRhc2soICdkZXBsb3ktZGVjYWYnLFxyXG4gICAgJ0RlcGxveXMgYSBkZWNhZiB2ZXJzaW9uIG9mIHRoZSBzaW11bGF0aW9uXFxuJyArXHJcbiAgICAnLS1wcm9qZWN0IDogVGhlIG5hbWUgb2YgdGhlIHByb2plY3QgdG8gZGVwbG95JyxcclxuICAgIHdyYXBUYXNrKCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGRlcGxveURlY2FmID0gcmVxdWlyZSggJy4vZGVjYWYvZGVwbG95RGVjYWYnICk7XHJcblxyXG4gICAgICBhc3NlcnQoIGdydW50Lm9wdGlvbiggJ3Byb2plY3QnICksICdSZXF1aXJlcyBzcGVjaWZ5aW5nIGEgcmVwb3NpdG9yeSB3aXRoIC0tcHJvamVjdD17e1BST0pFQ1R9fScgKTtcclxuICAgICAgYXNzZXJ0KCBncnVudC5vcHRpb24oICdkZXYnICkgfHwgZ3J1bnQub3B0aW9uKCAncHJvZHVjdGlvbicgKSwgJ1JlcXVpcmVzIGF0IGxlYXN0IG9uZSBvZiAtLWRldiBvciAtLXByb2R1Y3Rpb24nICk7XHJcbiAgICAgIGF3YWl0IGRlcGxveURlY2FmKCBncnVudC5vcHRpb24oICdwcm9qZWN0JyApLCAhIWdydW50Lm9wdGlvbiggJ2RldicgKSwgISFncnVudC5vcHRpb24oICdwcm9kdWN0aW9uJyApICk7XHJcbiAgICB9ICkgKTtcclxuXHJcbiAgZ3J1bnQucmVnaXN0ZXJUYXNrKCAnYnVpbGQtZGVjYWYnLFxyXG4gICAgJ0J1aWxkcyBhIGRlY2FmIHZlcnNpb24gb2YgdGhlIHNpbXVsYXRpb25cXG4nICtcclxuICAgICctLXByb2plY3QgOiBUaGUgbmFtZSBvZiB0aGUgcHJvamVjdCB0byBkZXBsb3knLFxyXG4gICAgd3JhcFRhc2soIGFzeW5jICgpID0+IHtcclxuICAgICAgY29uc3QgYnVpbGREZWNhZiA9IHJlcXVpcmUoICcuL2RlY2FmL2J1aWxkRGVjYWYnICk7XHJcblxyXG4gICAgICBhc3NlcnQoIGdydW50Lm9wdGlvbiggJ3Byb2plY3QnICksICdSZXF1aXJlcyBzcGVjaWZ5aW5nIGEgcmVwb3NpdG9yeSB3aXRoIC0tcHJvamVjdD17e1BST0pFQ1R9fScgKTtcclxuICAgICAgYXdhaXQgYnVpbGREZWNhZiggZ3J1bnQub3B0aW9uKCAncHJvamVjdCcgKSwgZ3J1bnQub3B0aW9uKCAncHJlbG9hZFJlc291cmNlcycgKSApO1xyXG4gICAgfSApICk7XHJcblxyXG4gIGdydW50LnJlZ2lzdGVyVGFzayggJ2NyZWF0ZS1zaW0nLFxyXG4gICAgJ0NyZWF0ZXMgYSBzaW0gYmFzZWQgb24gdGhlIHNpbXVsYS1yYXNhIHRlbXBsYXRlLlxcbicgK1xyXG4gICAgJy0tcmVwbz1cInN0cmluZ1wiIDogdGhlIHJlcG9zaXRvcnkgbmFtZVxcbicgK1xyXG4gICAgJy0tYXV0aG9yPVwic3RyaW5nXCIgOiB0aGUgYXV0aG9yIG5hbWVcXG4nICtcclxuICAgICctLXRpdGxlPVwic3RyaW5nXCIgOiAob3B0aW9uYWwpIHRoZSBzaW11bGF0aW9uIHRpdGxlXFxuJyArXHJcbiAgICAnLS1jbGVhbj10cnVlIDogKG9wdGlvbmFsKSBkZWxldGVzIHRoZSByZXBvc2l0b3J5IGRpcmVjdG9yeSBpZiBpdCBleGlzdHMnLFxyXG4gICAgd3JhcFRhc2soIGFzeW5jICgpID0+IHtcclxuICAgICAgY29uc3QgY3JlYXRlU2ltID0gcmVxdWlyZSggJy4vY3JlYXRlU2ltJyApO1xyXG5cclxuICAgICAgY29uc3QgcmVwbyA9IGdydW50Lm9wdGlvbiggJ3JlcG8nICk7XHJcbiAgICAgIGFzc2VydElzVmFsaWRSZXBvTmFtZSggcmVwbyApO1xyXG5cclxuICAgICAgY29uc3QgYXV0aG9yID0gZ3J1bnQub3B0aW9uKCAnYXV0aG9yJyApO1xyXG4gICAgICBjb25zdCB0aXRsZSA9IGdydW50Lm9wdGlvbiggJ3RpdGxlJyApO1xyXG4gICAgICBjb25zdCBjbGVhbiA9IGdydW50Lm9wdGlvbiggJ2NsZWFuJyApO1xyXG5cclxuICAgICAgYXNzZXJ0KCByZXBvLCAnUmVxdWlyZXMgc3BlY2lmeWluZyBhIHJlcG9zaXRvcnkgbmFtZSB3aXRoIC0tcmVwbz17e1JFUE99fScgKTtcclxuICAgICAgYXNzZXJ0KCBncnVudC5vcHRpb24oICdhdXRob3InICksICdSZXF1aXJlcyBzcGVjaWZ5aW5nIGEgYXV0aG9yIHdpdGggLS1hdXRob3I9e3tBVVRIT1J9fScgKTtcclxuXHJcbiAgICAgIGF3YWl0IGNyZWF0ZVNpbSggcmVwbywgYXV0aG9yLCB7IHRpdGxlOiB0aXRsZSwgY2xlYW46IGNsZWFuIH0gKTtcclxuICAgIH0gKSApO1xyXG5cclxuICBncnVudC5yZWdpc3RlclRhc2soICdsaW50LWV2ZXJ5dGhpbmcnLCAnbGludCBhbGwganMgZmlsZXMgZm9yIGFsbCByZXBvcycsIHdyYXBUYXNrKCBhc3luYyAoKSA9PiB7XHJcbiAgICBjb25zdCBnZXREYXRhRmlsZSA9IHJlcXVpcmUoICcuLi9jb21tb24vZ2V0RGF0YUZpbGUnICk7XHJcblxyXG4gICAgLy8gLS1kaXNhYmxlLWVzbGludC1jYWNoZSBkaXNhYmxlcyB0aGUgY2FjaGUsIHVzZWZ1bCBmb3IgZGV2ZWxvcGluZyBydWxlc1xyXG4gICAgY29uc3QgY2FjaGUgPSAhZ3J1bnQub3B0aW9uKCAnZGlzYWJsZS1lc2xpbnQtY2FjaGUnICk7XHJcbiAgICBjb25zdCBhY3RpdmVSZXBvcyA9IGdldERhdGFGaWxlKCAnYWN0aXZlLXJlcG9zJyApLmZpbHRlciggcmVwbyA9PiByZXBvICE9PSAncGVyZW5uaWFsLWFsaWFzJyApOyAvLyByZW1vdmUgZHVwbGljYXRlIHBlcmVubmlhbCBjb3B5XHJcbiAgICBjb25zdCBmaXggPSBncnVudC5vcHRpb24oICdmaXgnICk7XHJcbiAgICBjb25zdCBjaGlwQXdheSA9IGdydW50Lm9wdGlvbiggJ2NoaXAtYXdheScgKTtcclxuICAgIGNvbnN0IHNob3dQcm9ncmVzc0JhciA9ICFncnVudC5vcHRpb24oICdoaWRlLXByb2dyZXNzLWJhcicgKTtcclxuXHJcbiAgICBsZXQgbGludDtcclxuICAgIHRyeSB7XHJcbiAgICAgIGxpbnQgPSByZXF1aXJlKCAnLi4vLi4vLi4vY2hpcHBlci9qcy9ncnVudC9saW50JyApO1xyXG4gICAgfVxyXG4gICAgY2F0Y2goIGUgKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCAnbGludCBwcm9jZXNzIG5vdCBmb3VuZCwgaXMgeW91ciBjaGlwcGVyIHJlcG8gdXAgdG8gZGF0ZT8nICk7XHJcbiAgICAgIGxpbnQgPSB7fTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBUaGUgQVBJcyBhcmUgdGhlIHNhbWUgZm9yIHRoZXNlIHR3byB2ZXJzaW9ucyBvZiBsaW50IHN1cHBvcnRcclxuICAgIGlmICggbGludC5jaGlwcGVyQVBJVmVyc2lvbiA9PT0gJ3Byb21pc2VzUGVyUmVwbzEnIHx8IGxpbnQuY2hpcHBlckFQSVZlcnNpb24gPT09ICducHgnICkge1xyXG4gICAgICBjb25zdCBsaW50UmV0dXJuVmFsdWUgPSBhd2FpdCBsaW50KCBhY3RpdmVSZXBvcywge1xyXG4gICAgICAgIGNhY2hlOiBjYWNoZSxcclxuICAgICAgICBmaXg6IGZpeCxcclxuICAgICAgICBjaGlwQXdheTogY2hpcEF3YXksXHJcbiAgICAgICAgc2hvd1Byb2dyZXNzQmFyOiBzaG93UHJvZ3Jlc3NCYXJcclxuICAgICAgfSApO1xyXG5cclxuICAgICAgLy8gT3V0cHV0IHJlc3VsdHMgb24gZXJyb3JzLlxyXG4gICAgICBpZiAoICFsaW50UmV0dXJuVmFsdWUub2sgKSB7XHJcbiAgICAgICAgZ3J1bnQuZmFpbC5mYXRhbCggJ0xpbnQgZmFpbGVkJyApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSApICk7XHJcblxyXG4gIGdydW50LnJlZ2lzdGVyVGFzayggJ2dlbmVyYXRlLWRhdGEnLCAnR2VuZXJhdGVzIHRoZSBsaXN0cyB1bmRlciBwZXJlbm5pYWwvZGF0YS8sIGFuZCBpZiB0aGVyZSB3ZXJlIGNoYW5nZXMsIHdpbGwgY29tbWl0IGFuZCBwdXNoLicsIHdyYXBUYXNrKCBhc3luYyAoKSA9PiB7XHJcbiAgICBjb25zdCBnZW5lcmF0ZURhdGEgPSByZXF1aXJlKCAnLi9nZW5lcmF0ZURhdGEnICk7XHJcbiAgICBhd2FpdCBnZW5lcmF0ZURhdGEoIGdydW50ICk7XHJcbiAgfSApICk7XHJcblxyXG4gIGdydW50LnJlZ2lzdGVyVGFzayggJ2Nsb25lLW1pc3NpbmctcmVwb3MnLCAnQ2xvbmVzIG1pc3NpbmcgcmVwb3MnLCB3cmFwVGFzayggYXN5bmMgKCkgPT4ge1xyXG4gICAgY29uc3QgY2xvbmVNaXNzaW5nUmVwb3MgPSByZXF1aXJlKCAnLi4vY29tbW9uL2Nsb25lTWlzc2luZ1JlcG9zJyApO1xyXG5cclxuICAgIGF3YWl0IGNsb25lTWlzc2luZ1JlcG9zKCk7XHJcbiAgfSApICk7XHJcblxyXG4gIGdydW50LnJlZ2lzdGVyVGFzayggJ21haW50ZW5hbmNlJywgJ1N0YXJ0cyBhIG1haW50ZW5hbmNlIFJFUEwnLCB3cmFwVGFzayggYXN5bmMgKCkgPT4ge1xyXG4gICAgY29uc3QgTWFpbnRlbmFuY2UgPSByZXF1aXJlKCAnLi4vY29tbW9uL01haW50ZW5hbmNlJyApO1xyXG5cclxuICAgIGF3YWl0IE1haW50ZW5hbmNlLnN0YXJ0UkVQTCgpO1xyXG4gIH0gKSApO1xyXG5cclxuICBncnVudC5yZWdpc3RlclRhc2soICdtYWludGVuYW5jZS1jaGVjay1icmFuY2gtc3RhdHVzJywgJ1JlcG9ydHMgb3V0IG9uIHJlbGVhc2UgYnJhbmNoIHN0YXR1c2VzJywgd3JhcFRhc2soIGFzeW5jICgpID0+IHtcclxuICAgIGNvbnN0IE1haW50ZW5hbmNlID0gcmVxdWlyZSggJy4uL2NvbW1vbi9NYWludGVuYW5jZScgKTtcclxuICAgIGNvbnN0IHdpbnN0b24gPSByZXF1aXJlKCAnd2luc3RvbicgKTtcclxuXHJcbiAgICB3aW5zdG9uLmRlZmF1bHQudHJhbnNwb3J0cy5jb25zb2xlLmxldmVsID0gJ2Vycm9yJztcclxuXHJcbiAgICBhd2FpdCBNYWludGVuYW5jZS5jaGVja0JyYW5jaFN0YXR1cygpO1xyXG4gIH0gKSApO1xyXG5cclxuICBncnVudC5yZWdpc3RlclRhc2soICdtYWludGVuYW5jZS1saXN0JywgJ0xpc3RzIG91dCB0aGUgY3VycmVudCBtYWludGVuYW5jZSBwcm9jZXNzIHN0YXRlJywgd3JhcFRhc2soIGFzeW5jICgpID0+IHtcclxuICAgIGNvbnN0IE1haW50ZW5hbmNlID0gcmVxdWlyZSggJy4uL2NvbW1vbi9NYWludGVuYW5jZScgKTtcclxuICAgIGF3YWl0IE1haW50ZW5hbmNlLmxpc3QoKTtcclxuICB9ICkgKTtcclxuXHJcbiAgZ3J1bnQucmVnaXN0ZXJUYXNrKCAnbWFpbnRlbmFuY2UtY3JlYXRlLXBhdGNoJywgJ0FkZHMgYSBwYXRjaCB0byB0aGUgbWFpbnRlbmFuY2UgcHJvY2VzcycsIHdyYXBUYXNrKCBhc3luYyAoKSA9PiB7XHJcbiAgICBjb25zdCBNYWludGVuYW5jZSA9IHJlcXVpcmUoICcuLi9jb21tb24vTWFpbnRlbmFuY2UnICk7XHJcblxyXG4gICAgY29uc3QgcmVwbyA9IGdydW50Lm9wdGlvbiggJ3JlcG8nICk7XHJcbiAgICBhc3NlcnRJc1ZhbGlkUmVwb05hbWUoIHJlcG8gKTtcclxuXHJcbiAgICBjb25zdCBtZXNzYWdlID0gZ3J1bnQub3B0aW9uKCAnbWVzc2FnZScgKTtcclxuXHJcbiAgICBhc3NlcnQoIHJlcG8sICdSZXF1aXJlcyBzcGVjaWZ5aW5nIGEgcmVwbyB0aGF0IHdpbGwgbmVlZCB0byBiZSBwYXRjaGVkIHdpdGggLS1yZXBvPXt7UkVQT319JyApO1xyXG4gICAgYXNzZXJ0KCBncnVudC5vcHRpb24oICdtZXNzYWdlJyApLCAnUmVxdWlyZXMgc3BlY2lmeWluZyBhIG1lc3NhZ2UgKGluY2x1ZGVkIHdpdGggY29tbWl0cykgd2l0aCAtLW1lc3NhZ2U9e3tNRVNTQUdFfX0nICk7XHJcblxyXG4gICAgYXdhaXQgTWFpbnRlbmFuY2UuY3JlYXRlUGF0Y2goIHJlcG8sIG1lc3NhZ2UgKTtcclxuICB9ICkgKTtcclxuXHJcbiAgZ3J1bnQucmVnaXN0ZXJUYXNrKCAncmVvcGVuLWlzc3Vlcy1mcm9tLXRvZG9zJywgJ0lmIHRoZXJlIGlzIGEgVE9ETyBpbiB0aGUgcHJvamVjdCBwb2ludGluZyB0byBhIGNsb3NlZCBpc3N1ZSwgcmVvcGVuIGl0LicsIHdyYXBUYXNrKCBhc3luYyAoKSA9PiB7XHJcbiAgICBhd2FpdCByZXF1aXJlKCAnLi9yZW9wZW5Jc3N1ZXNGcm9tVE9ET3MnICkoKTtcclxuICB9ICkgKTtcclxufTsiXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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