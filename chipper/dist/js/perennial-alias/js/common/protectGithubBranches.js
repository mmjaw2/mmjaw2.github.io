// Copyright 2021, University of Colorado Boulder

/**
 * Sets branch protection rules for the provided list of repositories. The default branch protection rules prevent
 * deletion of the branch. There are other things you can do with branch protection rules but we decided not to
 * apply them at this time. See https://github.com/phetsims/special-ops/issues/197 for more information.
 *
 * See https://docs.github.com/en/graphql/reference/input-objects#createbranchprotectionruleinput for documentation
 * of what you can do with protection rules.
 *
 * If rules for the protected patterns already exist they will be deleted and replaced so they can be easily updated.
 *
 * USAGE:
 * protectGithubBranches.protectBranches( [ "my-first-repo", "my-second-repo" ] );
 *
 * of
 *
 * protectGithubBranches.clearBranchProtections( [ "my-first-repo", "my-second-repo" ] );
 *
 * @author Jesse Greenberg (PhET Interactive Simulations)
 */

const https = require('https');
const buildLocal = require('./buildLocal');

// protects main, and all branche used in production deploys
const BRANCH_NAME_PATTERNS = ['main', '*[0-9].[0-9]*'];

// Options for the https request to the github graphql server
const options = {
  hostname: 'api.github.com',
  path: '/graphql',
  method: 'POST',
  headers: {
    Authorization: `Bearer ${buildLocal.developerGithubAccessToken}`,
    'Content-Type': 'application/json',
    'user-agent': 'node.js'
  }
};

/**
 * Creates the GraphQL query string to get the existing branch protection rules for the provided repo name under
 * the phetsims project.
 *
 * @param {string} repositoryName
 * @returns {string}
 */
const createBranchProtectionRuleQueryData = repositoryName => {
  return createQueryData(`query BranchProtectionRule {
    repository(owner: "phetsims", name: "${repositoryName}") { 
      branchProtectionRules(first: 100) { 
        nodes {
          # pattern for the rule 
          pattern,
          
          # uniqueID for the rule assigned by github, required to request deletion
          id
        }
      }
    } }`);
};

/**
 * Gets the GraphQL query string that will delete an existing branch protection rule. Use
 * createBranchProtectionRuleQueryData to get the unique IDs for each rule.
 *
 * @param ruleId
 * @returns {string}
 */
const createDeleteBranchProtectionRuleMutationData = ruleId => {
  return createQueryData(`mutation {
    deleteBranchProtectionRule(input:{branchProtectionRuleId: "${ruleId}"} ) {
      clientMutationId
    }
  }`);
};

/**
 * Creates the data string that requests the creation of a new github branch protection rule using a GraphQL query and
 * sent with an HTTPS request. The default rule prevents branch deletion. There are other things that can be
 * constrained or protected for the branch, but we decided not to apply anything else at this time.
 * See https://docs.github.com/en/graphql/reference/input-objects#createbranchprotectionruleinput for list
 * of things you can do with rules.
 *
 * @param {string} repositoryId - Unique ID for the repo, see createRepositoryIdQueryData()
 * @param {string} namePattern - pattern for the rule, all branches matching with fnmatch will be protected
 * @returns {string}
 */
const createRepositoryRuleMutationData = (repositoryId, namePattern) => {
  return createQueryData(`mutation {
    createBranchProtectionRule(input: {
      pattern: "${namePattern}",
      allowsDeletions: false,
  
      repositoryId: "${repositoryId}"
    } )
    
    # I think this specifies the data returned after the server receives the mutation request, not used but required
    # to send the mutation
    {
      branchProtectionRule {
        pattern
      }
    }
    }`);
};

/**
 * Creates the data string that requests the unique ID of a github repository using a GraphQL query sent with an
 * HTTPS request.
 *
 * @param {string} repositoryName - Name of the phetsims repository
 * @returns {string}
 */
const createRepositoryIdQueryData = repositoryName => {
  return createQueryData(`query { repository(owner: "phetsims", name: "${repositoryName}") { id } }`);
};

/**
 * Wraps a query string with additional formatting so that it can be used in a GraphQL query sent with https.
 *
 * @param {string} queryString
 * @returns {string}
 */
const createQueryData = queryString => {
  return JSON.stringify({
    query: queryString
  });
};

/**
 * Gets an error message from a JSON response. Just grabs the first error message if there are multiple.
 * @param jsonResponse - JSON response object from github. Errors are in a .errors array.
 * @returns {*|string}
 */
const getErrorMessage = jsonResponse => {
  if (jsonResponse.errors) {
    return jsonResponse.errors[0].message;
  } else {
    return 'No data returned';
  }
};

/**
 * Returns the unique ID of the provided phetsims repository.
 * @param {string} repositoryName
 * @returns {Promise<string>}
 */
async function getRepositoryId(repositoryName) {
  const handleJSONResponse = jsonResponse => {
    if (!jsonResponse.data || jsonResponse.data.repository === null) {
      throw new Error(`${getErrorMessage(jsonResponse)} Make sure developerGithubAccessToken in build-local.json may be incorrect or expired.`);
    }
    return jsonResponse.data.repository.id;
  };
  return sendPromisedHttpsRequest(createRepositoryIdQueryData(repositoryName), handleJSONResponse);
}

/**
 * Returns an array of objects, one for each existing branch protection rule for the repository, that has
 * the protection rule pattern and the unique ID for the rule assigned by github.
 *
 * @param {string} repositoryName
 * @returns {Promise<*[]>} - array of nodes with key value pairs of { "pattern": string, "id": string }
 */
async function getExistingBranchProtectionRules(repositoryName) {
  const handleJSONResponse = jsonResponse => {
    if (jsonResponse.errors) {
      throw new Error(getErrorMessage(jsonResponse));
    }
    if (!jsonResponse.data) {
      throw new Error(`No data returned by getExistingBranchProtectionRules for repo ${repositoryName}`);
    }
    return jsonResponse.data.repository.branchProtectionRules.nodes;
  };
  return sendPromisedHttpsRequest(createBranchProtectionRuleQueryData(repositoryName), handleJSONResponse);
}

/**
 * Creates the protection rule for all branches matching the namePattern for the phetsims repository with the provided
 * unique ID assigned by github.
 *
 * @param {string} repositoryId - unique ID for the repository, use getRepositoryId to get this
 * @param {string} namePattern - The pattern for the rule using fnmatch
 * @returns {Promise<Object>}
 */
async function writeProtectionRule(repositoryId, namePattern) {
  const handleJSONResponse = jsonResponse => {
    if (jsonResponse.errors) {
      throw new Error(getErrorMessage(jsonResponse));
    }
  };
  return sendPromisedHttpsRequest(createRepositoryRuleMutationData(repositoryId, namePattern), handleJSONResponse);
}

/**
 * Deletes an existing rule. We assume that that by running this we want to overwrite the existing rule.
 *
 * @param {string} ruleId
 * @param {string} namePattern
 * @param {string} repositoryName
 * @returns {Promise<Object>}
 */
async function deleteExistingProtectionRule(ruleId, namePattern, repositoryName) {
  const handleJSONResponse = jsonResponse => {
    if (jsonResponse.errors) {
      throw new Error(getErrorMessage(jsonResponse));
    } else {
      console.log(`Deleted existing branch protection rule ${namePattern} for repo ${repositoryName}`);
    }
  };
  return sendPromisedHttpsRequest(createDeleteBranchProtectionRuleMutationData(ruleId), handleJSONResponse);
}

/**
 * An async function that will delete all existing rules that match the provided namePattern for the repository.
 * Wrapped in a Promise so we can wait to write new rules until the existing rules are removed. If you try to
 * write over an existing rule without removing it github will respond with an error.
 *
 * @param {*[]} rules
 * @param {string} namePattern
 * @param {string} repositoryName
 * @returns {Promise<unknown[]>}
 */
async function deleteMatchingProtectionRules(rules, namePattern, repositoryName) {
  const promises = [];
  rules.forEach(rule => {
    // only delete rules that match the new pattern we want to protect
    if (rule.pattern === namePattern) {
      promises.push(deleteExistingProtectionRule(rule.id, namePattern, repositoryName));
    }
  });
  return Promise.all(promises);
}

/**
 * Sends a request to github's GraphQL server to query or mutate repository data.
 *
 * @param {string} queryData - the string sent with https
 * @param {function(Object)} handle - handles the JSON response from github
 * @returns {Promise<unknown>}
 */
async function sendPromisedHttpsRequest(queryData, handle) {
  return new Promise((resolve, reject) => {
    const request = https.request(options, response => {
      let responseBody = '';
      response.on('data', d => {
        responseBody += d;
      });
      response.on('end', () => {
        const jsonResponse = JSON.parse(responseBody);
        try {
          const resolveValue = handle(jsonResponse);
          resolve(resolveValue);
        } catch (error) {
          reject(error);
        }
      });
    });
    request.on('error', error => {
      console.error(error);
    });
    request.write(queryData);
    request.end();
  });
}

/**
 * Clear protections for the branches that PhET wants to protect.
 */
async function clearBranchProtections(repositories) {
  for (const repositoryName of repositories) {
    for (const namePattern of BRANCH_NAME_PATTERNS) {
      try {
        const branchProtectionRules = await getExistingBranchProtectionRules(repositoryName);
        await deleteMatchingProtectionRules(branchProtectionRules, namePattern, repositoryName);
      } catch (error) {
        console.log(`Error clearing github protection rule ${namePattern} for ${repositoryName}`);
      }
    }
  }
}

/**
 * Apply branch protection rules to prodcution branches (main, release branches).
 */
async function protectBranches(repositories) {
  // remove any trailing '/' from the repository names, which may have been added by auto complete
  const cleanedRepositories = repositories.map(repository => repository.replace(/\/$/, ''));

  // if the rule for the protected branch already exists, delete it - we assume that running this again means we
  // want to update rules for each namePattern
  await clearBranchProtections(cleanedRepositories);
  for (const repositoryName of cleanedRepositories) {
    // get the unique ID for each repository
    const repositoryId = await getRepositoryId(repositoryName);
    for (const namePattern of BRANCH_NAME_PATTERNS) {
      try {
        await writeProtectionRule(repositoryId, namePattern);
        console.log(`${namePattern} protection rule set for ${repositoryName}`);
      } catch (error) {
        console.log(`Error writing ${namePattern} rule for repo ${repositoryName}:`);
        console.log(error);
        console.log('\n');
      }
    }
  }
}
module.exports = {
  protectBranches: protectBranches,
  clearBranchProtections: clearBranchProtections
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJodHRwcyIsInJlcXVpcmUiLCJidWlsZExvY2FsIiwiQlJBTkNIX05BTUVfUEFUVEVSTlMiLCJvcHRpb25zIiwiaG9zdG5hbWUiLCJwYXRoIiwibWV0aG9kIiwiaGVhZGVycyIsIkF1dGhvcml6YXRpb24iLCJkZXZlbG9wZXJHaXRodWJBY2Nlc3NUb2tlbiIsImNyZWF0ZUJyYW5jaFByb3RlY3Rpb25SdWxlUXVlcnlEYXRhIiwicmVwb3NpdG9yeU5hbWUiLCJjcmVhdGVRdWVyeURhdGEiLCJjcmVhdGVEZWxldGVCcmFuY2hQcm90ZWN0aW9uUnVsZU11dGF0aW9uRGF0YSIsInJ1bGVJZCIsImNyZWF0ZVJlcG9zaXRvcnlSdWxlTXV0YXRpb25EYXRhIiwicmVwb3NpdG9yeUlkIiwibmFtZVBhdHRlcm4iLCJjcmVhdGVSZXBvc2l0b3J5SWRRdWVyeURhdGEiLCJxdWVyeVN0cmluZyIsIkpTT04iLCJzdHJpbmdpZnkiLCJxdWVyeSIsImdldEVycm9yTWVzc2FnZSIsImpzb25SZXNwb25zZSIsImVycm9ycyIsIm1lc3NhZ2UiLCJnZXRSZXBvc2l0b3J5SWQiLCJoYW5kbGVKU09OUmVzcG9uc2UiLCJkYXRhIiwicmVwb3NpdG9yeSIsIkVycm9yIiwiaWQiLCJzZW5kUHJvbWlzZWRIdHRwc1JlcXVlc3QiLCJnZXRFeGlzdGluZ0JyYW5jaFByb3RlY3Rpb25SdWxlcyIsImJyYW5jaFByb3RlY3Rpb25SdWxlcyIsIm5vZGVzIiwid3JpdGVQcm90ZWN0aW9uUnVsZSIsImRlbGV0ZUV4aXN0aW5nUHJvdGVjdGlvblJ1bGUiLCJjb25zb2xlIiwibG9nIiwiZGVsZXRlTWF0Y2hpbmdQcm90ZWN0aW9uUnVsZXMiLCJydWxlcyIsInByb21pc2VzIiwiZm9yRWFjaCIsInJ1bGUiLCJwYXR0ZXJuIiwicHVzaCIsIlByb21pc2UiLCJhbGwiLCJxdWVyeURhdGEiLCJoYW5kbGUiLCJyZXNvbHZlIiwicmVqZWN0IiwicmVxdWVzdCIsInJlc3BvbnNlIiwicmVzcG9uc2VCb2R5Iiwib24iLCJkIiwicGFyc2UiLCJyZXNvbHZlVmFsdWUiLCJlcnJvciIsIndyaXRlIiwiZW5kIiwiY2xlYXJCcmFuY2hQcm90ZWN0aW9ucyIsInJlcG9zaXRvcmllcyIsInByb3RlY3RCcmFuY2hlcyIsImNsZWFuZWRSZXBvc2l0b3JpZXMiLCJtYXAiLCJyZXBsYWNlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VzIjpbInByb3RlY3RHaXRodWJCcmFuY2hlcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAyMSwgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXHJcblxyXG4vKipcclxuICogU2V0cyBicmFuY2ggcHJvdGVjdGlvbiBydWxlcyBmb3IgdGhlIHByb3ZpZGVkIGxpc3Qgb2YgcmVwb3NpdG9yaWVzLiBUaGUgZGVmYXVsdCBicmFuY2ggcHJvdGVjdGlvbiBydWxlcyBwcmV2ZW50XHJcbiAqIGRlbGV0aW9uIG9mIHRoZSBicmFuY2guIFRoZXJlIGFyZSBvdGhlciB0aGluZ3MgeW91IGNhbiBkbyB3aXRoIGJyYW5jaCBwcm90ZWN0aW9uIHJ1bGVzIGJ1dCB3ZSBkZWNpZGVkIG5vdCB0b1xyXG4gKiBhcHBseSB0aGVtIGF0IHRoaXMgdGltZS4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waGV0c2ltcy9zcGVjaWFsLW9wcy9pc3N1ZXMvMTk3IGZvciBtb3JlIGluZm9ybWF0aW9uLlxyXG4gKlxyXG4gKiBTZWUgaHR0cHM6Ly9kb2NzLmdpdGh1Yi5jb20vZW4vZ3JhcGhxbC9yZWZlcmVuY2UvaW5wdXQtb2JqZWN0cyNjcmVhdGVicmFuY2hwcm90ZWN0aW9ucnVsZWlucHV0IGZvciBkb2N1bWVudGF0aW9uXHJcbiAqIG9mIHdoYXQgeW91IGNhbiBkbyB3aXRoIHByb3RlY3Rpb24gcnVsZXMuXHJcbiAqXHJcbiAqIElmIHJ1bGVzIGZvciB0aGUgcHJvdGVjdGVkIHBhdHRlcm5zIGFscmVhZHkgZXhpc3QgdGhleSB3aWxsIGJlIGRlbGV0ZWQgYW5kIHJlcGxhY2VkIHNvIHRoZXkgY2FuIGJlIGVhc2lseSB1cGRhdGVkLlxyXG4gKlxyXG4gKiBVU0FHRTpcclxuICogcHJvdGVjdEdpdGh1YkJyYW5jaGVzLnByb3RlY3RCcmFuY2hlcyggWyBcIm15LWZpcnN0LXJlcG9cIiwgXCJteS1zZWNvbmQtcmVwb1wiIF0gKTtcclxuICpcclxuICogb2ZcclxuICpcclxuICogcHJvdGVjdEdpdGh1YkJyYW5jaGVzLmNsZWFyQnJhbmNoUHJvdGVjdGlvbnMoIFsgXCJteS1maXJzdC1yZXBvXCIsIFwibXktc2Vjb25kLXJlcG9cIiBdICk7XHJcbiAqXHJcbiAqIEBhdXRob3IgSmVzc2UgR3JlZW5iZXJnIChQaEVUIEludGVyYWN0aXZlIFNpbXVsYXRpb25zKVxyXG4gKi9cclxuXHJcbmNvbnN0IGh0dHBzID0gcmVxdWlyZSggJ2h0dHBzJyApO1xyXG5jb25zdCBidWlsZExvY2FsID0gcmVxdWlyZSggJy4vYnVpbGRMb2NhbCcgKTtcclxuXHJcbi8vIHByb3RlY3RzIG1haW4sIGFuZCBhbGwgYnJhbmNoZSB1c2VkIGluIHByb2R1Y3Rpb24gZGVwbG95c1xyXG5jb25zdCBCUkFOQ0hfTkFNRV9QQVRURVJOUyA9IFsgJ21haW4nLCAnKlswLTldLlswLTldKicgXTtcclxuXHJcbi8vIE9wdGlvbnMgZm9yIHRoZSBodHRwcyByZXF1ZXN0IHRvIHRoZSBnaXRodWIgZ3JhcGhxbCBzZXJ2ZXJcclxuY29uc3Qgb3B0aW9ucyA9IHtcclxuICBob3N0bmFtZTogJ2FwaS5naXRodWIuY29tJyxcclxuICBwYXRoOiAnL2dyYXBocWwnLFxyXG4gIG1ldGhvZDogJ1BPU1QnLFxyXG4gIGhlYWRlcnM6IHtcclxuICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHtidWlsZExvY2FsLmRldmVsb3BlckdpdGh1YkFjY2Vzc1Rva2VufWAsXHJcbiAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG4gICAgJ3VzZXItYWdlbnQnOiAnbm9kZS5qcydcclxuICB9XHJcbn07XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyB0aGUgR3JhcGhRTCBxdWVyeSBzdHJpbmcgdG8gZ2V0IHRoZSBleGlzdGluZyBicmFuY2ggcHJvdGVjdGlvbiBydWxlcyBmb3IgdGhlIHByb3ZpZGVkIHJlcG8gbmFtZSB1bmRlclxyXG4gKiB0aGUgcGhldHNpbXMgcHJvamVjdC5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IHJlcG9zaXRvcnlOYW1lXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAqL1xyXG5jb25zdCBjcmVhdGVCcmFuY2hQcm90ZWN0aW9uUnVsZVF1ZXJ5RGF0YSA9IHJlcG9zaXRvcnlOYW1lID0+IHtcclxuICByZXR1cm4gY3JlYXRlUXVlcnlEYXRhKCBgcXVlcnkgQnJhbmNoUHJvdGVjdGlvblJ1bGUge1xyXG4gICAgcmVwb3NpdG9yeShvd25lcjogXCJwaGV0c2ltc1wiLCBuYW1lOiBcIiR7cmVwb3NpdG9yeU5hbWV9XCIpIHsgXHJcbiAgICAgIGJyYW5jaFByb3RlY3Rpb25SdWxlcyhmaXJzdDogMTAwKSB7IFxyXG4gICAgICAgIG5vZGVzIHtcclxuICAgICAgICAgICMgcGF0dGVybiBmb3IgdGhlIHJ1bGUgXHJcbiAgICAgICAgICBwYXR0ZXJuLFxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAjIHVuaXF1ZUlEIGZvciB0aGUgcnVsZSBhc3NpZ25lZCBieSBnaXRodWIsIHJlcXVpcmVkIHRvIHJlcXVlc3QgZGVsZXRpb25cclxuICAgICAgICAgIGlkXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9IH1gXHJcbiAgKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXRzIHRoZSBHcmFwaFFMIHF1ZXJ5IHN0cmluZyB0aGF0IHdpbGwgZGVsZXRlIGFuIGV4aXN0aW5nIGJyYW5jaCBwcm90ZWN0aW9uIHJ1bGUuIFVzZVxyXG4gKiBjcmVhdGVCcmFuY2hQcm90ZWN0aW9uUnVsZVF1ZXJ5RGF0YSB0byBnZXQgdGhlIHVuaXF1ZSBJRHMgZm9yIGVhY2ggcnVsZS5cclxuICpcclxuICogQHBhcmFtIHJ1bGVJZFxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gKi9cclxuY29uc3QgY3JlYXRlRGVsZXRlQnJhbmNoUHJvdGVjdGlvblJ1bGVNdXRhdGlvbkRhdGEgPSBydWxlSWQgPT4ge1xyXG4gIHJldHVybiBjcmVhdGVRdWVyeURhdGEoIGBtdXRhdGlvbiB7XHJcbiAgICBkZWxldGVCcmFuY2hQcm90ZWN0aW9uUnVsZShpbnB1dDp7YnJhbmNoUHJvdGVjdGlvblJ1bGVJZDogXCIke3J1bGVJZH1cIn0gKSB7XHJcbiAgICAgIGNsaWVudE11dGF0aW9uSWRcclxuICAgIH1cclxuICB9YCApO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgdGhlIGRhdGEgc3RyaW5nIHRoYXQgcmVxdWVzdHMgdGhlIGNyZWF0aW9uIG9mIGEgbmV3IGdpdGh1YiBicmFuY2ggcHJvdGVjdGlvbiBydWxlIHVzaW5nIGEgR3JhcGhRTCBxdWVyeSBhbmRcclxuICogc2VudCB3aXRoIGFuIEhUVFBTIHJlcXVlc3QuIFRoZSBkZWZhdWx0IHJ1bGUgcHJldmVudHMgYnJhbmNoIGRlbGV0aW9uLiBUaGVyZSBhcmUgb3RoZXIgdGhpbmdzIHRoYXQgY2FuIGJlXHJcbiAqIGNvbnN0cmFpbmVkIG9yIHByb3RlY3RlZCBmb3IgdGhlIGJyYW5jaCwgYnV0IHdlIGRlY2lkZWQgbm90IHRvIGFwcGx5IGFueXRoaW5nIGVsc2UgYXQgdGhpcyB0aW1lLlxyXG4gKiBTZWUgaHR0cHM6Ly9kb2NzLmdpdGh1Yi5jb20vZW4vZ3JhcGhxbC9yZWZlcmVuY2UvaW5wdXQtb2JqZWN0cyNjcmVhdGVicmFuY2hwcm90ZWN0aW9ucnVsZWlucHV0IGZvciBsaXN0XHJcbiAqIG9mIHRoaW5ncyB5b3UgY2FuIGRvIHdpdGggcnVsZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSByZXBvc2l0b3J5SWQgLSBVbmlxdWUgSUQgZm9yIHRoZSByZXBvLCBzZWUgY3JlYXRlUmVwb3NpdG9yeUlkUXVlcnlEYXRhKClcclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVQYXR0ZXJuIC0gcGF0dGVybiBmb3IgdGhlIHJ1bGUsIGFsbCBicmFuY2hlcyBtYXRjaGluZyB3aXRoIGZubWF0Y2ggd2lsbCBiZSBwcm90ZWN0ZWRcclxuICogQHJldHVybnMge3N0cmluZ31cclxuICovXHJcbmNvbnN0IGNyZWF0ZVJlcG9zaXRvcnlSdWxlTXV0YXRpb25EYXRhID0gKCByZXBvc2l0b3J5SWQsIG5hbWVQYXR0ZXJuICkgPT4ge1xyXG4gIHJldHVybiBjcmVhdGVRdWVyeURhdGEoIGBtdXRhdGlvbiB7XHJcbiAgICBjcmVhdGVCcmFuY2hQcm90ZWN0aW9uUnVsZShpbnB1dDoge1xyXG4gICAgICBwYXR0ZXJuOiBcIiR7bmFtZVBhdHRlcm59XCIsXHJcbiAgICAgIGFsbG93c0RlbGV0aW9uczogZmFsc2UsXHJcbiAgXHJcbiAgICAgIHJlcG9zaXRvcnlJZDogXCIke3JlcG9zaXRvcnlJZH1cIlxyXG4gICAgfSApXHJcbiAgICBcclxuICAgICMgSSB0aGluayB0aGlzIHNwZWNpZmllcyB0aGUgZGF0YSByZXR1cm5lZCBhZnRlciB0aGUgc2VydmVyIHJlY2VpdmVzIHRoZSBtdXRhdGlvbiByZXF1ZXN0LCBub3QgdXNlZCBidXQgcmVxdWlyZWRcclxuICAgICMgdG8gc2VuZCB0aGUgbXV0YXRpb25cclxuICAgIHtcclxuICAgICAgYnJhbmNoUHJvdGVjdGlvblJ1bGUge1xyXG4gICAgICAgIHBhdHRlcm5cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgfWAgKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIHRoZSBkYXRhIHN0cmluZyB0aGF0IHJlcXVlc3RzIHRoZSB1bmlxdWUgSUQgb2YgYSBnaXRodWIgcmVwb3NpdG9yeSB1c2luZyBhIEdyYXBoUUwgcXVlcnkgc2VudCB3aXRoIGFuXHJcbiAqIEhUVFBTIHJlcXVlc3QuXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSByZXBvc2l0b3J5TmFtZSAtIE5hbWUgb2YgdGhlIHBoZXRzaW1zIHJlcG9zaXRvcnlcclxuICogQHJldHVybnMge3N0cmluZ31cclxuICovXHJcbmNvbnN0IGNyZWF0ZVJlcG9zaXRvcnlJZFF1ZXJ5RGF0YSA9IHJlcG9zaXRvcnlOYW1lID0+IHtcclxuICByZXR1cm4gY3JlYXRlUXVlcnlEYXRhKCBgcXVlcnkgeyByZXBvc2l0b3J5KG93bmVyOiBcInBoZXRzaW1zXCIsIG5hbWU6IFwiJHtyZXBvc2l0b3J5TmFtZX1cIikgeyBpZCB9IH1gICk7XHJcbn07XHJcblxyXG4vKipcclxuICogV3JhcHMgYSBxdWVyeSBzdHJpbmcgd2l0aCBhZGRpdGlvbmFsIGZvcm1hdHRpbmcgc28gdGhhdCBpdCBjYW4gYmUgdXNlZCBpbiBhIEdyYXBoUUwgcXVlcnkgc2VudCB3aXRoIGh0dHBzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gcXVlcnlTdHJpbmdcclxuICogQHJldHVybnMge3N0cmluZ31cclxuICovXHJcbmNvbnN0IGNyZWF0ZVF1ZXJ5RGF0YSA9IHF1ZXJ5U3RyaW5nID0+IHtcclxuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoIHtcclxuICAgIHF1ZXJ5OiBxdWVyeVN0cmluZ1xyXG4gIH0gKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXRzIGFuIGVycm9yIG1lc3NhZ2UgZnJvbSBhIEpTT04gcmVzcG9uc2UuIEp1c3QgZ3JhYnMgdGhlIGZpcnN0IGVycm9yIG1lc3NhZ2UgaWYgdGhlcmUgYXJlIG11bHRpcGxlLlxyXG4gKiBAcGFyYW0ganNvblJlc3BvbnNlIC0gSlNPTiByZXNwb25zZSBvYmplY3QgZnJvbSBnaXRodWIuIEVycm9ycyBhcmUgaW4gYSAuZXJyb3JzIGFycmF5LlxyXG4gKiBAcmV0dXJucyB7KnxzdHJpbmd9XHJcbiAqL1xyXG5jb25zdCBnZXRFcnJvck1lc3NhZ2UgPSBqc29uUmVzcG9uc2UgPT4ge1xyXG4gIGlmICgganNvblJlc3BvbnNlLmVycm9ycyApIHtcclxuICAgIHJldHVybiBqc29uUmVzcG9uc2UuZXJyb3JzWyAwIF0ubWVzc2FnZTtcclxuICB9XHJcbiAgZWxzZSB7XHJcbiAgICByZXR1cm4gJ05vIGRhdGEgcmV0dXJuZWQnO1xyXG4gIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSB1bmlxdWUgSUQgb2YgdGhlIHByb3ZpZGVkIHBoZXRzaW1zIHJlcG9zaXRvcnkuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSByZXBvc2l0b3J5TmFtZVxyXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fVxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gZ2V0UmVwb3NpdG9yeUlkKCByZXBvc2l0b3J5TmFtZSApIHtcclxuICBjb25zdCBoYW5kbGVKU09OUmVzcG9uc2UgPSBqc29uUmVzcG9uc2UgPT4ge1xyXG4gICAgaWYgKCAhanNvblJlc3BvbnNlLmRhdGEgfHwganNvblJlc3BvbnNlLmRhdGEucmVwb3NpdG9yeSA9PT0gbnVsbCApIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCBgJHtnZXRFcnJvck1lc3NhZ2UoIGpzb25SZXNwb25zZSApfSBNYWtlIHN1cmUgZGV2ZWxvcGVyR2l0aHViQWNjZXNzVG9rZW4gaW4gYnVpbGQtbG9jYWwuanNvbiBtYXkgYmUgaW5jb3JyZWN0IG9yIGV4cGlyZWQuYCApO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBqc29uUmVzcG9uc2UuZGF0YS5yZXBvc2l0b3J5LmlkO1xyXG4gIH07XHJcblxyXG4gIHJldHVybiBzZW5kUHJvbWlzZWRIdHRwc1JlcXVlc3QoIGNyZWF0ZVJlcG9zaXRvcnlJZFF1ZXJ5RGF0YSggcmVwb3NpdG9yeU5hbWUgKSwgaGFuZGxlSlNPTlJlc3BvbnNlICk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGFuIGFycmF5IG9mIG9iamVjdHMsIG9uZSBmb3IgZWFjaCBleGlzdGluZyBicmFuY2ggcHJvdGVjdGlvbiBydWxlIGZvciB0aGUgcmVwb3NpdG9yeSwgdGhhdCBoYXNcclxuICogdGhlIHByb3RlY3Rpb24gcnVsZSBwYXR0ZXJuIGFuZCB0aGUgdW5pcXVlIElEIGZvciB0aGUgcnVsZSBhc3NpZ25lZCBieSBnaXRodWIuXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSByZXBvc2l0b3J5TmFtZVxyXG4gKiBAcmV0dXJucyB7UHJvbWlzZTwqW10+fSAtIGFycmF5IG9mIG5vZGVzIHdpdGgga2V5IHZhbHVlIHBhaXJzIG9mIHsgXCJwYXR0ZXJuXCI6IHN0cmluZywgXCJpZFwiOiBzdHJpbmcgfVxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gZ2V0RXhpc3RpbmdCcmFuY2hQcm90ZWN0aW9uUnVsZXMoIHJlcG9zaXRvcnlOYW1lICkge1xyXG4gIGNvbnN0IGhhbmRsZUpTT05SZXNwb25zZSA9IGpzb25SZXNwb25zZSA9PiB7XHJcbiAgICBpZiAoIGpzb25SZXNwb25zZS5lcnJvcnMgKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvciggZ2V0RXJyb3JNZXNzYWdlKCBqc29uUmVzcG9uc2UgKSApO1xyXG4gICAgfVxyXG4gICAgaWYgKCAhanNvblJlc3BvbnNlLmRhdGEgKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvciggYE5vIGRhdGEgcmV0dXJuZWQgYnkgZ2V0RXhpc3RpbmdCcmFuY2hQcm90ZWN0aW9uUnVsZXMgZm9yIHJlcG8gJHtyZXBvc2l0b3J5TmFtZX1gICk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ganNvblJlc3BvbnNlLmRhdGEucmVwb3NpdG9yeS5icmFuY2hQcm90ZWN0aW9uUnVsZXMubm9kZXM7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIHNlbmRQcm9taXNlZEh0dHBzUmVxdWVzdCggY3JlYXRlQnJhbmNoUHJvdGVjdGlvblJ1bGVRdWVyeURhdGEoIHJlcG9zaXRvcnlOYW1lICksIGhhbmRsZUpTT05SZXNwb25zZSApO1xyXG59XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyB0aGUgcHJvdGVjdGlvbiBydWxlIGZvciBhbGwgYnJhbmNoZXMgbWF0Y2hpbmcgdGhlIG5hbWVQYXR0ZXJuIGZvciB0aGUgcGhldHNpbXMgcmVwb3NpdG9yeSB3aXRoIHRoZSBwcm92aWRlZFxyXG4gKiB1bmlxdWUgSUQgYXNzaWduZWQgYnkgZ2l0aHViLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVwb3NpdG9yeUlkIC0gdW5pcXVlIElEIGZvciB0aGUgcmVwb3NpdG9yeSwgdXNlIGdldFJlcG9zaXRvcnlJZCB0byBnZXQgdGhpc1xyXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVBhdHRlcm4gLSBUaGUgcGF0dGVybiBmb3IgdGhlIHJ1bGUgdXNpbmcgZm5tYXRjaFxyXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fVxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gd3JpdGVQcm90ZWN0aW9uUnVsZSggcmVwb3NpdG9yeUlkLCBuYW1lUGF0dGVybiApIHtcclxuICBjb25zdCBoYW5kbGVKU09OUmVzcG9uc2UgPSBqc29uUmVzcG9uc2UgPT4ge1xyXG4gICAgaWYgKCBqc29uUmVzcG9uc2UuZXJyb3JzICkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoIGdldEVycm9yTWVzc2FnZSgganNvblJlc3BvbnNlICkgKTtcclxuICAgIH1cclxuICB9O1xyXG4gIHJldHVybiBzZW5kUHJvbWlzZWRIdHRwc1JlcXVlc3QoIGNyZWF0ZVJlcG9zaXRvcnlSdWxlTXV0YXRpb25EYXRhKCByZXBvc2l0b3J5SWQsIG5hbWVQYXR0ZXJuICksIGhhbmRsZUpTT05SZXNwb25zZSApO1xyXG59XHJcblxyXG4vKipcclxuICogRGVsZXRlcyBhbiBleGlzdGluZyBydWxlLiBXZSBhc3N1bWUgdGhhdCB0aGF0IGJ5IHJ1bm5pbmcgdGhpcyB3ZSB3YW50IHRvIG92ZXJ3cml0ZSB0aGUgZXhpc3RpbmcgcnVsZS5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IHJ1bGVJZFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVBhdHRlcm5cclxuICogQHBhcmFtIHtzdHJpbmd9IHJlcG9zaXRvcnlOYW1lXHJcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59XHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBkZWxldGVFeGlzdGluZ1Byb3RlY3Rpb25SdWxlKCBydWxlSWQsIG5hbWVQYXR0ZXJuLCByZXBvc2l0b3J5TmFtZSApIHtcclxuICBjb25zdCBoYW5kbGVKU09OUmVzcG9uc2UgPSBqc29uUmVzcG9uc2UgPT4ge1xyXG4gICAgaWYgKCBqc29uUmVzcG9uc2UuZXJyb3JzICkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoIGdldEVycm9yTWVzc2FnZSgganNvblJlc3BvbnNlICkgKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICBjb25zb2xlLmxvZyggYERlbGV0ZWQgZXhpc3RpbmcgYnJhbmNoIHByb3RlY3Rpb24gcnVsZSAke25hbWVQYXR0ZXJufSBmb3IgcmVwbyAke3JlcG9zaXRvcnlOYW1lfWAgKTtcclxuICAgIH1cclxuICB9O1xyXG4gIHJldHVybiBzZW5kUHJvbWlzZWRIdHRwc1JlcXVlc3QoIGNyZWF0ZURlbGV0ZUJyYW5jaFByb3RlY3Rpb25SdWxlTXV0YXRpb25EYXRhKCBydWxlSWQgKSwgaGFuZGxlSlNPTlJlc3BvbnNlICk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBbiBhc3luYyBmdW5jdGlvbiB0aGF0IHdpbGwgZGVsZXRlIGFsbCBleGlzdGluZyBydWxlcyB0aGF0IG1hdGNoIHRoZSBwcm92aWRlZCBuYW1lUGF0dGVybiBmb3IgdGhlIHJlcG9zaXRvcnkuXHJcbiAqIFdyYXBwZWQgaW4gYSBQcm9taXNlIHNvIHdlIGNhbiB3YWl0IHRvIHdyaXRlIG5ldyBydWxlcyB1bnRpbCB0aGUgZXhpc3RpbmcgcnVsZXMgYXJlIHJlbW92ZWQuIElmIHlvdSB0cnkgdG9cclxuICogd3JpdGUgb3ZlciBhbiBleGlzdGluZyBydWxlIHdpdGhvdXQgcmVtb3ZpbmcgaXQgZ2l0aHViIHdpbGwgcmVzcG9uZCB3aXRoIGFuIGVycm9yLlxyXG4gKlxyXG4gKiBAcGFyYW0geypbXX0gcnVsZXNcclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVQYXR0ZXJuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSByZXBvc2l0b3J5TmFtZVxyXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx1bmtub3duW10+fVxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gZGVsZXRlTWF0Y2hpbmdQcm90ZWN0aW9uUnVsZXMoIHJ1bGVzLCBuYW1lUGF0dGVybiwgcmVwb3NpdG9yeU5hbWUgKSB7XHJcblxyXG4gIGNvbnN0IHByb21pc2VzID0gW107XHJcbiAgcnVsZXMuZm9yRWFjaCggcnVsZSA9PiB7XHJcblxyXG4gICAgLy8gb25seSBkZWxldGUgcnVsZXMgdGhhdCBtYXRjaCB0aGUgbmV3IHBhdHRlcm4gd2Ugd2FudCB0byBwcm90ZWN0XHJcbiAgICBpZiAoIHJ1bGUucGF0dGVybiA9PT0gbmFtZVBhdHRlcm4gKSB7XHJcbiAgICAgIHByb21pc2VzLnB1c2goIGRlbGV0ZUV4aXN0aW5nUHJvdGVjdGlvblJ1bGUoIHJ1bGUuaWQsIG5hbWVQYXR0ZXJuLCByZXBvc2l0b3J5TmFtZSApICk7XHJcbiAgICB9XHJcbiAgfSApO1xyXG5cclxuICByZXR1cm4gUHJvbWlzZS5hbGwoIHByb21pc2VzICk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTZW5kcyBhIHJlcXVlc3QgdG8gZ2l0aHViJ3MgR3JhcGhRTCBzZXJ2ZXIgdG8gcXVlcnkgb3IgbXV0YXRlIHJlcG9zaXRvcnkgZGF0YS5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IHF1ZXJ5RGF0YSAtIHRoZSBzdHJpbmcgc2VudCB3aXRoIGh0dHBzXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oT2JqZWN0KX0gaGFuZGxlIC0gaGFuZGxlcyB0aGUgSlNPTiByZXNwb25zZSBmcm9tIGdpdGh1YlxyXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx1bmtub3duPn1cclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIHNlbmRQcm9taXNlZEh0dHBzUmVxdWVzdCggcXVlcnlEYXRhLCBoYW5kbGUgKSB7XHJcbiAgcmV0dXJuIG5ldyBQcm9taXNlKCAoIHJlc29sdmUsIHJlamVjdCApID0+IHtcclxuICAgIGNvbnN0IHJlcXVlc3QgPSBodHRwcy5yZXF1ZXN0KCBvcHRpb25zLCByZXNwb25zZSA9PiB7XHJcbiAgICAgIGxldCByZXNwb25zZUJvZHkgPSAnJztcclxuXHJcbiAgICAgIHJlc3BvbnNlLm9uKCAnZGF0YScsIGQgPT4ge1xyXG4gICAgICAgIHJlc3BvbnNlQm9keSArPSBkO1xyXG4gICAgICB9ICk7XHJcblxyXG4gICAgICByZXNwb25zZS5vbiggJ2VuZCcsICgpID0+IHtcclxuICAgICAgICBjb25zdCBqc29uUmVzcG9uc2UgPSBKU09OLnBhcnNlKCByZXNwb25zZUJvZHkgKTtcclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGNvbnN0IHJlc29sdmVWYWx1ZSA9IGhhbmRsZSgganNvblJlc3BvbnNlICk7XHJcbiAgICAgICAgICByZXNvbHZlKCByZXNvbHZlVmFsdWUgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2goIGVycm9yICkge1xyXG4gICAgICAgICAgcmVqZWN0KCBlcnJvciApO1xyXG4gICAgICAgIH1cclxuICAgICAgfSApO1xyXG4gICAgfSApO1xyXG5cclxuICAgIHJlcXVlc3Qub24oICdlcnJvcicsIGVycm9yID0+IHtcclxuICAgICAgY29uc29sZS5lcnJvciggZXJyb3IgKTtcclxuICAgIH0gKTtcclxuXHJcbiAgICByZXF1ZXN0LndyaXRlKCBxdWVyeURhdGEgKTtcclxuICAgIHJlcXVlc3QuZW5kKCk7XHJcbiAgfSApO1xyXG59XHJcblxyXG4vKipcclxuICogQ2xlYXIgcHJvdGVjdGlvbnMgZm9yIHRoZSBicmFuY2hlcyB0aGF0IFBoRVQgd2FudHMgdG8gcHJvdGVjdC5cclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGNsZWFyQnJhbmNoUHJvdGVjdGlvbnMoIHJlcG9zaXRvcmllcyApIHtcclxuICBmb3IgKCBjb25zdCByZXBvc2l0b3J5TmFtZSBvZiByZXBvc2l0b3JpZXMgKSB7XHJcbiAgICBmb3IgKCBjb25zdCBuYW1lUGF0dGVybiBvZiBCUkFOQ0hfTkFNRV9QQVRURVJOUyApIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBicmFuY2hQcm90ZWN0aW9uUnVsZXMgPSBhd2FpdCBnZXRFeGlzdGluZ0JyYW5jaFByb3RlY3Rpb25SdWxlcyggcmVwb3NpdG9yeU5hbWUgKTtcclxuICAgICAgICBhd2FpdCBkZWxldGVNYXRjaGluZ1Byb3RlY3Rpb25SdWxlcyggYnJhbmNoUHJvdGVjdGlvblJ1bGVzLCBuYW1lUGF0dGVybiwgcmVwb3NpdG9yeU5hbWUgKTtcclxuICAgICAgfVxyXG4gICAgICBjYXRjaCggZXJyb3IgKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coIGBFcnJvciBjbGVhcmluZyBnaXRodWIgcHJvdGVjdGlvbiBydWxlICR7bmFtZVBhdHRlcm59IGZvciAke3JlcG9zaXRvcnlOYW1lfWAgKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEFwcGx5IGJyYW5jaCBwcm90ZWN0aW9uIHJ1bGVzIHRvIHByb2RjdXRpb24gYnJhbmNoZXMgKG1haW4sIHJlbGVhc2UgYnJhbmNoZXMpLlxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gcHJvdGVjdEJyYW5jaGVzKCByZXBvc2l0b3JpZXMgKSB7XHJcblxyXG4gIC8vIHJlbW92ZSBhbnkgdHJhaWxpbmcgJy8nIGZyb20gdGhlIHJlcG9zaXRvcnkgbmFtZXMsIHdoaWNoIG1heSBoYXZlIGJlZW4gYWRkZWQgYnkgYXV0byBjb21wbGV0ZVxyXG4gIGNvbnN0IGNsZWFuZWRSZXBvc2l0b3JpZXMgPSByZXBvc2l0b3JpZXMubWFwKCByZXBvc2l0b3J5ID0+IHJlcG9zaXRvcnkucmVwbGFjZSggL1xcLyQvLCAnJyApICk7XHJcblxyXG4gIC8vIGlmIHRoZSBydWxlIGZvciB0aGUgcHJvdGVjdGVkIGJyYW5jaCBhbHJlYWR5IGV4aXN0cywgZGVsZXRlIGl0IC0gd2UgYXNzdW1lIHRoYXQgcnVubmluZyB0aGlzIGFnYWluIG1lYW5zIHdlXHJcbiAgLy8gd2FudCB0byB1cGRhdGUgcnVsZXMgZm9yIGVhY2ggbmFtZVBhdHRlcm5cclxuICBhd2FpdCBjbGVhckJyYW5jaFByb3RlY3Rpb25zKCBjbGVhbmVkUmVwb3NpdG9yaWVzICk7XHJcblxyXG4gIGZvciAoIGNvbnN0IHJlcG9zaXRvcnlOYW1lIG9mIGNsZWFuZWRSZXBvc2l0b3JpZXMgKSB7XHJcblxyXG4gICAgLy8gZ2V0IHRoZSB1bmlxdWUgSUQgZm9yIGVhY2ggcmVwb3NpdG9yeVxyXG4gICAgY29uc3QgcmVwb3NpdG9yeUlkID0gYXdhaXQgZ2V0UmVwb3NpdG9yeUlkKCByZXBvc2l0b3J5TmFtZSApO1xyXG5cclxuICAgIGZvciAoIGNvbnN0IG5hbWVQYXR0ZXJuIG9mIEJSQU5DSF9OQU1FX1BBVFRFUk5TICkge1xyXG5cclxuICAgICAgdHJ5IHtcclxuICAgICAgICBhd2FpdCB3cml0ZVByb3RlY3Rpb25SdWxlKCByZXBvc2l0b3J5SWQsIG5hbWVQYXR0ZXJuICk7XHJcbiAgICAgICAgY29uc29sZS5sb2coIGAke25hbWVQYXR0ZXJufSBwcm90ZWN0aW9uIHJ1bGUgc2V0IGZvciAke3JlcG9zaXRvcnlOYW1lfWAgKTtcclxuICAgICAgfVxyXG4gICAgICBjYXRjaCggZXJyb3IgKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coIGBFcnJvciB3cml0aW5nICR7bmFtZVBhdHRlcm59IHJ1bGUgZm9yIHJlcG8gJHtyZXBvc2l0b3J5TmFtZX06YCApO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCBlcnJvciApO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCAnXFxuJyApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICBwcm90ZWN0QnJhbmNoZXM6IHByb3RlY3RCcmFuY2hlcyxcclxuICBjbGVhckJyYW5jaFByb3RlY3Rpb25zOiBjbGVhckJyYW5jaFByb3RlY3Rpb25zXHJcbn07Il0sIm1hcHBpbmdzIjoiQUFB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