// Copyright 2020-2024, University of Colorado Boulder

/**
 * A lightweight version of Property (that satisfies some of the interface), meant for high-performance applications
 * where validation, phet-io support and other things are not needed.
 *
 * This directly extends TinyEmitter in order to save memory.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

import axon from './axon.js';
import TinyEmitter from './TinyEmitter.js';
import Validation from './Validation.js';

// Just a shorter name

export default class TinyProperty extends TinyEmitter {
  // Store the internal value -- NOT for general use (but used in Scenery for performance)

  // If provided, force use of the custom value comparison beyond reference equality checks. Keeps some compatibility
  // with the Property interface to have the equality check in this type too. Not defining in the general case for
  // memory usage, only using if we notice this flag set. This is not readonly so that we can update this after construction. Defaults to "reference".

  constructor(value, onBeforeNotify, hasListenerOrderDependencies, reentrantNotificationStrategy) {
    // Defaults to "queue" for Properties so that we notify all listeners for a value change
    // before notifying for the next value change. For example, if we change from a->b, and one listener changes the value
    // from b->c, that reentrant value change will queue its listeners for after all listeners have fired for a->b. For
    // specifics see documentation in TinyEmitter.
    super(onBeforeNotify, hasListenerOrderDependencies, reentrantNotificationStrategy || 'queue');
    this._value = value;
  }

  /**
   * Returns the value.
   *
   * You can also use the es5 getter (property.value) but this means is provided for inner loops
   * or internal code that must be fast.
   */
  get() {
    return this._value;
  }

  /**
   * Returns the value.
   */
  get value() {
    return this.get();
  }

  /**
   * Sets the value.
   */
  set value(newValue) {
    this.set(newValue);
  }

  /**
   * Sets the value and notifies listeners, unless deferred or disposed. You can also use the es5 getter
   * (property.value) but this means is provided for inner loops or internal code that must be fast. If the value
   * hasn't changed, this is a no-op.
   */
  set(value) {
    // It is very important that `equalsValue` holds all logic about if the value should change AND if listeners
    // are notified.
    if (!this.equalsValue(value)) {
      const oldValue = this._value;
      this.setPropertyValue(value);
      this.notifyListeners(oldValue);
    }
  }

  /**
   * Sets the value without notifying any listeners. This is a place to override if a subtype performs additional work
   * when setting the value.
   */
  setPropertyValue(value) {
    this._value = value;
  }

  /**
   * Returns true if and only if the specified value equals the value of this property. This is used to determine if
   * a Property's value should change and if listeners should be notified. In general, this implementation should
   * not be overridden except to provide more correct "value"s as parameters for the areValuesEqual() function.
   */
  equalsValue(value) {
    return this.areValuesEqual(value, this._value);
  }

  /**
   * Central logic for determining value equality for Property. This determines if a value should change, and if
   * listeners should notify based on set() call.
   *
   * Determines equality semantics for value comparison, including whether notifications are sent out when the
   * wrapped value changes, and whether onValue() is triggered. See Validation.equalsForValidationStrategy for details
   * and doc on ValueComparisonStrategy
   *
   * Overriding this function is deprecated, instead provide a custom valueComparisonStrategy.
   */
  areValuesEqual(a, b) {
    return Validation.equalsForValidationStrategy(a, b, this.valueComparisonStrategy);
  }

  /**
   * Directly notifies listeners of changes.
   */
  notifyListeners(oldValue) {
    // We use this._value here for performance, AND to avoid calling onAccessAttempt unnecessarily.
    this.emit(this._value, oldValue, this);
  }

  /**
   * Adds listener and calls it immediately. If listener is already registered, this is a no-op. The initial
   * notification provides the current value for newValue and null for oldValue.
   */
  link(listener) {
    this.addListener(listener);
    listener(this._value, null, this); // null should be used when an object is expected but unavailable
  }

  /**
   * Add an listener to the TinyProperty, without calling it back right away. This is used when you need to register a
   * listener without an immediate callback.
   */
  lazyLink(listener) {
    this.addListener(listener); // Because it's a lazy link, it will never be called with null
  }

  /**
   * Removes a listener. If listener is not registered, this is a no-op.
   */
  unlink(listener) {
    this.removeListener(listener);
  }

  /**
   * Removes all listeners. If no listeners are registered, this is a no-op.
   */
  unlinkAll() {
    this.removeAllListeners();
  }

  /**
   * Links an object's named attribute to this TinyProperty.  Returns a handle so it can be removed using
   * TinyProperty.unlink();
   * Example: modelVisibleProperty.linkAttribute(view, 'visible');
   *
   * NOTE: Duplicated with Property.linkAttribute
   */
  linkAttribute(object, attributeName) {
    const handle = value => {
      object[attributeName] = value;
    };
    this.link(handle);
    return handle;
  }

  /**
   * Returns true if the value can be set externally, using .value= or set()
   */
  isSettable() {
    return true;
  }
  get valueComparisonStrategy() {
    return this._valueComparisonStrategy || 'reference';
  }
  set valueComparisonStrategy(valueComparisonStrategy) {
    this._valueComparisonStrategy = valueComparisonStrategy;
  }

  /**
   * Releases references.
   */
  dispose() {
    // Remove any listeners that are still attached (note that the emitter dispose would do this also, but without the
    // potentially-needed extra logic of changeCount, etc.)
    this.unlinkAll();
    super.dispose();
  }
}
axon.register('TinyProperty', TinyProperty);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJheG9uIiwiVGlueUVtaXR0ZXIiLCJWYWxpZGF0aW9uIiwiVGlueVByb3BlcnR5IiwiY29uc3RydWN0b3IiLCJ2YWx1ZSIsIm9uQmVmb3JlTm90aWZ5IiwiaGFzTGlzdGVuZXJPcmRlckRlcGVuZGVuY2llcyIsInJlZW50cmFudE5vdGlmaWNhdGlvblN0cmF0ZWd5IiwiX3ZhbHVlIiwiZ2V0IiwibmV3VmFsdWUiLCJzZXQiLCJlcXVhbHNWYWx1ZSIsIm9sZFZhbHVlIiwic2V0UHJvcGVydHlWYWx1ZSIsIm5vdGlmeUxpc3RlbmVycyIsImFyZVZhbHVlc0VxdWFsIiwiYSIsImIiLCJlcXVhbHNGb3JWYWxpZGF0aW9uU3RyYXRlZ3kiLCJ2YWx1ZUNvbXBhcmlzb25TdHJhdGVneSIsImVtaXQiLCJsaW5rIiwibGlzdGVuZXIiLCJhZGRMaXN0ZW5lciIsImxhenlMaW5rIiwidW5saW5rIiwicmVtb3ZlTGlzdGVuZXIiLCJ1bmxpbmtBbGwiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJsaW5rQXR0cmlidXRlIiwib2JqZWN0IiwiYXR0cmlidXRlTmFtZSIsImhhbmRsZSIsImlzU2V0dGFibGUiLCJfdmFsdWVDb21wYXJpc29uU3RyYXRlZ3kiLCJkaXNwb3NlIiwicmVnaXN0ZXIiXSwic291cmNlcyI6WyJUaW55UHJvcGVydHkudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMjAtMjAyNCwgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXHJcblxyXG4vKipcclxuICogQSBsaWdodHdlaWdodCB2ZXJzaW9uIG9mIFByb3BlcnR5ICh0aGF0IHNhdGlzZmllcyBzb21lIG9mIHRoZSBpbnRlcmZhY2UpLCBtZWFudCBmb3IgaGlnaC1wZXJmb3JtYW5jZSBhcHBsaWNhdGlvbnNcclxuICogd2hlcmUgdmFsaWRhdGlvbiwgcGhldC1pbyBzdXBwb3J0IGFuZCBvdGhlciB0aGluZ3MgYXJlIG5vdCBuZWVkZWQuXHJcbiAqXHJcbiAqIFRoaXMgZGlyZWN0bHkgZXh0ZW5kcyBUaW55RW1pdHRlciBpbiBvcmRlciB0byBzYXZlIG1lbW9yeS5cclxuICpcclxuICogQGF1dGhvciBTYW0gUmVpZCAoUGhFVCBJbnRlcmFjdGl2ZSBTaW11bGF0aW9ucylcclxuICogQGF1dGhvciBKb25hdGhhbiBPbHNvbiA8am9uYXRoYW4ub2xzb25AY29sb3JhZG8uZWR1PlxyXG4gKi9cclxuXHJcbmltcG9ydCBheG9uIGZyb20gJy4vYXhvbi5qcyc7XHJcbmltcG9ydCBUaW55RW1pdHRlciwgeyBUaW55RW1pdHRlck9wdGlvbnMgfSBmcm9tICcuL1RpbnlFbWl0dGVyLmpzJztcclxuaW1wb3J0IFRQcm9wZXJ0eSBmcm9tICcuL1RQcm9wZXJ0eS5qcyc7XHJcbmltcG9ydCBUUmVhZE9ubHlQcm9wZXJ0eSwgeyBQcm9wZXJ0eUxhenlMaW5rTGlzdGVuZXIsIFByb3BlcnR5TGlua0xpc3RlbmVyLCBQcm9wZXJ0eUxpc3RlbmVyIH0gZnJvbSAnLi9UUmVhZE9ubHlQcm9wZXJ0eS5qcyc7XHJcbmltcG9ydCBWYWxpZGF0aW9uLCB7IFZhbHVlQ29tcGFyaXNvblN0cmF0ZWd5IH0gZnJvbSAnLi9WYWxpZGF0aW9uLmpzJztcclxuXHJcbmV4cG9ydCB0eXBlIFRpbnlQcm9wZXJ0eUVtaXR0ZXJQYXJhbWV0ZXJzPFQ+ID0gWyBULCBUIHwgbnVsbCwgVFJlYWRPbmx5UHJvcGVydHk8VD4gXTtcclxuZXhwb3J0IHR5cGUgVGlueVByb3BlcnR5T25CZWZvcmVOb3RpZnk8VD4gPSAoIC4uLmFyZ3M6IFRpbnlQcm9wZXJ0eUVtaXR0ZXJQYXJhbWV0ZXJzPFQ+ICkgPT4gdm9pZDtcclxuXHJcbi8vIEp1c3QgYSBzaG9ydGVyIG5hbWVcclxudHlwZSBPcHRpb25zQWxpYXM8VD4gPSBUaW55RW1pdHRlck9wdGlvbnM8VGlueVByb3BlcnR5RW1pdHRlclBhcmFtZXRlcnM8VD4+O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGlueVByb3BlcnR5PFQ+IGV4dGVuZHMgVGlueUVtaXR0ZXI8VGlueVByb3BlcnR5RW1pdHRlclBhcmFtZXRlcnM8VD4+IGltcGxlbWVudHMgVFByb3BlcnR5PFQ+IHtcclxuXHJcbiAgcHVibGljIF92YWx1ZTogVDsgLy8gU3RvcmUgdGhlIGludGVybmFsIHZhbHVlIC0tIE5PVCBmb3IgZ2VuZXJhbCB1c2UgKGJ1dCB1c2VkIGluIFNjZW5lcnkgZm9yIHBlcmZvcm1hbmNlKVxyXG5cclxuICAvLyBJZiBwcm92aWRlZCwgZm9yY2UgdXNlIG9mIHRoZSBjdXN0b20gdmFsdWUgY29tcGFyaXNvbiBiZXlvbmQgcmVmZXJlbmNlIGVxdWFsaXR5IGNoZWNrcy4gS2VlcHMgc29tZSBjb21wYXRpYmlsaXR5XHJcbiAgLy8gd2l0aCB0aGUgUHJvcGVydHkgaW50ZXJmYWNlIHRvIGhhdmUgdGhlIGVxdWFsaXR5IGNoZWNrIGluIHRoaXMgdHlwZSB0b28uIE5vdCBkZWZpbmluZyBpbiB0aGUgZ2VuZXJhbCBjYXNlIGZvclxyXG4gIC8vIG1lbW9yeSB1c2FnZSwgb25seSB1c2luZyBpZiB3ZSBub3RpY2UgdGhpcyBmbGFnIHNldC4gVGhpcyBpcyBub3QgcmVhZG9ubHkgc28gdGhhdCB3ZSBjYW4gdXBkYXRlIHRoaXMgYWZ0ZXIgY29uc3RydWN0aW9uLiBEZWZhdWx0cyB0byBcInJlZmVyZW5jZVwiLlxyXG4gIHB1YmxpYyBfdmFsdWVDb21wYXJpc29uU3RyYXRlZ3k/OiBWYWx1ZUNvbXBhcmlzb25TdHJhdGVneTxUPjtcclxuXHJcbiAgcHVibGljIGNvbnN0cnVjdG9yKCB2YWx1ZTogVCwgb25CZWZvcmVOb3RpZnk/OiBPcHRpb25zQWxpYXM8VD5bJ29uQmVmb3JlTm90aWZ5J10gfCBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgaGFzTGlzdGVuZXJPcmRlckRlcGVuZGVuY2llcz86IE9wdGlvbnNBbGlhczxUPlsnaGFzTGlzdGVuZXJPcmRlckRlcGVuZGVuY2llcyddIHwgbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAgIHJlZW50cmFudE5vdGlmaWNhdGlvblN0cmF0ZWd5PzogT3B0aW9uc0FsaWFzPFQ+WydyZWVudHJhbnROb3RpZmljYXRpb25TdHJhdGVneSddIHwgbnVsbCApIHtcclxuXHJcbiAgICAvLyBEZWZhdWx0cyB0byBcInF1ZXVlXCIgZm9yIFByb3BlcnRpZXMgc28gdGhhdCB3ZSBub3RpZnkgYWxsIGxpc3RlbmVycyBmb3IgYSB2YWx1ZSBjaGFuZ2VcclxuICAgIC8vIGJlZm9yZSBub3RpZnlpbmcgZm9yIHRoZSBuZXh0IHZhbHVlIGNoYW5nZS4gRm9yIGV4YW1wbGUsIGlmIHdlIGNoYW5nZSBmcm9tIGEtPmIsIGFuZCBvbmUgbGlzdGVuZXIgY2hhbmdlcyB0aGUgdmFsdWVcclxuICAgIC8vIGZyb20gYi0+YywgdGhhdCByZWVudHJhbnQgdmFsdWUgY2hhbmdlIHdpbGwgcXVldWUgaXRzIGxpc3RlbmVycyBmb3IgYWZ0ZXIgYWxsIGxpc3RlbmVycyBoYXZlIGZpcmVkIGZvciBhLT5iLiBGb3JcclxuICAgIC8vIHNwZWNpZmljcyBzZWUgZG9jdW1lbnRhdGlvbiBpbiBUaW55RW1pdHRlci5cclxuICAgIHN1cGVyKCBvbkJlZm9yZU5vdGlmeSwgaGFzTGlzdGVuZXJPcmRlckRlcGVuZGVuY2llcywgcmVlbnRyYW50Tm90aWZpY2F0aW9uU3RyYXRlZ3kgfHwgJ3F1ZXVlJyApO1xyXG5cclxuICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSB2YWx1ZS5cclxuICAgKlxyXG4gICAqIFlvdSBjYW4gYWxzbyB1c2UgdGhlIGVzNSBnZXR0ZXIgKHByb3BlcnR5LnZhbHVlKSBidXQgdGhpcyBtZWFucyBpcyBwcm92aWRlZCBmb3IgaW5uZXIgbG9vcHNcclxuICAgKiBvciBpbnRlcm5hbCBjb2RlIHRoYXQgbXVzdCBiZSBmYXN0LlxyXG4gICAqL1xyXG4gIHB1YmxpYyBnZXQoKTogVCB7XHJcbiAgICByZXR1cm4gdGhpcy5fdmFsdWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSB2YWx1ZS5cclxuICAgKi9cclxuICBwdWJsaWMgZ2V0IHZhbHVlKCk6IFQge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0KCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXRzIHRoZSB2YWx1ZS5cclxuICAgKi9cclxuICBwdWJsaWMgc2V0IHZhbHVlKCBuZXdWYWx1ZTogVCApIHtcclxuICAgIHRoaXMuc2V0KCBuZXdWYWx1ZSApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0cyB0aGUgdmFsdWUgYW5kIG5vdGlmaWVzIGxpc3RlbmVycywgdW5sZXNzIGRlZmVycmVkIG9yIGRpc3Bvc2VkLiBZb3UgY2FuIGFsc28gdXNlIHRoZSBlczUgZ2V0dGVyXHJcbiAgICogKHByb3BlcnR5LnZhbHVlKSBidXQgdGhpcyBtZWFucyBpcyBwcm92aWRlZCBmb3IgaW5uZXIgbG9vcHMgb3IgaW50ZXJuYWwgY29kZSB0aGF0IG11c3QgYmUgZmFzdC4gSWYgdGhlIHZhbHVlXHJcbiAgICogaGFzbid0IGNoYW5nZWQsIHRoaXMgaXMgYSBuby1vcC5cclxuICAgKi9cclxuICBwdWJsaWMgc2V0KCB2YWx1ZTogVCApOiB2b2lkIHtcclxuXHJcbiAgICAvLyBJdCBpcyB2ZXJ5IGltcG9ydGFudCB0aGF0IGBlcXVhbHNWYWx1ZWAgaG9sZHMgYWxsIGxvZ2ljIGFib3V0IGlmIHRoZSB2YWx1ZSBzaG91bGQgY2hhbmdlIEFORCBpZiBsaXN0ZW5lcnNcclxuICAgIC8vIGFyZSBub3RpZmllZC5cclxuICAgIGlmICggIXRoaXMuZXF1YWxzVmFsdWUoIHZhbHVlICkgKSB7XHJcbiAgICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy5fdmFsdWU7XHJcblxyXG4gICAgICB0aGlzLnNldFByb3BlcnR5VmFsdWUoIHZhbHVlICk7XHJcblxyXG4gICAgICB0aGlzLm5vdGlmeUxpc3RlbmVycyggb2xkVmFsdWUgKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgdGhlIHZhbHVlIHdpdGhvdXQgbm90aWZ5aW5nIGFueSBsaXN0ZW5lcnMuIFRoaXMgaXMgYSBwbGFjZSB0byBvdmVycmlkZSBpZiBhIHN1YnR5cGUgcGVyZm9ybXMgYWRkaXRpb25hbCB3b3JrXHJcbiAgICogd2hlbiBzZXR0aW5nIHRoZSB2YWx1ZS5cclxuICAgKi9cclxuICBwdWJsaWMgc2V0UHJvcGVydHlWYWx1ZSggdmFsdWU6IFQgKTogdm9pZCB7XHJcbiAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0cnVlIGlmIGFuZCBvbmx5IGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgZXF1YWxzIHRoZSB2YWx1ZSBvZiB0aGlzIHByb3BlcnR5LiBUaGlzIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIGlmXHJcbiAgICogYSBQcm9wZXJ0eSdzIHZhbHVlIHNob3VsZCBjaGFuZ2UgYW5kIGlmIGxpc3RlbmVycyBzaG91bGQgYmUgbm90aWZpZWQuIEluIGdlbmVyYWwsIHRoaXMgaW1wbGVtZW50YXRpb24gc2hvdWxkXHJcbiAgICogbm90IGJlIG92ZXJyaWRkZW4gZXhjZXB0IHRvIHByb3ZpZGUgbW9yZSBjb3JyZWN0IFwidmFsdWVcInMgYXMgcGFyYW1ldGVycyBmb3IgdGhlIGFyZVZhbHVlc0VxdWFsKCkgZnVuY3Rpb24uXHJcbiAgICovXHJcbiAgcHJvdGVjdGVkIGVxdWFsc1ZhbHVlKCB2YWx1ZTogVCApOiBib29sZWFuIHtcclxuICAgIHJldHVybiB0aGlzLmFyZVZhbHVlc0VxdWFsKCB2YWx1ZSwgdGhpcy5fdmFsdWUgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENlbnRyYWwgbG9naWMgZm9yIGRldGVybWluaW5nIHZhbHVlIGVxdWFsaXR5IGZvciBQcm9wZXJ0eS4gVGhpcyBkZXRlcm1pbmVzIGlmIGEgdmFsdWUgc2hvdWxkIGNoYW5nZSwgYW5kIGlmXHJcbiAgICogbGlzdGVuZXJzIHNob3VsZCBub3RpZnkgYmFzZWQgb24gc2V0KCkgY2FsbC5cclxuICAgKlxyXG4gICAqIERldGVybWluZXMgZXF1YWxpdHkgc2VtYW50aWNzIGZvciB2YWx1ZSBjb21wYXJpc29uLCBpbmNsdWRpbmcgd2hldGhlciBub3RpZmljYXRpb25zIGFyZSBzZW50IG91dCB3aGVuIHRoZVxyXG4gICAqIHdyYXBwZWQgdmFsdWUgY2hhbmdlcywgYW5kIHdoZXRoZXIgb25WYWx1ZSgpIGlzIHRyaWdnZXJlZC4gU2VlIFZhbGlkYXRpb24uZXF1YWxzRm9yVmFsaWRhdGlvblN0cmF0ZWd5IGZvciBkZXRhaWxzXHJcbiAgICogYW5kIGRvYyBvbiBWYWx1ZUNvbXBhcmlzb25TdHJhdGVneVxyXG4gICAqXHJcbiAgICogT3ZlcnJpZGluZyB0aGlzIGZ1bmN0aW9uIGlzIGRlcHJlY2F0ZWQsIGluc3RlYWQgcHJvdmlkZSBhIGN1c3RvbSB2YWx1ZUNvbXBhcmlzb25TdHJhdGVneS5cclxuICAgKi9cclxuICBwdWJsaWMgYXJlVmFsdWVzRXF1YWwoIGE6IFQsIGI6IFQgKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gVmFsaWRhdGlvbi5lcXVhbHNGb3JWYWxpZGF0aW9uU3RyYXRlZ3k8VD4oIGEsIGIsIHRoaXMudmFsdWVDb21wYXJpc29uU3RyYXRlZ3kgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERpcmVjdGx5IG5vdGlmaWVzIGxpc3RlbmVycyBvZiBjaGFuZ2VzLlxyXG4gICAqL1xyXG4gIHB1YmxpYyBub3RpZnlMaXN0ZW5lcnMoIG9sZFZhbHVlOiBUICk6IHZvaWQge1xyXG4gICAgLy8gV2UgdXNlIHRoaXMuX3ZhbHVlIGhlcmUgZm9yIHBlcmZvcm1hbmNlLCBBTkQgdG8gYXZvaWQgY2FsbGluZyBvbkFjY2Vzc0F0dGVtcHQgdW5uZWNlc3NhcmlseS5cclxuICAgIHRoaXMuZW1pdCggdGhpcy5fdmFsdWUsIG9sZFZhbHVlLCB0aGlzICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBZGRzIGxpc3RlbmVyIGFuZCBjYWxscyBpdCBpbW1lZGlhdGVseS4gSWYgbGlzdGVuZXIgaXMgYWxyZWFkeSByZWdpc3RlcmVkLCB0aGlzIGlzIGEgbm8tb3AuIFRoZSBpbml0aWFsXHJcbiAgICogbm90aWZpY2F0aW9uIHByb3ZpZGVzIHRoZSBjdXJyZW50IHZhbHVlIGZvciBuZXdWYWx1ZSBhbmQgbnVsbCBmb3Igb2xkVmFsdWUuXHJcbiAgICovXHJcbiAgcHVibGljIGxpbmsoIGxpc3RlbmVyOiBQcm9wZXJ0eUxpbmtMaXN0ZW5lcjxUPiApOiB2b2lkIHtcclxuICAgIHRoaXMuYWRkTGlzdGVuZXIoIGxpc3RlbmVyICk7XHJcblxyXG4gICAgbGlzdGVuZXIoIHRoaXMuX3ZhbHVlLCBudWxsLCB0aGlzICk7IC8vIG51bGwgc2hvdWxkIGJlIHVzZWQgd2hlbiBhbiBvYmplY3QgaXMgZXhwZWN0ZWQgYnV0IHVuYXZhaWxhYmxlXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBZGQgYW4gbGlzdGVuZXIgdG8gdGhlIFRpbnlQcm9wZXJ0eSwgd2l0aG91dCBjYWxsaW5nIGl0IGJhY2sgcmlnaHQgYXdheS4gVGhpcyBpcyB1c2VkIHdoZW4geW91IG5lZWQgdG8gcmVnaXN0ZXIgYVxyXG4gICAqIGxpc3RlbmVyIHdpdGhvdXQgYW4gaW1tZWRpYXRlIGNhbGxiYWNrLlxyXG4gICAqL1xyXG4gIHB1YmxpYyBsYXp5TGluayggbGlzdGVuZXI6IFByb3BlcnR5TGF6eUxpbmtMaXN0ZW5lcjxUPiApOiB2b2lkIHtcclxuICAgIHRoaXMuYWRkTGlzdGVuZXIoIGxpc3RlbmVyIGFzIFByb3BlcnR5TGlua0xpc3RlbmVyPFQ+ICk7IC8vIEJlY2F1c2UgaXQncyBhIGxhenkgbGluaywgaXQgd2lsbCBuZXZlciBiZSBjYWxsZWQgd2l0aCBudWxsXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZW1vdmVzIGEgbGlzdGVuZXIuIElmIGxpc3RlbmVyIGlzIG5vdCByZWdpc3RlcmVkLCB0aGlzIGlzIGEgbm8tb3AuXHJcbiAgICovXHJcbiAgcHVibGljIHVubGluayggbGlzdGVuZXI6IFByb3BlcnR5TGlzdGVuZXI8VD4gKTogdm9pZCB7XHJcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCBsaXN0ZW5lciBhcyBQcm9wZXJ0eUxpbmtMaXN0ZW5lcjxUPiApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlcyBhbGwgbGlzdGVuZXJzLiBJZiBubyBsaXN0ZW5lcnMgYXJlIHJlZ2lzdGVyZWQsIHRoaXMgaXMgYSBuby1vcC5cclxuICAgKi9cclxuICBwdWJsaWMgdW5saW5rQWxsKCk6IHZvaWQge1xyXG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIExpbmtzIGFuIG9iamVjdCdzIG5hbWVkIGF0dHJpYnV0ZSB0byB0aGlzIFRpbnlQcm9wZXJ0eS4gIFJldHVybnMgYSBoYW5kbGUgc28gaXQgY2FuIGJlIHJlbW92ZWQgdXNpbmdcclxuICAgKiBUaW55UHJvcGVydHkudW5saW5rKCk7XHJcbiAgICogRXhhbXBsZTogbW9kZWxWaXNpYmxlUHJvcGVydHkubGlua0F0dHJpYnV0ZSh2aWV3LCAndmlzaWJsZScpO1xyXG4gICAqXHJcbiAgICogTk9URTogRHVwbGljYXRlZCB3aXRoIFByb3BlcnR5LmxpbmtBdHRyaWJ1dGVcclxuICAgKi9cclxuICBwdWJsaWMgbGlua0F0dHJpYnV0ZTxBdHRyIGV4dGVuZHMgc3RyaW5nPiggb2JqZWN0OiB7IFtrZXkgaW4gQXR0cl06IFQgfSwgYXR0cmlidXRlTmFtZTogQXR0ciApOiAoIHZhbHVlOiBUICkgPT4gdm9pZCB7XHJcbiAgICBjb25zdCBoYW5kbGUgPSAoIHZhbHVlOiBUICkgPT4geyBvYmplY3RbIGF0dHJpYnV0ZU5hbWUgXSA9IHZhbHVlOyB9O1xyXG4gICAgdGhpcy5saW5rKCBoYW5kbGUgKTtcclxuICAgIHJldHVybiBoYW5kbGU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHZhbHVlIGNhbiBiZSBzZXQgZXh0ZXJuYWxseSwgdXNpbmcgLnZhbHVlPSBvciBzZXQoKVxyXG4gICAqL1xyXG4gIHB1YmxpYyBpc1NldHRhYmxlKCk6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgZ2V0IHZhbHVlQ29tcGFyaXNvblN0cmF0ZWd5KCk6IFZhbHVlQ29tcGFyaXNvblN0cmF0ZWd5PFQ+IHtcclxuICAgIHJldHVybiB0aGlzLl92YWx1ZUNvbXBhcmlzb25TdHJhdGVneSB8fCAncmVmZXJlbmNlJztcclxuICB9XHJcblxyXG4gIHB1YmxpYyBzZXQgdmFsdWVDb21wYXJpc29uU3RyYXRlZ3koIHZhbHVlQ29tcGFyaXNvblN0cmF0ZWd5OiBWYWx1ZUNvbXBhcmlzb25TdHJhdGVneTxUPiApIHtcclxuICAgIHRoaXMuX3ZhbHVlQ29tcGFyaXNvblN0cmF0ZWd5ID0gdmFsdWVDb21wYXJpc29uU3RyYXRlZ3k7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZWxlYXNlcyByZWZlcmVuY2VzLlxyXG4gICAqL1xyXG4gIHB1YmxpYyBvdmVycmlkZSBkaXNwb3NlKCk6IHZvaWQge1xyXG4gICAgLy8gUmVtb3ZlIGFueSBsaXN0ZW5lcnMgdGhhdCBhcmUgc3RpbGwgYXR0YWNoZWQgKG5vdGUgdGhhdCB0aGUgZW1pdHRlciBkaXNwb3NlIHdvdWxkIGRvIHRoaXMgYWxzbywgYnV0IHdpdGhvdXQgdGhlXHJcbiAgICAvLyBwb3RlbnRpYWxseS1uZWVkZWQgZXh0cmEgbG9naWMgb2YgY2hhbmdlQ291bnQsIGV0Yy4pXHJcbiAgICB0aGlzLnVubGlua0FsbCgpO1xyXG5cclxuICAgIHN1cGVyLmRpc3Bvc2UoKTtcclxuICB9XHJcbn1cclxuXHJcbmF4b24ucmVnaXN0ZXIoICdUaW55UHJvcGVydHknLCBUaW55UHJvcGVydHkgKTsiXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPQSxJQUFJLE1BQU0sV0FBVztBQUM1QixPQUFPQyxX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