// Copyright 2022-2024, University of Colorado Boulder

/**
 * A DerivedProperty that applies a string pattern (like StringUtils.fillIn). It has options for mapping values,
 * either with decimalPlaces or an arbitrary function so that there is just one Property set up for disposal.
 *
 * PatternStringPropertyTests.ts has many examples that may be useful!
 *
 * Basic usage can involve values as Properties or directly as values (both work):
 *
 * | const patternStringProperty = new TinyProperty( '{{valueA}} + {{valueB}}' );
 * | const property = new PatternStringProperty( patternStringProperty, {
 * |   valueA: 5,
 * |   valueB: new TinyProperty( 7 )
 * | } );
 * | property.value; // '5 + 7'
 *
 * Did your string use StringUtils.format? formatNames can be used to be compatible:
 *
 * | const property = new PatternStringProperty( new TinyProperty( '{0} + {1}' ), {
 * |   valueA: 5,
 * |   valueB: new TinyProperty( 7 )
 * | }, {
 * |   formatNames: [ 'valueA', 'valueB' ]
 * | } );
 * | property.value; // '5 + 7'
 *
 * Want to apply unit conversions or other formulas? Use maps
 *
 * | const gramsProperty = new TinyProperty( 2000 );
 * | new PatternStringProperty( new TinyProperty( '{{kilograms}} kg' ), {
 * |   kilograms: gramsProperty
 * | }, {
 * |   maps: {
 * |     kilograms: ( grams: number ) => grams / 1000
 * |   }
 * | } );
 * | property.value; // '2 kg'
 *
 * Using a numeric value, and want to show a certain number of decimal places? Use decimalPlaces!
 *
 * | const gramsProperty = new TinyProperty( 2143 );
 * | new PatternStringProperty( new TinyProperty( '{{kilograms}} kg' ), {
 * |   kilograms: gramsProperty
 * | }, {
 * |   maps: {
 * |     kilograms: ( grams: number ) => grams / 1000
 * |   },
 * |   decimalPlaces: 2
 * | } );
 * | property.value; // '2.14 kg'
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

import { isTReadOnlyProperty } from './TReadOnlyProperty.js';
import Utils from '../../dot/js/Utils.js';
import optionize from '../../phet-core/js/optionize.js';
import axon from './axon.js';
import Tandem from '../../tandem/js/Tandem.js';
import DerivedStringProperty from './DerivedStringProperty.js';

// The type of allowed values for a PatternStringProperty

// The types of values that we won't require maps for

// We'll require maps for things that aren't string | number, or Property types with only those values

// Need special behavior to support conditionally requiring maps

// Shared here, since it will always be the same function
const stringify = value => `${value}`;
export default class PatternStringProperty extends DerivedStringProperty {
  constructor(patternProperty, values, providedOptions) {
    assert && assert(!(values.tandem instanceof Tandem), 'Did you intend to put tandem in providedOptions?');
    const options = optionize()({
      formatNames: [],
      decimalPlaces: null,
      phetioFeatured: true,
      // This is the best default to match all i18n "model" strings, see https://github.com/phetsims/studio/issues/304#issuecomment-1572613118
      tandemNameSuffix: 'StringProperty'
    }, providedOptions);
    const dependencies = [patternProperty];
    const maps = {};
    const keys = Object.keys(values);
    keys.forEach(key => {
      const value = values[key]; // This is the declared type anyway, TypeScript is needing the cast
      if (isTReadOnlyProperty(value)) {
        dependencies.push(value);
      }
      let stringNumberMap = stringify;

      // If we are applying decimal places, "prepend" that map before the others
      if (options.decimalPlaces !== null && (typeof options.decimalPlaces === 'number' || options.decimalPlaces[key] !== null)) {
        // It won't be null (we checked above for hasDecimalPlaces), asserted below
        const decimalPlaces = typeof options.decimalPlaces === 'number' || options.decimalPlaces === null ? options.decimalPlaces : options.decimalPlaces[key];
        assert && assert(decimalPlaces !== null);
        stringNumberMap = value => stringify(typeof value === 'number' ? Utils.toFixed(value, decimalPlaces) : value);
      }

      // If we are applying a map, "prepend" that map before the others, so that if it returns a number, we can
      // apply decimal places to it.
      if (options.maps && options.maps.hasOwnProperty(key)) {
        maps[key] = value => stringNumberMap(options.maps[key](value));
      } else {
        maps[key] = stringNumberMap;
      }
    });

    // @ts-expect-error We can't get our dependencies to dynamically type here fully
    super(dependencies, (...propertyValues) => {
      const getValue = value => {
        const index = dependencies.indexOf(value);

        // If it's a Property, it will be in our dependencies, and we'll look up the value from our DerivedProperty
        return index >= 0 ? propertyValues[index] : value;
      };
      let result = `${getValue(patternProperty)}`; // String cast (it won't be a number, due to TypeScript)

      // Handle StringUtils.format compatibility, turning {0} => formatName[ 0 ], {1} => formatName[ 1 ], etc.
      options.formatNames.forEach((formatName, index) => {
        result = result.replace(new RegExp(`\\{${index}\\}`, 'g'), `{{${formatName}}}`);
      });

      // {string[]} parse out the set of placeholders
      const placeholders = result.match(/\{\{[^{}]+\}\}/g) || [];

      // replace each placeholder with its corresponding value
      for (let i = 0; i < placeholders.length; i++) {
        const placeholder = placeholders[i];

        // key is the portion of the placeholder between the curly braces
        const key = placeholder.replace('{{', '').replace('}}', '');
        if (keys.includes(key)) {
          let value = getValue(values[key]);
          if (maps[key]) {
            value = maps[key](value);
          }
          result = result.replace(placeholder, `${value}`);
        }
      }
      return result;
    }, options);
  }
}
axon.register('PatternStringProperty', PatternStringProperty);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJpc1RSZWFkT25seVByb3BlcnR5IiwiVXRpbHMiLCJvcHRpb25pemUiLCJheG9uIiwiVGFuZGVtIiwiRGVyaXZlZFN0cmluZ1Byb3BlcnR5Iiwic3RyaW5naWZ5IiwidmFsdWUiLCJQYXR0ZXJuU3RyaW5nUHJvcGVydHkiLCJjb25zdHJ1Y3RvciIsInBhdHRlcm5Qcm9wZXJ0eSIsInZhbHVlcyIsInByb3ZpZGVkT3B0aW9ucyIsImFzc2VydCIsInRhbmRlbSIsIm9wdGlvbnMiLCJmb3JtYXROYW1lcyIsImRlY2ltYWxQbGFjZXMiLCJwaGV0aW9GZWF0dXJlZCIsInRhbmRlbU5hbWVTdWZmaXgiLCJkZXBlbmRlbmNpZXMiLCJtYXBzIiwia2V5cyIsIk9iamVjdCIsImZvckVhY2giLCJrZXkiLCJwdXNoIiwic3RyaW5nTnVtYmVyTWFwIiwidG9GaXhlZCIsImhhc093blByb3BlcnR5IiwicHJvcGVydHlWYWx1ZXMiLCJnZXRWYWx1ZSIsImluZGV4IiwiaW5kZXhPZiIsInJlc3VsdCIsImZvcm1hdE5hbWUiLCJyZXBsYWNlIiwiUmVnRXhwIiwicGxhY2Vob2xkZXJzIiwibWF0Y2giLCJpIiwibGVuZ3RoIiwicGxhY2Vob2xkZXIiLCJpbmNsdWRlcyIsInJlZ2lzdGVyIl0sInNvdXJjZXMiOlsiUGF0dGVyblN0cmluZ1Byb3BlcnR5LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDIyLTIwMjQsIFVuaXZlcnNpdHkgb2YgQ29sb3JhZG8gQm91bGRlclxyXG5cclxuLyoqXHJcbiAqIEEgRGVyaXZlZFByb3BlcnR5IHRoYXQgYXBwbGllcyBhIHN0cmluZyBwYXR0ZXJuIChsaWtlIFN0cmluZ1V0aWxzLmZpbGxJbikuIEl0IGhhcyBvcHRpb25zIGZvciBtYXBwaW5nIHZhbHVlcyxcclxuICogZWl0aGVyIHdpdGggZGVjaW1hbFBsYWNlcyBvciBhbiBhcmJpdHJhcnkgZnVuY3Rpb24gc28gdGhhdCB0aGVyZSBpcyBqdXN0IG9uZSBQcm9wZXJ0eSBzZXQgdXAgZm9yIGRpc3Bvc2FsLlxyXG4gKlxyXG4gKiBQYXR0ZXJuU3RyaW5nUHJvcGVydHlUZXN0cy50cyBoYXMgbWFueSBleGFtcGxlcyB0aGF0IG1heSBiZSB1c2VmdWwhXHJcbiAqXHJcbiAqIEJhc2ljIHVzYWdlIGNhbiBpbnZvbHZlIHZhbHVlcyBhcyBQcm9wZXJ0aWVzIG9yIGRpcmVjdGx5IGFzIHZhbHVlcyAoYm90aCB3b3JrKTpcclxuICpcclxuICogfCBjb25zdCBwYXR0ZXJuU3RyaW5nUHJvcGVydHkgPSBuZXcgVGlueVByb3BlcnR5KCAne3t2YWx1ZUF9fSArIHt7dmFsdWVCfX0nICk7XHJcbiAqIHwgY29uc3QgcHJvcGVydHkgPSBuZXcgUGF0dGVyblN0cmluZ1Byb3BlcnR5KCBwYXR0ZXJuU3RyaW5nUHJvcGVydHksIHtcclxuICogfCAgIHZhbHVlQTogNSxcclxuICogfCAgIHZhbHVlQjogbmV3IFRpbnlQcm9wZXJ0eSggNyApXHJcbiAqIHwgfSApO1xyXG4gKiB8IHByb3BlcnR5LnZhbHVlOyAvLyAnNSArIDcnXHJcbiAqXHJcbiAqIERpZCB5b3VyIHN0cmluZyB1c2UgU3RyaW5nVXRpbHMuZm9ybWF0PyBmb3JtYXROYW1lcyBjYW4gYmUgdXNlZCB0byBiZSBjb21wYXRpYmxlOlxyXG4gKlxyXG4gKiB8IGNvbnN0IHByb3BlcnR5ID0gbmV3IFBhdHRlcm5TdHJpbmdQcm9wZXJ0eSggbmV3IFRpbnlQcm9wZXJ0eSggJ3swfSArIHsxfScgKSwge1xyXG4gKiB8ICAgdmFsdWVBOiA1LFxyXG4gKiB8ICAgdmFsdWVCOiBuZXcgVGlueVByb3BlcnR5KCA3IClcclxuICogfCB9LCB7XHJcbiAqIHwgICBmb3JtYXROYW1lczogWyAndmFsdWVBJywgJ3ZhbHVlQicgXVxyXG4gKiB8IH0gKTtcclxuICogfCBwcm9wZXJ0eS52YWx1ZTsgLy8gJzUgKyA3J1xyXG4gKlxyXG4gKiBXYW50IHRvIGFwcGx5IHVuaXQgY29udmVyc2lvbnMgb3Igb3RoZXIgZm9ybXVsYXM/IFVzZSBtYXBzXHJcbiAqXHJcbiAqIHwgY29uc3QgZ3JhbXNQcm9wZXJ0eSA9IG5ldyBUaW55UHJvcGVydHkoIDIwMDAgKTtcclxuICogfCBuZXcgUGF0dGVyblN0cmluZ1Byb3BlcnR5KCBuZXcgVGlueVByb3BlcnR5KCAne3traWxvZ3JhbXN9fSBrZycgKSwge1xyXG4gKiB8ICAga2lsb2dyYW1zOiBncmFtc1Byb3BlcnR5XHJcbiAqIHwgfSwge1xyXG4gKiB8ICAgbWFwczoge1xyXG4gKiB8ICAgICBraWxvZ3JhbXM6ICggZ3JhbXM6IG51bWJlciApID0+IGdyYW1zIC8gMTAwMFxyXG4gKiB8ICAgfVxyXG4gKiB8IH0gKTtcclxuICogfCBwcm9wZXJ0eS52YWx1ZTsgLy8gJzIga2cnXHJcbiAqXHJcbiAqIFVzaW5nIGEgbnVtZXJpYyB2YWx1ZSwgYW5kIHdhbnQgdG8gc2hvdyBhIGNlcnRhaW4gbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzPyBVc2UgZGVjaW1hbFBsYWNlcyFcclxuICpcclxuICogfCBjb25zdCBncmFtc1Byb3BlcnR5ID0gbmV3IFRpbnlQcm9wZXJ0eSggMjE0MyApO1xyXG4gKiB8IG5ldyBQYXR0ZXJuU3RyaW5nUHJvcGVydHkoIG5ldyBUaW55UHJvcGVydHkoICd7e2tpbG9ncmFtc319IGtnJyApLCB7XHJcbiAqIHwgICBraWxvZ3JhbXM6IGdyYW1zUHJvcGVydHlcclxuICogfCB9LCB7XHJcbiAqIHwgICBtYXBzOiB7XHJcbiAqIHwgICAgIGtpbG9ncmFtczogKCBncmFtczogbnVtYmVyICkgPT4gZ3JhbXMgLyAxMDAwXHJcbiAqIHwgICB9LFxyXG4gKiB8ICAgZGVjaW1hbFBsYWNlczogMlxyXG4gKiB8IH0gKTtcclxuICogfCBwcm9wZXJ0eS52YWx1ZTsgLy8gJzIuMTQga2cnXHJcbiAqXHJcbiAqIEBhdXRob3IgSm9uYXRoYW4gT2xzb24gPGpvbmF0aGFuLm9sc29uQGNvbG9yYWRvLmVkdT5cclxuICovXHJcblxyXG5pbXBvcnQgVFJlYWRPbmx5UHJvcGVydHksIHsgaXNUUmVhZE9ubHlQcm9wZXJ0eSB9IGZyb20gJy4vVFJlYWRPbmx5UHJvcGVydHkuanMnO1xyXG5pbXBvcnQgVXRpbHMgZnJvbSAnLi4vLi4vZG90L2pzL1V0aWxzLmpzJztcclxuaW1wb3J0IG9wdGlvbml6ZSBmcm9tICcuLi8uLi9waGV0LWNvcmUvanMvb3B0aW9uaXplLmpzJztcclxuaW1wb3J0IEludGVudGlvbmFsQW55IGZyb20gJy4uLy4uL3BoZXQtY29yZS9qcy90eXBlcy9JbnRlbnRpb25hbEFueS5qcyc7XHJcbmltcG9ydCBDb2xsYXBzZVByb3BlcnR5VmFsdWUgZnJvbSAnLi4vLi4vcGhldC1jb3JlL2pzL3R5cGVzL0NvbGxhcHNlUHJvcGVydHlWYWx1ZS5qcyc7XHJcbmltcG9ydCBLZXlzTWF0Y2hpbmcgZnJvbSAnLi4vLi4vcGhldC1jb3JlL2pzL3R5cGVzL0tleXNNYXRjaGluZy5qcyc7XHJcbmltcG9ydCBLZXlzTm90TWF0Y2hpbmcgZnJvbSAnLi4vLi4vcGhldC1jb3JlL2pzL3R5cGVzL0tleXNOb3RNYXRjaGluZy5qcyc7XHJcbmltcG9ydCBheG9uIGZyb20gJy4vYXhvbi5qcyc7XHJcbmltcG9ydCBUYW5kZW0gZnJvbSAnLi4vLi4vdGFuZGVtL2pzL1RhbmRlbS5qcyc7XHJcbmltcG9ydCBEZXJpdmVkU3RyaW5nUHJvcGVydHksIHsgRGVyaXZlZFN0cmluZ1Byb3BlcnR5T3B0aW9ucyB9IGZyb20gJy4vRGVyaXZlZFN0cmluZ1Byb3BlcnR5LmpzJztcclxuXHJcbi8vIFRoZSB0eXBlIG9mIGFsbG93ZWQgdmFsdWVzIGZvciBhIFBhdHRlcm5TdHJpbmdQcm9wZXJ0eVxyXG50eXBlIFZhbHVlc1R5cGUgPSBSZWNvcmQ8c3RyaW5nLCBJbnRlbnRpb25hbEFueT47XHJcblxyXG4vLyBUaGUgdHlwZXMgb2YgdmFsdWVzIHRoYXQgd2Ugd29uJ3QgcmVxdWlyZSBtYXBzIGZvclxyXG50eXBlIFN0cmluZ051bWJlck9yUHJvcGVydHkgPSBzdHJpbmcgfCBudW1iZXIgfCBUUmVhZE9ubHlQcm9wZXJ0eTxzdHJpbmc+IHwgVFJlYWRPbmx5UHJvcGVydHk8bnVtYmVyPiB8IFRSZWFkT25seVByb3BlcnR5PHN0cmluZyB8IG51bWJlcj47XHJcblxyXG4vLyBXZSdsbCByZXF1aXJlIG1hcHMgZm9yIHRoaW5ncyB0aGF0IGFyZW4ndCBzdHJpbmcgfCBudW1iZXIsIG9yIFByb3BlcnR5IHR5cGVzIHdpdGggb25seSB0aG9zZSB2YWx1ZXNcclxudHlwZSBNYXBzVHlwZTxWYWx1ZXMgZXh0ZW5kcyBWYWx1ZXNUeXBlPiA9IHtcclxuICBbS2V5IGluIEtleXNNYXRjaGluZzxWYWx1ZXMsIFN0cmluZ051bWJlck9yUHJvcGVydHk+XT86ICggdmFsdWU6IENvbGxhcHNlUHJvcGVydHlWYWx1ZTxWYWx1ZXNbS2V5XT4gKSA9PiBzdHJpbmcgfCBudW1iZXI7XHJcbn0gJiB7XHJcbiAgW0tleSBpbiBLZXlzTm90TWF0Y2hpbmc8VmFsdWVzLCBTdHJpbmdOdW1iZXJPclByb3BlcnR5Pl06ICggdmFsdWU6IENvbGxhcHNlUHJvcGVydHlWYWx1ZTxWYWx1ZXNbS2V5XT4gKSA9PiBzdHJpbmcgfCBudW1iZXI7XHJcbn07XHJcblxyXG50eXBlIE9wdGlvbmFsU2VsZk9wdGlvbnM8VmFsdWVzIGV4dGVuZHMgVmFsdWVzVHlwZT4gPSB7XHJcblxyXG4gIC8qKlxyXG4gICAqIFJvdW5kcyBudW1lcmljIHZhbHVlcyB0byBhIGdpdmVuIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBpZiBwcm92aWRlZC4gSWYgYSBudW1iZXIgaXMgZ2l2ZW4sIGl0IHdpbGwgYXBwbHkgdG9cclxuICAgKiBBTEwgbnVtZXJpYyB2YWx1ZXMgKG9mIHR5cGUgJ251bWJlcicpLiBBIHJlY29yZCBjYW4gYWxzbyBiZSBwcm92aWRlZCB0aGF0IHByb3ZpZGVzIGRlY2ltYWxQbGFjZXMgZm9yIHNwZWNpZmljXHJcbiAgICogdmFsdWVzLlxyXG4gICAqXHJcbiAgICogRm9yIGV4YW1wbGU6XHJcbiAgICogfCBjb25zdCBzdHJpbmdQcm9wZXJ0eSA9IG5ldyBUaW55UHJvcGVydHkoICdUZXN0OiB7e3ZhbHVlfX0nICk7XHJcbiAgICogfCBjb25zdCB2YWx1ZVByb3BlcnR5ID0gbmV3IFRpbnlQcm9wZXJ0eSggNS4xMjM0NSApO1xyXG4gICAqIHwgbmV3IFBhdHRlcm5TdHJpbmdQcm9wZXJ0eSggc3RyaW5nUHJvcGVydHksIHsgdmFsdWU6IHZhbHVlUHJvcGVydHkgfSwgeyBkZWNpbWFsUGxhY2VzOiAyIH0gKVxyXG4gICAqIHdpbGwgdGFrZSB0aGUgdmFsdWUgJ1Rlc3Q6IDUuMTInLlxyXG4gICAqXHJcbiAgICogTXVsdGlwbGUgZGVjaW1hbCBwbGFjZXMgZXhhbXBsZTpcclxuICAgKiB8IGNvbnN0IHN0cmluZ1Byb3BlcnR5ID0gbmV3IFRpbnlQcm9wZXJ0eSggJ1RoZXJlIGFyZSB7e3NxdWlycmVsc319IG1pbGxpb24gc3F1aXJyZWxzIHdobyBlYXQgbW9yZSB0aGFuIHt7YWNvcm5zfX0gYWNvcm5zIGEgZGF5JyApO1xyXG4gICAqIHwgY29uc3Qgc3F1aXJyZWxzUHJvcGVydHkgPSBuZXcgVGlueVByb3BlcnR5KCA1LjEyMzQ1ICk7XHJcbiAgICogfCBjb25zdCBhY29ybnNQcm9wZXJ0eSA9IG5ldyBUaW55UHJvcGVydHkoIDIwLjI1NCApO1xyXG4gICAqIHwgbmV3IFBhdHRlcm5TdHJpbmdQcm9wZXJ0eSggc3RyaW5nUHJvcGVydHksIHtcclxuICAgKiB8ICAgc3F1aXJyZWxzOiBzcXVpcnJlbHNQcm9wZXJ0eSxcclxuICAgKiB8ICAgYWNvcm5zOiBhY29ybnNQcm9wZXJ0eVxyXG4gICAqIHwgfSwge1xyXG4gICAqIHwgICBkZWNpbWFsUGxhY2VzOiB7XHJcbiAgICogfCAgICAgc3F1aXJyZWxzOiAwLFxyXG4gICAqIHwgICAgIGFjb3JuczogMlxyXG4gICAqIHwgICB9XHJcbiAgICogfCB9IClcclxuICAgKlxyXG4gICAqIE5PVEU6IFByb3ZpZGUgbnVsbCBpZiBkZWNpbWFsIHBsYWNlcyBzaG91bGQgbm90IGJlIHVzZWQgZm9yIGEgZ2l2ZW4gdmFsdWVcclxuICAgKi9cclxuICBkZWNpbWFsUGxhY2VzPzogbnVtYmVyIHwgbnVsbCB8IFJlY29yZDxrZXlvZiBWYWx1ZXMsIG51bWJlciB8IG51bGw+O1xyXG5cclxuICAvKipcclxuICAgKiBAZGVwcmVjYXRlZCAtIG9ubHkgdXNlZCBmb3IgY29udmVydGluZyB2ZXN0aWdpYWwgdXNhZ2VzIG9mIFN0cmluZ1V0aWxzLmZvcm1hdFxyXG4gICAqXHJcbiAgICogRm9yIGhhbmRsaW5nIHBhdHRlcm4gc3RyaW5ncyBmcm9tIFN0cmluZ1V0aWxzLmZvcm1hdCwgd2hpY2ggd2lsbCB0dXJuIHswfSA9PiB7e2Zvcm1hdE5hbWVbIDAgXX19LFxyXG4gICAqIHsxfSA9PiB7e2Zvcm1hdE5hbWVbIDEgXX19LCBldGMuXHJcbiAgICpcclxuICAgKiBGb3IgZXhhbXBsZTpcclxuICAgKiB8IGNvbnN0IHN0cmluZ1Byb3BlcnR5ID0gbmV3IFRpbnlQcm9wZXJ0eSggJ1Rlc3Q6IHswfScgKTtcclxuICAgKiB8IGNvbnN0IHZhbHVlUHJvcGVydHkgPSBuZXcgVGlueVByb3BlcnR5KCA1ICk7XHJcbiAgICogfCBuZXcgUGF0dGVyblN0cmluZ1Byb3BlcnR5KCBzdHJpbmdQcm9wZXJ0eSwgeyB2YWx1ZTogdmFsdWVQcm9wZXJ0eSB9LCB7IGZvcm1hdE5hbWVzOiBbICd2YWx1ZScgXSB9ICk7XHJcbiAgICogV2lsbCBlZmZlY3RpdmVseSByZXBsYWNlIHswfSBpbiB0aGUgcGF0dGVybiB0byB7e3ZhbHVlfX0sIHdoaWNoIHdpbGwgdGhlbiBiZSB1c2VkIGFzIG5vcm1hbFxyXG4gICAqL1xyXG4gIGZvcm1hdE5hbWVzPzogc3RyaW5nW107XHJcbn07XHJcblxyXG50eXBlIFNlbGZPcHRpb25zPFZhbHVlcyBleHRlbmRzIFZhbHVlc1R5cGU+ID0gT3B0aW9uYWxTZWxmT3B0aW9uczxWYWx1ZXM+ICZcclxuICAoIEtleXNOb3RNYXRjaGluZzxWYWx1ZXMsIFN0cmluZ051bWJlck9yUHJvcGVydHk+IGV4dGVuZHMgbmV2ZXIgPyB7XHJcbiAgICAvLyBNYXBzIHRoZSBpbnB1dCBzdHJpbmcvbnVtZXJpYyB2YWx1ZXMgKGRlcGVuZGluZyBvbiB0aGUgUHJvcGVydHkgdHlwZSkgdG8gYSBzdHJpbmcgb3IgbnVtYmVyLiBEZWNpbWFsIHBsYWNlcyB3aWxsIGJlXHJcbiAgICAvLyBhcHBsaWVkIGFmdGVyIHRoaXMgc3RlcCAoaWYgaXQgcmV0dXJucyBhIG51bWJlcikuXHJcbiAgICAvL1xyXG4gICAgLy8gRm9yIGV4YW1wbGU6XHJcbiAgICAvLyB8IGNvbnN0IHN0cmluZ1Byb3BlcnR5ID0gbmV3IFRpbnlQcm9wZXJ0eSggJ3t7Z3JhbXN9fSBncmFtcycgKTtcclxuICAgIC8vIHwgY29uc3Qga2lsb2dyYW1zUHJvcGVydHkgPSBuZXcgVGlueVByb3BlcnR5KCA1LjEyICk7XHJcbiAgICAvLyB8IG5ldyBQYXR0ZXJuU3RyaW5nUHJvcGVydHkoIHN0cmluZ1Byb3BlcnR5LCB7IHByZXBvc2l0aW9uOiBraWxvZ3JhbXNQcm9wZXJ0eSB9LCB7XHJcbiAgICAvLyB8ICAgbWFwczogeyBwcmVwb3NpdGlvbjoga2lsb2dyYW1zID0+IGtpbG9ncmFtcyAvIDEwMDAgfVxyXG4gICAgLy8gfCB9ICk7XHJcbiAgICBtYXBzPzogTWFwc1R5cGU8VmFsdWVzPjtcclxuICB9IDoge1xyXG4gICAgICAvLyBNYWtlIHRoaXMgcmVxdWlyZWQgaWYgc29tZW9uZSdzIHBhc3NpbmcgaW4gc29tZXRoaW5nIHRoYXQgaXMgb2YgYSBub24tc3RyaW5nL251bWJlciB0eXBlXHJcbiAgICAgIG1hcHM6IE1hcHNUeXBlPFZhbHVlcz47XHJcbiAgICB9ICk7XHJcblxyXG50eXBlIFN1cGVyT3B0aW9ucyA9IERlcml2ZWRTdHJpbmdQcm9wZXJ0eU9wdGlvbnM8c3RyaW5nPjtcclxuZXhwb3J0IHR5cGUgUGF0dGVyblN0cmluZ1Byb3BlcnR5T3B0aW9uczxWYWx1ZXMgZXh0ZW5kcyBWYWx1ZXNUeXBlPiA9IFNlbGZPcHRpb25zPFZhbHVlcz4gJiBTdXBlck9wdGlvbnM7XHJcblxyXG4vLyBOZWVkIHNwZWNpYWwgYmVoYXZpb3IgdG8gc3VwcG9ydCBjb25kaXRpb25hbGx5IHJlcXVpcmluZyBtYXBzXHJcbnR5cGUgRmlyc3RQYXJhbWV0ZXJUeXBlVG9PcHRpb25pemU8VmFsdWVzIGV4dGVuZHMgVmFsdWVzVHlwZT4gPSBPcHRpb25hbFNlbGZPcHRpb25zPFZhbHVlcz4gJiB7IG1hcHM/OiBNYXBzVHlwZTxWYWx1ZXM+IH0gJiBTdXBlck9wdGlvbnM7XHJcblxyXG4vLyBTaGFyZWQgaGVyZSwgc2luY2UgaXQgd2lsbCBhbHdheXMgYmUgdGhlIHNhbWUgZnVuY3Rpb25cclxuY29uc3Qgc3RyaW5naWZ5ID0gKCB2YWx1ZTogc3RyaW5nIHwgbnVtYmVyICk6IHN0cmluZyA9PiBgJHt2YWx1ZX1gO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGF0dGVyblN0cmluZ1Byb3BlcnR5PFZhbHVlcyBleHRlbmRzIFZhbHVlc1R5cGU+IGV4dGVuZHMgRGVyaXZlZFN0cmluZ1Byb3BlcnR5PHN0cmluZyxcclxuICB1bmtub3duLFxyXG4gIHVua25vd24sXHJcbiAgdW5rbm93bixcclxuICB1bmtub3duLFxyXG4gIHVua25vd24sXHJcbiAgdW5rbm93bixcclxuICB1bmtub3duLFxyXG4gIHVua25vd24sXHJcbiAgdW5rbm93bixcclxuICB1bmtub3duLFxyXG4gIHVua25vd24sXHJcbiAgdW5rbm93bixcclxuICB1bmtub3duLFxyXG4gIHVua25vd24sXHJcbiAgdW5rbm93bj4ge1xyXG4gIHB1YmxpYyBjb25zdHJ1Y3RvciggcGF0dGVyblByb3BlcnR5OiBUUmVhZE9ubHlQcm9wZXJ0eTxzdHJpbmc+LCB2YWx1ZXM6IFZhbHVlcywgcHJvdmlkZWRPcHRpb25zPzogUGF0dGVyblN0cmluZ1Byb3BlcnR5T3B0aW9uczxWYWx1ZXM+ICkge1xyXG5cclxuICAgIGFzc2VydCAmJiBhc3NlcnQoICEoIHZhbHVlcy50YW5kZW0gaW5zdGFuY2VvZiBUYW5kZW0gKSwgJ0RpZCB5b3UgaW50ZW5kIHRvIHB1dCB0YW5kZW0gaW4gcHJvdmlkZWRPcHRpb25zPycgKTtcclxuXHJcbiAgICBjb25zdCBvcHRpb25zID0gb3B0aW9uaXplPEZpcnN0UGFyYW1ldGVyVHlwZVRvT3B0aW9uaXplPFZhbHVlcz4sIE9wdGlvbmFsU2VsZk9wdGlvbnM8VmFsdWVzPiwgU3VwZXJPcHRpb25zPigpKCB7XHJcbiAgICAgIGZvcm1hdE5hbWVzOiBbXSxcclxuXHJcbiAgICAgIGRlY2ltYWxQbGFjZXM6IG51bGwsXHJcblxyXG4gICAgICBwaGV0aW9GZWF0dXJlZDogdHJ1ZSwgLy8gVGhpcyBpcyB0aGUgYmVzdCBkZWZhdWx0IHRvIG1hdGNoIGFsbCBpMThuIFwibW9kZWxcIiBzdHJpbmdzLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL3N0dWRpby9pc3N1ZXMvMzA0I2lzc3VlY29tbWVudC0xNTcyNjEzMTE4XHJcbiAgICAgIHRhbmRlbU5hbWVTdWZmaXg6ICdTdHJpbmdQcm9wZXJ0eSdcclxuICAgIH0sIHByb3ZpZGVkT3B0aW9ucyApO1xyXG5cclxuICAgIGNvbnN0IGRlcGVuZGVuY2llczogVFJlYWRPbmx5UHJvcGVydHk8SW50ZW50aW9uYWxBbnk+W10gPSBbIHBhdHRlcm5Qcm9wZXJ0eSBdO1xyXG4gICAgY29uc3QgbWFwczogUmVjb3JkPGtleW9mIFZhbHVlcywgKCB2YWx1ZTogSW50ZW50aW9uYWxBbnkgKSA9PiBzdHJpbmc+ID0ge30gYXMgSW50ZW50aW9uYWxBbnk7XHJcblxyXG4gICAgY29uc3Qga2V5czogKCBrZXlvZiBWYWx1ZXMgKVtdID0gT2JqZWN0LmtleXMoIHZhbHVlcyApO1xyXG4gICAga2V5cy5mb3JFYWNoKCBrZXkgPT4ge1xyXG4gICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1sga2V5IF0gYXMgSW50ZW50aW9uYWxBbnk7IC8vIFRoaXMgaXMgdGhlIGRlY2xhcmVkIHR5cGUgYW55d2F5LCBUeXBlU2NyaXB0IGlzIG5lZWRpbmcgdGhlIGNhc3RcclxuICAgICAgaWYgKCBpc1RSZWFkT25seVByb3BlcnR5KCB2YWx1ZSApICkge1xyXG4gICAgICAgIGRlcGVuZGVuY2llcy5wdXNoKCB2YWx1ZSApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBsZXQgc3RyaW5nTnVtYmVyTWFwOiAoIHZhbHVlOiBzdHJpbmcgfCBudW1iZXIgKSA9PiBzdHJpbmcgPSBzdHJpbmdpZnk7XHJcblxyXG4gICAgICAvLyBJZiB3ZSBhcmUgYXBwbHlpbmcgZGVjaW1hbCBwbGFjZXMsIFwicHJlcGVuZFwiIHRoYXQgbWFwIGJlZm9yZSB0aGUgb3RoZXJzXHJcbiAgICAgIGlmICggb3B0aW9ucy5kZWNpbWFsUGxhY2VzICE9PSBudWxsICYmICggdHlwZW9mIG9wdGlvbnMuZGVjaW1hbFBsYWNlcyA9PT0gJ251bWJlcicgfHwgb3B0aW9ucy5kZWNpbWFsUGxhY2VzWyBrZXkgXSAhPT0gbnVsbCApICkge1xyXG4gICAgICAgIC8vIEl0IHdvbid0IGJlIG51bGwgKHdlIGNoZWNrZWQgYWJvdmUgZm9yIGhhc0RlY2ltYWxQbGFjZXMpLCBhc3NlcnRlZCBiZWxvd1xyXG4gICAgICAgIGNvbnN0IGRlY2ltYWxQbGFjZXM6IG51bWJlciA9ICggdHlwZW9mIG9wdGlvbnMuZGVjaW1hbFBsYWNlcyA9PT0gJ251bWJlcicgfHwgb3B0aW9ucy5kZWNpbWFsUGxhY2VzID09PSBudWxsIClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IG9wdGlvbnMuZGVjaW1hbFBsYWNlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogb3B0aW9ucy5kZWNpbWFsUGxhY2VzWyBrZXkgXSE7XHJcbiAgICAgICAgYXNzZXJ0ICYmIGFzc2VydCggZGVjaW1hbFBsYWNlcyAhPT0gbnVsbCApO1xyXG5cclxuICAgICAgICBzdHJpbmdOdW1iZXJNYXAgPSAoIHZhbHVlOiBzdHJpbmcgfCBudW1iZXIgKSA9PiBzdHJpbmdpZnkoIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgPyBVdGlscy50b0ZpeGVkKCB2YWx1ZSwgZGVjaW1hbFBsYWNlcyApIDogdmFsdWUgKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gSWYgd2UgYXJlIGFwcGx5aW5nIGEgbWFwLCBcInByZXBlbmRcIiB0aGF0IG1hcCBiZWZvcmUgdGhlIG90aGVycywgc28gdGhhdCBpZiBpdCByZXR1cm5zIGEgbnVtYmVyLCB3ZSBjYW5cclxuICAgICAgLy8gYXBwbHkgZGVjaW1hbCBwbGFjZXMgdG8gaXQuXHJcbiAgICAgIGlmICggb3B0aW9ucy5tYXBzICYmIG9wdGlvbnMubWFwcy5oYXNPd25Qcm9wZXJ0eSgga2V5ICkgKSB7XHJcbiAgICAgICAgbWFwc1sga2V5IF0gPSB2YWx1ZSA9PiBzdHJpbmdOdW1iZXJNYXAoIG9wdGlvbnMubWFwcyFbIGtleSBdKCB2YWx1ZSApICk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgbWFwc1sga2V5IF0gPSBzdHJpbmdOdW1iZXJNYXA7XHJcbiAgICAgIH1cclxuICAgIH0gKTtcclxuXHJcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFdlIGNhbid0IGdldCBvdXIgZGVwZW5kZW5jaWVzIHRvIGR5bmFtaWNhbGx5IHR5cGUgaGVyZSBmdWxseVxyXG4gICAgc3VwZXIoIGRlcGVuZGVuY2llcywgKCAuLi5wcm9wZXJ0eVZhbHVlczogdW5rbm93bltdICkgPT4ge1xyXG5cclxuICAgICAgY29uc3QgZ2V0VmFsdWUgPSAoIHZhbHVlOiB1bmtub3duICk6IHVua25vd24gPT4ge1xyXG4gICAgICAgIGNvbnN0IGluZGV4ID0gZGVwZW5kZW5jaWVzLmluZGV4T2YoIHZhbHVlIGFzIEludGVudGlvbmFsQW55ICk7XHJcblxyXG4gICAgICAgIC8vIElmIGl0J3MgYSBQcm9wZXJ0eSwgaXQgd2lsbCBiZSBpbiBvdXIgZGVwZW5kZW5jaWVzLCBhbmQgd2UnbGwgbG9vayB1cCB0aGUgdmFsdWUgZnJvbSBvdXIgRGVyaXZlZFByb3BlcnR5XHJcbiAgICAgICAgcmV0dXJuIGluZGV4ID49IDAgPyBwcm9wZXJ0eVZhbHVlc1sgaW5kZXggXSA6IHZhbHVlO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgbGV0IHJlc3VsdCA9IGAke2dldFZhbHVlKCBwYXR0ZXJuUHJvcGVydHkgKX1gOyAvLyBTdHJpbmcgY2FzdCAoaXQgd29uJ3QgYmUgYSBudW1iZXIsIGR1ZSB0byBUeXBlU2NyaXB0KVxyXG5cclxuICAgICAgLy8gSGFuZGxlIFN0cmluZ1V0aWxzLmZvcm1hdCBjb21wYXRpYmlsaXR5LCB0dXJuaW5nIHswfSA9PiBmb3JtYXROYW1lWyAwIF0sIHsxfSA9PiBmb3JtYXROYW1lWyAxIF0sIGV0Yy5cclxuICAgICAgb3B0aW9ucy5mb3JtYXROYW1lcy5mb3JFYWNoKCAoIGZvcm1hdE5hbWU6IHN0cmluZywgaW5kZXg6IG51bWJlciApID0+IHtcclxuICAgICAgICByZXN1bHQgPSByZXN1bHQucmVwbGFjZSggbmV3IFJlZ0V4cCggYFxcXFx7JHtpbmRleH1cXFxcfWAsICdnJyApLCBge3ske2Zvcm1hdE5hbWV9fX1gICk7XHJcbiAgICAgIH0gKTtcclxuXHJcbiAgICAgIC8vIHtzdHJpbmdbXX0gcGFyc2Ugb3V0IHRoZSBzZXQgb2YgcGxhY2Vob2xkZXJzXHJcbiAgICAgIGNvbnN0IHBsYWNlaG9sZGVycyA9IHJlc3VsdC5tYXRjaCggL1xce1xce1tee31dK1xcfVxcfS9nICkgfHwgW107XHJcblxyXG4gICAgICAvLyByZXBsYWNlIGVhY2ggcGxhY2Vob2xkZXIgd2l0aCBpdHMgY29ycmVzcG9uZGluZyB2YWx1ZVxyXG4gICAgICBmb3IgKCBsZXQgaSA9IDA7IGkgPCBwbGFjZWhvbGRlcnMubGVuZ3RoOyBpKysgKSB7XHJcbiAgICAgICAgY29uc3QgcGxhY2Vob2xkZXIgPSBwbGFjZWhvbGRlcnNbIGkgXTtcclxuXHJcbiAgICAgICAgLy8ga2V5IGlzIHRoZSBwb3J0aW9uIG9mIHRoZSBwbGFjZWhvbGRlciBiZXR3ZWVuIHRoZSBjdXJseSBicmFjZXNcclxuICAgICAgICBjb25zdCBrZXkgPSBwbGFjZWhvbGRlci5yZXBsYWNlKCAne3snLCAnJyApLnJlcGxhY2UoICd9fScsICcnICk7XHJcbiAgICAgICAgaWYgKCBrZXlzLmluY2x1ZGVzKCBrZXkgKSApIHtcclxuICAgICAgICAgIGxldCB2YWx1ZSA9IGdldFZhbHVlKCB2YWx1ZXNbIGtleSBdICk7XHJcbiAgICAgICAgICBpZiAoIG1hcHNbIGtleSBdICkge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IG1hcHNbIGtleSBdKCB2YWx1ZSApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UoIHBsYWNlaG9sZGVyLCBgJHt2YWx1ZX1gICk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfSwgb3B0aW9ucyApO1xyXG4gIH1cclxufVxyXG5cclxuYXhvbi5yZWdpc3RlciggJ1BhdHRlcm5TdHJpbmdQcm9wZXJ0eScsIFBhdHRlcm5TdHJpbmdQcm9wZXJ0eSApOyJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBNEJBLG1CQUFtQixRQUFRLHdCQUF3QjtBQUMvRSxPQUFPQyxLQUFLLE1BQU0sdUJBQXVCO0FBQ3pDLE9BQU9DLFNBQVMsTUFBTSxpQ0FBaUM7QUFLdkQsT0FBT0MsSUFBSSxNQUFNLFdBQVc7QUFDNUIsT0FBT0MsTUFBTSxNQUFNLDJCQUEyQjtBQUM5QyxPQUFPQyxxQkFBcUIsTUFB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