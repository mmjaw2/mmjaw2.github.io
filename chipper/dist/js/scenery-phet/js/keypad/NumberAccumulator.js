// Copyright 2017-2024, University of Colorado Boulder

/**
 * A key accumulator that collects user input for integer and floating point values, intended for use in conjunction
 * with the common-code keypad.
 *
 * @author Aadish Gupta
 * @author John Blanco
 * @author Chris Malley (PixelZoom, Inc.)
 */

import DerivedProperty from '../../../axon/js/DerivedProperty.js';
import optionize from '../../../phet-core/js/optionize.js';
import Tandem from '../../../tandem/js/Tandem.js';
import NullableIO from '../../../tandem/js/types/NullableIO.js';
import NumberIO from '../../../tandem/js/types/NumberIO.js';
import sceneryPhet from '../sceneryPhet.js';
import AbstractKeyAccumulator from './AbstractKeyAccumulator.js';
import KeyID from './KeyID.js';
import DerivedStringProperty from '../../../axon/js/DerivedStringProperty.js';
// constants
const NEGATIVE_CHAR = '\u2212';
const DECIMAL_CHAR = '.';

// Define the maximum integer that can be handled.  The portion with the explicit numeric value is necessary for IE11
// support, see https://github.com/phetsims/scenery-phet/issues/332.
const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
const MAX_DIGITS = MAX_SAFE_INTEGER.toString().length - 1;
class NumberAccumulator extends AbstractKeyAccumulator {
  // string representation of the keys entered by the user

  // numerical value of the keys entered by the user

  constructor(providedOptions) {
    const options = optionize()({
      maxDigitsRightOfMantissa: 0,
      maxDigits: MAX_DIGITS,
      tandem: Tandem.REQUIRED,
      tandemNameSuffix: 'NumberAccumulator'
    }, providedOptions);

    // verify option values
    assert && assert(options.maxDigits > 0 && options.maxDigits <= MAX_DIGITS, `maxDigits is out of range: ${options.maxDigits}`);
    assert && assert(options.maxDigitsRightOfMantissa >= 0 && options.maxDigitsRightOfMantissa <= options.maxDigits, `maxDigitsRightOfMantissa is out of range: ${options.maxDigitsRightOfMantissa}`);

    // Validators to be passed to AbstractKeyAccumulator
    const validators = [proposedKeys => {
      return this.getNumberOfDigits(proposedKeys) <= options.maxDigits && !(this.getNumberOfDigits(proposedKeys) === options.maxDigits && proposedKeys[proposedKeys.length - 1] === KeyID.DECIMAL) && this.getNumberOfDigitsRightOfMantissa(proposedKeys) <= options.maxDigitsRightOfMantissa;
    }];
    super(validators);
    this.stringProperty = new DerivedStringProperty([this.accumulatedKeysProperty], accumulatedKeys => {
      return this.keysToString(accumulatedKeys);
    }, {
      tandem: options.tandem.createTandem('stringProperty') // eslint-disable-line bad-sim-text
    });
    this.valueProperty = new DerivedProperty(
    // Use the accumulated keys rather than the string as a dependency since it avoids issues with dependencies,
    // see https://github.com/phetsims/scenery-phet/issues/833.
    [this.accumulatedKeysProperty], accumulatedKeys => {
      const stringValue = this.keysToString(accumulatedKeys);
      return this.stringToInteger(stringValue);
    }, {
      tandem: options.tandem.createTandem('valueProperty'),
      phetioValueType: NullableIO(NumberIO)
    });
  }

  /**
   * Invoked when a key is pressed and creates proposed set of keys to be passed to the validator
   * @param keyIdentifier - identifier for the key pressed
   */
  handleKeyPressed(keyIdentifier) {
    const newArray = this.handleClearOnNextKeyPress(keyIdentifier);
    if (this.isDigit(keyIdentifier)) {
      this.removeLeadingZero(newArray);
      newArray.push(keyIdentifier);
    } else if (keyIdentifier === KeyID.BACKSPACE) {
      newArray.pop();
    } else if (keyIdentifier === KeyID.PLUS_MINUS) {
      // check if first element of array is instance of this class
      if (newArray.length > 0 && newArray[0] === KeyID.PLUS_MINUS) {
        newArray.shift();
      } else {
        newArray.unshift(keyIdentifier);
      }
    } else if (keyIdentifier === KeyID.DECIMAL) {
      if (!this.containsFloatingPoint(newArray)) {
        newArray.push(keyIdentifier);
      }
    } else {
      assert && assert(false, `unsupported keyIdentifier: ${keyIdentifier}`);
    }

    // Validate and update the keys
    this.validateKeys(newArray) && this.updateKeys(newArray);
  }

  /**
   * Removes leading zeros from the array.
   */
  removeLeadingZero(array) {
    if (this.valueProperty.get() === 0 && !this.containsFloatingPoint(array)) {
      array.pop();
    }
  }

  /**
   * Converts a set of keys to a string.
   */
  keysToString(keys) {
    let returnValue = '';
    let i = 0;

    // the plus/minus key (if present) will be first key, and indicates that the number is negative
    if (keys.length > 0 && keys[i] === KeyID.PLUS_MINUS) {
      returnValue = NEGATIVE_CHAR;
      i++;
    }

    // process remaining keys
    for (; i < keys.length; i++) {
      if (keys[i] === KeyID.DECIMAL) {
        returnValue = returnValue + DECIMAL_CHAR;
      } else {
        // the plus/minus key should be first if present
        assert && assert(this.isDigit(keys[i]), 'unexpected key type');
        returnValue = returnValue + keys[i];
      }
    }
    return returnValue;
  }

  /**
   * Converts a string representation to a number.
   */
  stringToInteger(stringValue) {
    let returnValue = null;

    // if stringValue contains something other than just a minus sign...
    if (stringValue.length > 0 && !(stringValue.length === 1 && stringValue.startsWith(NEGATIVE_CHAR)) && (this.getNumberOfDigitsLeftOfMantissa(this.accumulatedKeysProperty.get()) > 0 || this.getNumberOfDigitsRightOfMantissa(this.accumulatedKeysProperty.get()) > 0)) {
      // replace Unicode minus with vanilla '-', or parseInt will fail for negative numbers
      returnValue = Number(stringValue.replace(NEGATIVE_CHAR, '-').replace(DECIMAL_CHAR, '.'));
      assert && assert(!isNaN(returnValue), `invalid number: ${returnValue}`);
    }
    return returnValue;
  }

  /**
   * Gets the number of digits to the left of mantissa in the accumulator.
   */
  getNumberOfDigitsLeftOfMantissa(keys) {
    let numberOfDigits = 0;
    for (let i = 0; i < keys.length; i++) {
      if (this.isDigit(keys[i])) {
        numberOfDigits++;
      }
      if (keys[i] === KeyID.DECIMAL) {
        break;
      }
    }
    return numberOfDigits;
  }

  /**
   * Gets the number of digits to the right of mantissa in the accumulator.
   */
  getNumberOfDigitsRightOfMantissa(keys) {
    const decimalKeyIndex = keys.indexOf(KeyID.DECIMAL);
    let numberOfDigits = 0;
    if (decimalKeyIndex >= 0) {
      for (let i = decimalKeyIndex; i < keys.length; i++) {
        if (this.isDigit(keys[i])) {
          numberOfDigits++;
        }
      }
    }
    return numberOfDigits;
  }

  /**
   * Gets the number of digits in the accumulator.
   */
  getNumberOfDigits(keys) {
    let numberOfDigits = 0;
    for (let i = 0; i < keys.length; i++) {
      if (this.isDigit(keys[i])) {
        numberOfDigits++;
      }
    }
    return numberOfDigits;
  }

  /**
   * Gets the number of digits in the accumulator.
   */
  containsFloatingPoint(keys) {
    return keys.includes(KeyID.DECIMAL);
  }

  /**
   * Returns whether the character is valid digit or not
   */
  isDigit(char) {
    return char >= '0' && char <= '9';
  }

  /**
   * clear the accumulator
   */
  clear() {
    super.clear();
    this.setClearOnNextKeyPress(false);
  }
  dispose() {
    this.valueProperty.dispose();
    this.stringProperty.dispose();
    super.dispose();
  }
}
sceneryPhet.register('NumberAccumulator', NumberAccumulator);
export default NumberAccumulator;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJEZXJpdmVkUHJvcGVydHkiLCJvcHRpb25pemUiLCJUYW5kZW0iLCJOdWxsYWJsZUlPIiwiTnVtYmVySU8iLCJzY2VuZXJ5UGhldCIsIkFic3RyYWN0S2V5QWNjdW11bGF0b3IiLCJLZXlJRCIsIkRlcml2ZWRTdHJpbmdQcm9wZXJ0eSIsIk5FR0FUSVZFX0NIQVIiLCJERUNJTUFMX0NIQVIiLCJNQVhfU0FGRV9JTlRFR0VSIiwiTnVtYmVyIiwiTUFYX0RJR0lUUyIsInRvU3RyaW5nIiwibGVuZ3RoIiwiTnVtYmVyQWNjdW11bGF0b3IiLCJjb25zdHJ1Y3RvciIsInByb3ZpZGVkT3B0aW9ucyIsIm9wdGlvbnMiLCJtYXhEaWdpdHNSaWdodE9mTWFudGlzc2EiLCJtYXhEaWdpdHMiLCJ0YW5kZW0iLCJSRVFVSVJFRCIsInRhbmRlbU5hbWVTdWZmaXgiLCJhc3NlcnQiLCJ2YWxpZGF0b3JzIiwicHJvcG9zZWRLZXlzIiwiZ2V0TnVtYmVyT2ZEaWdpdHMiLCJERUNJTUFMIiwiZ2V0TnVtYmVyT2ZEaWdpdHNSaWdodE9mTWFudGlzc2EiLCJzdHJpbmdQcm9wZXJ0eSIsImFjY3VtdWxhdGVkS2V5c1Byb3BlcnR5IiwiYWNjdW11bGF0ZWRLZXlzIiwia2V5c1RvU3RyaW5nIiwiY3JlYXRlVGFuZGVtIiwidmFsdWVQcm9wZXJ0eSIsInN0cmluZ1ZhbHVlIiwic3RyaW5nVG9JbnRlZ2VyIiwicGhldGlvVmFsdWVUeXBlIiwiaGFuZGxlS2V5UHJlc3NlZCIsImtleUlkZW50aWZpZXIiLCJuZXdBcnJheSIsImhhbmRsZUNsZWFyT25OZXh0S2V5UHJlc3MiLCJpc0RpZ2l0IiwicmVtb3ZlTGVhZGluZ1plcm8iLCJwdXNoIiwiQkFDS1NQQUNFIiwicG9wIiwiUExVU19NSU5VUyIsInNoaWZ0IiwidW5zaGlmdCIsImNvbnRhaW5zRmxvYXRpbmdQb2ludCIsInZhbGlkYXRlS2V5cyIsInVwZGF0ZUtleXMiLCJhcnJheSIsImdldCIsImtleXMiLCJyZXR1cm5WYWx1ZSIsImkiLCJzdGFydHNXaXRoIiwiZ2V0TnVtYmVyT2ZEaWdpdHNMZWZ0T2ZNYW50aXNzYSIsInJlcGxhY2UiLCJpc05hTiIsIm51bWJlck9mRGlnaXRzIiwiZGVjaW1hbEtleUluZGV4IiwiaW5kZXhPZiIsImluY2x1ZGVzIiwiY2hhciIsImNsZWFyIiwic2V0Q2xlYXJPbk5leHRLZXlQcmVzcyIsImRpc3Bvc2UiLCJyZWdpc3RlciJdLCJzb3VyY2VzIjpbIk51bWJlckFjY3VtdWxhdG9yLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDE3LTIwMjQsIFVuaXZlcnNpdHkgb2YgQ29sb3JhZG8gQm91bGRlclxyXG5cclxuLyoqXHJcbiAqIEEga2V5IGFjY3VtdWxhdG9yIHRoYXQgY29sbGVjdHMgdXNlciBpbnB1dCBmb3IgaW50ZWdlciBhbmQgZmxvYXRpbmcgcG9pbnQgdmFsdWVzLCBpbnRlbmRlZCBmb3IgdXNlIGluIGNvbmp1bmN0aW9uXHJcbiAqIHdpdGggdGhlIGNvbW1vbi1jb2RlIGtleXBhZC5cclxuICpcclxuICogQGF1dGhvciBBYWRpc2ggR3VwdGFcclxuICogQGF1dGhvciBKb2huIEJsYW5jb1xyXG4gKiBAYXV0aG9yIENocmlzIE1hbGxleSAoUGl4ZWxab29tLCBJbmMuKVxyXG4gKi9cclxuXHJcbmltcG9ydCBEZXJpdmVkUHJvcGVydHkgZnJvbSAnLi4vLi4vLi4vYXhvbi9qcy9EZXJpdmVkUHJvcGVydHkuanMnO1xyXG5pbXBvcnQgUmVhZE9ubHlQcm9wZXJ0eSBmcm9tICcuLi8uLi8uLi9heG9uL2pzL1JlYWRPbmx5UHJvcGVydHkuanMnO1xyXG5pbXBvcnQgb3B0aW9uaXplIGZyb20gJy4uLy4uLy4uL3BoZXQtY29yZS9qcy9vcHRpb25pemUuanMnO1xyXG5pbXBvcnQgVGFuZGVtIGZyb20gJy4uLy4uLy4uL3RhbmRlbS9qcy9UYW5kZW0uanMnO1xyXG5pbXBvcnQgTnVsbGFibGVJTyBmcm9tICcuLi8uLi8uLi90YW5kZW0vanMvdHlwZXMvTnVsbGFibGVJTy5qcyc7XHJcbmltcG9ydCBOdW1iZXJJTyBmcm9tICcuLi8uLi8uLi90YW5kZW0vanMvdHlwZXMvTnVtYmVySU8uanMnO1xyXG5pbXBvcnQgc2NlbmVyeVBoZXQgZnJvbSAnLi4vc2NlbmVyeVBoZXQuanMnO1xyXG5pbXBvcnQgQWJzdHJhY3RLZXlBY2N1bXVsYXRvciBmcm9tICcuL0Fic3RyYWN0S2V5QWNjdW11bGF0b3IuanMnO1xyXG5pbXBvcnQgS2V5SUQsIHsgS2V5SURWYWx1ZSB9IGZyb20gJy4vS2V5SUQuanMnO1xyXG5pbXBvcnQgRGVyaXZlZFN0cmluZ1Byb3BlcnR5IGZyb20gJy4uLy4uLy4uL2F4b24vanMvRGVyaXZlZFN0cmluZ1Byb3BlcnR5LmpzJztcclxuaW1wb3J0IHsgUGhldGlvT2JqZWN0T3B0aW9ucyB9IGZyb20gJy4uLy4uLy4uL3RhbmRlbS9qcy9QaGV0aW9PYmplY3QuanMnO1xyXG5cclxuLy8gY29uc3RhbnRzXHJcbmNvbnN0IE5FR0FUSVZFX0NIQVIgPSAnXFx1MjIxMic7XHJcbmNvbnN0IERFQ0lNQUxfQ0hBUiA9ICcuJztcclxuXHJcbi8vIERlZmluZSB0aGUgbWF4aW11bSBpbnRlZ2VyIHRoYXQgY2FuIGJlIGhhbmRsZWQuICBUaGUgcG9ydGlvbiB3aXRoIHRoZSBleHBsaWNpdCBudW1lcmljIHZhbHVlIGlzIG5lY2Vzc2FyeSBmb3IgSUUxMVxyXG4vLyBzdXBwb3J0LCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL3NjZW5lcnktcGhldC9pc3N1ZXMvMzMyLlxyXG5jb25zdCBNQVhfU0FGRV9JTlRFR0VSID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgfHwgOTAwNzE5OTI1NDc0MDk5MTtcclxuY29uc3QgTUFYX0RJR0lUUyA9IE1BWF9TQUZFX0lOVEVHRVIudG9TdHJpbmcoKS5sZW5ndGggLSAxO1xyXG5cclxudHlwZSBTZWxmT3B0aW9ucyA9IHtcclxuICBtYXhEaWdpdHNSaWdodE9mTWFudGlzc2E/OiBudW1iZXI7XHJcbiAgbWF4RGlnaXRzPzogbnVtYmVyO1xyXG59ICYgUGljazxQaGV0aW9PYmplY3RPcHRpb25zLCAndGFuZGVtJyB8ICd0YW5kZW1OYW1lU3VmZml4Jz47XHJcblxyXG5leHBvcnQgdHlwZSBOdW1iZXJBY2N1bXVsYXRvck9wdGlvbnMgPSBTZWxmT3B0aW9ucztcclxuXHJcbmNsYXNzIE51bWJlckFjY3VtdWxhdG9yIGV4dGVuZHMgQWJzdHJhY3RLZXlBY2N1bXVsYXRvciB7XHJcblxyXG4gIC8vIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUga2V5cyBlbnRlcmVkIGJ5IHRoZSB1c2VyXHJcbiAgcHVibGljIHJlYWRvbmx5IHN0cmluZ1Byb3BlcnR5OiBSZWFkT25seVByb3BlcnR5PHN0cmluZz47XHJcblxyXG4gIC8vIG51bWVyaWNhbCB2YWx1ZSBvZiB0aGUga2V5cyBlbnRlcmVkIGJ5IHRoZSB1c2VyXHJcbiAgcHVibGljIHJlYWRvbmx5IHZhbHVlUHJvcGVydHk6IFJlYWRPbmx5UHJvcGVydHk8bnVtYmVyIHwgbnVsbD47XHJcblxyXG4gIHB1YmxpYyBjb25zdHJ1Y3RvciggcHJvdmlkZWRPcHRpb25zPzogTnVtYmVyQWNjdW11bGF0b3JPcHRpb25zICkge1xyXG5cclxuICAgIGNvbnN0IG9wdGlvbnMgPSBvcHRpb25pemU8TnVtYmVyQWNjdW11bGF0b3JPcHRpb25zLCBTZWxmT3B0aW9ucz4oKSgge1xyXG4gICAgICBtYXhEaWdpdHNSaWdodE9mTWFudGlzc2E6IDAsXHJcbiAgICAgIG1heERpZ2l0czogTUFYX0RJR0lUUyxcclxuICAgICAgdGFuZGVtOiBUYW5kZW0uUkVRVUlSRUQsXHJcbiAgICAgIHRhbmRlbU5hbWVTdWZmaXg6ICdOdW1iZXJBY2N1bXVsYXRvcidcclxuICAgIH0sIHByb3ZpZGVkT3B0aW9ucyApO1xyXG5cclxuICAgIC8vIHZlcmlmeSBvcHRpb24gdmFsdWVzXHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCBvcHRpb25zLm1heERpZ2l0cyA+IDAgJiYgb3B0aW9ucy5tYXhEaWdpdHMgPD0gTUFYX0RJR0lUUyxcclxuICAgICAgYG1heERpZ2l0cyBpcyBvdXQgb2YgcmFuZ2U6ICR7b3B0aW9ucy5tYXhEaWdpdHN9YCApO1xyXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggb3B0aW9ucy5tYXhEaWdpdHNSaWdodE9mTWFudGlzc2EgPj0gMCAmJiBvcHRpb25zLm1heERpZ2l0c1JpZ2h0T2ZNYW50aXNzYSA8PSBvcHRpb25zLm1heERpZ2l0cyxcclxuICAgICAgYG1heERpZ2l0c1JpZ2h0T2ZNYW50aXNzYSBpcyBvdXQgb2YgcmFuZ2U6ICR7b3B0aW9ucy5tYXhEaWdpdHNSaWdodE9mTWFudGlzc2F9YCApO1xyXG5cclxuICAgIC8vIFZhbGlkYXRvcnMgdG8gYmUgcGFzc2VkIHRvIEFic3RyYWN0S2V5QWNjdW11bGF0b3JcclxuICAgIGNvbnN0IHZhbGlkYXRvcnMgPSBbXHJcbiAgICAgICggcHJvcG9zZWRLZXlzOiBLZXlJRFZhbHVlW10gKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TnVtYmVyT2ZEaWdpdHMoIHByb3Bvc2VkS2V5cyApIDw9IG9wdGlvbnMubWF4RGlnaXRzXHJcbiAgICAgICAgICAgICAgICYmICEoIHRoaXMuZ2V0TnVtYmVyT2ZEaWdpdHMoIHByb3Bvc2VkS2V5cyApID09PSBvcHRpb25zLm1heERpZ2l0c1xyXG4gICAgICAgICAgICAgICAmJiBwcm9wb3NlZEtleXNbIHByb3Bvc2VkS2V5cy5sZW5ndGggLSAxIF0gPT09IEtleUlELkRFQ0lNQUwgKVxyXG4gICAgICAgICAgICAgICAmJiB0aGlzLmdldE51bWJlck9mRGlnaXRzUmlnaHRPZk1hbnRpc3NhKCBwcm9wb3NlZEtleXMgKSA8PSBvcHRpb25zLm1heERpZ2l0c1JpZ2h0T2ZNYW50aXNzYTtcclxuICAgICAgfVxyXG4gICAgXTtcclxuXHJcbiAgICBzdXBlciggdmFsaWRhdG9ycyApO1xyXG5cclxuICAgIHRoaXMuc3RyaW5nUHJvcGVydHkgPSBuZXcgRGVyaXZlZFN0cmluZ1Byb3BlcnR5KCBbIHRoaXMuYWNjdW11bGF0ZWRLZXlzUHJvcGVydHkgXSwgYWNjdW11bGF0ZWRLZXlzID0+IHtcclxuICAgICAgcmV0dXJuIHRoaXMua2V5c1RvU3RyaW5nKCBhY2N1bXVsYXRlZEtleXMgKTtcclxuICAgIH0sIHtcclxuICAgICAgdGFuZGVtOiBvcHRpb25zLnRhbmRlbS5jcmVhdGVUYW5kZW0oICdzdHJpbmdQcm9wZXJ0eScgKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGJhZC1zaW0tdGV4dFxyXG4gICAgfSApO1xyXG5cclxuICAgIHRoaXMudmFsdWVQcm9wZXJ0eSA9IG5ldyBEZXJpdmVkUHJvcGVydHkoXHJcblxyXG4gICAgICAvLyBVc2UgdGhlIGFjY3VtdWxhdGVkIGtleXMgcmF0aGVyIHRoYW4gdGhlIHN0cmluZyBhcyBhIGRlcGVuZGVuY3kgc2luY2UgaXQgYXZvaWRzIGlzc3VlcyB3aXRoIGRlcGVuZGVuY2llcyxcclxuICAgICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waGV0c2ltcy9zY2VuZXJ5LXBoZXQvaXNzdWVzLzgzMy5cclxuICAgICAgWyB0aGlzLmFjY3VtdWxhdGVkS2V5c1Byb3BlcnR5IF0sXHJcbiAgICAgIGFjY3VtdWxhdGVkS2V5cyA9PiB7XHJcbiAgICAgICAgY29uc3Qgc3RyaW5nVmFsdWUgPSB0aGlzLmtleXNUb1N0cmluZyggYWNjdW11bGF0ZWRLZXlzICk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyaW5nVG9JbnRlZ2VyKCBzdHJpbmdWYWx1ZSApO1xyXG4gICAgICB9LFxyXG4gICAgICB7XHJcbiAgICAgICAgdGFuZGVtOiBvcHRpb25zLnRhbmRlbS5jcmVhdGVUYW5kZW0oICd2YWx1ZVByb3BlcnR5JyApLFxyXG4gICAgICAgIHBoZXRpb1ZhbHVlVHlwZTogTnVsbGFibGVJTyggTnVtYmVySU8gKVxyXG4gICAgICB9XHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW52b2tlZCB3aGVuIGEga2V5IGlzIHByZXNzZWQgYW5kIGNyZWF0ZXMgcHJvcG9zZWQgc2V0IG9mIGtleXMgdG8gYmUgcGFzc2VkIHRvIHRoZSB2YWxpZGF0b3JcclxuICAgKiBAcGFyYW0ga2V5SWRlbnRpZmllciAtIGlkZW50aWZpZXIgZm9yIHRoZSBrZXkgcHJlc3NlZFxyXG4gICAqL1xyXG4gIHB1YmxpYyBvdmVycmlkZSBoYW5kbGVLZXlQcmVzc2VkKCBrZXlJZGVudGlmaWVyOiBLZXlJRFZhbHVlICk6IHZvaWQge1xyXG4gICAgY29uc3QgbmV3QXJyYXkgPSB0aGlzLmhhbmRsZUNsZWFyT25OZXh0S2V5UHJlc3MoIGtleUlkZW50aWZpZXIgKTtcclxuICAgIGlmICggdGhpcy5pc0RpZ2l0KCBrZXlJZGVudGlmaWVyICkgKSB7XHJcbiAgICAgIHRoaXMucmVtb3ZlTGVhZGluZ1plcm8oIG5ld0FycmF5ICk7XHJcbiAgICAgIG5ld0FycmF5LnB1c2goIGtleUlkZW50aWZpZXIgKTtcclxuXHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgga2V5SWRlbnRpZmllciA9PT0gS2V5SUQuQkFDS1NQQUNFICkge1xyXG4gICAgICBuZXdBcnJheS5wb3AoKTtcclxuXHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgga2V5SWRlbnRpZmllciA9PT0gS2V5SUQuUExVU19NSU5VUyApIHtcclxuICAgICAgLy8gY2hlY2sgaWYgZmlyc3QgZWxlbWVudCBvZiBhcnJheSBpcyBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzXHJcbiAgICAgIGlmICggbmV3QXJyYXkubGVuZ3RoID4gMCAmJiBuZXdBcnJheVsgMCBdID09PSBLZXlJRC5QTFVTX01JTlVTICkge1xyXG4gICAgICAgIG5ld0FycmF5LnNoaWZ0KCk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgbmV3QXJyYXkudW5zaGlmdCgga2V5SWRlbnRpZmllciApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgga2V5SWRlbnRpZmllciA9PT0gS2V5SUQuREVDSU1BTCApIHtcclxuICAgICAgaWYgKCAhdGhpcy5jb250YWluc0Zsb2F0aW5nUG9pbnQoIG5ld0FycmF5ICkgKSB7XHJcbiAgICAgICAgbmV3QXJyYXkucHVzaCgga2V5SWRlbnRpZmllciApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgYXNzZXJ0ICYmIGFzc2VydCggZmFsc2UsIGB1bnN1cHBvcnRlZCBrZXlJZGVudGlmaWVyOiAke2tleUlkZW50aWZpZXJ9YCApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFZhbGlkYXRlIGFuZCB1cGRhdGUgdGhlIGtleXNcclxuICAgIHRoaXMudmFsaWRhdGVLZXlzKCBuZXdBcnJheSApICYmIHRoaXMudXBkYXRlS2V5cyggbmV3QXJyYXkgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbW92ZXMgbGVhZGluZyB6ZXJvcyBmcm9tIHRoZSBhcnJheS5cclxuICAgKi9cclxuICBwcml2YXRlIHJlbW92ZUxlYWRpbmdaZXJvKCBhcnJheTogS2V5SURWYWx1ZVtdICk6IHZvaWQge1xyXG4gICAgaWYgKCB0aGlzLnZhbHVlUHJvcGVydHkuZ2V0KCkgPT09IDAgJiYgIXRoaXMuY29udGFpbnNGbG9hdGluZ1BvaW50KCBhcnJheSApICkge1xyXG4gICAgICBhcnJheS5wb3AoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnZlcnRzIGEgc2V0IG9mIGtleXMgdG8gYSBzdHJpbmcuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBrZXlzVG9TdHJpbmcoIGtleXM6IEtleUlEVmFsdWVbXSApOiBzdHJpbmcge1xyXG5cclxuICAgIGxldCByZXR1cm5WYWx1ZSA9ICcnO1xyXG4gICAgbGV0IGkgPSAwO1xyXG5cclxuICAgIC8vIHRoZSBwbHVzL21pbnVzIGtleSAoaWYgcHJlc2VudCkgd2lsbCBiZSBmaXJzdCBrZXksIGFuZCBpbmRpY2F0ZXMgdGhhdCB0aGUgbnVtYmVyIGlzIG5lZ2F0aXZlXHJcbiAgICBpZiAoIGtleXMubGVuZ3RoID4gMCAmJiBrZXlzWyBpIF0gPT09IEtleUlELlBMVVNfTUlOVVMgKSB7XHJcbiAgICAgIHJldHVyblZhbHVlID0gTkVHQVRJVkVfQ0hBUjtcclxuICAgICAgaSsrO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHByb2Nlc3MgcmVtYWluaW5nIGtleXNcclxuICAgIGZvciAoIDsgaSA8IGtleXMubGVuZ3RoOyBpKysgKSB7XHJcblxyXG4gICAgICBpZiAoIGtleXNbIGkgXSA9PT0gS2V5SUQuREVDSU1BTCApIHtcclxuICAgICAgICByZXR1cm5WYWx1ZSA9IHJldHVyblZhbHVlICsgREVDSU1BTF9DSEFSO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG5cclxuICAgICAgICAvLyB0aGUgcGx1cy9taW51cyBrZXkgc2hvdWxkIGJlIGZpcnN0IGlmIHByZXNlbnRcclxuICAgICAgICBhc3NlcnQgJiYgYXNzZXJ0KCB0aGlzLmlzRGlnaXQoIGtleXNbIGkgXSApLCAndW5leHBlY3RlZCBrZXkgdHlwZScgKTtcclxuICAgICAgICByZXR1cm5WYWx1ZSA9IHJldHVyblZhbHVlICsga2V5c1sgaSBdO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJldHVyblZhbHVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ29udmVydHMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gdG8gYSBudW1iZXIuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBzdHJpbmdUb0ludGVnZXIoIHN0cmluZ1ZhbHVlOiBzdHJpbmcgKTogbnVtYmVyIHwgbnVsbCB7XHJcbiAgICBsZXQgcmV0dXJuVmFsdWUgPSBudWxsO1xyXG5cclxuICAgIC8vIGlmIHN0cmluZ1ZhbHVlIGNvbnRhaW5zIHNvbWV0aGluZyBvdGhlciB0aGFuIGp1c3QgYSBtaW51cyBzaWduLi4uXHJcbiAgICBpZiAoIHN0cmluZ1ZhbHVlLmxlbmd0aCA+IDBcclxuICAgICAgICAgJiYgISggc3RyaW5nVmFsdWUubGVuZ3RoID09PSAxICYmIHN0cmluZ1ZhbHVlLnN0YXJ0c1dpdGgoIE5FR0FUSVZFX0NIQVIgKSApXHJcbiAgICAgICAgICYmICggdGhpcy5nZXROdW1iZXJPZkRpZ2l0c0xlZnRPZk1hbnRpc3NhKCB0aGlzLmFjY3VtdWxhdGVkS2V5c1Byb3BlcnR5LmdldCgpICkgPiAwIHx8XHJcbiAgICAgICAgICAgICAgdGhpcy5nZXROdW1iZXJPZkRpZ2l0c1JpZ2h0T2ZNYW50aXNzYSggdGhpcy5hY2N1bXVsYXRlZEtleXNQcm9wZXJ0eS5nZXQoKSApID4gMCApICkge1xyXG5cclxuICAgICAgLy8gcmVwbGFjZSBVbmljb2RlIG1pbnVzIHdpdGggdmFuaWxsYSAnLScsIG9yIHBhcnNlSW50IHdpbGwgZmFpbCBmb3IgbmVnYXRpdmUgbnVtYmVyc1xyXG4gICAgICByZXR1cm5WYWx1ZSA9IE51bWJlciggc3RyaW5nVmFsdWUucmVwbGFjZSggTkVHQVRJVkVfQ0hBUiwgJy0nICkucmVwbGFjZSggREVDSU1BTF9DSEFSLCAnLicgKSApO1xyXG4gICAgICBhc3NlcnQgJiYgYXNzZXJ0KCAhaXNOYU4oIHJldHVyblZhbHVlICksIGBpbnZhbGlkIG51bWJlcjogJHtyZXR1cm5WYWx1ZX1gICk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJldHVyblZhbHVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyB0aGUgbnVtYmVyIG9mIGRpZ2l0cyB0byB0aGUgbGVmdCBvZiBtYW50aXNzYSBpbiB0aGUgYWNjdW11bGF0b3IuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBnZXROdW1iZXJPZkRpZ2l0c0xlZnRPZk1hbnRpc3NhKCBrZXlzOiBLZXlJRFZhbHVlW10gKTogbnVtYmVyIHtcclxuICAgIGxldCBudW1iZXJPZkRpZ2l0cyA9IDA7XHJcbiAgICBmb3IgKCBsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrICkge1xyXG4gICAgICBpZiAoIHRoaXMuaXNEaWdpdCgga2V5c1sgaSBdICkgKSB7XHJcbiAgICAgICAgbnVtYmVyT2ZEaWdpdHMrKztcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCBrZXlzWyBpIF0gPT09IEtleUlELkRFQ0lNQUwgKSB7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBudW1iZXJPZkRpZ2l0cztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgdGhlIG51bWJlciBvZiBkaWdpdHMgdG8gdGhlIHJpZ2h0IG9mIG1hbnRpc3NhIGluIHRoZSBhY2N1bXVsYXRvci5cclxuICAgKi9cclxuICBwcml2YXRlIGdldE51bWJlck9mRGlnaXRzUmlnaHRPZk1hbnRpc3NhKCBrZXlzOiBLZXlJRFZhbHVlW10gKTogbnVtYmVyIHtcclxuICAgIGNvbnN0IGRlY2ltYWxLZXlJbmRleCA9IGtleXMuaW5kZXhPZiggS2V5SUQuREVDSU1BTCApO1xyXG4gICAgbGV0IG51bWJlck9mRGlnaXRzID0gMDtcclxuICAgIGlmICggZGVjaW1hbEtleUluZGV4ID49IDAgKSB7XHJcbiAgICAgIGZvciAoIGxldCBpID0gZGVjaW1hbEtleUluZGV4OyBpIDwga2V5cy5sZW5ndGg7IGkrKyApIHtcclxuICAgICAgICBpZiAoIHRoaXMuaXNEaWdpdCgga2V5c1sgaSBdICkgKSB7XHJcbiAgICAgICAgICBudW1iZXJPZkRpZ2l0cysrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bWJlck9mRGlnaXRzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBpbiB0aGUgYWNjdW11bGF0b3IuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBnZXROdW1iZXJPZkRpZ2l0cygga2V5czogS2V5SURWYWx1ZVtdICk6IG51bWJlciB7XHJcbiAgICBsZXQgbnVtYmVyT2ZEaWdpdHMgPSAwO1xyXG4gICAgZm9yICggbGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKyApIHtcclxuICAgICAgaWYgKCB0aGlzLmlzRGlnaXQoIGtleXNbIGkgXSApICkge1xyXG4gICAgICAgIG51bWJlck9mRGlnaXRzKys7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBudW1iZXJPZkRpZ2l0cztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgdGhlIG51bWJlciBvZiBkaWdpdHMgaW4gdGhlIGFjY3VtdWxhdG9yLlxyXG4gICAqL1xyXG4gIHByaXZhdGUgY29udGFpbnNGbG9hdGluZ1BvaW50KCBrZXlzOiBLZXlJRFZhbHVlW10gKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4ga2V5cy5pbmNsdWRlcyggS2V5SUQuREVDSU1BTCApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBjaGFyYWN0ZXIgaXMgdmFsaWQgZGlnaXQgb3Igbm90XHJcbiAgICovXHJcbiAgcHJpdmF0ZSBpc0RpZ2l0KCBjaGFyOiBLZXlJRFZhbHVlICk6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuIGNoYXIgPj0gJzAnICYmIGNoYXIgPD0gJzknO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogY2xlYXIgdGhlIGFjY3VtdWxhdG9yXHJcbiAgICovXHJcbiAgcHVibGljIG92ZXJyaWRlIGNsZWFyKCk6IHZvaWQge1xyXG4gICAgc3VwZXIuY2xlYXIoKTtcclxuICAgIHRoaXMuc2V0Q2xlYXJPbk5leHRLZXlQcmVzcyggZmFsc2UgKTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBvdmVycmlkZSBkaXNwb3NlKCk6IHZvaWQge1xyXG4gICAgdGhpcy52YWx1ZVByb3BlcnR5LmRpc3Bvc2UoKTtcclxuICAgIHRoaXMuc3RyaW5nUHJvcGVydHkuZGlzcG9zZSgpO1xyXG4gICAgc3VwZXIuZGlzcG9zZSgpO1xyXG4gIH1cclxufVxyXG5cclxuc2NlbmVyeVBoZXQucmVnaXN0ZXIoICdOdW1iZXJBY2N1bXVsYXRvcicsIE51bWJlckFjY3VtdWxhdG9yICk7XHJcbmV4cG9ydCBkZWZhdWx0IE51bWJlckFjY3VtdWxhdG9y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