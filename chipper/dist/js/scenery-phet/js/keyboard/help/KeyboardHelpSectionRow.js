// Copyright 2022-2024, University of Colorado Boulder

/**
 * A row of KeyboardHelpSection, containing the label, icon, and text. Many of the static functions of
 * KeyboardHelpSection will return a KeyboardHelpSectionRow. The label and icon are often grouped in an AlignGroup for
 * easy positioning in KeyboardHelpSection. This cannot be done in KeyboardHelpSection directly because different
 * labels and icons will have varying layout. For instance, see labelWithIcon vs labelWithIconList.
 *
 * @author Jesse Greenberg (PhET Interactive Simulations)
 */

import optionize, { combineOptions } from '../../../../phet-core/js/optionize.js';
import { AlignGroup, HBox, Node, RichText, Text, VBox } from '../../../../scenery/js/imports.js';
import PhetFont from '../../PhetFont.js';
import sceneryPhet from '../../sceneryPhet.js';
import SceneryPhetStrings from '../../SceneryPhetStrings.js';
import LetterKeyNode from '../LetterKeyNode.js';
import TextKeyNode from '../TextKeyNode.js';
import KeyboardHelpIconFactory from './KeyboardHelpIconFactory.js';
import KeyboardHelpSection from './KeyboardHelpSection.js';

// text fonts and max widths
const LABEL_FONT = new PhetFont(16);
const OR_TEXT_MAX_WIDTH = 16;

// Options type for labelWithIconList, see that function.

// Options type for labelWithIcon, see that function

class KeyboardHelpSectionRow {
  // Includes a reference to the Text because KeyboardHelpSection will constrain the width of all text in its
  // KeyboardHelpSectionRows for i18n.

  // A layout Node containing the readable Text describing this row.

  // An icon Node graphically showing the keyboard keys for this row.

  // voicing - When Voicing is enabled, this is the content for this row that will be spoken with speech synthesis
  // when the row is activated with a click.

  // Reusable font style and size for the KeyboardHelpDialog labels.
  static LABEL_FONT = LABEL_FONT;
  constructor(text, label, icon, providedOptions) {
    const options = optionize()({
      readingBlockContent: null
    }, providedOptions);
    this.text = text;
    this.label = label;
    this.icon = icon;
    this.readingBlockContent = options.readingBlockContent;
  }

  /**
   * Sets visibility of the label, icon, and text so that it can be hidden if necessary. If using
   * KeyboardHelpSection, this will also correctly layout the content because of scenery dynamic layout.
   */
  setContentsVisible(visible) {
    this.text.visible = visible;
    this.label.visible = visible;
    this.icon.visible = visible;
  }

  /**
   * Horizontally align a label and an icon, with the label on the left and the icon on the right. AlignGroup is used
   * to give the label and icon identical dimensions for easy layout in KeyboardHelpSection.
   */
  static labelWithIcon(labelString, icon, providedOptions) {
    const options = optionize()({
      labelInnerContent: null,
      readingBlockContent: null,
      labelOptions: {
        font: LABEL_FONT
      },
      iconOptions: {
        tagName: 'li'
      }
    }, providedOptions);
    const labelText = new RichText(labelString, options.labelOptions);

    // make the label and icon the same height so that they will align when we assemble help section group
    const labelIconGroup = new AlignGroup({
      matchHorizontal: false
    });
    const labelBox = labelIconGroup.createBox(labelText);
    const iconBox = labelIconGroup.createBox(new Node({
      children: [icon]
    }), options.iconOptions);
    iconBox.innerContent = options.labelInnerContent;
    return new KeyboardHelpSectionRow(labelText, labelBox, iconBox, {
      readingBlockContent: options.readingBlockContent || options.labelInnerContent
    });
  }

  /**
   * Creates a row with one or more keys, with keys separated by '+'.
   * @param keyStrings - each should be a letter key
   * @param labelString
   * @param [providedOptions]
   */
  static createKeysRowFromStrings(keyStrings, labelString, providedOptions) {
    return KeyboardHelpSectionRow.createKeysRow(keyStrings.map(key => new LetterKeyNode(key)), labelString, providedOptions);
  }

  /**
   * Creates a row with one or more keys, with keys separated by '+'.
   */
  static createKeysRow(keyIcons, labelString, providedOptions) {
    assert && assert(keyIcons.length > 0, 'expected keys');
    let keysNode = null;
    for (let i = 0; i < keyIcons.length; i++) {
      const keyNode = keyIcons[i];

      // Continue to "add" more icons to the end of the keysNode with iconPlusIcon until we go through all keyIcons.
      // If there is only one keyIcon it will just be returned without any '+' icons.
      keysNode = keysNode ? KeyboardHelpIconFactory.iconPlusIcon(keysNode, keyNode) : keyNode;
    }
    assert && assert(keysNode, 'keysNode must be defined since there were more than zero keyIcons.');
    return KeyboardHelpSectionRow.labelWithIcon(labelString, keysNode, providedOptions);
  }

  /**
   * Create an entry for the dialog that looks horizontally aligns a letter key with a 'J' key separated by a plus
   * sign, with a descriptive label. Something like:   * "J + S jumps close to sweater"
   * @param keyString - the letter name that will come after 'J', note this can be hard coded, no need for i18n.
   * @param labelString - visual label
   * @param [providedOptions]
   */
  static createJumpKeyRow(keyString, labelString, providedOptions) {
    return KeyboardHelpSectionRow.createKeysRowFromStrings(['J', keyString], labelString, providedOptions);
  }

  /**
   * Create a KeyboardHelpSectionRow that describes how to play and pause the sim with the "Alt" + "K" hotkey.
   */
  static createPlayPauseKeyRow(labelString, providedOptions) {
    return KeyboardHelpSectionRow.createGlobalHotkeyRow(labelString, SceneryPhetStrings.key.kStringProperty, providedOptions);
  }

  /**
   * Create a KeyboardHelpSectionRow that describes how to step forward the sim with the "Alt" + "L" hotkeys.
   */
  static createStepForwardKeyRow(labelString, providedOptions) {
    return KeyboardHelpSectionRow.createGlobalHotkeyRow(labelString, SceneryPhetStrings.key.lStringProperty, providedOptions);
  }

  /**
   * Create a KeyboardHelpSectionRow that describes how to use a global hotkey. Global hotkeys are triggered with "Alt" plus
   * some other key, to be provided.
   */
  static createGlobalHotkeyRow(labelString, keyString, providedOptions) {
    return KeyboardHelpSectionRow.createKeysRow([TextKeyNode.altOrOption(), new LetterKeyNode(keyString)], labelString, providedOptions);
  }

  /**
   * Create a label with a list of icons. The icons will be vertically aligned, each separated by 'or' text. The
   * label will be vertically centered with the first item in the list of icons. To vertically align the label
   * with the first icon, AlignGroup is used. Finally, an AlignGroup is used to make the label
   * content match height with the entire icon list. When assembled, the label with icon list will look like:
   *
   * This is the label: Icon1 or
   *                    Icon2 or
   *                    Icon3
   */
  static labelWithIconList(labelString, icons, providedOptions) {
    const options = optionize()({
      labelInnerContent: null,
      readingBlockContent: null,
      iconsVBoxOptions: {},
      labelOptions: {
        font: LABEL_FONT
      }
    }, providedOptions);
    options.iconsVBoxOptions = combineOptions({
      spacing: KeyboardHelpSection.DEFAULT_VERTICAL_ICON_SPACING * 0.75,
      // less than the normal vertical icon spacing since it is a group
      align: 'left',
      // pdom - each icon will be presented as a list item under the parent 'ul' of the KeyboardHelpSectionRow.
      tagName: 'li',
      innerContent: options.labelInnerContent
    }, options.iconsVBoxOptions);
    const labelText = new RichText(labelString, options.labelOptions);

    // horizontally align the label with the first item in the list of icons, guarantees that the label and first
    // icon have identical heights
    const labelFirstIconGroup = new AlignGroup({
      matchHorizontal: false
    });
    labelFirstIconGroup.createBox(new Node({
      children: [icons[0]]
    })); // create the box to restrain bounds, but a reference isn't necessary
    const labelBox = labelFirstIconGroup.createBox(labelText);
    const iconsWithOrText = [];

    // for each of the icons (excluding the last one, add a vertically aligned 'or' text to the right
    for (let i = 0; i < icons.length - 1; i++) {
      const orText = new Text(SceneryPhetStrings.keyboardHelpDialog.orStringProperty, {
        font: LABEL_FONT,
        maxWidth: OR_TEXT_MAX_WIDTH
      });

      // place orText with the icon in an HBox
      const hBox = new HBox({
        children: [new Node({
          children: [icons[i]]
        }), orText],
        spacing: KeyboardHelpIconFactory.DEFAULT_ICON_SPACING
      });
      iconsWithOrText.push(hBox);
    }
    iconsWithOrText.push(icons[icons.length - 1]);

    // place icons in a VBox, passing through optional spacing and a11y representation
    const iconsVBox = new VBox(combineOptions({
      children: iconsWithOrText
    }, options.iconsVBoxOptions));

    // make the label the same height as the icon list by aligning them in a box that matches height
    const groupOptions = {
      yAlign: 'top'
    };
    const labelIconListGroup = new AlignGroup({
      matchHorizontal: false
    });
    const iconsBox = labelIconListGroup.createBox(iconsVBox, groupOptions); // create the box to match height, but reference not necessary
    const labelWithHeightBox = labelIconListGroup.createBox(labelBox, groupOptions);
    return new KeyboardHelpSectionRow(labelText, labelWithHeightBox, iconsBox, {
      readingBlockContent: options.readingBlockContent || options.labelInnerContent
    });
  }
}
sceneryPhet.register('KeyboardHelpSectionRow', KeyboardHelpSectionRow);
export default KeyboardHelpSectionRow;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJvcHRpb25pemUiLCJjb21iaW5lT3B0aW9ucyIsIkFsaWduR3JvdXAiLCJIQm94IiwiTm9kZSIsIlJpY2hUZXh0IiwiVGV4dCIsIlZCb3giLCJQaGV0Rm9udCIsInNjZW5lcnlQaGV0IiwiU2NlbmVyeVBoZXRTdHJpbmdzIiwiTGV0dGVyS2V5Tm9kZSIsIlRleHRLZXlOb2RlIiwiS2V5Ym9hcmRIZWxwSWNvbkZhY3RvcnkiLCJLZXlib2FyZEhlbHBTZWN0aW9uIiwiTEFCRUxfRk9OVCIsIk9SX1RFWFRfTUFYX1dJRFRIIiwiS2V5Ym9hcmRIZWxwU2VjdGlvblJvdyIsImNvbnN0cnVjdG9yIiwidGV4dCIsImxhYmVsIiwiaWNvbiIsInByb3ZpZGVkT3B0aW9ucyIsIm9wdGlvbnMiLCJyZWFkaW5nQmxvY2tDb250ZW50Iiwic2V0Q29udGVudHNWaXNpYmxlIiwidmlzaWJsZSIsImxhYmVsV2l0aEljb24iLCJsYWJlbFN0cmluZyIsImxhYmVsSW5uZXJDb250ZW50IiwibGFiZWxPcHRpb25zIiwiZm9udCIsImljb25PcHRpb25zIiwidGFnTmFtZSIsImxhYmVsVGV4dCIsImxhYmVsSWNvbkdyb3VwIiwibWF0Y2hIb3Jpem9udGFsIiwibGFiZWxCb3giLCJjcmVhdGVCb3giLCJpY29uQm94IiwiY2hpbGRyZW4iLCJpbm5lckNvbnRlbnQiLCJjcmVhdGVLZXlzUm93RnJvbVN0cmluZ3MiLCJrZXlTdHJpbmdzIiwiY3JlYXRlS2V5c1JvdyIsIm1hcCIsImtleSIsImtleUljb25zIiwiYXNzZXJ0IiwibGVuZ3RoIiwia2V5c05vZGUiLCJpIiwia2V5Tm9kZSIsImljb25QbHVzSWNvbiIsImNyZWF0ZUp1bXBLZXlSb3ciLCJrZXlTdHJpbmciLCJjcmVhdGVQbGF5UGF1c2VLZXlSb3ciLCJjcmVhdGVHbG9iYWxIb3RrZXlSb3ciLCJrU3RyaW5nUHJvcGVydHkiLCJjcmVhdGVTdGVwRm9yd2FyZEtleVJvdyIsImxTdHJpbmdQcm9wZXJ0eSIsImFsdE9yT3B0aW9uIiwibGFiZWxXaXRoSWNvbkxpc3QiLCJpY29ucyIsImljb25zVkJveE9wdGlvbnMiLCJzcGFjaW5nIiwiREVGQVVMVF9WRVJUSUNBTF9JQ09OX1NQQUNJTkciLCJhbGlnbiIsImxhYmVsRmlyc3RJY29uR3JvdXAiLCJpY29uc1dpdGhPclRleHQiLCJvclRleHQiLCJrZXlib2FyZEhlbHBEaWFsb2ciLCJvclN0cmluZ1Byb3BlcnR5IiwibWF4V2lkdGgiLCJoQm94IiwiREVGQVVMVF9JQ09OX1NQQUNJTkciLCJwdXNoIiwiaWNvbnNWQm94IiwiZ3JvdXBPcHRpb25zIiwieUFsaWduIiwibGFiZWxJY29uTGlzdEdyb3VwIiwiaWNvbnNCb3giLCJsYWJlbFdpdGhIZWlnaHRCb3giLCJyZWdpc3RlciJdLCJzb3VyY2VzIjpbIktleWJvYXJkSGVscFNlY3Rpb25Sb3cudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMjItMjAyNCwgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXHJcblxyXG4vKipcclxuICogQSByb3cgb2YgS2V5Ym9hcmRIZWxwU2VjdGlvbiwgY29udGFpbmluZyB0aGUgbGFiZWwsIGljb24sIGFuZCB0ZXh0LiBNYW55IG9mIHRoZSBzdGF0aWMgZnVuY3Rpb25zIG9mXHJcbiAqIEtleWJvYXJkSGVscFNlY3Rpb24gd2lsbCByZXR1cm4gYSBLZXlib2FyZEhlbHBTZWN0aW9uUm93LiBUaGUgbGFiZWwgYW5kIGljb24gYXJlIG9mdGVuIGdyb3VwZWQgaW4gYW4gQWxpZ25Hcm91cCBmb3JcclxuICogZWFzeSBwb3NpdGlvbmluZyBpbiBLZXlib2FyZEhlbHBTZWN0aW9uLiBUaGlzIGNhbm5vdCBiZSBkb25lIGluIEtleWJvYXJkSGVscFNlY3Rpb24gZGlyZWN0bHkgYmVjYXVzZSBkaWZmZXJlbnRcclxuICogbGFiZWxzIGFuZCBpY29ucyB3aWxsIGhhdmUgdmFyeWluZyBsYXlvdXQuIEZvciBpbnN0YW5jZSwgc2VlIGxhYmVsV2l0aEljb24gdnMgbGFiZWxXaXRoSWNvbkxpc3QuXHJcbiAqXHJcbiAqIEBhdXRob3IgSmVzc2UgR3JlZW5iZXJnIChQaEVUIEludGVyYWN0aXZlIFNpbXVsYXRpb25zKVxyXG4gKi9cclxuXHJcbmltcG9ydCBUUmVhZE9ubHlQcm9wZXJ0eSBmcm9tICcuLi8uLi8uLi8uLi9heG9uL2pzL1RSZWFkT25seVByb3BlcnR5LmpzJztcclxuaW1wb3J0IG9wdGlvbml6ZSwgeyBjb21iaW5lT3B0aW9ucyB9IGZyb20gJy4uLy4uLy4uLy4uL3BoZXQtY29yZS9qcy9vcHRpb25pemUuanMnO1xyXG5pbXBvcnQgU3RyaWN0T21pdCBmcm9tICcuLi8uLi8uLi8uLi9waGV0LWNvcmUvanMvdHlwZXMvU3RyaWN0T21pdC5qcyc7XHJcbmltcG9ydCB7IEFsaWduQm94T3B0aW9ucywgQWxpZ25Hcm91cCwgSEJveCwgTm9kZSwgUERPTVZhbHVlVHlwZSwgUmljaFRleHQsIFJpY2hUZXh0T3B0aW9ucywgVGV4dCwgVkJveCwgVkJveE9wdGlvbnMgfSBmcm9tICcuLi8uLi8uLi8uLi9zY2VuZXJ5L2pzL2ltcG9ydHMuanMnO1xyXG5pbXBvcnQgeyBWb2ljaW5nUmVzcG9uc2UgfSBmcm9tICcuLi8uLi8uLi8uLi91dHRlcmFuY2UtcXVldWUvanMvUmVzcG9uc2VQYWNrZXQuanMnO1xyXG5pbXBvcnQgUGhldEZvbnQgZnJvbSAnLi4vLi4vUGhldEZvbnQuanMnO1xyXG5pbXBvcnQgc2NlbmVyeVBoZXQgZnJvbSAnLi4vLi4vc2NlbmVyeVBoZXQuanMnO1xyXG5pbXBvcnQgU2NlbmVyeVBoZXRTdHJpbmdzIGZyb20gJy4uLy4uL1NjZW5lcnlQaGV0U3RyaW5ncy5qcyc7XHJcbmltcG9ydCBMZXR0ZXJLZXlOb2RlIGZyb20gJy4uL0xldHRlcktleU5vZGUuanMnO1xyXG5pbXBvcnQgVGV4dEtleU5vZGUgZnJvbSAnLi4vVGV4dEtleU5vZGUuanMnO1xyXG5pbXBvcnQgS2V5Ym9hcmRIZWxwSWNvbkZhY3RvcnkgZnJvbSAnLi9LZXlib2FyZEhlbHBJY29uRmFjdG9yeS5qcyc7XHJcbmltcG9ydCBLZXlib2FyZEhlbHBTZWN0aW9uIGZyb20gJy4vS2V5Ym9hcmRIZWxwU2VjdGlvbi5qcyc7XHJcblxyXG4vLyB0ZXh0IGZvbnRzIGFuZCBtYXggd2lkdGhzXHJcbmNvbnN0IExBQkVMX0ZPTlQgPSBuZXcgUGhldEZvbnQoIDE2ICk7XHJcbmNvbnN0IE9SX1RFWFRfTUFYX1dJRFRIID0gMTY7XHJcblxyXG4vLyBPcHRpb25zIHR5cGUgZm9yIGxhYmVsV2l0aEljb25MaXN0LCBzZWUgdGhhdCBmdW5jdGlvbi5cclxudHlwZSBMYWJlbFdpdGhJY29uTGlzdE9wdGlvbnMgPSB7XHJcblxyXG4gIC8vIGNvbnRlbnQgZm9yIHRoZSBwYXJhbGxlbCBET00gcmVwcmVzZW50aW5nIHRoZSBlbnRpcmUgcm93LCByZWFkIGJ5IGEgc2NyZWVuIHJlYWRlclxyXG4gIGxhYmVsSW5uZXJDb250ZW50PzogUERPTVZhbHVlVHlwZSB8IG51bGw7XHJcblxyXG4gIC8vIG9wdGlvbnMgcGFzc2VkIHRvIHRoZSBSaWNoVGV4dCBsYWJlbFxyXG4gIGxhYmVsT3B0aW9ucz86IFJpY2hUZXh0T3B0aW9ucztcclxuXHJcbiAgLy8gdm9pY2luZ1xyXG4gIC8vIENvbnRlbnQgZm9yIHRoaXMgaWNvbiB0aGF0IGlzIHJlYWQgYnkgdGhlIFZvaWNpbmcgZmVhdHVyZSB3aGVuIGluIGEgS2V5Ym9hcmRIZWxwU2VjdGlvbi4gSWYgbnVsbCxcclxuICAvLyB3aWxsIGRlZmF1bHQgdG8gb3B0aW9ucy5sYWJlbElubmVyQ29udGVudC5cclxuICByZWFkaW5nQmxvY2tDb250ZW50PzogVm9pY2luZ1Jlc3BvbnNlIHwgbnVsbDtcclxuXHJcbiAgLy8gT3B0aW9ucyBmb3IgdGhlIFZCb3ggdGhhdCBtYW5hZ2VzIGxheW91dCBmb3IgYWxsIGljb25zIGluIHRoZSBsaXN0LiBPcHRpb25zIG9taXR0ZWQgYXJlIHNldCBieSB0aGUgZnVuY3Rpb24uXHJcbiAgaWNvbnNWQm94T3B0aW9ucz86IFN0cmljdE9taXQ8VkJveE9wdGlvbnMsICdpbm5lckNvbnRlbnQnIHwgJ3NwYWNpbmcnIHwgJ2FsaWduJyB8ICd0YWdOYW1lJz47XHJcbn07XHJcblxyXG4vLyBPcHRpb25zIHR5cGUgZm9yIGxhYmVsV2l0aEljb24sIHNlZSB0aGF0IGZ1bmN0aW9uXHJcbnR5cGUgTGFiZWxXaXRoSWNvbk9wdGlvbnMgPSB7XHJcblxyXG4gIC8vIHtzdHJpbmd8bnVsbH0gdG8gcHJvdmlkZSB0aGUgUERPTSBkZXNjcmlwdGlvbiBvZiB0aGlzIHJvd1xyXG4gIGxhYmVsSW5uZXJDb250ZW50Pzogc3RyaW5nIHwgVFJlYWRPbmx5UHJvcGVydHk8c3RyaW5nPiB8IG51bGw7XHJcblxyXG4gIC8vIHtzdHJpbmd9IC0gQ29udGVudCBmb3IgdGhpcyBpY29uIHRoYXQgaXMgcmVhZCBieSB0aGUgVm9pY2luZyBmZWF0dXJlIHdoZW4gaW4gYSBLZXlib2FyZEhlbHBTZWN0aW9uLiBJZiBudWxsLFxyXG4gIC8vIHdpbGwgZGVmYXVsdCB0byB0aGUgb3B0aW9ucy5sYWJlbElubmVyQ29udGVudC5cclxuICByZWFkaW5nQmxvY2tDb250ZW50PzogVm9pY2luZ1Jlc3BvbnNlIHwgbnVsbDtcclxuXHJcbiAgLy8gb3B0aW9ucyBwYXNzZWQgdG8gdGhlIFJpY2hUZXh0IGxhYmVsXHJcbiAgbGFiZWxPcHRpb25zPzogUmljaFRleHRPcHRpb25zO1xyXG5cclxuICAvLyBvcHRpb25zIHBhc3NlZCB0byB0aGUgQWxpZ25Cb3ggc3Vycm91bmRpbmcgdGhlIGljb25cclxuICBpY29uT3B0aW9ucz86IFN0cmljdE9taXQ8QWxpZ25Cb3hPcHRpb25zLCAnaW5uZXJDb250ZW50Jz47XHJcbn07XHJcblxyXG50eXBlIFNlbGZPcHRpb25zID0ge1xyXG5cclxuICAvLyB2b2ljaW5nIC0gVGhlIGNvbnRlbnQgdGhhdCBpcyByZWFkIHdpdGggdGhlIFZvaWNpbmcgZmVhdHVyZSB3aGVuIGVuYWJsZWQuIFdoZW4gY2xpY2tlZCwgdGhlIHJlYWRpbmdCbG9ja0NvbnRlbnRcclxuICAvLyBmb3IgZXZlcnkgS2V5Ym9hcmRIZWxwU2VjdGlvblJvdyBpbiB0aGUgS2V5Ym9hcmRIZWxwU2VjdGlvbiBpcyByZWFkLlxyXG4gIHJlYWRpbmdCbG9ja0NvbnRlbnQ/OiBWb2ljaW5nUmVzcG9uc2UgfCBudWxsO1xyXG59O1xyXG50eXBlIEtleWJvYXJkSGVscFNlY3Rpb25Sb3dPcHRpb25zID0gU2VsZk9wdGlvbnM7XHJcblxyXG5jbGFzcyBLZXlib2FyZEhlbHBTZWN0aW9uUm93IHtcclxuXHJcbiAgLy8gSW5jbHVkZXMgYSByZWZlcmVuY2UgdG8gdGhlIFRleHQgYmVjYXVzZSBLZXlib2FyZEhlbHBTZWN0aW9uIHdpbGwgY29uc3RyYWluIHRoZSB3aWR0aCBvZiBhbGwgdGV4dCBpbiBpdHNcclxuICAvLyBLZXlib2FyZEhlbHBTZWN0aW9uUm93cyBmb3IgaTE4bi5cclxuICBwdWJsaWMgcmVhZG9ubHkgdGV4dDogVGV4dCB8IFJpY2hUZXh0O1xyXG5cclxuICAvLyBBIGxheW91dCBOb2RlIGNvbnRhaW5pbmcgdGhlIHJlYWRhYmxlIFRleHQgZGVzY3JpYmluZyB0aGlzIHJvdy5cclxuICBwdWJsaWMgcmVhZG9ubHkgbGFiZWw6IE5vZGU7XHJcblxyXG4gIC8vIEFuIGljb24gTm9kZSBncmFwaGljYWxseSBzaG93aW5nIHRoZSBrZXlib2FyZCBrZXlzIGZvciB0aGlzIHJvdy5cclxuICBwdWJsaWMgcmVhZG9ubHkgaWNvbjogTm9kZTtcclxuXHJcbiAgLy8gdm9pY2luZyAtIFdoZW4gVm9pY2luZyBpcyBlbmFibGVkLCB0aGlzIGlzIHRoZSBjb250ZW50IGZvciB0aGlzIHJvdyB0aGF0IHdpbGwgYmUgc3Bva2VuIHdpdGggc3BlZWNoIHN5bnRoZXNpc1xyXG4gIC8vIHdoZW4gdGhlIHJvdyBpcyBhY3RpdmF0ZWQgd2l0aCBhIGNsaWNrLlxyXG4gIHB1YmxpYyByZWFkb25seSByZWFkaW5nQmxvY2tDb250ZW50OiBWb2ljaW5nUmVzcG9uc2UgfCBudWxsO1xyXG5cclxuICAvLyBSZXVzYWJsZSBmb250IHN0eWxlIGFuZCBzaXplIGZvciB0aGUgS2V5Ym9hcmRIZWxwRGlhbG9nIGxhYmVscy5cclxuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IExBQkVMX0ZPTlQgPSBMQUJFTF9GT05UO1xyXG5cclxuICBwdWJsaWMgY29uc3RydWN0b3IoIHRleHQ6IFRleHQgfCBSaWNoVGV4dCwgbGFiZWw6IE5vZGUsIGljb246IE5vZGUsIHByb3ZpZGVkT3B0aW9ucz86IEtleWJvYXJkSGVscFNlY3Rpb25Sb3dPcHRpb25zICkge1xyXG4gICAgY29uc3Qgb3B0aW9ucyA9IG9wdGlvbml6ZTxLZXlib2FyZEhlbHBTZWN0aW9uUm93T3B0aW9ucywgU2VsZk9wdGlvbnM+KCkoIHtcclxuICAgICAgcmVhZGluZ0Jsb2NrQ29udGVudDogbnVsbFxyXG4gICAgfSwgcHJvdmlkZWRPcHRpb25zICk7XHJcblxyXG4gICAgdGhpcy50ZXh0ID0gdGV4dDtcclxuICAgIHRoaXMubGFiZWwgPSBsYWJlbDtcclxuICAgIHRoaXMuaWNvbiA9IGljb247XHJcbiAgICB0aGlzLnJlYWRpbmdCbG9ja0NvbnRlbnQgPSBvcHRpb25zLnJlYWRpbmdCbG9ja0NvbnRlbnQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXRzIHZpc2liaWxpdHkgb2YgdGhlIGxhYmVsLCBpY29uLCBhbmQgdGV4dCBzbyB0aGF0IGl0IGNhbiBiZSBoaWRkZW4gaWYgbmVjZXNzYXJ5LiBJZiB1c2luZ1xyXG4gICAqIEtleWJvYXJkSGVscFNlY3Rpb24sIHRoaXMgd2lsbCBhbHNvIGNvcnJlY3RseSBsYXlvdXQgdGhlIGNvbnRlbnQgYmVjYXVzZSBvZiBzY2VuZXJ5IGR5bmFtaWMgbGF5b3V0LlxyXG4gICAqL1xyXG4gIHB1YmxpYyBzZXRDb250ZW50c1Zpc2libGUoIHZpc2libGU6IGJvb2xlYW4gKTogdm9pZCB7XHJcbiAgICB0aGlzLnRleHQudmlzaWJsZSA9IHZpc2libGU7XHJcbiAgICB0aGlzLmxhYmVsLnZpc2libGUgPSB2aXNpYmxlO1xyXG4gICAgdGhpcy5pY29uLnZpc2libGUgPSB2aXNpYmxlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSG9yaXpvbnRhbGx5IGFsaWduIGEgbGFiZWwgYW5kIGFuIGljb24sIHdpdGggdGhlIGxhYmVsIG9uIHRoZSBsZWZ0IGFuZCB0aGUgaWNvbiBvbiB0aGUgcmlnaHQuIEFsaWduR3JvdXAgaXMgdXNlZFxyXG4gICAqIHRvIGdpdmUgdGhlIGxhYmVsIGFuZCBpY29uIGlkZW50aWNhbCBkaW1lbnNpb25zIGZvciBlYXN5IGxheW91dCBpbiBLZXlib2FyZEhlbHBTZWN0aW9uLlxyXG4gICAqL1xyXG4gIHB1YmxpYyBzdGF0aWMgbGFiZWxXaXRoSWNvbiggbGFiZWxTdHJpbmc6IHN0cmluZyB8IFRSZWFkT25seVByb3BlcnR5PHN0cmluZz4sIGljb246IE5vZGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlZE9wdGlvbnM/OiBMYWJlbFdpdGhJY29uT3B0aW9ucyApOiBLZXlib2FyZEhlbHBTZWN0aW9uUm93IHtcclxuICAgIGNvbnN0IG9wdGlvbnMgPSBvcHRpb25pemU8TGFiZWxXaXRoSWNvbk9wdGlvbnM+KCkoIHtcclxuICAgICAgbGFiZWxJbm5lckNvbnRlbnQ6IG51bGwsXHJcbiAgICAgIHJlYWRpbmdCbG9ja0NvbnRlbnQ6IG51bGwsXHJcblxyXG4gICAgICBsYWJlbE9wdGlvbnM6IHtcclxuICAgICAgICBmb250OiBMQUJFTF9GT05UXHJcbiAgICAgIH0sXHJcblxyXG4gICAgICBpY29uT3B0aW9uczoge1xyXG4gICAgICAgIHRhZ05hbWU6ICdsaSdcclxuICAgICAgfVxyXG4gICAgfSwgcHJvdmlkZWRPcHRpb25zICk7XHJcblxyXG4gICAgY29uc3QgbGFiZWxUZXh0ID0gbmV3IFJpY2hUZXh0KCBsYWJlbFN0cmluZywgb3B0aW9ucy5sYWJlbE9wdGlvbnMgKTtcclxuXHJcbiAgICAvLyBtYWtlIHRoZSBsYWJlbCBhbmQgaWNvbiB0aGUgc2FtZSBoZWlnaHQgc28gdGhhdCB0aGV5IHdpbGwgYWxpZ24gd2hlbiB3ZSBhc3NlbWJsZSBoZWxwIHNlY3Rpb24gZ3JvdXBcclxuICAgIGNvbnN0IGxhYmVsSWNvbkdyb3VwID0gbmV3IEFsaWduR3JvdXAoIHsgbWF0Y2hIb3Jpem9udGFsOiBmYWxzZSB9ICk7XHJcbiAgICBjb25zdCBsYWJlbEJveCA9IGxhYmVsSWNvbkdyb3VwLmNyZWF0ZUJveCggbGFiZWxUZXh0ICk7XHJcbiAgICBjb25zdCBpY29uQm94ID0gbGFiZWxJY29uR3JvdXAuY3JlYXRlQm94KCBuZXcgTm9kZSggeyBjaGlsZHJlbjogWyBpY29uIF0gfSApLCBvcHRpb25zLmljb25PcHRpb25zICk7XHJcblxyXG4gICAgaWNvbkJveC5pbm5lckNvbnRlbnQgPSBvcHRpb25zLmxhYmVsSW5uZXJDb250ZW50O1xyXG5cclxuICAgIHJldHVybiBuZXcgS2V5Ym9hcmRIZWxwU2VjdGlvblJvdyggbGFiZWxUZXh0LCBsYWJlbEJveCwgaWNvbkJveCwge1xyXG4gICAgICByZWFkaW5nQmxvY2tDb250ZW50OiBvcHRpb25zLnJlYWRpbmdCbG9ja0NvbnRlbnQgfHwgb3B0aW9ucy5sYWJlbElubmVyQ29udGVudFxyXG4gICAgfSApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhIHJvdyB3aXRoIG9uZSBvciBtb3JlIGtleXMsIHdpdGgga2V5cyBzZXBhcmF0ZWQgYnkgJysnLlxyXG4gICAqIEBwYXJhbSBrZXlTdHJpbmdzIC0gZWFjaCBzaG91bGQgYmUgYSBsZXR0ZXIga2V5XHJcbiAgICogQHBhcmFtIGxhYmVsU3RyaW5nXHJcbiAgICogQHBhcmFtIFtwcm92aWRlZE9wdGlvbnNdXHJcbiAgICovXHJcbiAgcHVibGljIHN0YXRpYyBjcmVhdGVLZXlzUm93RnJvbVN0cmluZ3MoIGtleVN0cmluZ3M6IHN0cmluZ1tdLCBsYWJlbFN0cmluZzogc3RyaW5nIHwgVFJlYWRPbmx5UHJvcGVydHk8c3RyaW5nPixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZWRPcHRpb25zPzogTGFiZWxXaXRoSWNvbk9wdGlvbnMgKTogS2V5Ym9hcmRIZWxwU2VjdGlvblJvdyB7XHJcbiAgICByZXR1cm4gS2V5Ym9hcmRIZWxwU2VjdGlvblJvdy5jcmVhdGVLZXlzUm93KCBrZXlTdHJpbmdzLm1hcCgga2V5ID0+IG5ldyBMZXR0ZXJLZXlOb2RlKCBrZXkgKSApLCBsYWJlbFN0cmluZywgcHJvdmlkZWRPcHRpb25zICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIGEgcm93IHdpdGggb25lIG9yIG1vcmUga2V5cywgd2l0aCBrZXlzIHNlcGFyYXRlZCBieSAnKycuXHJcbiAgICovXHJcbiAgcHVibGljIHN0YXRpYyBjcmVhdGVLZXlzUm93KCBrZXlJY29uczogTm9kZVtdLCBsYWJlbFN0cmluZzogc3RyaW5nIHwgVFJlYWRPbmx5UHJvcGVydHk8c3RyaW5nPixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVkT3B0aW9ucz86IExhYmVsV2l0aEljb25PcHRpb25zICk6IEtleWJvYXJkSGVscFNlY3Rpb25Sb3cge1xyXG4gICAgYXNzZXJ0ICYmIGFzc2VydCgga2V5SWNvbnMubGVuZ3RoID4gMCwgJ2V4cGVjdGVkIGtleXMnICk7XHJcbiAgICBsZXQga2V5c05vZGU6IE5vZGUgfCBudWxsID0gbnVsbDtcclxuICAgIGZvciAoIGxldCBpID0gMDsgaSA8IGtleUljb25zLmxlbmd0aDsgaSsrICkge1xyXG4gICAgICBjb25zdCBrZXlOb2RlID0ga2V5SWNvbnNbIGkgXTtcclxuXHJcbiAgICAgIC8vIENvbnRpbnVlIHRvIFwiYWRkXCIgbW9yZSBpY29ucyB0byB0aGUgZW5kIG9mIHRoZSBrZXlzTm9kZSB3aXRoIGljb25QbHVzSWNvbiB1bnRpbCB3ZSBnbyB0aHJvdWdoIGFsbCBrZXlJY29ucy5cclxuICAgICAgLy8gSWYgdGhlcmUgaXMgb25seSBvbmUga2V5SWNvbiBpdCB3aWxsIGp1c3QgYmUgcmV0dXJuZWQgd2l0aG91dCBhbnkgJysnIGljb25zLlxyXG4gICAgICBrZXlzTm9kZSA9IGtleXNOb2RlID8gS2V5Ym9hcmRIZWxwSWNvbkZhY3RvcnkuaWNvblBsdXNJY29uKCBrZXlzTm9kZSwga2V5Tm9kZSApIDoga2V5Tm9kZTtcclxuICAgIH1cclxuXHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCBrZXlzTm9kZSwgJ2tleXNOb2RlIG11c3QgYmUgZGVmaW5lZCBzaW5jZSB0aGVyZSB3ZXJlIG1vcmUgdGhhbiB6ZXJvIGtleUljb25zLicgKTtcclxuICAgIHJldHVybiBLZXlib2FyZEhlbHBTZWN0aW9uUm93LmxhYmVsV2l0aEljb24oIGxhYmVsU3RyaW5nLCBrZXlzTm9kZSEsIHByb3ZpZGVkT3B0aW9ucyApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlIGFuIGVudHJ5IGZvciB0aGUgZGlhbG9nIHRoYXQgbG9va3MgaG9yaXpvbnRhbGx5IGFsaWducyBhIGxldHRlciBrZXkgd2l0aCBhICdKJyBrZXkgc2VwYXJhdGVkIGJ5IGEgcGx1c1xyXG4gICAqIHNpZ24sIHdpdGggYSBkZXNjcmlwdGl2ZSBsYWJlbC4gU29tZXRoaW5nIGxpa2U6ICAgKiBcIkogKyBTIGp1bXBzIGNsb3NlIHRvIHN3ZWF0ZXJcIlxyXG4gICAqIEBwYXJhbSBrZXlTdHJpbmcgLSB0aGUgbGV0dGVyIG5hbWUgdGhhdCB3aWxsIGNvbWUgYWZ0ZXIgJ0onLCBub3RlIHRoaXMgY2FuIGJlIGhhcmQgY29kZWQsIG5vIG5lZWQgZm9yIGkxOG4uXHJcbiAgICogQHBhcmFtIGxhYmVsU3RyaW5nIC0gdmlzdWFsIGxhYmVsXHJcbiAgICogQHBhcmFtIFtwcm92aWRlZE9wdGlvbnNdXHJcbiAgICovXHJcbiAgcHVibGljIHN0YXRpYyBjcmVhdGVKdW1wS2V5Um93KCBrZXlTdHJpbmc6IHN0cmluZywgbGFiZWxTdHJpbmc6IHN0cmluZyB8IFRSZWFkT25seVByb3BlcnR5PHN0cmluZz4sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlZE9wdGlvbnM/OiBMYWJlbFdpdGhJY29uT3B0aW9ucyApOiBLZXlib2FyZEhlbHBTZWN0aW9uUm93IHtcclxuICAgIHJldHVybiBLZXlib2FyZEhlbHBTZWN0aW9uUm93LmNyZWF0ZUtleXNSb3dGcm9tU3RyaW5ncyggWyAnSicsIGtleVN0cmluZyBdLCBsYWJlbFN0cmluZywgcHJvdmlkZWRPcHRpb25zICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGUgYSBLZXlib2FyZEhlbHBTZWN0aW9uUm93IHRoYXQgZGVzY3JpYmVzIGhvdyB0byBwbGF5IGFuZCBwYXVzZSB0aGUgc2ltIHdpdGggdGhlIFwiQWx0XCIgKyBcIktcIiBob3RrZXkuXHJcbiAgICovXHJcbiAgcHVibGljIHN0YXRpYyBjcmVhdGVQbGF5UGF1c2VLZXlSb3coIGxhYmVsU3RyaW5nOiBzdHJpbmcgfCBUUmVhZE9ubHlQcm9wZXJ0eTxzdHJpbmc+LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlZE9wdGlvbnM/OiBMYWJlbFdpdGhJY29uT3B0aW9ucyApOiBLZXlib2FyZEhlbHBTZWN0aW9uUm93IHtcclxuICAgIHJldHVybiBLZXlib2FyZEhlbHBTZWN0aW9uUm93LmNyZWF0ZUdsb2JhbEhvdGtleVJvdyggbGFiZWxTdHJpbmcsIFNjZW5lcnlQaGV0U3RyaW5ncy5rZXkua1N0cmluZ1Byb3BlcnR5LCBwcm92aWRlZE9wdGlvbnMgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhIEtleWJvYXJkSGVscFNlY3Rpb25Sb3cgdGhhdCBkZXNjcmliZXMgaG93IHRvIHN0ZXAgZm9yd2FyZCB0aGUgc2ltIHdpdGggdGhlIFwiQWx0XCIgKyBcIkxcIiBob3RrZXlzLlxyXG4gICAqL1xyXG4gIHB1YmxpYyBzdGF0aWMgY3JlYXRlU3RlcEZvcndhcmRLZXlSb3coIGxhYmVsU3RyaW5nOiBzdHJpbmcgfCBUUmVhZE9ubHlQcm9wZXJ0eTxzdHJpbmc+LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVkT3B0aW9ucz86IExhYmVsV2l0aEljb25PcHRpb25zICk6IEtleWJvYXJkSGVscFNlY3Rpb25Sb3cge1xyXG4gICAgcmV0dXJuIEtleWJvYXJkSGVscFNlY3Rpb25Sb3cuY3JlYXRlR2xvYmFsSG90a2V5Um93KCBsYWJlbFN0cmluZywgU2NlbmVyeVBoZXRTdHJpbmdzLmtleS5sU3RyaW5nUHJvcGVydHksIHByb3ZpZGVkT3B0aW9ucyApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlIGEgS2V5Ym9hcmRIZWxwU2VjdGlvblJvdyB0aGF0IGRlc2NyaWJlcyBob3cgdG8gdXNlIGEgZ2xvYmFsIGhvdGtleS4gR2xvYmFsIGhvdGtleXMgYXJlIHRyaWdnZXJlZCB3aXRoIFwiQWx0XCIgcGx1c1xyXG4gICAqIHNvbWUgb3RoZXIga2V5LCB0byBiZSBwcm92aWRlZC5cclxuICAgKi9cclxuICBwdWJsaWMgc3RhdGljIGNyZWF0ZUdsb2JhbEhvdGtleVJvdyggbGFiZWxTdHJpbmc6IHN0cmluZyB8IFRSZWFkT25seVByb3BlcnR5PHN0cmluZz4sIGtleVN0cmluZzogc3RyaW5nIHwgVFJlYWRPbmx5UHJvcGVydHk8c3RyaW5nPixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZWRPcHRpb25zPzogTGFiZWxXaXRoSWNvbk9wdGlvbnMgKTogS2V5Ym9hcmRIZWxwU2VjdGlvblJvdyB7XHJcbiAgICByZXR1cm4gS2V5Ym9hcmRIZWxwU2VjdGlvblJvdy5jcmVhdGVLZXlzUm93KCBbIFRleHRLZXlOb2RlLmFsdE9yT3B0aW9uKCksIG5ldyBMZXR0ZXJLZXlOb2RlKCBrZXlTdHJpbmcgKSBdLCBsYWJlbFN0cmluZywgcHJvdmlkZWRPcHRpb25zICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGUgYSBsYWJlbCB3aXRoIGEgbGlzdCBvZiBpY29ucy4gVGhlIGljb25zIHdpbGwgYmUgdmVydGljYWxseSBhbGlnbmVkLCBlYWNoIHNlcGFyYXRlZCBieSAnb3InIHRleHQuIFRoZVxyXG4gICAqIGxhYmVsIHdpbGwgYmUgdmVydGljYWxseSBjZW50ZXJlZCB3aXRoIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBsaXN0IG9mIGljb25zLiBUbyB2ZXJ0aWNhbGx5IGFsaWduIHRoZSBsYWJlbFxyXG4gICAqIHdpdGggdGhlIGZpcnN0IGljb24sIEFsaWduR3JvdXAgaXMgdXNlZC4gRmluYWxseSwgYW4gQWxpZ25Hcm91cCBpcyB1c2VkIHRvIG1ha2UgdGhlIGxhYmVsXHJcbiAgICogY29udGVudCBtYXRjaCBoZWlnaHQgd2l0aCB0aGUgZW50aXJlIGljb24gbGlzdC4gV2hlbiBhc3NlbWJsZWQsIHRoZSBsYWJlbCB3aXRoIGljb24gbGlzdCB3aWxsIGxvb2sgbGlrZTpcclxuICAgKlxyXG4gICAqIFRoaXMgaXMgdGhlIGxhYmVsOiBJY29uMSBvclxyXG4gICAqICAgICAgICAgICAgICAgICAgICBJY29uMiBvclxyXG4gICAqICAgICAgICAgICAgICAgICAgICBJY29uM1xyXG4gICAqL1xyXG4gIHB1YmxpYyBzdGF0aWMgbGFiZWxXaXRoSWNvbkxpc3QoIGxhYmVsU3RyaW5nOiBzdHJpbmcgfCBUUmVhZE9ubHlQcm9wZXJ0eTxzdHJpbmc+LCBpY29uczogTm9kZVtdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVkT3B0aW9ucz86IExhYmVsV2l0aEljb25MaXN0T3B0aW9ucyApOiBLZXlib2FyZEhlbHBTZWN0aW9uUm93IHtcclxuXHJcbiAgICBjb25zdCBvcHRpb25zID0gb3B0aW9uaXplPExhYmVsV2l0aEljb25MaXN0T3B0aW9ucz4oKSgge1xyXG4gICAgICBsYWJlbElubmVyQ29udGVudDogbnVsbCxcclxuICAgICAgcmVhZGluZ0Jsb2NrQ29udGVudDogbnVsbCxcclxuICAgICAgaWNvbnNWQm94T3B0aW9uczoge30sXHJcbiAgICAgIGxhYmVsT3B0aW9uczoge1xyXG4gICAgICAgIGZvbnQ6IExBQkVMX0ZPTlRcclxuICAgICAgfVxyXG4gICAgfSwgcHJvdmlkZWRPcHRpb25zICk7XHJcblxyXG4gICAgb3B0aW9ucy5pY29uc1ZCb3hPcHRpb25zID0gY29tYmluZU9wdGlvbnM8VkJveE9wdGlvbnM+KCB7XHJcbiAgICAgIHNwYWNpbmc6IEtleWJvYXJkSGVscFNlY3Rpb24uREVGQVVMVF9WRVJUSUNBTF9JQ09OX1NQQUNJTkcgKiAwLjc1LCAvLyBsZXNzIHRoYW4gdGhlIG5vcm1hbCB2ZXJ0aWNhbCBpY29uIHNwYWNpbmcgc2luY2UgaXQgaXMgYSBncm91cFxyXG4gICAgICBhbGlnbjogJ2xlZnQnLFxyXG5cclxuICAgICAgLy8gcGRvbSAtIGVhY2ggaWNvbiB3aWxsIGJlIHByZXNlbnRlZCBhcyBhIGxpc3QgaXRlbSB1bmRlciB0aGUgcGFyZW50ICd1bCcgb2YgdGhlIEtleWJvYXJkSGVscFNlY3Rpb25Sb3cuXHJcbiAgICAgIHRhZ05hbWU6ICdsaScsXHJcbiAgICAgIGlubmVyQ29udGVudDogb3B0aW9ucy5sYWJlbElubmVyQ29udGVudFxyXG4gICAgfSwgb3B0aW9ucy5pY29uc1ZCb3hPcHRpb25zICk7XHJcblxyXG4gICAgY29uc3QgbGFiZWxUZXh0ID0gbmV3IFJpY2hUZXh0KCBsYWJlbFN0cmluZywgb3B0aW9ucy5sYWJlbE9wdGlvbnMgKTtcclxuXHJcbiAgICAvLyBob3Jpem9udGFsbHkgYWxpZ24gdGhlIGxhYmVsIHdpdGggdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIGxpc3Qgb2YgaWNvbnMsIGd1YXJhbnRlZXMgdGhhdCB0aGUgbGFiZWwgYW5kIGZpcnN0XHJcbiAgICAvLyBpY29uIGhhdmUgaWRlbnRpY2FsIGhlaWdodHNcclxuICAgIGNvbnN0IGxhYmVsRmlyc3RJY29uR3JvdXAgPSBuZXcgQWxpZ25Hcm91cCggeyBtYXRjaEhvcml6b250YWw6IGZhbHNlIH0gKTtcclxuICAgIGxhYmVsRmlyc3RJY29uR3JvdXAuY3JlYXRlQm94KCBuZXcgTm9kZSggeyBjaGlsZHJlbjogWyBpY29uc1sgMCBdIF0gfSApICk7IC8vIGNyZWF0ZSB0aGUgYm94IHRvIHJlc3RyYWluIGJvdW5kcywgYnV0IGEgcmVmZXJlbmNlIGlzbid0IG5lY2Vzc2FyeVxyXG4gICAgY29uc3QgbGFiZWxCb3ggPSBsYWJlbEZpcnN0SWNvbkdyb3VwLmNyZWF0ZUJveCggbGFiZWxUZXh0ICk7XHJcblxyXG4gICAgY29uc3QgaWNvbnNXaXRoT3JUZXh0ID0gW107XHJcblxyXG4gICAgLy8gZm9yIGVhY2ggb2YgdGhlIGljb25zIChleGNsdWRpbmcgdGhlIGxhc3Qgb25lLCBhZGQgYSB2ZXJ0aWNhbGx5IGFsaWduZWQgJ29yJyB0ZXh0IHRvIHRoZSByaWdodFxyXG4gICAgZm9yICggbGV0IGkgPSAwOyBpIDwgaWNvbnMubGVuZ3RoIC0gMTsgaSsrICkge1xyXG4gICAgICBjb25zdCBvclRleHQgPSBuZXcgVGV4dCggU2NlbmVyeVBoZXRTdHJpbmdzLmtleWJvYXJkSGVscERpYWxvZy5vclN0cmluZ1Byb3BlcnR5LCB7XHJcbiAgICAgICAgZm9udDogTEFCRUxfRk9OVCxcclxuICAgICAgICBtYXhXaWR0aDogT1JfVEVYVF9NQVhfV0lEVEhcclxuICAgICAgfSApO1xyXG5cclxuICAgICAgLy8gcGxhY2Ugb3JUZXh0IHdpdGggdGhlIGljb24gaW4gYW4gSEJveFxyXG4gICAgICBjb25zdCBoQm94ID0gbmV3IEhCb3goIHtcclxuICAgICAgICBjaGlsZHJlbjogWyBuZXcgTm9kZSggeyBjaGlsZHJlbjogWyBpY29uc1sgaSBdIF0gfSApLCBvclRleHQgXSxcclxuICAgICAgICBzcGFjaW5nOiBLZXlib2FyZEhlbHBJY29uRmFjdG9yeS5ERUZBVUxUX0lDT05fU1BBQ0lOR1xyXG4gICAgICB9ICk7XHJcbiAgICAgIGljb25zV2l0aE9yVGV4dC5wdXNoKCBoQm94ICk7XHJcbiAgICB9XHJcbiAgICBpY29uc1dpdGhPclRleHQucHVzaCggaWNvbnNbIGljb25zLmxlbmd0aCAtIDEgXSApO1xyXG5cclxuICAgIC8vIHBsYWNlIGljb25zIGluIGEgVkJveCwgcGFzc2luZyB0aHJvdWdoIG9wdGlvbmFsIHNwYWNpbmcgYW5kIGExMXkgcmVwcmVzZW50YXRpb25cclxuICAgIGNvbnN0IGljb25zVkJveCA9IG5ldyBWQm94KCBjb21iaW5lT3B0aW9uczxWQm94T3B0aW9ucz4oIHtcclxuICAgICAgY2hpbGRyZW46IGljb25zV2l0aE9yVGV4dFxyXG4gICAgfSwgb3B0aW9ucy5pY29uc1ZCb3hPcHRpb25zICkgKTtcclxuXHJcbiAgICAvLyBtYWtlIHRoZSBsYWJlbCB0aGUgc2FtZSBoZWlnaHQgYXMgdGhlIGljb24gbGlzdCBieSBhbGlnbmluZyB0aGVtIGluIGEgYm94IHRoYXQgbWF0Y2hlcyBoZWlnaHRcclxuICAgIGNvbnN0IGdyb3VwT3B0aW9uczogQWxpZ25Cb3hPcHRpb25zID0geyB5QWxpZ246ICd0b3AnIH07XHJcbiAgICBjb25zdCBsYWJlbEljb25MaXN0R3JvdXAgPSBuZXcgQWxpZ25Hcm91cCggeyBtYXRjaEhvcml6b250YWw6IGZhbHNlIH0gKTtcclxuICAgIGNvbnN0IGljb25zQm94ID0gbGFiZWxJY29uTGlzdEdyb3VwLmNyZWF0ZUJveCggaWNvbnNWQm94LCBncm91cE9wdGlvbnMgKTsgLy8gY3JlYXRlIHRoZSBib3ggdG8gbWF0Y2ggaGVpZ2h0LCBidXQgcmVmZXJlbmNlIG5vdCBuZWNlc3NhcnlcclxuICAgIGNvbnN0IGxhYmVsV2l0aEhlaWdodEJveCA9IGxhYmVsSWNvbkxpc3RHcm91cC5jcmVhdGVCb3goIGxhYmVsQm94LCBncm91cE9wdGlvbnMgKTtcclxuXHJcbiAgICByZXR1cm4gbmV3IEtleWJvYXJkSGVscFNlY3Rpb25Sb3coIGxhYmVsVGV4dCwgbGFiZWxXaXRoSGVpZ2h0Qm94LCBpY29uc0JveCwge1xyXG4gICAgICByZWFkaW5nQmxvY2tDb250ZW50OiBvcHRpb25zLnJlYWRpbmdCbG9ja0NvbnRlbnQgfHwgb3B0aW9ucy5sYWJlbElubmVyQ29udGVudFxyXG4gICAgfSApO1xyXG4gIH1cclxufVxyXG5cclxuc2NlbmVyeVBoZXQucmVnaXN0ZXIoICdLZXlib2FyZEhlbHBTZWN0aW9uUm93JywgS2V5Ym9hcmRIZWxwU2VjdGlvblJvdyApO1xyXG5leHBvcnQgZGVmYXVsdCBLZXlib2FyZEhlbHBTZWN0aW9uUm93OyJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQSxPQUFPQSxTQUFTLElBQUlDLGNBQWMsUUFBUSx1Q0FBdUM7QUFFakYsU0FBMEJDLFVBQVUsRUFBRUMsSUFBSSxFQUFFQyxJQUFJLEVBQWlCQyxRQUFRLEVBQW1CQyxJQUFJLEVBQUVDLElBQUksUUFBcUIsbUNBQW1DO0FBRTlKLE9BQU9DLFFBQVEsTUFBTSxtQkFBbUI7QUFDeEMsT0FBT0MsV0FBVyxNQUFNLHNCQUFzQjtBQUM5QyxPQUFPQyxrQkFBa0IsTUFBTSw2QkFBNkI7QUFDNUQsT0FBT0MsYUFBYSxNQUFNLHFCQUFxQjtBQUMvQyxPQUFPQyxXQUFXLE1BQU0sbUJBQW1CO0FBQzNDLE9BQU9DLHVCQUF1QixNQUFNLDhCQUE4QjtBQUNsRSxPQUFPQyxtQkFBbUIsTUFBTSwwQkFBMEI7O0FBRTFEO0FBQ0EsTUFBTUMsVUFBVSxHQUFHLElBQUlQLFFBQVEsQ0FBRSxFQUFHLENBQUM7QUFDckMsTUFBTVEsaUJBQWlCLEdBQUcsRUFBRTs7QUFFNUI7O0FBa0JBOztBQXlCQSxNQUFNQyxzQkFBc0IsQ0FBQztFQUUzQjtFQUNBOztFQUdBOztFQUdBOztFQUdBO0VBQ0E7O0VBR0E7RUFDQSxPQUF1QkYsVUFBVSxHQUFHQSxVQUFVO0VBRXZDRyxXQUFXQSxDQUFFQyxJQUFxQixFQUFFQyxLQUFXLEVBQUVDLElBQVUsRUFBRUMsZUFBK0MsRUFBRztJQUNwSCxNQUFNQyxPQUFPLEdBQUd2QixTQUFTLENBQTZDLENBQUMsQ0FBRTtNQUN2RXdCLG1CQUFt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