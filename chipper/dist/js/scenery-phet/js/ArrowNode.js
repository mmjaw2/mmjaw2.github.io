// Copyright 2013-2024, University of Colorado Boulder

/**
 * A single- or double-headed arrow. This is a convenience class, most of the work is done in ArrowShape.
 *
 * @author John Blanco
 * @author Chris Malley (PixelZoom, Inc.)
 * @author Aaron Davis
 * @author Sam Reid (PhET Interactive Simulations)
 */

import { Shape } from '../../kite/js/imports.js';
import InstanceRegistry from '../../phet-core/js/documentation/InstanceRegistry.js';
import optionize from '../../phet-core/js/optionize.js';
import { Path } from '../../scenery/js/imports.js';
import ArrowShape from './ArrowShape.js';
import sceneryPhet from './sceneryPhet.js';
export default class ArrowNode extends Path {
  // Get these fields using ES5 getters.
  constructor(tailX, tailY, tipX, tipY, providedOptions) {
    // default options
    const options = optionize()({
      headHeight: 10,
      headWidth: 10,
      tailWidth: 5,
      isHeadDynamic: false,
      scaleTailToo: false,
      fractionalHeadHeight: 0.5,
      // head will be scaled when headHeight is greater than fractionalHeadHeight * arrow length
      doubleHead: false,
      // true puts heads on both ends of the arrow, false puts a head at the tip

      // Path options
      fill: 'black',
      stroke: 'black',
      lineWidth: 1
    }, providedOptions);

    // things you're likely to mess up, add more as needed
    assert && assert(options.headWidth > options.tailWidth);
    super(null);
    this.options = options;
    this.shapePoints = [];
    this._tailX = tailX;
    this._tailY = tailY;
    this._tipX = tipX;
    this._tipY = tipY;
    this.setTailAndTip(tailX, tailY, tipX, tipY);
    this.mutate(options);

    // support for binder documentation, stripped out in builds and only runs when ?binder is specified
    assert && phet?.chipper?.queryParameters?.binder && InstanceRegistry.registerDataURL('scenery-phet', 'ArrowNode', this);
  }

  // Set these fields using setTail, setTip, setTailAndTip.

  get tailX() {
    return this._tailX;
  }
  get tailY() {
    return this._tailY;
  }
  get tipX() {
    return this._tipX;
  }
  get tipY() {
    return this._tipY;
  }

  /**
   * Sets the tail and tip positions to update the arrow shape.
   * If the tail and tip are at the same point, the arrow is not shown.
   */
  setTailAndTip(tailX, tailY, tipX, tipY) {
    this._tailX = tailX;
    this._tailY = tailY;
    this._tipX = tipX;
    this._tipY = tipY;
    const numberOfPointsChanged = this.updateShapePoints();

    // This bit of logic is to improve performance for the case where the Shape instance can be reused
    // (if the number of points in the array is the same).
    if (!this.shape || numberOfPointsChanged) {
      this.updateShape();
    } else {
      // This is the higher-performance case where the Shape instance can be reused
      this.shape.invalidatePoints();
    }
  }

  /**
   * Initialize or update the shape. Only called if the number of points in the shape changes.
   */
  updateShape() {
    const shape = new Shape();
    if (this.shapePoints.length > 1) {
      shape.moveToPoint(this.shapePoints[0]);
      for (let i = 1; i < this.shapePoints.length; i++) {
        shape.lineToPoint(this.shapePoints[i]);
      }
      shape.close();
    }
    this.shape = shape;
  }

  /**
   * Sets the tail position.
   */
  setTail(tailX, tailY) {
    this.setTailAndTip(tailX, tailY, this._tipX, this._tipY);
  }

  /**
   * Sets the tip position.
   */
  setTip(tipX, tipY) {
    this.setTailAndTip(this._tailX, this._tailY, tipX, tipY);
  }

  /**
   * Update the internal shapePoints array which is used to populate the points in the Shape instance.
   * Returns true if the number of points in the array has changed, which would require building a new shape instance.
   */
  updateShapePoints() {
    const numberOfPoints = this.shapePoints.length;
    this.shapePoints = ArrowShape.getArrowShapePoints(this._tailX, this._tailY, this._tipX, this._tipY, this.shapePoints, this.options);
    return this.shapePoints.length !== numberOfPoints;
  }

  /**
   * Sets the tail width.
   */
  setTailWidth(tailWidth) {
    this.options.tailWidth = tailWidth;
    this.updateShapePoints();
    this.updateShape();
  }

  /**
   * Sets whether the arrow has one or two heads.
   */
  setDoubleHead(doubleHead) {
    this.options.doubleHead = doubleHead;
    this.updateShapePoints();
    this.updateShape();
  }
}
sceneryPhet.register('ArrowNode', ArrowNode);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJTaGFwZSIsIkluc3RhbmNlUmVnaXN0cnkiLCJvcHRpb25pemUiLCJQYXRoIiwiQXJyb3dTaGFwZSIsInNjZW5lcnlQaGV0IiwiQXJyb3dOb2RlIiwiY29uc3RydWN0b3IiLCJ0YWlsWCIsInRhaWxZIiwidGlwWCIsInRpcFkiLCJwcm92aWRlZE9wdGlvbnMiLCJvcHRpb25zIiwiaGVhZEhlaWdodCIsImhlYWRXaWR0aCIsInRhaWxXaWR0aCIsImlzSGVhZER5bmFtaWMiLCJzY2FsZVRhaWxUb28iLCJmcmFjdGlvbmFsSGVhZEhlaWdodCIsImRvdWJsZUhlYWQiLCJmaWxsIiwic3Ryb2tlIiwibGluZVdpZHRoIiwiYXNzZXJ0Iiwic2hhcGVQb2ludHMiLCJfdGFpbFgiLCJfdGFpbFkiLCJfdGlwWCIsIl90aXBZIiwic2V0VGFpbEFuZFRpcCIsIm11dGF0ZSIsInBoZXQiLCJjaGlwcGVyIiwicXVlcnlQYXJhbWV0ZXJzIiwiYmluZGVyIiwicmVnaXN0ZXJEYXRhVVJMIiwibnVtYmVyT2ZQb2ludHNDaGFuZ2VkIiwidXBkYXRlU2hhcGVQb2ludHMiLCJzaGFwZSIsInVwZGF0ZVNoYXBlIiwiaW52YWxpZGF0ZVBvaW50cyIsImxlbmd0aCIsIm1vdmVUb1BvaW50IiwiaSIsImxpbmVUb1BvaW50IiwiY2xvc2UiLCJzZXRUYWlsIiwic2V0VGlwIiwibnVtYmVyT2ZQb2ludHMiLCJnZXRBcnJvd1NoYXBlUG9pbnRzIiwic2V0VGFpbFdpZHRoIiwic2V0RG91YmxlSGVhZCIsInJlZ2lzdGVyIl0sInNvdXJjZXMiOlsiQXJyb3dOb2RlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDEzLTIwMjQsIFVuaXZlcnNpdHkgb2YgQ29sb3JhZG8gQm91bGRlclxyXG5cclxuLyoqXHJcbiAqIEEgc2luZ2xlLSBvciBkb3VibGUtaGVhZGVkIGFycm93LiBUaGlzIGlzIGEgY29udmVuaWVuY2UgY2xhc3MsIG1vc3Qgb2YgdGhlIHdvcmsgaXMgZG9uZSBpbiBBcnJvd1NoYXBlLlxyXG4gKlxyXG4gKiBAYXV0aG9yIEpvaG4gQmxhbmNvXHJcbiAqIEBhdXRob3IgQ2hyaXMgTWFsbGV5IChQaXhlbFpvb20sIEluYy4pXHJcbiAqIEBhdXRob3IgQWFyb24gRGF2aXNcclxuICogQGF1dGhvciBTYW0gUmVpZCAoUGhFVCBJbnRlcmFjdGl2ZSBTaW11bGF0aW9ucylcclxuICovXHJcblxyXG5pbXBvcnQgVmVjdG9yMiBmcm9tICcuLi8uLi9kb3QvanMvVmVjdG9yMi5qcyc7XHJcbmltcG9ydCB7IFNoYXBlIH0gZnJvbSAnLi4vLi4va2l0ZS9qcy9pbXBvcnRzLmpzJztcclxuaW1wb3J0IEluc3RhbmNlUmVnaXN0cnkgZnJvbSAnLi4vLi4vcGhldC1jb3JlL2pzL2RvY3VtZW50YXRpb24vSW5zdGFuY2VSZWdpc3RyeS5qcyc7XHJcbmltcG9ydCBvcHRpb25pemUgZnJvbSAnLi4vLi4vcGhldC1jb3JlL2pzL29wdGlvbml6ZS5qcyc7XHJcbmltcG9ydCB7IFBhdGgsIFBhdGhPcHRpb25zIH0gZnJvbSAnLi4vLi4vc2NlbmVyeS9qcy9pbXBvcnRzLmpzJztcclxuaW1wb3J0IEFycm93U2hhcGUgZnJvbSAnLi9BcnJvd1NoYXBlLmpzJztcclxuaW1wb3J0IHNjZW5lcnlQaGV0IGZyb20gJy4vc2NlbmVyeVBoZXQuanMnO1xyXG5cclxudHlwZSBTZWxmT3B0aW9ucyA9IHtcclxuICBoZWFkSGVpZ2h0PzogbnVtYmVyO1xyXG4gIGhlYWRXaWR0aD86IG51bWJlcjtcclxuICB0YWlsV2lkdGg/OiBudW1iZXI7XHJcbiAgaXNIZWFkRHluYW1pYz86IGJvb2xlYW47XHJcbiAgc2NhbGVUYWlsVG9vPzogYm9vbGVhbjtcclxuXHJcbiAgLy8gaGVhZCB3aWxsIGJlIHNjYWxlZCB3aGVuIGhlYWRIZWlnaHQgaXMgZ3JlYXRlciB0aGFuIGZyYWN0aW9uYWxIZWFkSGVpZ2h0ICogYXJyb3cgbGVuZ3RoXHJcbiAgZnJhY3Rpb25hbEhlYWRIZWlnaHQ/OiBudW1iZXI7XHJcblxyXG4gIC8vIHRydWUgcHV0cyBoZWFkcyBvbiBib3RoIGVuZHMgb2YgdGhlIGFycm93LCBmYWxzZSBwdXRzIGEgaGVhZCBhdCB0aGUgdGlwXHJcbiAgZG91YmxlSGVhZD86IGJvb2xlYW47XHJcbn07XHJcblxyXG5leHBvcnQgdHlwZSBBcnJvd05vZGVPcHRpb25zID0gU2VsZk9wdGlvbnMgJiBQYXRoT3B0aW9ucztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFycm93Tm9kZSBleHRlbmRzIFBhdGgge1xyXG5cclxuICAvLyBHZXQgdGhlc2UgZmllbGRzIHVzaW5nIEVTNSBnZXR0ZXJzLlxyXG4gIHB1YmxpYyBjb25zdHJ1Y3RvciggdGFpbFg6IG51bWJlciwgdGFpbFk6IG51bWJlciwgdGlwWDogbnVtYmVyLCB0aXBZOiBudW1iZXIsIHByb3ZpZGVkT3B0aW9ucz86IEFycm93Tm9kZU9wdGlvbnMgKSB7XHJcblxyXG4gICAgLy8gZGVmYXVsdCBvcHRpb25zXHJcbiAgICBjb25zdCBvcHRpb25zID0gb3B0aW9uaXplPEFycm93Tm9kZU9wdGlvbnMsIFNlbGZPcHRpb25zLCBQYXRoT3B0aW9ucz4oKSgge1xyXG4gICAgICBoZWFkSGVpZ2h0OiAxMCxcclxuICAgICAgaGVhZFdpZHRoOiAxMCxcclxuICAgICAgdGFpbFdpZHRoOiA1LFxyXG4gICAgICBpc0hlYWREeW5hbWljOiBmYWxzZSxcclxuICAgICAgc2NhbGVUYWlsVG9vOiBmYWxzZSxcclxuICAgICAgZnJhY3Rpb25hbEhlYWRIZWlnaHQ6IDAuNSwgLy8gaGVhZCB3aWxsIGJlIHNjYWxlZCB3aGVuIGhlYWRIZWlnaHQgaXMgZ3JlYXRlciB0aGFuIGZyYWN0aW9uYWxIZWFkSGVpZ2h0ICogYXJyb3cgbGVuZ3RoXHJcbiAgICAgIGRvdWJsZUhlYWQ6IGZhbHNlLCAvLyB0cnVlIHB1dHMgaGVhZHMgb24gYm90aCBlbmRzIG9mIHRoZSBhcnJvdywgZmFsc2UgcHV0cyBhIGhlYWQgYXQgdGhlIHRpcFxyXG5cclxuICAgICAgLy8gUGF0aCBvcHRpb25zXHJcbiAgICAgIGZpbGw6ICdibGFjaycsXHJcbiAgICAgIHN0cm9rZTogJ2JsYWNrJyxcclxuICAgICAgbGluZVdpZHRoOiAxXHJcbiAgICB9LCBwcm92aWRlZE9wdGlvbnMgKTtcclxuXHJcbiAgICAvLyB0aGluZ3MgeW91J3JlIGxpa2VseSB0byBtZXNzIHVwLCBhZGQgbW9yZSBhcyBuZWVkZWRcclxuICAgIGFzc2VydCAmJiBhc3NlcnQoIG9wdGlvbnMuaGVhZFdpZHRoID4gb3B0aW9ucy50YWlsV2lkdGggKTtcclxuXHJcbiAgICBzdXBlciggbnVsbCApO1xyXG5cclxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XHJcbiAgICB0aGlzLnNoYXBlUG9pbnRzID0gW107XHJcblxyXG4gICAgdGhpcy5fdGFpbFggPSB0YWlsWDtcclxuICAgIHRoaXMuX3RhaWxZID0gdGFpbFk7XHJcbiAgICB0aGlzLl90aXBYID0gdGlwWDtcclxuICAgIHRoaXMuX3RpcFkgPSB0aXBZO1xyXG5cclxuICAgIHRoaXMuc2V0VGFpbEFuZFRpcCggdGFpbFgsIHRhaWxZLCB0aXBYLCB0aXBZICk7XHJcblxyXG4gICAgdGhpcy5tdXRhdGUoIG9wdGlvbnMgKTtcclxuXHJcbiAgICAvLyBzdXBwb3J0IGZvciBiaW5kZXIgZG9jdW1lbnRhdGlvbiwgc3RyaXBwZWQgb3V0IGluIGJ1aWxkcyBhbmQgb25seSBydW5zIHdoZW4gP2JpbmRlciBpcyBzcGVjaWZpZWRcclxuICAgIGFzc2VydCAmJiBwaGV0Py5jaGlwcGVyPy5xdWVyeVBhcmFtZXRlcnM/LmJpbmRlciAmJiBJbnN0YW5jZVJlZ2lzdHJ5LnJlZ2lzdGVyRGF0YVVSTCggJ3NjZW5lcnktcGhldCcsICdBcnJvd05vZGUnLCB0aGlzICk7XHJcbiAgfVxyXG5cclxuICAvLyBTZXQgdGhlc2UgZmllbGRzIHVzaW5nIHNldFRhaWwsIHNldFRpcCwgc2V0VGFpbEFuZFRpcC5cclxuICBwcml2YXRlIF90YWlsWDogbnVtYmVyO1xyXG5cclxuICBwdWJsaWMgZ2V0IHRhaWxYKCk6IG51bWJlciB7IHJldHVybiB0aGlzLl90YWlsWDsgfVxyXG5cclxuICBwcml2YXRlIF90YWlsWTogbnVtYmVyO1xyXG5cclxuICBwcml2YXRlIHJlYWRvbmx5IG9wdGlvbnM6IFJlcXVpcmVkPFNlbGZPcHRpb25zPjtcclxuICBwcml2YXRlIHNoYXBlUG9pbnRzOiBWZWN0b3IyW107XHJcblxyXG4gIHB1YmxpYyBnZXQgdGFpbFkoKTogbnVtYmVyIHsgcmV0dXJuIHRoaXMuX3RhaWxZOyB9XHJcblxyXG4gIHByaXZhdGUgX3RpcFg6IG51bWJlcjtcclxuXHJcbiAgcHVibGljIGdldCB0aXBYKCk6IG51bWJlciB7IHJldHVybiB0aGlzLl90aXBYOyB9XHJcblxyXG4gIHByaXZhdGUgX3RpcFk6IG51bWJlcjtcclxuXHJcbiAgcHVibGljIGdldCB0aXBZKCk6IG51bWJlciB7IHJldHVybiB0aGlzLl90aXBZOyB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgdGhlIHRhaWwgYW5kIHRpcCBwb3NpdGlvbnMgdG8gdXBkYXRlIHRoZSBhcnJvdyBzaGFwZS5cclxuICAgKiBJZiB0aGUgdGFpbCBhbmQgdGlwIGFyZSBhdCB0aGUgc2FtZSBwb2ludCwgdGhlIGFycm93IGlzIG5vdCBzaG93bi5cclxuICAgKi9cclxuICBwdWJsaWMgc2V0VGFpbEFuZFRpcCggdGFpbFg6IG51bWJlciwgdGFpbFk6IG51bWJlciwgdGlwWDogbnVtYmVyLCB0aXBZOiBudW1iZXIgKTogdm9pZCB7XHJcblxyXG4gICAgdGhpcy5fdGFpbFggPSB0YWlsWDtcclxuICAgIHRoaXMuX3RhaWxZID0gdGFpbFk7XHJcbiAgICB0aGlzLl90aXBYID0gdGlwWDtcclxuICAgIHRoaXMuX3RpcFkgPSB0aXBZO1xyXG5cclxuICAgIGNvbnN0IG51bWJlck9mUG9pbnRzQ2hhbmdlZCA9IHRoaXMudXBkYXRlU2hhcGVQb2ludHMoKTtcclxuXHJcbiAgICAvLyBUaGlzIGJpdCBvZiBsb2dpYyBpcyB0byBpbXByb3ZlIHBlcmZvcm1hbmNlIGZvciB0aGUgY2FzZSB3aGVyZSB0aGUgU2hhcGUgaW5zdGFuY2UgY2FuIGJlIHJldXNlZFxyXG4gICAgLy8gKGlmIHRoZSBudW1iZXIgb2YgcG9pbnRzIGluIHRoZSBhcnJheSBpcyB0aGUgc2FtZSkuXHJcbiAgICBpZiAoICF0aGlzLnNoYXBlIHx8IG51bWJlck9mUG9pbnRzQ2hhbmdlZCApIHtcclxuICAgICAgdGhpcy51cGRhdGVTaGFwZSgpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcblxyXG4gICAgICAvLyBUaGlzIGlzIHRoZSBoaWdoZXItcGVyZm9ybWFuY2UgY2FzZSB3aGVyZSB0aGUgU2hhcGUgaW5zdGFuY2UgY2FuIGJlIHJldXNlZFxyXG4gICAgICB0aGlzLnNoYXBlLmludmFsaWRhdGVQb2ludHMoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEluaXRpYWxpemUgb3IgdXBkYXRlIHRoZSBzaGFwZS4gT25seSBjYWxsZWQgaWYgdGhlIG51bWJlciBvZiBwb2ludHMgaW4gdGhlIHNoYXBlIGNoYW5nZXMuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSB1cGRhdGVTaGFwZSgpOiB2b2lkIHtcclxuXHJcbiAgICBjb25zdCBzaGFwZSA9IG5ldyBTaGFwZSgpO1xyXG5cclxuICAgIGlmICggdGhpcy5zaGFwZVBvaW50cy5sZW5ndGggPiAxICkge1xyXG4gICAgICBzaGFwZS5tb3ZlVG9Qb2ludCggdGhpcy5zaGFwZVBvaW50c1sgMCBdICk7XHJcbiAgICAgIGZvciAoIGxldCBpID0gMTsgaSA8IHRoaXMuc2hhcGVQb2ludHMubGVuZ3RoOyBpKysgKSB7XHJcbiAgICAgICAgc2hhcGUubGluZVRvUG9pbnQoIHRoaXMuc2hhcGVQb2ludHNbIGkgXSApO1xyXG4gICAgICB9XHJcbiAgICAgIHNoYXBlLmNsb3NlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5zaGFwZSA9IHNoYXBlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0cyB0aGUgdGFpbCBwb3NpdGlvbi5cclxuICAgKi9cclxuICBwdWJsaWMgc2V0VGFpbCggdGFpbFg6IG51bWJlciwgdGFpbFk6IG51bWJlciApOiB2b2lkIHtcclxuICAgIHRoaXMuc2V0VGFpbEFuZFRpcCggdGFpbFgsIHRhaWxZLCB0aGlzLl90aXBYLCB0aGlzLl90aXBZICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXRzIHRoZSB0aXAgcG9zaXRpb24uXHJcbiAgICovXHJcbiAgcHVibGljIHNldFRpcCggdGlwWDogbnVtYmVyLCB0aXBZOiBudW1iZXIgKTogdm9pZCB7XHJcbiAgICB0aGlzLnNldFRhaWxBbmRUaXAoIHRoaXMuX3RhaWxYLCB0aGlzLl90YWlsWSwgdGlwWCwgdGlwWSApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlIHRoZSBpbnRlcm5hbCBzaGFwZVBvaW50cyBhcnJheSB3aGljaCBpcyB1c2VkIHRvIHBvcHVsYXRlIHRoZSBwb2ludHMgaW4gdGhlIFNoYXBlIGluc3RhbmNlLlxyXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgbnVtYmVyIG9mIHBvaW50cyBpbiB0aGUgYXJyYXkgaGFzIGNoYW5nZWQsIHdoaWNoIHdvdWxkIHJlcXVpcmUgYnVpbGRpbmcgYSBuZXcgc2hhcGUgaW5zdGFuY2UuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSB1cGRhdGVTaGFwZVBvaW50cygpOiBib29sZWFuIHtcclxuICAgIGNvbnN0IG51bWJlck9mUG9pbnRzID0gdGhpcy5zaGFwZVBvaW50cy5sZW5ndGg7XHJcbiAgICB0aGlzLnNoYXBlUG9pbnRzID0gQXJyb3dTaGFwZS5nZXRBcnJvd1NoYXBlUG9pbnRzKCB0aGlzLl90YWlsWCwgdGhpcy5fdGFpbFksIHRoaXMuX3RpcFgsIHRoaXMuX3RpcFksIHRoaXMuc2hhcGVQb2ludHMsIHRoaXMub3B0aW9ucyApO1xyXG4gICAgcmV0dXJuICggdGhpcy5zaGFwZVBvaW50cy5sZW5ndGggIT09IG51bWJlck9mUG9pbnRzICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXRzIHRoZSB0YWlsIHdpZHRoLlxyXG4gICAqL1xyXG4gIHB1YmxpYyBzZXRUYWlsV2lkdGgoIHRhaWxXaWR0aDogbnVtYmVyICk6IHZvaWQge1xyXG4gICAgdGhpcy5vcHRpb25zLnRhaWxXaWR0aCA9IHRhaWxXaWR0aDtcclxuICAgIHRoaXMudXBkYXRlU2hhcGVQb2ludHMoKTtcclxuICAgIHRoaXMudXBkYXRlU2hhcGUoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgd2hldGhlciB0aGUgYXJyb3cgaGFzIG9uZSBvciB0d28gaGVhZHMuXHJcbiAgICovXHJcbiAgcHVibGljIHNldERvdWJsZUhlYWQoIGRvdWJsZUhlYWQ6IGJvb2xlYW4gKTogdm9pZCB7XHJcbiAgICB0aGlzLm9wdGlvbnMuZG91YmxlSGVhZCA9IGRvdWJsZUhlYWQ7XHJcbiAgICB0aGlzLnVwZGF0ZVNoYXBlUG9pbnRzKCk7XHJcbiAgICB0aGlzLnVwZGF0ZVNoYXBlKCk7XHJcbiAgfVxyXG59XHJcblxyXG5zY2VuZXJ5UGhldC5yZWdpc3RlciggJ0Fycm93Tm9kZScsIEFycm93Tm9kZSApOyJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQSxTQUFTQSxLQUFLLFFBQVEsMEJBQTBCO0FBQ2hELE9BQU9DLGdCQUFnQixNQUFNLHNEQUFzRDtBQUNuRixPQUFPQyxTQUFTLE1BQU0saUNBQWlDO0FBQ3ZELFNBQVNDLElBQUksUUFBcUIsNkJBQTZCO0FBQy9ELE9BQU9DLFVBQVUsTUFBTSxpQkFBaUI7QUFDeEMsT0FBT0MsV0FBVyxNQUFNLGtCQUFrQjtBQWtCMUMsZUFBZSxNQUFNQyxTQUFTLFNBQVNILElBQUksQ0FBQztFQUUxQztFQUNPSSxXQUFXQSxDQUFFQyxLQUFhLEVBQUVDLEtBQWEsRUFBRUMsSUFBWSxFQUFFQyxJQUFZLEVBQUVDLGVBQWtDLEVBQUc7SUFFakg7SUFDQSxNQUFNQyxPQUFPLEdBQUdYLFNBQVMsQ0FBNkMs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