// Copyright 2019-2023, University of Colorado Boulder

/**
 * Graph is the base class for graphs, intended to be sub-classed. A screen can have multiple graphs.
 *
 * Graphs are responsible for:
 *   - Keeping track of where the origin is dragged and updating a modelViewTransformProperty.
 *   - Keeping track of the active (selected) vector on a graph.
 *   - Managing one or more VectorSets
 *
 * @author Brandon Li
 */

import DerivedProperty from '../../../../axon/js/DerivedProperty.js';
import Property from '../../../../axon/js/Property.js';
import Bounds2 from '../../../../dot/js/Bounds2.js';
import Vector2 from '../../../../dot/js/Vector2.js';
import ModelViewTransform2 from '../../../../phetcommon/js/view/ModelViewTransform2.js';
import vectorAddition from '../../vectorAddition.js';
import VectorAdditionConstants from '../VectorAdditionConstants.js';
import GraphOrientations from './GraphOrientations.js';
import optionize from '../../../../phet-core/js/optionize.js';
import Disposable from '../../../../axon/js/Disposable.js';

// scale of the coordinate transformation of model coordinates to view coordinates
const MODEL_TO_VIEW_SCALE = 14.5;
export default class Graph {
  // the vectorSets for this graph

  // orientation of the graph

  // coordinate snap mode for the graph, Cartesian or polar

  // Bounds of the graph, in model coordinates. Use graphModelBounds() to read this.

  // bounds of the graph in view coordinates, constant for the lifetime of the sim.

  // maps graph coordinates between model and view

  // The active (selected) vector. A graph has at most one active vector. If null, there is no active vector.

  // Since the origin is being dragged, modelViewTransform is in the model. That being said, it is necessary to know the
  // view coordinates of the graph node's bottom-left to calculate the model view transform.
  // Calculate the default for the grid's bottom-left, in view coordinates.
  static DEFAULT_BOTTOM_LEFT = new Vector2(VectorAdditionConstants.SCREEN_VIEW_BOUNDS.minX + VectorAdditionConstants.AXES_ARROW_X_EXTENSION + 10, VectorAdditionConstants.SCREEN_VIEW_BOUNDS.maxY - VectorAdditionConstants.AXES_ARROW_Y_EXTENSION - 45);

  /**
   * @param initialGraphBounds - the model bounds of the graph at the start of the sim
   * @param coordinateSnapMode - the coordinate snap mode of the graph. A graph is either strictly polar or Cartesian.
   * @param [providedOptions]
   */
  constructor(initialGraphBounds, coordinateSnapMode, providedOptions) {
    const options = optionize()({
      // SelfOptions
      orientation: GraphOrientations.TWO_DIMENSIONAL,
      bottomLeft: Graph.DEFAULT_BOTTOM_LEFT
    }, providedOptions);
    this.vectorSets = [];
    this.orientation = options.orientation;
    this.coordinateSnapMode = coordinateSnapMode;
    this.graphModelBoundsProperty = new Property(initialGraphBounds, {
      valueType: Bounds2
    });
    this.graphViewBounds = new Bounds2(options.bottomLeft.x, options.bottomLeft.y - MODEL_TO_VIEW_SCALE * initialGraphBounds.height, options.bottomLeft.x + MODEL_TO_VIEW_SCALE * initialGraphBounds.width, options.bottomLeft.y);
    this.modelViewTransformProperty = new DerivedProperty([this.graphModelBoundsProperty], graphModelBounds => ModelViewTransform2.createRectangleInvertedYMapping(graphModelBounds, this.graphViewBounds), {
      valueType: ModelViewTransform2
    });
    this.activeVectorProperty = new Property(null);
  }
  dispose() {
    Disposable.assertNotDisposable();
  }
  reset() {
    this.graphModelBoundsProperty.reset();
    this.vectorSets.forEach(vectorSet => vectorSet.reset());
    this.activeVectorProperty.reset();
  }

  /**
   * Erases the graph.
   */
  erase() {
    this.vectorSets.forEach(vectorSet => vectorSet.erase());
    this.activeVectorProperty.reset();
  }

  /**
   * Moves the origin to a specified point on the graph.
   */
  moveOriginToPoint(point) {
    assert && assert(this.graphModelBoundsProperty.value.containsPoint(point), `point is out of bounds: ${point}`);

    // Round to integer
    const roundedPoint = point.roundSymmetric();
    this.graphModelBoundsProperty.value = this.graphModelBounds.shiftedXY(-roundedPoint.x, -roundedPoint.y);
  }

  /**
   * Gets the bounds of the graph
   */
  get graphModelBounds() {
    return this.graphModelBoundsProperty.value;
  }
}
vectorAddition.register('Graph', Graph);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJEZXJpdmVkUHJvcGVydHkiLCJQcm9wZXJ0eSIsIkJvdW5kczIiLCJWZWN0b3IyIiwiTW9kZWxWaWV3VHJhbnNmb3JtMiIsInZlY3RvckFkZGl0aW9uIiwiVmVjdG9yQWRkaXRpb25Db25zdGFudHMiLCJHcmFwaE9yaWVudGF0aW9ucyIsIm9wdGlvbml6ZSIsIkRpc3Bvc2FibGUiLCJNT0RFTF9UT19WSUVXX1NDQUxFIiwiR3JhcGgiLCJERUZBVUxUX0JPVFRPTV9MRUZUIiwiU0NSRUVOX1ZJRVdfQk9VTkRTIiwibWluWCIsIkFYRVNfQVJST1dfWF9FWFRFTlNJT04iLCJtYXhZIiwiQVhFU19BUlJPV19ZX0VYVEVOU0lPTiIsImNvbnN0cnVjdG9yIiwiaW5pdGlhbEdyYXBoQm91bmRzIiwiY29vcmRpbmF0ZVNuYXBNb2RlIiwicHJvdmlkZWRPcHRpb25zIiwib3B0aW9ucyIsIm9yaWVudGF0aW9uIiwiVFdPX0RJTUVOU0lPTkFMIiwiYm90dG9tTGVmdCIsInZlY3RvclNldHMiLCJncmFwaE1vZGVsQm91bmRzUHJvcGVydHkiLCJ2YWx1ZVR5cGUiLCJncmFwaFZpZXdCb3VuZHMiLCJ4IiwieSIsImhlaWdodCIsIndpZHRoIiwibW9kZWxWaWV3VHJhbnNmb3JtUHJvcGVydHkiLCJncmFwaE1vZGVsQm91bmRzIiwiY3JlYXRlUmVjdGFuZ2xlSW52ZXJ0ZWRZTWFwcGluZyIsImFjdGl2ZVZlY3RvclByb3BlcnR5IiwiZGlzcG9zZSIsImFzc2VydE5vdERpc3Bvc2FibGUiLCJyZXNldCIsImZvckVhY2giLCJ2ZWN0b3JTZXQiLCJlcmFzZSIsIm1vdmVPcmlnaW5Ub1BvaW50IiwicG9pbnQiLCJhc3NlcnQiLCJ2YWx1ZSIsImNvbnRhaW5zUG9pbnQiLCJyb3VuZGVkUG9pbnQiLCJyb3VuZFN5bW1ldHJpYyIsInNoaWZ0ZWRYWSIsInJlZ2lzdGVyIl0sInNvdXJjZXMiOlsiR3JhcGgudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTktMjAyMywgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXHJcblxyXG4vKipcclxuICogR3JhcGggaXMgdGhlIGJhc2UgY2xhc3MgZm9yIGdyYXBocywgaW50ZW5kZWQgdG8gYmUgc3ViLWNsYXNzZWQuIEEgc2NyZWVuIGNhbiBoYXZlIG11bHRpcGxlIGdyYXBocy5cclxuICpcclxuICogR3JhcGhzIGFyZSByZXNwb25zaWJsZSBmb3I6XHJcbiAqICAgLSBLZWVwaW5nIHRyYWNrIG9mIHdoZXJlIHRoZSBvcmlnaW4gaXMgZHJhZ2dlZCBhbmQgdXBkYXRpbmcgYSBtb2RlbFZpZXdUcmFuc2Zvcm1Qcm9wZXJ0eS5cclxuICogICAtIEtlZXBpbmcgdHJhY2sgb2YgdGhlIGFjdGl2ZSAoc2VsZWN0ZWQpIHZlY3RvciBvbiBhIGdyYXBoLlxyXG4gKiAgIC0gTWFuYWdpbmcgb25lIG9yIG1vcmUgVmVjdG9yU2V0c1xyXG4gKlxyXG4gKiBAYXV0aG9yIEJyYW5kb24gTGlcclxuICovXHJcblxyXG5pbXBvcnQgRGVyaXZlZFByb3BlcnR5IGZyb20gJy4uLy4uLy4uLy4uL2F4b24vanMvRGVyaXZlZFByb3BlcnR5LmpzJztcclxuaW1wb3J0IFByb3BlcnR5IGZyb20gJy4uLy4uLy4uLy4uL2F4b24vanMvUHJvcGVydHkuanMnO1xyXG5pbXBvcnQgQm91bmRzMiBmcm9tICcuLi8uLi8uLi8uLi9kb3QvanMvQm91bmRzMi5qcyc7XHJcbmltcG9ydCBWZWN0b3IyIGZyb20gJy4uLy4uLy4uLy4uL2RvdC9qcy9WZWN0b3IyLmpzJztcclxuaW1wb3J0IE1vZGVsVmlld1RyYW5zZm9ybTIgZnJvbSAnLi4vLi4vLi4vLi4vcGhldGNvbW1vbi9qcy92aWV3L01vZGVsVmlld1RyYW5zZm9ybTIuanMnO1xyXG5pbXBvcnQgdmVjdG9yQWRkaXRpb24gZnJvbSAnLi4vLi4vdmVjdG9yQWRkaXRpb24uanMnO1xyXG5pbXBvcnQgVmVjdG9yQWRkaXRpb25Db25zdGFudHMgZnJvbSAnLi4vVmVjdG9yQWRkaXRpb25Db25zdGFudHMuanMnO1xyXG5pbXBvcnQgQ29vcmRpbmF0ZVNuYXBNb2RlcyBmcm9tICcuL0Nvb3JkaW5hdGVTbmFwTW9kZXMuanMnO1xyXG5pbXBvcnQgR3JhcGhPcmllbnRhdGlvbnMgZnJvbSAnLi9HcmFwaE9yaWVudGF0aW9ucy5qcyc7XHJcbmltcG9ydCBWZWN0b3IgZnJvbSAnLi9WZWN0b3IuanMnO1xyXG5pbXBvcnQgb3B0aW9uaXplIGZyb20gJy4uLy4uLy4uLy4uL3BoZXQtY29yZS9qcy9vcHRpb25pemUuanMnO1xyXG5pbXBvcnQgVmVjdG9yU2V0IGZyb20gJy4vVmVjdG9yU2V0LmpzJztcclxuaW1wb3J0IFRSZWFkT25seVByb3BlcnR5IGZyb20gJy4uLy4uLy4uLy4uL2F4b24vanMvVFJlYWRPbmx5UHJvcGVydHkuanMnO1xyXG5pbXBvcnQgRGlzcG9zYWJsZSBmcm9tICcuLi8uLi8uLi8uLi9heG9uL2pzL0Rpc3Bvc2FibGUuanMnO1xyXG5cclxuLy8gc2NhbGUgb2YgdGhlIGNvb3JkaW5hdGUgdHJhbnNmb3JtYXRpb24gb2YgbW9kZWwgY29vcmRpbmF0ZXMgdG8gdmlldyBjb29yZGluYXRlc1xyXG5jb25zdCBNT0RFTF9UT19WSUVXX1NDQUxFID0gMTQuNTtcclxuXHJcbnR5cGUgU2VsZk9wdGlvbnMgPSB7XHJcbiAgb3JpZW50YXRpb24/OiBHcmFwaE9yaWVudGF0aW9ucztcclxuICBib3R0b21MZWZ0PzogVmVjdG9yMjsgLy8gYm90dG9tIGxlZnQgY29ybmVyIG9mIHRoZSBncmFwaCwgaW4gdmlldyBjb29yZGluYXRlc1xyXG59O1xyXG5cclxudHlwZSBHcmFwaE9wdGlvbnMgPSBTZWxmT3B0aW9ucztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdyYXBoIHtcclxuXHJcbiAgLy8gdGhlIHZlY3RvclNldHMgZm9yIHRoaXMgZ3JhcGhcclxuICBwdWJsaWMgdmVjdG9yU2V0czogVmVjdG9yU2V0W107XHJcblxyXG4gIC8vIG9yaWVudGF0aW9uIG9mIHRoZSBncmFwaFxyXG4gIHB1YmxpYyByZWFkb25seSBvcmllbnRhdGlvbjogR3JhcGhPcmllbnRhdGlvbnM7XHJcblxyXG4gIC8vIGNvb3JkaW5hdGUgc25hcCBtb2RlIGZvciB0aGUgZ3JhcGgsIENhcnRlc2lhbiBvciBwb2xhclxyXG4gIHB1YmxpYyByZWFkb25seSBjb29yZGluYXRlU25hcE1vZGU6IENvb3JkaW5hdGVTbmFwTW9kZXM7XHJcblxyXG4gIC8vIEJvdW5kcyBvZiB0aGUgZ3JhcGgsIGluIG1vZGVsIGNvb3JkaW5hdGVzLiBVc2UgZ3JhcGhNb2RlbEJvdW5kcygpIHRvIHJlYWQgdGhpcy5cclxuICBwcml2YXRlIHJlYWRvbmx5IGdyYXBoTW9kZWxCb3VuZHNQcm9wZXJ0eTogUHJvcGVydHk8Qm91bmRzMj47XHJcblxyXG4gIC8vIGJvdW5kcyBvZiB0aGUgZ3JhcGggaW4gdmlldyBjb29yZGluYXRlcywgY29uc3RhbnQgZm9yIHRoZSBsaWZldGltZSBvZiB0aGUgc2ltLlxyXG4gIHB1YmxpYyByZWFkb25seSBncmFwaFZpZXdCb3VuZHM6IEJvdW5kczI7XHJcblxyXG4gIC8vIG1hcHMgZ3JhcGggY29vcmRpbmF0ZXMgYmV0d2VlbiBtb2RlbCBhbmQgdmlld1xyXG4gIHB1YmxpYyByZWFkb25seSBtb2RlbFZpZXdUcmFuc2Zvcm1Qcm9wZXJ0eTogVFJlYWRPbmx5UHJvcGVydHk8TW9kZWxWaWV3VHJhbnNmb3JtMj47XHJcblxyXG4gIC8vIFRoZSBhY3RpdmUgKHNlbGVjdGVkKSB2ZWN0b3IuIEEgZ3JhcGggaGFzIGF0IG1vc3Qgb25lIGFjdGl2ZSB2ZWN0b3IuIElmIG51bGwsIHRoZXJlIGlzIG5vIGFjdGl2ZSB2ZWN0b3IuXHJcbiAgcHVibGljIHJlYWRvbmx5IGFjdGl2ZVZlY3RvclByb3BlcnR5OiBQcm9wZXJ0eTxWZWN0b3IgfCBudWxsPjtcclxuXHJcbiAgLy8gU2luY2UgdGhlIG9yaWdpbiBpcyBiZWluZyBkcmFnZ2VkLCBtb2RlbFZpZXdUcmFuc2Zvcm0gaXMgaW4gdGhlIG1vZGVsLiBUaGF0IGJlaW5nIHNhaWQsIGl0IGlzIG5lY2Vzc2FyeSB0byBrbm93IHRoZVxyXG4gIC8vIHZpZXcgY29vcmRpbmF0ZXMgb2YgdGhlIGdyYXBoIG5vZGUncyBib3R0b20tbGVmdCB0byBjYWxjdWxhdGUgdGhlIG1vZGVsIHZpZXcgdHJhbnNmb3JtLlxyXG4gIC8vIENhbGN1bGF0ZSB0aGUgZGVmYXVsdCBmb3IgdGhlIGdyaWQncyBib3R0b20tbGVmdCwgaW4gdmlldyBjb29yZGluYXRlcy5cclxuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IERFRkFVTFRfQk9UVE9NX0xFRlQgPSBuZXcgVmVjdG9yMihcclxuICAgIFZlY3RvckFkZGl0aW9uQ29uc3RhbnRzLlNDUkVFTl9WSUVXX0JPVU5EUy5taW5YICsgVmVjdG9yQWRkaXRpb25Db25zdGFudHMuQVhFU19BUlJPV19YX0VYVEVOU0lPTiArIDEwLFxyXG4gICAgVmVjdG9yQWRkaXRpb25Db25zdGFudHMuU0NSRUVOX1ZJRVdfQk9VTkRTLm1heFkgLSBWZWN0b3JBZGRpdGlvbkNvbnN0YW50cy5BWEVTX0FSUk9XX1lfRVhURU5TSU9OIC0gNDVcclxuICApO1xyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0gaW5pdGlhbEdyYXBoQm91bmRzIC0gdGhlIG1vZGVsIGJvdW5kcyBvZiB0aGUgZ3JhcGggYXQgdGhlIHN0YXJ0IG9mIHRoZSBzaW1cclxuICAgKiBAcGFyYW0gY29vcmRpbmF0ZVNuYXBNb2RlIC0gdGhlIGNvb3JkaW5hdGUgc25hcCBtb2RlIG9mIHRoZSBncmFwaC4gQSBncmFwaCBpcyBlaXRoZXIgc3RyaWN0bHkgcG9sYXIgb3IgQ2FydGVzaWFuLlxyXG4gICAqIEBwYXJhbSBbcHJvdmlkZWRPcHRpb25zXVxyXG4gICAqL1xyXG4gIHByb3RlY3RlZCBjb25zdHJ1Y3RvciggaW5pdGlhbEdyYXBoQm91bmRzOiBCb3VuZHMyLCBjb29yZGluYXRlU25hcE1vZGU6IENvb3JkaW5hdGVTbmFwTW9kZXMsIHByb3ZpZGVkT3B0aW9ucz86IEdyYXBoT3B0aW9ucyApIHtcclxuXHJcbiAgICBjb25zdCBvcHRpb25zID0gb3B0aW9uaXplPEdyYXBoT3B0aW9ucywgU2VsZk9wdGlvbnM+KCkoIHtcclxuXHJcbiAgICAgIC8vIFNlbGZPcHRpb25zXHJcbiAgICAgIG9yaWVudGF0aW9uOiBHcmFwaE9yaWVudGF0aW9ucy5UV09fRElNRU5TSU9OQUwsXHJcbiAgICAgIGJvdHRvbUxlZnQ6IEdyYXBoLkRFRkFVTFRfQk9UVE9NX0xFRlRcclxuICAgIH0sIHByb3ZpZGVkT3B0aW9ucyApO1xyXG5cclxuICAgIHRoaXMudmVjdG9yU2V0cyA9IFtdO1xyXG4gICAgdGhpcy5vcmllbnRhdGlvbiA9IG9wdGlvbnMub3JpZW50YXRpb247XHJcbiAgICB0aGlzLmNvb3JkaW5hdGVTbmFwTW9kZSA9IGNvb3JkaW5hdGVTbmFwTW9kZTtcclxuXHJcbiAgICB0aGlzLmdyYXBoTW9kZWxCb3VuZHNQcm9wZXJ0eSA9IG5ldyBQcm9wZXJ0eSggaW5pdGlhbEdyYXBoQm91bmRzLCB7XHJcbiAgICAgIHZhbHVlVHlwZTogQm91bmRzMlxyXG4gICAgfSApO1xyXG5cclxuICAgIHRoaXMuZ3JhcGhWaWV3Qm91bmRzID0gbmV3IEJvdW5kczIoIG9wdGlvbnMuYm90dG9tTGVmdC54LFxyXG4gICAgICBvcHRpb25zLmJvdHRvbUxlZnQueSAtIE1PREVMX1RPX1ZJRVdfU0NBTEUgKiBpbml0aWFsR3JhcGhCb3VuZHMuaGVpZ2h0LFxyXG4gICAgICBvcHRpb25zLmJvdHRvbUxlZnQueCArIE1PREVMX1RPX1ZJRVdfU0NBTEUgKiBpbml0aWFsR3JhcGhCb3VuZHMud2lkdGgsXHJcbiAgICAgIG9wdGlvbnMuYm90dG9tTGVmdC55ICk7XHJcblxyXG4gICAgdGhpcy5tb2RlbFZpZXdUcmFuc2Zvcm1Qcm9wZXJ0eSA9IG5ldyBEZXJpdmVkUHJvcGVydHkoXHJcbiAgICAgIFsgdGhpcy5ncmFwaE1vZGVsQm91bmRzUHJvcGVydHkgXSxcclxuICAgICAgZ3JhcGhNb2RlbEJvdW5kcyA9PiBNb2RlbFZpZXdUcmFuc2Zvcm0yLmNyZWF0ZVJlY3RhbmdsZUludmVydGVkWU1hcHBpbmcoIGdyYXBoTW9kZWxCb3VuZHMsIHRoaXMuZ3JhcGhWaWV3Qm91bmRzICksXHJcbiAgICAgIHsgdmFsdWVUeXBlOiBNb2RlbFZpZXdUcmFuc2Zvcm0yIH1cclxuICAgICk7XHJcblxyXG4gICAgdGhpcy5hY3RpdmVWZWN0b3JQcm9wZXJ0eSA9IG5ldyBQcm9wZXJ0eTxWZWN0b3IgfCBudWxsPiggbnVsbCApO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIGRpc3Bvc2UoKTogdm9pZCB7XHJcbiAgICBEaXNwb3NhYmxlLmFzc2VydE5vdERpc3Bvc2FibGUoKTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyByZXNldCgpOiB2b2lkIHtcclxuICAgIHRoaXMuZ3JhcGhNb2RlbEJvdW5kc1Byb3BlcnR5LnJlc2V0KCk7XHJcbiAgICB0aGlzLnZlY3RvclNldHMuZm9yRWFjaCggdmVjdG9yU2V0ID0+IHZlY3RvclNldC5yZXNldCgpICk7XHJcbiAgICB0aGlzLmFjdGl2ZVZlY3RvclByb3BlcnR5LnJlc2V0KCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBFcmFzZXMgdGhlIGdyYXBoLlxyXG4gICAqL1xyXG4gIHB1YmxpYyBlcmFzZSgpOiB2b2lkIHtcclxuICAgIHRoaXMudmVjdG9yU2V0cy5mb3JFYWNoKCB2ZWN0b3JTZXQgPT4gdmVjdG9yU2V0LmVyYXNlKCkgKTtcclxuICAgIHRoaXMuYWN0aXZlVmVjdG9yUHJvcGVydHkucmVzZXQoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1vdmVzIHRoZSBvcmlnaW4gdG8gYSBzcGVjaWZpZWQgcG9pbnQgb24gdGhlIGdyYXBoLlxyXG4gICAqL1xyXG4gIHB1YmxpYyBtb3ZlT3JpZ2luVG9Qb2ludCggcG9pbnQ6IFZlY3RvcjIgKTogdm9pZCB7XHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCB0aGlzLmdyYXBoTW9kZWxCb3VuZHNQcm9wZXJ0eS52YWx1ZS5jb250YWluc1BvaW50KCBwb2ludCApLCBgcG9pbnQgaXMgb3V0IG9mIGJvdW5kczogJHtwb2ludH1gICk7XHJcblxyXG4gICAgLy8gUm91bmQgdG8gaW50ZWdlclxyXG4gICAgY29uc3Qgcm91bmRlZFBvaW50ID0gcG9pbnQucm91bmRTeW1tZXRyaWMoKTtcclxuICAgIHRoaXMuZ3JhcGhNb2RlbEJvdW5kc1Byb3BlcnR5LnZhbHVlID0gdGhpcy5ncmFwaE1vZGVsQm91bmRzLnNoaWZ0ZWRYWSggLXJvdW5kZWRQb2ludC54LCAtcm91bmRlZFBvaW50LnkgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgdGhlIGJvdW5kcyBvZiB0aGUgZ3JhcGhcclxuICAgKi9cclxuICBwdWJsaWMgZ2V0IGdyYXBoTW9kZWxCb3VuZHMoKTogQm91bmRzMiB7XHJcbiAgICByZXR1cm4gdGhpcy5ncmFwaE1vZGVsQm91bmRzUHJvcGVydHkudmFsdWU7XHJcbiAgfVxyXG59XHJcblxyXG52ZWN0b3JBZGRpdGlvbi5yZWdpc3RlciggJ0dyYXBoJywgR3JhcGggKTsiXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU9BLGVBQWUsTUFBTSx3Q0FBd0M7QUFDcEUsT0FBT0MsUUFBUSxNQUFNLGlDQUFpQztBQUN0RCxPQUFPQyxPQUFPLE1BQU0sK0JBQStCO0FBQ25ELE9BQU9DLE9BQU8sTUFBTSwrQkFBK0I7QUFDbkQsT0FBT0MsbUJBQW1CLE1BQU0sdURBQXVEO0FBQ3ZGLE9BQU9DLGNBQWMsTUFBTSx5QkFBeUI7QUFDcEQsT0FBT0MsdUJBQXVCLE1BQU0sK0JBQStCO0FBRW5FLE9BQU9DLGlCQUFpQixNQUFNLHdCQUF3QjtBQUV0RCxPQUFPQyxTQUFTLE1BQU0sdUNBQXVDO0FBRzdELE9BQU9DLFVBQVUsTUFBTSxtQ0FBbUM7O0FBRTFEO0FBQ0EsTUFBTUMsbUJBQW1CLEdBQUcsSUFBSTtBQVNoQyxlQUFlLE1BQU1DLEtBQUssQ0FBQztFQUV6Qjs7RUFHQTs7RUFHQTs7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