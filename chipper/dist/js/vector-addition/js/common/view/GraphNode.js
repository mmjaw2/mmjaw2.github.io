// Copyright 2019-2023, University of Colorado Boulder

/**
 * GraphNode draws the graph, including its grid, axes, ticks, and origin manipulator.
 *
 * @author Martin Veillette
 * @author Chris Malley (PixelZoom, Inc.)
 */

import Vector2 from '../../../../dot/js/Vector2.js';
import { Shape } from '../../../../kite/js/imports.js';
import ArrowNode from '../../../../scenery-phet/js/ArrowNode.js';
import { Color, Node, Path, Rectangle, Text } from '../../../../scenery/js/imports.js';
import vectorAddition from '../../vectorAddition.js';
import VectorAdditionStrings from '../../VectorAdditionStrings.js';
import GraphOrientations from '../model/GraphOrientations.js';
import VectorAdditionColors from '../VectorAdditionColors.js';
import VectorAdditionConstants from '../VectorAdditionConstants.js';
import OriginManipulator from './OriginManipulator.js';
import optionize from '../../../../phet-core/js/optionize.js';

//----------------------------------------------------------------------------------------
// constants

// grid
const MAJOR_GRID_LINE_WIDTH = 1.5; // view units
const MINOR_GRID_LINE_WIDTH = 1; // view units

// axes
const AXES_ARROW_X_EXTENSION = VectorAdditionConstants.AXES_ARROW_X_EXTENSION;
const AXES_ARROW_Y_EXTENSION = VectorAdditionConstants.AXES_ARROW_Y_EXTENSION;

// tick marks
const MAJOR_TICK_SPACING = 5; // model units
const MINOR_TICK_SPACING = 1; // model units
const TICK_LENGTH = 1; // model units
const ORIGIN_TICK_LENGTH = 2; // model units
const TICK_MARK_OPTIONS = {
  lineWidth: 1,
  stroke: Color.BLACK
};

// tick labels
const TICK_LABEL_OPTIONS = {
  font: VectorAdditionConstants.TICK_LABEL_FONT,
  fill: 'rgb( 130, 130, 130 )',
  maxWidth: 30
};
const TICK_LABEL_SPACING = 10; // model units
const TICK_LABEL_X_OFFSET = 15; // from x = 0, view units
const TICK_LABEL_Y_OFFSET = 15; // from y = 0, view units

export default class GraphNode extends Node {
  constructor(graph, gridVisibilityProperty) {
    const graphViewBounds = graph.graphViewBounds;
    const background = new Rectangle(graphViewBounds, {
      fill: VectorAdditionColors.GRAPH_BACKGROUND_COLOR,
      stroke: VectorAdditionColors.GRAPH_MINOR_LINE_COLOR,
      lineWidth: MINOR_GRID_LINE_WIDTH
    });
    const children = [background, new MajorAndMinorGridLines(graph, graphViewBounds, gridVisibilityProperty), new TicksNode(graph)];

    // Create axes as needed, based on graph orientation
    if (graph.orientation !== GraphOrientations.VERTICAL) {
      children.push(new XAxisNode(graph, graphViewBounds));
    }
    if (graph.orientation !== GraphOrientations.HORIZONTAL) {
      children.push(new YAxisNode(graph, graphViewBounds));
    }
    children.push(new OriginManipulator(graph));
    super({
      children: children,
      isDisposable: false
    });

    // Clicking in the graph clears the active (selected) vector.
    // Use a raw 'down' listener so that this doesn't impact the ability to touch snag vectors and origin manipulator.
    // See https://github.com/phetsims/vector-addition/issues/243
    // No need to remove, exists for the lifetime of the sim.
    background.addInputListener({
      down: () => {
        graph.activeVectorProperty.value = null;
      }
    });
  }
}

/**
 * Draws the major and minor grid lines.  Handles visibility of the grid.
 */
class MajorAndMinorGridLines extends Node {
  constructor(graph, graphViewBounds, gridVisibilityProperty) {
    const majorGridLines = new GridLines(graph, graphViewBounds, {
      spacing: MAJOR_TICK_SPACING,
      lineWidth: MAJOR_GRID_LINE_WIDTH,
      stroke: VectorAdditionColors.GRAPH_MAJOR_LINE_COLOR
    });
    const minorGridLinesPath = new GridLines(graph, graphViewBounds, {
      spacing: MINOR_TICK_SPACING,
      lineWidth: MINOR_GRID_LINE_WIDTH,
      stroke: VectorAdditionColors.GRAPH_MINOR_LINE_COLOR
    });
    super({
      children: [minorGridLinesPath, majorGridLines],
      pickable: false
    });

    // Observe changes to the grid visibility Property, and update visibility.
    // No need to unlink since GraphNodes exist for the lifetime of the sim.
    gridVisibilityProperty.linkAttribute(this, 'visible');
  }
}

/**
 * Draws grid lines at some spacing. Used to draw one type of grid line (major or minor).
 * Updates when the origin changes. Optimized to take advantage of constant view bounds.
 */

class GridLines extends Path {
  constructor(graph, graphViewBounds, providedOptions) {
    const options = optionize()({
      // GridLinesSelfOptions
      spacing: 1,
      // PathOptions
      lineWidth: 1,
      stroke: 'black'
    }, providedOptions);
    super(new Shape(), options);
    this.graphViewBounds = graphViewBounds;

    // Update when the modelViewTransform changes, triggered when the origin is moved.
    // unlink is unnecessary, exists for the lifetime of the sim.
    graph.modelViewTransformProperty.link(modelViewTransform => {
      // Convenience variables
      const graphMinX = graph.graphModelBounds.minX;
      const graphMaxX = graph.graphModelBounds.maxX;
      const graphMinY = graph.graphModelBounds.minY;
      const graphMaxY = graph.graphModelBounds.maxY;
      const shape = new Shape();

      // Vertical lines
      const firstX = graphMinX - graphMinX % options.spacing;
      for (let xValue = firstX; xValue <= graphMaxX; xValue += options.spacing) {
        shape.moveTo(xValue, graphMinY).verticalLineTo(graphMaxY);
      }

      // Horizontal lines
      const firstY = graphMinY - graphMinY % options.spacing;
      for (let yValue = firstY; yValue <= graphMaxY; yValue += options.spacing) {
        shape.moveTo(graphMinX, yValue).horizontalLineTo(graphMaxX);
      }
      this.setShape(modelViewTransform.modelToViewShape(shape));
    });
  }

  /**
   * Performance optimization, since the grid's view bounds are constant.
   */
  computeShapeBounds() {
    return this.graphViewBounds;
  }
}

/**
 * Draws the x-axis.
 */
class XAxisNode extends Node {
  constructor(graph, graphViewBounds) {
    const arrowNode = new ArrowNode(graphViewBounds.minX - AXES_ARROW_X_EXTENSION, 0, graphViewBounds.maxX + AXES_ARROW_X_EXTENSION, 0, VectorAdditionConstants.AXES_ARROW_OPTIONS);
    const axisLabel = new Text(VectorAdditionStrings.symbol.x, {
      font: VectorAdditionConstants.AXIS_LABEL_FONT,
      maxWidth: 22,
      left: arrowNode.right + 6,
      centerY: arrowNode.centerY
    });
    super({
      children: [arrowNode, axisLabel],
      pickable: false
    });

    // When the origin moves, adjust the position of the axis.
    // unlink is unnecessary, exists for the lifetime of the sim.
    graph.modelViewTransformProperty.link(modelViewTransform => {
      this.y = modelViewTransform.modelToViewY(0);
    });
  }
}

/**
 * Draws the y axis.
 */
class YAxisNode extends Node {
  constructor(graph, graphViewBounds) {
    const arrowNode = new ArrowNode(0, graphViewBounds.minY - AXES_ARROW_Y_EXTENSION, 0, graphViewBounds.maxY + AXES_ARROW_Y_EXTENSION, VectorAdditionConstants.AXES_ARROW_OPTIONS);
    const axisLabel = new Text(VectorAdditionStrings.symbol.y, {
      font: VectorAdditionConstants.AXIS_LABEL_FONT,
      maxWidth: 30,
      centerX: arrowNode.centerX,
      bottom: arrowNode.top - 3
    });
    super({
      children: [arrowNode, axisLabel],
      pickable: false
    });

    // When the origin moves, adjust the position of the axis.
    // unlink is unnecessary, exists for the lifetime of the sim.
    graph.modelViewTransformProperty.link(modelViewTransform => {
      this.x = modelViewTransform.modelToViewX(0);
    });
  }
}

/**
 * Draws the tick marks and labels.
 */
class TicksNode extends Node {
  constructor(graph) {
    const tickMarksPath = new Path(new Shape(), TICK_MARK_OPTIONS);
    const tickLabelsParent = new Node();
    const originLabel = new Text('0', TICK_LABEL_OPTIONS);
    super({
      children: [tickMarksPath, tickLabelsParent],
      pickable: false
    });

    // Update ticks when the graph's origin moves.
    // unlink is unnecessary, exists for the lifetime of the sim.
    graph.modelViewTransformProperty.link(modelViewTransform => {
      const viewOrigin = modelViewTransform.modelToViewPosition(Vector2.ZERO);
      const tickMarksShape = new Shape();
      const tickLabels = [];
      if (graph.orientation !== GraphOrientations.VERTICAL) {
        // x tick marks
        const firstXTick = graph.graphModelBounds.minX - graph.graphModelBounds.minX % MAJOR_TICK_SPACING;
        for (let xValue = firstXTick; xValue <= graph.graphModelBounds.maxX; xValue = xValue + MAJOR_TICK_SPACING) {
          const tickLength = xValue === 0 ? ORIGIN_TICK_LENGTH : TICK_LENGTH; // origin tick is different
          tickMarksShape.moveTo(xValue, -tickLength / 2).verticalLineTo(tickLength / 2);
        }

        // x tick labels
        const firstXLabel = graph.graphModelBounds.minX - graph.graphModelBounds.minX % TICK_LABEL_SPACING;
        for (let xValue = firstXLabel; xValue <= graph.graphModelBounds.maxX; xValue = xValue + TICK_LABEL_SPACING) {
          if (xValue !== 0) {
            const tickLabel = new Text(xValue, TICK_LABEL_OPTIONS);
            tickLabel.centerX = modelViewTransform.modelToViewX(xValue);
            tickLabel.top = viewOrigin.y + TICK_LABEL_Y_OFFSET;
            tickLabels.push(tickLabel);
          }
        }
      }
      if (graph.orientation !== GraphOrientations.HORIZONTAL) {
        // y tick marks
        const firstYTick = graph.graphModelBounds.minY - graph.graphModelBounds.minY % MAJOR_TICK_SPACING;
        for (let yValue = firstYTick; yValue <= graph.graphModelBounds.maxY; yValue = yValue + MAJOR_TICK_SPACING) {
          const tickLength = yValue === 0 ? ORIGIN_TICK_LENGTH : TICK_LENGTH; // origin tick is different
          tickMarksShape.moveTo(-tickLength / 2, yValue).horizontalLineTo(tickLength / 2);
        }

        // y tick labels
        const firstYLabel = graph.graphModelBounds.minY - graph.graphModelBounds.minY % TICK_LABEL_SPACING;
        for (let yValue = firstYLabel; yValue <= graph.graphModelBounds.maxY; yValue = yValue + TICK_LABEL_SPACING) {
          if (yValue !== 0) {
            const tickLabel = new Text(yValue, TICK_LABEL_OPTIONS);
            tickLabel.right = viewOrigin.x - TICK_LABEL_X_OFFSET;
            tickLabel.centerY = modelViewTransform.modelToViewY(yValue);
            tickLabels.push(tickLabel);
          }
        }
      }

      // Origin tick label
      if (graph.orientation !== GraphOrientations.TWO_DIMENSIONAL) {
        tickLabels.push(originLabel);
        if (graph.orientation === GraphOrientations.HORIZONTAL) {
          originLabel.centerX = viewOrigin.x;
          originLabel.top = viewOrigin.y + TICK_LABEL_Y_OFFSET;
        } else {
          originLabel.right = viewOrigin.x - TICK_LABEL_X_OFFSET;
          originLabel.centerY = viewOrigin.y;
        }
      }
      tickMarksPath.shape = modelViewTransform.modelToViewShape(tickMarksShape);
      tickLabelsParent.children = tickLabels;
    });
  }
}
vectorAddition.register('GraphNode', GraphNode);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJWZWN0b3IyIiwiU2hhcGUiLCJBcnJvd05vZGUiLCJDb2xvciIsIk5vZGUiLCJQYXRoIiwiUmVjdGFuZ2xlIiwiVGV4dCIsInZlY3RvckFkZGl0aW9uIiwiVmVjdG9yQWRkaXRpb25TdHJpbmdzIiwiR3JhcGhPcmllbnRhdGlvbnMiLCJWZWN0b3JBZGRpdGlvbkNvbG9ycyIsIlZlY3RvckFkZGl0aW9uQ29uc3RhbnRzIiwiT3JpZ2luTWFuaXB1bGF0b3IiLCJvcHRpb25pemUiLCJNQUpPUl9HUklEX0xJTkVfV0lEVEgiLCJNSU5PUl9HUklEX0xJTkVfV0lEVEgiLCJBWEVTX0FSUk9XX1hfRVhURU5TSU9OIiwiQVhFU19BUlJPV19ZX0VYVEVOU0lPTiIsIk1BSk9SX1RJQ0tfU1BBQ0lORyIsIk1JTk9SX1RJQ0tfU1BBQ0lORyIsIlRJQ0tfTEVOR1RIIiwiT1JJR0lOX1RJQ0tfTEVOR1RIIiwiVElDS19NQVJLX09QVElPTlMiLCJsaW5lV2lkdGgiLCJzdHJva2UiLCJCTEFDSyIsIlRJQ0tfTEFCRUxfT1BUSU9OUyIsImZvbnQiLCJUSUNLX0xBQkVMX0ZPTlQiLCJmaWxsIiwibWF4V2lkdGgiLCJUSUNLX0xBQkVMX1NQQUNJTkciLCJUSUNLX0xBQkVMX1hfT0ZGU0VUIiwiVElDS19MQUJFTF9ZX09GRlNFVCIsIkdyYXBoTm9kZSIsImNvbnN0cnVjdG9yIiwiZ3JhcGgiLCJncmlkVmlzaWJpbGl0eVByb3BlcnR5IiwiZ3JhcGhWaWV3Qm91bmRzIiwiYmFja2dyb3VuZCIsIkdSQVBIX0JBQ0tHUk9VTkRfQ09MT1IiLCJHUkFQSF9NSU5PUl9MSU5FX0NPTE9SIiwiY2hpbGRyZW4iLCJNYWpvckFuZE1pbm9yR3JpZExpbmVzIiwiVGlja3NOb2RlIiwib3JpZW50YXRpb24iLCJWRVJUSUNBTCIsInB1c2giLCJYQXhpc05vZGUiLCJIT1JJWk9OVEFMIiwiWUF4aXNOb2RlIiwiaXNEaXNwb3NhYmxlIiwiYWRkSW5wdXRMaXN0ZW5lciIsImRvd24iLCJhY3RpdmVWZWN0b3JQcm9wZXJ0eSIsInZhbHVlIiwibWFqb3JHcmlkTGluZXMiLCJHcmlkTGluZXMiLCJzcGFjaW5nIiwiR1JBUEhfTUFKT1JfTElORV9DT0xPUiIsIm1pbm9yR3JpZExpbmVzUGF0aCIsInBpY2thYmxlIiwibGlua0F0dHJpYnV0ZSIsInByb3ZpZGVkT3B0aW9ucyIsIm9wdGlvbnMiLCJtb2RlbFZpZXdUcmFuc2Zvcm1Qcm9wZXJ0eSIsImxpbmsiLCJtb2RlbFZpZXdUcmFuc2Zvcm0iLCJncmFwaE1pblgiLCJncmFwaE1vZGVsQm91bmRzIiwibWluWCIsImdyYXBoTWF4WCIsIm1heFgiLCJncmFwaE1pblkiLCJtaW5ZIiwiZ3JhcGhNYXhZIiwibWF4WSIsInNoYXBlIiwiZmlyc3RYIiwieFZhbHVlIiwibW92ZVRvIiwidmVydGljYWxMaW5lVG8iLCJmaXJzdFkiLCJ5VmFsdWUiLCJob3Jpem9udGFsTGluZVRvIiwic2V0U2hhcGUiLCJtb2RlbFRvVmlld1NoYXBlIiwiY29tcHV0ZVNoYXBlQm91bmRzIiwiYXJyb3dOb2RlIiwiQVhFU19BUlJPV19PUFRJT05TIiwiYXhpc0xhYmVsIiwic3ltYm9sIiwieCIsIkFYSVNfTEFCRUxfRk9OVCIsImxlZnQiLCJyaWdodCIsImNlbnRlclkiLCJ5IiwibW9kZWxUb1ZpZXdZIiwiY2VudGVyWCIsImJvdHRvbSIsInRvcCIsIm1vZGVsVG9WaWV3WCIsInRpY2tNYXJrc1BhdGgiLCJ0aWNrTGFiZWxzUGFyZW50Iiwib3JpZ2luTGFiZWwiLCJ2aWV3T3JpZ2luIiwibW9kZWxUb1ZpZXdQb3NpdGlvbiIsIlpFUk8iLCJ0aWNrTWFya3NTaGFwZSIsInRpY2tMYWJlbHMiLCJmaXJzdFhUaWNrIiwidGlja0xlbmd0aCIsImZpcnN0WExhYmVsIiwidGlja0xhYmVsIiwiZmlyc3RZVGljayIsImZpcnN0WUxhYmVsIiwiVFdPX0RJTUVOU0lPTkFMIiwicmVnaXN0ZXIiXSwic291cmNlcyI6WyJHcmFwaE5vZGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTktMjAyMywgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXHJcblxyXG4vKipcclxuICogR3JhcGhOb2RlIGRyYXdzIHRoZSBncmFwaCwgaW5jbHVkaW5nIGl0cyBncmlkLCBheGVzLCB0aWNrcywgYW5kIG9yaWdpbiBtYW5pcHVsYXRvci5cclxuICpcclxuICogQGF1dGhvciBNYXJ0aW4gVmVpbGxldHRlXHJcbiAqIEBhdXRob3IgQ2hyaXMgTWFsbGV5IChQaXhlbFpvb20sIEluYy4pXHJcbiAqL1xyXG5cclxuaW1wb3J0IFZlY3RvcjIgZnJvbSAnLi4vLi4vLi4vLi4vZG90L2pzL1ZlY3RvcjIuanMnO1xyXG5pbXBvcnQgeyBTaGFwZSB9IGZyb20gJy4uLy4uLy4uLy4uL2tpdGUvanMvaW1wb3J0cy5qcyc7XHJcbmltcG9ydCBBcnJvd05vZGUgZnJvbSAnLi4vLi4vLi4vLi4vc2NlbmVyeS1waGV0L2pzL0Fycm93Tm9kZS5qcyc7XHJcbmltcG9ydCB7IENvbG9yLCBOb2RlLCBQYXRoLCBQYXRoT3B0aW9ucywgUmVjdGFuZ2xlLCBUZXh0IH0gZnJvbSAnLi4vLi4vLi4vLi4vc2NlbmVyeS9qcy9pbXBvcnRzLmpzJztcclxuaW1wb3J0IHZlY3RvckFkZGl0aW9uIGZyb20gJy4uLy4uL3ZlY3RvckFkZGl0aW9uLmpzJztcclxuaW1wb3J0IFZlY3RvckFkZGl0aW9uU3RyaW5ncyBmcm9tICcuLi8uLi9WZWN0b3JBZGRpdGlvblN0cmluZ3MuanMnO1xyXG5pbXBvcnQgR3JhcGggZnJvbSAnLi4vbW9kZWwvR3JhcGguanMnO1xyXG5pbXBvcnQgR3JhcGhPcmllbnRhdGlvbnMgZnJvbSAnLi4vbW9kZWwvR3JhcGhPcmllbnRhdGlvbnMuanMnO1xyXG5pbXBvcnQgVmVjdG9yQWRkaXRpb25Db2xvcnMgZnJvbSAnLi4vVmVjdG9yQWRkaXRpb25Db2xvcnMuanMnO1xyXG5pbXBvcnQgVmVjdG9yQWRkaXRpb25Db25zdGFudHMgZnJvbSAnLi4vVmVjdG9yQWRkaXRpb25Db25zdGFudHMuanMnO1xyXG5pbXBvcnQgT3JpZ2luTWFuaXB1bGF0b3IgZnJvbSAnLi9PcmlnaW5NYW5pcHVsYXRvci5qcyc7XHJcbmltcG9ydCBQcm9wZXJ0eSBmcm9tICcuLi8uLi8uLi8uLi9heG9uL2pzL1Byb3BlcnR5LmpzJztcclxuaW1wb3J0IEJvdW5kczIgZnJvbSAnLi4vLi4vLi4vLi4vZG90L2pzL0JvdW5kczIuanMnO1xyXG5pbXBvcnQgUGlja09wdGlvbmFsIGZyb20gJy4uLy4uLy4uLy4uL3BoZXQtY29yZS9qcy90eXBlcy9QaWNrT3B0aW9uYWwuanMnO1xyXG5pbXBvcnQgb3B0aW9uaXplIGZyb20gJy4uLy4uLy4uLy4uL3BoZXQtY29yZS9qcy9vcHRpb25pemUuanMnO1xyXG5cclxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vIGNvbnN0YW50c1xyXG5cclxuLy8gZ3JpZFxyXG5jb25zdCBNQUpPUl9HUklEX0xJTkVfV0lEVEggPSAxLjU7IC8vIHZpZXcgdW5pdHNcclxuY29uc3QgTUlOT1JfR1JJRF9MSU5FX1dJRFRIID0gMTsgLy8gdmlldyB1bml0c1xyXG5cclxuLy8gYXhlc1xyXG5jb25zdCBBWEVTX0FSUk9XX1hfRVhURU5TSU9OID0gVmVjdG9yQWRkaXRpb25Db25zdGFudHMuQVhFU19BUlJPV19YX0VYVEVOU0lPTjtcclxuY29uc3QgQVhFU19BUlJPV19ZX0VYVEVOU0lPTiA9IFZlY3RvckFkZGl0aW9uQ29uc3RhbnRzLkFYRVNfQVJST1dfWV9FWFRFTlNJT047XHJcblxyXG4vLyB0aWNrIG1hcmtzXHJcbmNvbnN0IE1BSk9SX1RJQ0tfU1BBQ0lORyA9IDU7IC8vIG1vZGVsIHVuaXRzXHJcbmNvbnN0IE1JTk9SX1RJQ0tfU1BBQ0lORyA9IDE7IC8vIG1vZGVsIHVuaXRzXHJcbmNvbnN0IFRJQ0tfTEVOR1RIID0gMTsgLy8gbW9kZWwgdW5pdHNcclxuY29uc3QgT1JJR0lOX1RJQ0tfTEVOR1RIID0gMjsgLy8gbW9kZWwgdW5pdHNcclxuY29uc3QgVElDS19NQVJLX09QVElPTlMgPSB7XHJcbiAgbGluZVdpZHRoOiAxLFxyXG4gIHN0cm9rZTogQ29sb3IuQkxBQ0tcclxufTtcclxuXHJcbi8vIHRpY2sgbGFiZWxzXHJcbmNvbnN0IFRJQ0tfTEFCRUxfT1BUSU9OUyA9IHtcclxuICBmb250OiBWZWN0b3JBZGRpdGlvbkNvbnN0YW50cy5USUNLX0xBQkVMX0ZPTlQsXHJcbiAgZmlsbDogJ3JnYiggMTMwLCAxMzAsIDEzMCApJyxcclxuICBtYXhXaWR0aDogMzBcclxufTtcclxuY29uc3QgVElDS19MQUJFTF9TUEFDSU5HID0gMTA7IC8vIG1vZGVsIHVuaXRzXHJcbmNvbnN0IFRJQ0tfTEFCRUxfWF9PRkZTRVQgPSAxNTsgLy8gZnJvbSB4ID0gMCwgdmlldyB1bml0c1xyXG5jb25zdCBUSUNLX0xBQkVMX1lfT0ZGU0VUID0gMTU7IC8vIGZyb20geSA9IDAsIHZpZXcgdW5pdHNcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdyYXBoTm9kZSBleHRlbmRzIE5vZGUge1xyXG5cclxuICBwdWJsaWMgY29uc3RydWN0b3IoIGdyYXBoOiBHcmFwaCwgZ3JpZFZpc2liaWxpdHlQcm9wZXJ0eTogUHJvcGVydHk8Ym9vbGVhbj4gKSB7XHJcblxyXG4gICAgY29uc3QgZ3JhcGhWaWV3Qm91bmRzID0gZ3JhcGguZ3JhcGhWaWV3Qm91bmRzO1xyXG5cclxuICAgIGNvbnN0IGJhY2tncm91bmQgPSBuZXcgUmVjdGFuZ2xlKCBncmFwaFZpZXdCb3VuZHMsIHtcclxuICAgICAgZmlsbDogVmVjdG9yQWRkaXRpb25Db2xvcnMuR1JBUEhfQkFDS0dST1VORF9DT0xPUixcclxuICAgICAgc3Ryb2tlOiBWZWN0b3JBZGRpdGlvbkNvbG9ycy5HUkFQSF9NSU5PUl9MSU5FX0NPTE9SLFxyXG4gICAgICBsaW5lV2lkdGg6IE1JTk9SX0dSSURfTElORV9XSURUSFxyXG4gICAgfSApO1xyXG5cclxuICAgIGNvbnN0IGNoaWxkcmVuID0gW1xyXG4gICAgICBiYWNrZ3JvdW5kLFxyXG4gICAgICBuZXcgTWFqb3JBbmRNaW5vckdyaWRMaW5lcyggZ3JhcGgsIGdyYXBoVmlld0JvdW5kcywgZ3JpZFZpc2liaWxpdHlQcm9wZXJ0eSApLFxyXG4gICAgICBuZXcgVGlja3NOb2RlKCBncmFwaCApXHJcbiAgICBdO1xyXG5cclxuICAgIC8vIENyZWF0ZSBheGVzIGFzIG5lZWRlZCwgYmFzZWQgb24gZ3JhcGggb3JpZW50YXRpb25cclxuICAgIGlmICggZ3JhcGgub3JpZW50YXRpb24gIT09IEdyYXBoT3JpZW50YXRpb25zLlZFUlRJQ0FMICkge1xyXG4gICAgICBjaGlsZHJlbi5wdXNoKCBuZXcgWEF4aXNOb2RlKCBncmFwaCwgZ3JhcGhWaWV3Qm91bmRzICkgKTtcclxuICAgIH1cclxuICAgIGlmICggZ3JhcGgub3JpZW50YXRpb24gIT09IEdyYXBoT3JpZW50YXRpb25zLkhPUklaT05UQUwgKSB7XHJcbiAgICAgIGNoaWxkcmVuLnB1c2goIG5ldyBZQXhpc05vZGUoIGdyYXBoLCBncmFwaFZpZXdCb3VuZHMgKSApO1xyXG4gICAgfVxyXG5cclxuICAgIGNoaWxkcmVuLnB1c2goIG5ldyBPcmlnaW5NYW5pcHVsYXRvciggZ3JhcGggKSApO1xyXG5cclxuICAgIHN1cGVyKCB7XHJcbiAgICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcclxuICAgICAgaXNEaXNwb3NhYmxlOiBmYWxzZVxyXG4gICAgfSApO1xyXG5cclxuICAgIC8vIENsaWNraW5nIGluIHRoZSBncmFwaCBjbGVhcnMgdGhlIGFjdGl2ZSAoc2VsZWN0ZWQpIHZlY3Rvci5cclxuICAgIC8vIFVzZSBhIHJhdyAnZG93bicgbGlzdGVuZXIgc28gdGhhdCB0aGlzIGRvZXNuJ3QgaW1wYWN0IHRoZSBhYmlsaXR5IHRvIHRvdWNoIHNuYWcgdmVjdG9ycyBhbmQgb3JpZ2luIG1hbmlwdWxhdG9yLlxyXG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waGV0c2ltcy92ZWN0b3ItYWRkaXRpb24vaXNzdWVzLzI0M1xyXG4gICAgLy8gTm8gbmVlZCB0byByZW1vdmUsIGV4aXN0cyBmb3IgdGhlIGxpZmV0aW1lIG9mIHRoZSBzaW0uXHJcbiAgICBiYWNrZ3JvdW5kLmFkZElucHV0TGlzdGVuZXIoIHtcclxuICAgICAgZG93bjogKCkgPT4geyBncmFwaC5hY3RpdmVWZWN0b3JQcm9wZXJ0eS52YWx1ZSA9IG51bGw7IH1cclxuICAgIH0gKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEcmF3cyB0aGUgbWFqb3IgYW5kIG1pbm9yIGdyaWQgbGluZXMuICBIYW5kbGVzIHZpc2liaWxpdHkgb2YgdGhlIGdyaWQuXHJcbiAqL1xyXG5jbGFzcyBNYWpvckFuZE1pbm9yR3JpZExpbmVzIGV4dGVuZHMgTm9kZSB7XHJcblxyXG4gIHB1YmxpYyBjb25zdHJ1Y3RvciggZ3JhcGg6IEdyYXBoLCBncmFwaFZpZXdCb3VuZHM6IEJvdW5kczIsIGdyaWRWaXNpYmlsaXR5UHJvcGVydHk6IFByb3BlcnR5PGJvb2xlYW4+ICkge1xyXG5cclxuICAgIGNvbnN0IG1ham9yR3JpZExpbmVzID0gbmV3IEdyaWRMaW5lcyggZ3JhcGgsIGdyYXBoVmlld0JvdW5kcywge1xyXG4gICAgICBzcGFjaW5nOiBNQUpPUl9USUNLX1NQQUNJTkcsXHJcbiAgICAgIGxpbmVXaWR0aDogTUFKT1JfR1JJRF9MSU5FX1dJRFRILFxyXG4gICAgICBzdHJva2U6IFZlY3RvckFkZGl0aW9uQ29sb3JzLkdSQVBIX01BSk9SX0xJTkVfQ09MT1JcclxuICAgIH0gKTtcclxuXHJcbiAgICBjb25zdCBtaW5vckdyaWRMaW5lc1BhdGggPSBuZXcgR3JpZExpbmVzKCBncmFwaCwgZ3JhcGhWaWV3Qm91bmRzLCB7XHJcbiAgICAgIHNwYWNpbmc6IE1JTk9SX1RJQ0tfU1BBQ0lORyxcclxuICAgICAgbGluZVdpZHRoOiBNSU5PUl9HUklEX0xJTkVfV0lEVEgsXHJcbiAgICAgIHN0cm9rZTogVmVjdG9yQWRkaXRpb25Db2xvcnMuR1JBUEhfTUlOT1JfTElORV9DT0xPUlxyXG4gICAgfSApO1xyXG5cclxuICAgIHN1cGVyKCB7XHJcbiAgICAgIGNoaWxkcmVuOiBbIG1pbm9yR3JpZExpbmVzUGF0aCwgbWFqb3JHcmlkTGluZXMgXSxcclxuICAgICAgcGlja2FibGU6IGZhbHNlXHJcbiAgICB9ICk7XHJcblxyXG4gICAgLy8gT2JzZXJ2ZSBjaGFuZ2VzIHRvIHRoZSBncmlkIHZpc2liaWxpdHkgUHJvcGVydHksIGFuZCB1cGRhdGUgdmlzaWJpbGl0eS5cclxuICAgIC8vIE5vIG5lZWQgdG8gdW5saW5rIHNpbmNlIEdyYXBoTm9kZXMgZXhpc3QgZm9yIHRoZSBsaWZldGltZSBvZiB0aGUgc2ltLlxyXG4gICAgZ3JpZFZpc2liaWxpdHlQcm9wZXJ0eS5saW5rQXR0cmlidXRlKCB0aGlzLCAndmlzaWJsZScgKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEcmF3cyBncmlkIGxpbmVzIGF0IHNvbWUgc3BhY2luZy4gVXNlZCB0byBkcmF3IG9uZSB0eXBlIG9mIGdyaWQgbGluZSAobWFqb3Igb3IgbWlub3IpLlxyXG4gKiBVcGRhdGVzIHdoZW4gdGhlIG9yaWdpbiBjaGFuZ2VzLiBPcHRpbWl6ZWQgdG8gdGFrZSBhZHZhbnRhZ2Ugb2YgY29uc3RhbnQgdmlldyBib3VuZHMuXHJcbiAqL1xyXG5cclxudHlwZSBHcmlkTGluZXNTZWxmT3B0aW9ucyA9IHtcclxuICBzcGFjaW5nPzogbnVtYmVyO1xyXG59O1xyXG5cclxudHlwZSBHcmlkTGluZXNPcHRpb25zID0gR3JpZExpbmVzU2VsZk9wdGlvbnMgJiBQaWNrT3B0aW9uYWw8UGF0aE9wdGlvbnMsICdsaW5lV2lkdGgnIHwgJ3N0cm9rZSc+O1xyXG5cclxuY2xhc3MgR3JpZExpbmVzIGV4dGVuZHMgUGF0aCB7XHJcblxyXG4gIHByaXZhdGUgcmVhZG9ubHkgZ3JhcGhWaWV3Qm91bmRzOiBCb3VuZHMyO1xyXG5cclxuICBwdWJsaWMgY29uc3RydWN0b3IoIGdyYXBoOiBHcmFwaCwgZ3JhcGhWaWV3Qm91bmRzOiBCb3VuZHMyLCBwcm92aWRlZE9wdGlvbnM/OiBHcmlkTGluZXNPcHRpb25zICkge1xyXG5cclxuICAgIGNvbnN0IG9wdGlvbnMgPSBvcHRpb25pemU8R3JpZExpbmVzT3B0aW9ucywgR3JpZExpbmVzU2VsZk9wdGlvbnMsIFBhdGhPcHRpb25zPigpKCB7XHJcblxyXG4gICAgICAvLyBHcmlkTGluZXNTZWxmT3B0aW9uc1xyXG4gICAgICBzcGFjaW5nOiAxLFxyXG5cclxuICAgICAgLy8gUGF0aE9wdGlvbnNcclxuICAgICAgbGluZVdpZHRoOiAxLFxyXG4gICAgICBzdHJva2U6ICdibGFjaydcclxuICAgIH0sIHByb3ZpZGVkT3B0aW9ucyApO1xyXG5cclxuICAgIHN1cGVyKCBuZXcgU2hhcGUoKSwgb3B0aW9ucyApO1xyXG5cclxuICAgIHRoaXMuZ3JhcGhWaWV3Qm91bmRzID0gZ3JhcGhWaWV3Qm91bmRzO1xyXG5cclxuICAgIC8vIFVwZGF0ZSB3aGVuIHRoZSBtb2RlbFZpZXdUcmFuc2Zvcm0gY2hhbmdlcywgdHJpZ2dlcmVkIHdoZW4gdGhlIG9yaWdpbiBpcyBtb3ZlZC5cclxuICAgIC8vIHVubGluayBpcyB1bm5lY2Vzc2FyeSwgZXhpc3RzIGZvciB0aGUgbGlmZXRpbWUgb2YgdGhlIHNpbS5cclxuICAgIGdyYXBoLm1vZGVsVmlld1RyYW5zZm9ybVByb3BlcnR5LmxpbmsoIG1vZGVsVmlld1RyYW5zZm9ybSA9PiB7XHJcblxyXG4gICAgICAvLyBDb252ZW5pZW5jZSB2YXJpYWJsZXNcclxuICAgICAgY29uc3QgZ3JhcGhNaW5YID0gZ3JhcGguZ3JhcGhNb2RlbEJvdW5kcy5taW5YO1xyXG4gICAgICBjb25zdCBncmFwaE1heFggPSBncmFwaC5ncmFwaE1vZGVsQm91bmRzLm1heFg7XHJcbiAgICAgIGNvbnN0IGdyYXBoTWluWSA9IGdyYXBoLmdyYXBoTW9kZWxCb3VuZHMubWluWTtcclxuICAgICAgY29uc3QgZ3JhcGhNYXhZID0gZ3JhcGguZ3JhcGhNb2RlbEJvdW5kcy5tYXhZO1xyXG5cclxuICAgICAgY29uc3Qgc2hhcGUgPSBuZXcgU2hhcGUoKTtcclxuXHJcbiAgICAgIC8vIFZlcnRpY2FsIGxpbmVzXHJcbiAgICAgIGNvbnN0IGZpcnN0WCA9IGdyYXBoTWluWCAtICggZ3JhcGhNaW5YICUgb3B0aW9ucy5zcGFjaW5nICk7XHJcbiAgICAgIGZvciAoIGxldCB4VmFsdWUgPSBmaXJzdFg7IHhWYWx1ZSA8PSBncmFwaE1heFg7IHhWYWx1ZSArPSBvcHRpb25zLnNwYWNpbmcgKSB7XHJcbiAgICAgICAgc2hhcGUubW92ZVRvKCB4VmFsdWUsIGdyYXBoTWluWSApLnZlcnRpY2FsTGluZVRvKCBncmFwaE1heFkgKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gSG9yaXpvbnRhbCBsaW5lc1xyXG4gICAgICBjb25zdCBmaXJzdFkgPSBncmFwaE1pblkgLSAoIGdyYXBoTWluWSAlIG9wdGlvbnMuc3BhY2luZyApO1xyXG4gICAgICBmb3IgKCBsZXQgeVZhbHVlID0gZmlyc3RZOyB5VmFsdWUgPD0gZ3JhcGhNYXhZOyB5VmFsdWUgKz0gb3B0aW9ucy5zcGFjaW5nICkge1xyXG4gICAgICAgIHNoYXBlLm1vdmVUbyggZ3JhcGhNaW5YLCB5VmFsdWUgKS5ob3Jpem9udGFsTGluZVRvKCBncmFwaE1heFggKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5zZXRTaGFwZSggbW9kZWxWaWV3VHJhbnNmb3JtLm1vZGVsVG9WaWV3U2hhcGUoIHNoYXBlICkgKTtcclxuICAgIH0gKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFBlcmZvcm1hbmNlIG9wdGltaXphdGlvbiwgc2luY2UgdGhlIGdyaWQncyB2aWV3IGJvdW5kcyBhcmUgY29uc3RhbnQuXHJcbiAgICovXHJcbiAgcHVibGljIG92ZXJyaWRlIGNvbXB1dGVTaGFwZUJvdW5kcygpOiBCb3VuZHMyIHtcclxuICAgIHJldHVybiB0aGlzLmdyYXBoVmlld0JvdW5kcztcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEcmF3cyB0aGUgeC1heGlzLlxyXG4gKi9cclxuY2xhc3MgWEF4aXNOb2RlIGV4dGVuZHMgTm9kZSB7XHJcblxyXG4gIHB1YmxpYyBjb25zdHJ1Y3RvciggZ3JhcGg6IEdyYXBoLCBncmFwaFZpZXdCb3VuZHM6IEJvdW5kczIgKSB7XHJcblxyXG4gICAgY29uc3QgYXJyb3dOb2RlID0gbmV3IEFycm93Tm9kZShcclxuICAgICAgZ3JhcGhWaWV3Qm91bmRzLm1pblggLSBBWEVTX0FSUk9XX1hfRVhURU5TSU9OLCAwLFxyXG4gICAgICBncmFwaFZpZXdCb3VuZHMubWF4WCArIEFYRVNfQVJST1dfWF9FWFRFTlNJT04sIDAsXHJcbiAgICAgIFZlY3RvckFkZGl0aW9uQ29uc3RhbnRzLkFYRVNfQVJST1dfT1BUSU9OU1xyXG4gICAgKTtcclxuXHJcbiAgICBjb25zdCBheGlzTGFiZWwgPSBuZXcgVGV4dCggVmVjdG9yQWRkaXRpb25TdHJpbmdzLnN5bWJvbC54LCB7XHJcbiAgICAgIGZvbnQ6IFZlY3RvckFkZGl0aW9uQ29uc3RhbnRzLkFYSVNfTEFCRUxfRk9OVCxcclxuICAgICAgbWF4V2lkdGg6IDIyLFxyXG4gICAgICBsZWZ0OiBhcnJvd05vZGUucmlnaHQgKyA2LFxyXG4gICAgICBjZW50ZXJZOiBhcnJvd05vZGUuY2VudGVyWVxyXG4gICAgfSApO1xyXG5cclxuICAgIHN1cGVyKCB7XHJcbiAgICAgIGNoaWxkcmVuOiBbIGFycm93Tm9kZSwgYXhpc0xhYmVsIF0sXHJcbiAgICAgIHBpY2thYmxlOiBmYWxzZVxyXG4gICAgfSApO1xyXG5cclxuICAgIC8vIFdoZW4gdGhlIG9yaWdpbiBtb3ZlcywgYWRqdXN0IHRoZSBwb3NpdGlvbiBvZiB0aGUgYXhpcy5cclxuICAgIC8vIHVubGluayBpcyB1bm5lY2Vzc2FyeSwgZXhpc3RzIGZvciB0aGUgbGlmZXRpbWUgb2YgdGhlIHNpbS5cclxuICAgIGdyYXBoLm1vZGVsVmlld1RyYW5zZm9ybVByb3BlcnR5LmxpbmsoIG1vZGVsVmlld1RyYW5zZm9ybSA9PiB7XHJcbiAgICAgIHRoaXMueSA9IG1vZGVsVmlld1RyYW5zZm9ybS5tb2RlbFRvVmlld1koIDAgKTtcclxuICAgIH0gKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEcmF3cyB0aGUgeSBheGlzLlxyXG4gKi9cclxuY2xhc3MgWUF4aXNOb2RlIGV4dGVuZHMgTm9kZSB7XHJcblxyXG4gIHB1YmxpYyBjb25zdHJ1Y3RvciggZ3JhcGg6IEdyYXBoLCBncmFwaFZpZXdCb3VuZHM6IEJvdW5kczIgKSB7XHJcblxyXG4gICAgY29uc3QgYXJyb3dOb2RlID0gbmV3IEFycm93Tm9kZShcclxuICAgICAgMCwgZ3JhcGhWaWV3Qm91bmRzLm1pblkgLSBBWEVTX0FSUk9XX1lfRVhURU5TSU9OLFxyXG4gICAgICAwLCBncmFwaFZpZXdCb3VuZHMubWF4WSArIEFYRVNfQVJST1dfWV9FWFRFTlNJT04sXHJcbiAgICAgIFZlY3RvckFkZGl0aW9uQ29uc3RhbnRzLkFYRVNfQVJST1dfT1BUSU9OU1xyXG4gICAgKTtcclxuXHJcbiAgICBjb25zdCBheGlzTGFiZWwgPSBuZXcgVGV4dCggVmVjdG9yQWRkaXRpb25TdHJpbmdzLnN5bWJvbC55LCB7XHJcbiAgICAgIGZvbnQ6IFZlY3RvckFkZGl0aW9uQ29uc3RhbnRzLkFYSVNfTEFCRUxfRk9OVCxcclxuICAgICAgbWF4V2lkdGg6IDMwLFxyXG4gICAgICBjZW50ZXJYOiBhcnJvd05vZGUuY2VudGVyWCxcclxuICAgICAgYm90dG9tOiBhcnJvd05vZGUudG9wIC0gM1xyXG4gICAgfSApO1xyXG5cclxuICAgIHN1cGVyKCB7XHJcbiAgICAgIGNoaWxkcmVuOiBbIGFycm93Tm9kZSwgYXhpc0xhYmVsIF0sXHJcbiAgICAgIHBpY2thYmxlOiBmYWxzZVxyXG4gICAgfSApO1xyXG5cclxuICAgIC8vIFdoZW4gdGhlIG9yaWdpbiBtb3ZlcywgYWRqdXN0IHRoZSBwb3NpdGlvbiBvZiB0aGUgYXhpcy5cclxuICAgIC8vIHVubGluayBpcyB1bm5lY2Vzc2FyeSwgZXhpc3RzIGZvciB0aGUgbGlmZXRpbWUgb2YgdGhlIHNpbS5cclxuICAgIGdyYXBoLm1vZGVsVmlld1RyYW5zZm9ybVByb3BlcnR5LmxpbmsoIG1vZGVsVmlld1RyYW5zZm9ybSA9PiB7XHJcbiAgICAgIHRoaXMueCA9IG1vZGVsVmlld1RyYW5zZm9ybS5tb2RlbFRvVmlld1goIDAgKTtcclxuICAgIH0gKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEcmF3cyB0aGUgdGljayBtYXJrcyBhbmQgbGFiZWxzLlxyXG4gKi9cclxuY2xhc3MgVGlja3NOb2RlIGV4dGVuZHMgTm9kZSB7XHJcblxyXG4gIHB1YmxpYyBjb25zdHJ1Y3RvciggZ3JhcGg6IEdyYXBoICkge1xyXG5cclxuICAgIGNvbnN0IHRpY2tNYXJrc1BhdGggPSBuZXcgUGF0aCggbmV3IFNoYXBlKCksIFRJQ0tfTUFSS19PUFRJT05TICk7XHJcbiAgICBjb25zdCB0aWNrTGFiZWxzUGFyZW50ID0gbmV3IE5vZGUoKTtcclxuICAgIGNvbnN0IG9yaWdpbkxhYmVsID0gbmV3IFRleHQoICcwJywgVElDS19MQUJFTF9PUFRJT05TICk7XHJcblxyXG4gICAgc3VwZXIoIHtcclxuICAgICAgY2hpbGRyZW46IFsgdGlja01hcmtzUGF0aCwgdGlja0xhYmVsc1BhcmVudCBdLFxyXG4gICAgICBwaWNrYWJsZTogZmFsc2VcclxuICAgIH0gKTtcclxuXHJcbiAgICAvLyBVcGRhdGUgdGlja3Mgd2hlbiB0aGUgZ3JhcGgncyBvcmlnaW4gbW92ZXMuXHJcbiAgICAvLyB1bmxpbmsgaXMgdW5uZWNlc3NhcnksIGV4aXN0cyBmb3IgdGhlIGxpZmV0aW1lIG9mIHRoZSBzaW0uXHJcbiAgICBncmFwaC5tb2RlbFZpZXdUcmFuc2Zvcm1Qcm9wZXJ0eS5saW5rKCBtb2RlbFZpZXdUcmFuc2Zvcm0gPT4ge1xyXG5cclxuICAgICAgY29uc3Qgdmlld09yaWdpbiA9IG1vZGVsVmlld1RyYW5zZm9ybS5tb2RlbFRvVmlld1Bvc2l0aW9uKCBWZWN0b3IyLlpFUk8gKTtcclxuICAgICAgY29uc3QgdGlja01hcmtzU2hhcGUgPSBuZXcgU2hhcGUoKTtcclxuICAgICAgY29uc3QgdGlja0xhYmVscyA9IFtdO1xyXG5cclxuICAgICAgaWYgKCBncmFwaC5vcmllbnRhdGlvbiAhPT0gR3JhcGhPcmllbnRhdGlvbnMuVkVSVElDQUwgKSB7XHJcblxyXG4gICAgICAgIC8vIHggdGljayBtYXJrc1xyXG4gICAgICAgIGNvbnN0IGZpcnN0WFRpY2sgPSBncmFwaC5ncmFwaE1vZGVsQm91bmRzLm1pblggLSAoIGdyYXBoLmdyYXBoTW9kZWxCb3VuZHMubWluWCAlIE1BSk9SX1RJQ0tfU1BBQ0lORyApO1xyXG4gICAgICAgIGZvciAoIGxldCB4VmFsdWUgPSBmaXJzdFhUaWNrOyB4VmFsdWUgPD0gZ3JhcGguZ3JhcGhNb2RlbEJvdW5kcy5tYXhYOyB4VmFsdWUgPSB4VmFsdWUgKyBNQUpPUl9USUNLX1NQQUNJTkcgKSB7XHJcbiAgICAgICAgICBjb25zdCB0aWNrTGVuZ3RoID0gKCB4VmFsdWUgPT09IDAgKSA/IE9SSUdJTl9USUNLX0xFTkdUSCA6IFRJQ0tfTEVOR1RIOyAvLyBvcmlnaW4gdGljayBpcyBkaWZmZXJlbnRcclxuICAgICAgICAgIHRpY2tNYXJrc1NoYXBlLm1vdmVUbyggeFZhbHVlLCAtdGlja0xlbmd0aCAvIDIgKS52ZXJ0aWNhbExpbmVUbyggdGlja0xlbmd0aCAvIDIgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHggdGljayBsYWJlbHNcclxuICAgICAgICBjb25zdCBmaXJzdFhMYWJlbCA9IGdyYXBoLmdyYXBoTW9kZWxCb3VuZHMubWluWCAtICggZ3JhcGguZ3JhcGhNb2RlbEJvdW5kcy5taW5YICUgVElDS19MQUJFTF9TUEFDSU5HICk7XHJcbiAgICAgICAgZm9yICggbGV0IHhWYWx1ZSA9IGZpcnN0WExhYmVsOyB4VmFsdWUgPD0gZ3JhcGguZ3JhcGhNb2RlbEJvdW5kcy5tYXhYOyB4VmFsdWUgPSB4VmFsdWUgKyBUSUNLX0xBQkVMX1NQQUNJTkcgKSB7XHJcbiAgICAgICAgICBpZiAoIHhWYWx1ZSAhPT0gMCApIHtcclxuICAgICAgICAgICAgY29uc3QgdGlja0xhYmVsID0gbmV3IFRleHQoIHhWYWx1ZSwgVElDS19MQUJFTF9PUFRJT05TICk7XHJcbiAgICAgICAgICAgIHRpY2tMYWJlbC5jZW50ZXJYID0gbW9kZWxWaWV3VHJhbnNmb3JtLm1vZGVsVG9WaWV3WCggeFZhbHVlICk7XHJcbiAgICAgICAgICAgIHRpY2tMYWJlbC50b3AgPSB2aWV3T3JpZ2luLnkgKyBUSUNLX0xBQkVMX1lfT0ZGU0VUO1xyXG4gICAgICAgICAgICB0aWNrTGFiZWxzLnB1c2goIHRpY2tMYWJlbCApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCBncmFwaC5vcmllbnRhdGlvbiAhPT0gR3JhcGhPcmllbnRhdGlvbnMuSE9SSVpPTlRBTCApIHtcclxuXHJcbiAgICAgICAgLy8geSB0aWNrIG1hcmtzXHJcbiAgICAgICAgY29uc3QgZmlyc3RZVGljayA9IGdyYXBoLmdyYXBoTW9kZWxCb3VuZHMubWluWSAtICggZ3JhcGguZ3JhcGhNb2RlbEJvdW5kcy5taW5ZICUgTUFKT1JfVElDS19TUEFDSU5HICk7XHJcbiAgICAgICAgZm9yICggbGV0IHlWYWx1ZSA9IGZpcnN0WVRpY2s7IHlWYWx1ZSA8PSBncmFwaC5ncmFwaE1vZGVsQm91bmRzLm1heFk7IHlWYWx1ZSA9IHlWYWx1ZSArIE1BSk9SX1RJQ0tfU1BBQ0lORyApIHtcclxuICAgICAgICAgIGNvbnN0IHRpY2tMZW5ndGggPSAoIHlWYWx1ZSA9PT0gMCApID8gT1JJR0lOX1RJQ0tfTEVOR1RIIDogVElDS19MRU5HVEg7IC8vIG9yaWdpbiB0aWNrIGlzIGRpZmZlcmVudFxyXG4gICAgICAgICAgdGlja01hcmtzU2hhcGUubW92ZVRvKCAtdGlja0xlbmd0aCAvIDIsIHlWYWx1ZSApLmhvcml6b250YWxMaW5lVG8oIHRpY2tMZW5ndGggLyAyICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyB5IHRpY2sgbGFiZWxzXHJcbiAgICAgICAgY29uc3QgZmlyc3RZTGFiZWwgPSBncmFwaC5ncmFwaE1vZGVsQm91bmRzLm1pblkgLSAoIGdyYXBoLmdyYXBoTW9kZWxCb3VuZHMubWluWSAlIFRJQ0tfTEFCRUxfU1BBQ0lORyApO1xyXG4gICAgICAgIGZvciAoIGxldCB5VmFsdWUgPSBmaXJzdFlMYWJlbDsgeVZhbHVlIDw9IGdyYXBoLmdyYXBoTW9kZWxCb3VuZHMubWF4WTsgeVZhbHVlID0geVZhbHVlICsgVElDS19MQUJFTF9TUEFDSU5HICkge1xyXG4gICAgICAgICAgaWYgKCB5VmFsdWUgIT09IDAgKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRpY2tMYWJlbCA9IG5ldyBUZXh0KCB5VmFsdWUsIFRJQ0tfTEFCRUxfT1BUSU9OUyApO1xyXG4gICAgICAgICAgICB0aWNrTGFiZWwucmlnaHQgPSB2aWV3T3JpZ2luLnggLSBUSUNLX0xBQkVMX1hfT0ZGU0VUO1xyXG4gICAgICAgICAgICB0aWNrTGFiZWwuY2VudGVyWSA9IG1vZGVsVmlld1RyYW5zZm9ybS5tb2RlbFRvVmlld1koIHlWYWx1ZSApO1xyXG4gICAgICAgICAgICB0aWNrTGFiZWxzLnB1c2goIHRpY2tMYWJlbCApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gT3JpZ2luIHRpY2sgbGFiZWxcclxuICAgICAgaWYgKCBncmFwaC5vcmllbnRhdGlvbiAhPT0gR3JhcGhPcmllbnRhdGlvbnMuVFdPX0RJTUVOU0lPTkFMICkge1xyXG5cclxuICAgICAgICB0aWNrTGFiZWxzLnB1c2goIG9yaWdpbkxhYmVsICk7XHJcblxyXG4gICAgICAgIGlmICggZ3JhcGgub3JpZW50YXRpb24gPT09IEdyYXBoT3JpZW50YXRpb25zLkhPUklaT05UQUwgKSB7XHJcbiAgICAgICAgICBvcmlnaW5MYWJlbC5jZW50ZXJYID0gdmlld09yaWdpbi54O1xyXG4gICAgICAgICAgb3JpZ2luTGFiZWwudG9wID0gdmlld09yaWdpbi55ICsgVElDS19MQUJFTF9ZX09GRlNFVDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICBvcmlnaW5MYWJlbC5yaWdodCA9IHZpZXdPcmlnaW4ueCAtIFRJQ0tfTEFCRUxfWF9PRkZTRVQ7XHJcbiAgICAgICAgICBvcmlnaW5MYWJlbC5jZW50ZXJZID0gdmlld09yaWdpbi55O1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgdGlja01hcmtzUGF0aC5zaGFwZSA9IG1vZGVsVmlld1RyYW5zZm9ybS5tb2RlbFRvVmlld1NoYXBlKCB0aWNrTWFya3NTaGFwZSApO1xyXG4gICAgICB0aWNrTGFiZWxzUGFyZW50LmNoaWxkcmVuID0gdGlja0xhYmVscztcclxuICAgIH0gKTtcclxuICB9XHJcbn1cclxuXHJcbnZlY3RvckFkZGl0aW9uLnJlZ2lzdGVyKCAnR3JhcGhOb2RlJywgR3JhcGhOb2RlICk7Il0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBT0EsT0FBTyxNQUFNLCtCQUErQjtBQUNuRCxTQUFTQyxLQUFLLFFBQVEsZ0NBQWdDO0FBQ3RELE9BQU9DLFNBQVMsTUFBTSwwQ0FBMEM7QUFDaEUsU0FBU0MsS0FBSyxFQUFFQyxJQUFJLEVBQUVDLElBQUksRUFBZUMsU0FBUyxFQUFFQyxJQUFJLFFBQVEsbUNBQW1DO0FBQ25HLE9BQU9DLGNBQWMsTUFBTSx5QkFBeUI7QUFDcEQsT0FBT0MscUJBQXFCLE1BQU0sZ0NBQWdDO0FBRWxFLE9BQU9DLGlCQUFpQixNQUFNLCtCQUErQjtBQUM3RCxPQUFPQyxvQkFBb0IsTUFBTSw0QkFBNEI7QUFDN0QsT0FBT0MsdUJBQXVCLE1BQU0sK0JBQStCO0FBQ25FLE9BQU9DLGlCQUFpQixNQUFNLHdCQUF3QjtBQUl0RCxPQUFPQyxTQUFTLE1BQU0sdUNBQXVDOztBQUU3RDtBQUNBOztBQUVBO0FBQ0EsTUFBTUMscUJBQXFCLEdBQUcsR0FBRyxDQUFDLENBQUM7QUFDbkMsTUFBTUMscUJBQXFCLEdBQUcsQ0FBQyxDQUFDLENBQUM7O0FBRWpDO0FBQ0EsTUFBTUMsc0JBQXNCLEdBQUdMLHVCQUF1QixDQUFDSyxzQkFBc0I7QUFDN0UsTUFBTUMsc0JBQXNCLEdBQUdOLHVCQUF1QixDQUFDTSxzQkFBc0I7O0FBRTdFO0FBQ0EsTUFBTUMsa0JBQWtCLEdBQUcsQ0FBQyxDQUFDLENBQUM7QUFDOUIsTUFBTUMsa0JBQWtCLEdBQUcsQ0FBQyxDQUFDLENBQUM7QUFDOUIsTUFBTUMsV0FBVyxHQUFHLENBQUMsQ0FBQyxDQUFDO0FBQ3ZCLE1BQU1DLGtCQUFrQixHQUFHLENBQUMsQ0FBQyxDQUFDO0FBQzlCLE1BQU1DLGlCQUFpQixHQUFHO0VBQ3hCQyxTQUFTLEVBQUUsQ0FBQztFQUNaQyxNQUFNLEVBQUV0QixLQUFLLENBQUN1QjtBQUNoQixDQUFDOztBQUVEO0FBQ0EsTUFBTUMsa0JBQWtCLEdBQUc7RUFDekJDLElBQUksRUFBRWhCLHVCQUF1QixDQUFDaUIsZUFBZTtFQUM3Q0MsSUFBSSxFQUFFLHNCQUFzQjtFQUM1QkMsUUFBUSxFQUFFO0FBQ1osQ0FBQztBQUNELE1BQU1DLGtCQUFrQixHQUFHLEVBQUUsQ0FBQyxDQUFDO0FBQy9CLE1BQU1DLG1CQUFtQixHQUFHLEVBQUUsQ0FBQyxDQUFDO0FBQ2hDLE1BQU1DLG1CQUFtQixHQUFHLEVBQUUsQ0FBQyxDQUFDOztBQUVoQyxlQUFlLE1BQU1DLFNBQVMsU0FBUy9CLElBQUksQ0FBQztFQUVuQ2dDLFdBQVdBLENBQUVDLEtBQVksRUFBRUMsc0JBQXlDLEVBQUc7SUFFNUUsTUFBTUMsZUFBZSxHQUFHRixLQUFLLENBQUNFLGVBQWU7SUFFN0MsTUFBTUMsVUFBVSxHQUFHLElBQUlsQyxTQUFTLENBQUVpQyxlQUFlLEVBQUU7TUFDakRULElBQUksRUFBRW5CLG9CQUFvQixDQUFDOEIsc0JBQXNCO01BQ2pEaEIsTUFBTSxFQUFFZCxvQkFBb0IsQ0FBQytCLHNCQUFzQjtNQUNuRGxCLFNBQVMsRUFBRVI7SUFDYixDQUFFLENBQUM7SUFFSCxNQUFNMkIsUUFBUSxHQUFHLENBQ2ZILFVBQVUsRUFDVixJQUFJSSxzQkFBc0IsQ0FBRVAsS0FBSyxFQUFFRSxlQUFlLEVBQUVELHNCQUF1QixDQUFDLEVBQzVFLElBQUlPLFNBQVMsQ0FBRVIsS0FBTSxDQUFDLENBQ3ZCOztJQUVEO0lBQ0EsSUFBS0EsS0FBSyxDQUFDUyxXQUFXLEtBQUtwQyxpQkFBaUIsQ0FBQ3FDLFFBQVEsRUFBRztNQUN0REosUUFBUSxDQUFDSyxJQUFJLENBQUUsSUFBSUMsU0FBUyxDQUFFWixLQUFLLEVBQUVFLGVBQWdCLENBQUUsQ0FBQztJQUMxRDtJQUNBLElBQUtGLEtBQUssQ0FBQ1MsV0FBVyxLQUFLcEMsaUJBQWlCLENBQUN3QyxVQUFVLEVBQUc7TUFDeERQLFFBQVEsQ0FBQ0ssSUFBSSxDQUFFLElBQUlHLFNBQVMsQ0FBRWQsS0FBSyxFQUFFRSxlQUFnQixDQUFFLENBQUM7SUFDMUQ7SUFFQUksUUFBUSxDQUFDSyxJQUFJLENBQUUsSUFBSW5DLGlCQUFpQixDQUFFd0IsS0FBTSxDQUFFLENBQUM7SUFFL0MsS0FBSyxDQUFFO01BQ0xNLFFBQVEsRUFBRUEsUUFBUTtNQUNsQlMsWUFBWSxFQUFFO0lBQ2hCLENBQUUsQ0FBQzs7SUFFSDtJQUNBO0lBQ0E7SUFDQTtJQUNBWixVQUFVLENBQUNhLGdCQUFnQixDQUFFO01BQzNCQyxJQUFJLEVBQUVBLENBQUEsS0FBTTtRQUFFakIsS0FBSyxDQUFDa0Isb0JBQW9CLENBQUNDLEtBQUssR0FBRyxJQUFJO01BQUU7SUFDekQsQ0FBRSxDQUFDO0VBQ0w7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNWixzQkFBc0IsU0FBU3hDLElBQUksQ0FBQztFQUVqQ2dDLFdBQVdBLENBQUVDLEtBQVksRUFBRUUsZUFBd0IsRUFBRUQsc0JBQXlDLEVBQUc7SUFFdEcsTUFBTW1CLGNBQWMsR0FBRyxJQUFJQyxTQUFTLENBQUVyQixLQUFLLEVBQUVFLGVBQWUsRUFBRTtNQUM1RG9CLE9BQU8sRUFBRXhDLGtCQUFrQjtNQUMzQkssU0FBUyxFQUFFVCxxQkFBcUI7TUFDaENVLE1BQU0sRUFBRWQsb0JBQW9CLENBQUNpRDtJQUMvQixDQUFFLENBQUM7SUFFSCxNQUFNQyxrQkFBa0IsR0FBRyxJQUFJSCxTQUFTLENBQUVyQixLQUFLLEVBQUVFLGVBQWUsRUFBRTtNQUNoRW9CLE9BQU8sRUFBRXZDLGtCQUFrQjtNQUMzQkksU0FBUyxFQUFFUixxQkFBcUI7TUFDaENTLE1BQU0sRUFBRWQsb0JBQW9CLENBQUMrQjtJQUMvQixDQUFFLENBQUM7SUFFSCxLQUFLLENBQUU7TUFDTEMsUUFBUSxFQUFFLENBQUVrQixrQkFBa0IsRUFBRUosY0FBYyxDQUFFO01BQ2hESyxRQUFRLEVBQUU7SUFDWixDQUFFLENBQUM7O0lBRUg7SUFDQTtJQUNBeEIsc0JBQXNCLENBQUN5QixhQUFhLENBQUUsSUFBSSxFQUFFLFNBQVUsQ0FBQztFQUN6RDtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQVFBLE1BQU1MLFNBQVMsU0FBU3JELElBQUksQ0FBQztFQUlwQitCLFdBQVdBLENBQUVDLEtBQVksRUFBRUUsZUFBd0IsRUFBRXlCLGVBQWtDLEVBQUc7SUFFL0YsTUFBTUMsT0FBTyxHQUFHbkQsU0FBUyxDQUFzRCxDQUFDLENBQUU7TUFFaEY7TUFDQTZDLE9BQU8sRUFBRSxDQUFDO01BRVY7TUFDQW5DLFNBQVMsRUFBRSxDQUFDO01BQ1pDLE1BQU0sRUFBRTtJQUNWLENBQUMsRUFBRXVDLGVBQWdCLENBQUM7SUFFcEIsS0FBSyxDQUFFLElBQUkvRCxLQUFLLENBQUMsQ0FBQyxFQUFFZ0UsT0FBUSxDQUFDO0lBRTdCLElBQUksQ0FBQzFCLGVBQWUsR0FBR0EsZUFBZTs7SUFFdEM7SUFDQTtJQUNBRixLQUFLLENBQUM2QiwwQkFBMEIsQ0FBQ0MsSUFBSSxDQUFFQyxrQkFBa0IsSUFBSTtNQUUzRDtNQUNBLE1BQU1DLFNBQVMsR0FBR2hDLEtBQUssQ0FBQ2lDLGdCQUFnQixDQUFDQyxJQUFJO01BQzdDLE1BQU1DLFNBQVMsR0FBR25DLEtBQUssQ0FBQ2lDLGdCQUFnQixDQUFDRyxJQUFJO01BQzdDLE1BQU1DLFNBQVMsR0FBR3JDLEtBQUssQ0FBQ2lDLGdCQUFnQixDQUFDSyxJQUFJO01BQzdDLE1BQU1DLFNBQVMsR0FBR3ZDLEtBQUssQ0FBQ2lDLGdCQUFnQixDQUFDTyxJQUFJO01BRTdDLE1BQU1DLEtBQUssR0FBRyxJQUFJN0UsS0FBSyxDQUFDLENBQUM7O01BRXpCO01BQ0EsTUFBTThFLE1BQU0sR0FBR1YsU0FBUyxHQUFLQSxTQUFTLEdBQUdKLE9BQU8sQ0FBQ04sT0FBUztNQUMxRCxLQUFNLElBQUlxQixNQUFNLEdBQUdELE1BQU0sRUFBRUMsTUFBTSxJQUFJUixTQUFTLEVBQUVRLE1BQU0sSUFBSWYsT0FBTyxDQUFDTixPQUFPLEVBQUc7UUFDMUVtQixLQUFLLENBQUNHLE1BQU0sQ0FBRUQsTUFBTSxFQUFFTixTQUFVLENBQUMsQ0FBQ1EsY0FBYyxDQUFFTixTQUFVLENBQUM7TUFDL0Q7O01BRUE7TUFDQSxNQUFNTyxNQUFNLEdBQUdULFNBQVMsR0FBS0EsU0FBUyxHQUFHVCxPQUFPLENBQUNOLE9BQVM7TUFDMUQsS0FBTSxJQUFJeUIsTUFBTSxHQUFHRCxNQUFNLEVBQUVDLE1BQU0sSUFBSVIsU0FBUyxFQUFFUSxNQUFNLElBQUluQixPQUFPLENBQUNOLE9BQU8sRUFBRztRQUMxRW1CLEtBQUssQ0FBQ0csTUFBTSxDQUFFWixTQUFTLEVBQUVlLE1BQU8sQ0FBQyxDQUFDQyxnQkFBZ0IsQ0FBRWIsU0FBVSxDQUFDO01BQ2pFO01BRUEsSUFBSSxDQUFDYyxRQUFRLENBQUVsQixrQkFBa0IsQ0FBQ21CLGdCQUFnQixDQUFFVCxLQUFNLENBQUUsQ0FBQztJQUMvRCxDQUFFLENBQUM7RUFDTDs7RUFFQTtBQUNGO0FBQ0E7RUFDa0JVLGtCQUFrQkEsQ0FBQSxFQUFZO0lBQzVDLE9BQU8sSUFBSSxDQUFDakQsZUFBZTtFQUM3QjtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU1VLFNBQVMsU0FBUzdDLElBQUksQ0FBQztFQUVwQmdDLFdBQVdBLENBQUVDLEtBQVksRUFBRUUsZUFBd0IsRUFBRztJQUUzRCxNQUFNa0QsU0FBUyxHQUFHLElBQUl2RixTQUFTLENBQzdCcUMsZUFBZSxDQUFDZ0MsSUFBSSxHQUFHdEQsc0JBQXNCLEVBQUUsQ0FBQyxFQUNoRHNCLGVBQWUsQ0FBQ2tDLElBQUksR0FBR3hELHNCQUFzQixFQUFFLENBQUMsRUFDaERMLHVCQUF1QixDQUFDOEUsa0JBQzFCLENBQUM7SUFFRCxNQUFNQyxTQUFTLEdBQUcsSUFBSXBGLElBQUksQ0FBRUUscUJBQXFCLENBQUNtRixNQUFNLENBQUNDLENBQUMsRUFBRTtNQUMxRGpFLElBQUksRUFBRWhCLHVCQUF1QixDQUFDa0YsZUFBZTtNQUM3Qy9ELFFBQVEsRUFBRSxFQUFFO01BQ1pnRSxJQUFJLEVBQUVOLFNBQVMsQ0FBQ08sS0FBSyxHQUFHLENBQUM7TUFDekJDLE9BQU8sRUFBRVIsU0FBUyxDQUFDUTtJQUNyQixDQUFFLENBQUM7SUFFSCxLQUFLLENBQUU7TUFDTHRELFFBQVEsRUFBRSxDQUFFOEMsU0FBUyxFQUFFRSxTQUFTLENBQUU7TUFDbEM3QixRQUFRLEVBQUU7SUFDWixDQUFFLENBQUM7O0lBRUg7SUFDQTtJQUNBekIsS0FBSyxDQUFDNkIsMEJBQTBCLENBQUNDLElBQUksQ0FBRUMsa0JBQWtCLElBQUk7TUFDM0QsSUFBSSxDQUFDOEIsQ0FBQyxHQUFHOUIsa0JBQWtCLENBQUMrQixZQUFZLENBQUUsQ0FBRSxDQUFDO0lBQy9DLENBQUUsQ0FBQztFQUNMO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTWhELFNBQVMsU0FBUy9DLElBQUksQ0FBQztFQUVwQmdDLFdBQVdBLENBQUVDLEtBQVksRUFBRUUsZUFBd0IsRUFBRztJQUUzRCxNQUFNa0QsU0FBUyxHQUFHLElBQUl2RixTQUFTLENBQzdCLENBQUMsRUFBRXFDLGVBQWUsQ0FBQ29DLElBQUksR0FBR3pELHNCQUFzQixFQUNoRCxDQUFDLEVBQUVxQixlQUFlLENBQUNzQyxJQUFJLEdBQUczRCxzQkFBc0IsRUFDaEROLHVCQUF1QixDQUFDOEUsa0JBQzFCLENBQUM7SUFFRCxNQUFNQyxTQUFTLEdBQUcsSUFBSXBGLElBQUksQ0FBRUUscUJBQXFCLENBQUNtRixNQUFNLENBQUNNLENBQUMsRUFBRTtNQUMxRHRFLElBQUksRUFBRWhCLHVCQUF1QixDQUFDa0YsZUFBZTtNQUM3Qy9ELFFBQVEsRUFBRSxFQUFFO01BQ1pxRSxPQUFPLEVBQUVYLFNBQVMsQ0FBQ1csT0FBTztNQUMxQkMsTUFBTSxFQUFFWixTQUFTLENBQUNhLEdBQUcsR0FBRztJQUMxQixDQUFFLENBQUM7SUFFSCxLQUFLLENBQUU7TUFDTDNELFFBQVEsRUFBRSxDQUFFOEMsU0FBUyxFQUFFRSxTQUFTLENBQUU7TUFDbEM3QixRQUFRLEVBQUU7SUFDWixDQUFFLENBQUM7O0lBRUg7SUFDQTtJQUNBekIsS0FBSyxDQUFDNkIsMEJBQTBCLENBQUNDLElBQUksQ0FBRUMsa0JBQWtCLElBQUk7TUFDM0QsSUFBSSxDQUFDeUIsQ0FBQyxHQUFHekIsa0JBQWtCLENBQUNtQyxZQUFZLENBQUUsQ0FBRSxDQUFDO0lBQy9DLENBQUUsQ0FBQztFQUNMO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTFELFNBQVMsU0FBU3pDLElBQUksQ0FBQztFQUVwQmdDLFdBQVdBLENBQUVDLEtBQVksRUFBRztJQUVqQyxNQUFNbUUsYUFBYSxHQUFHLElBQUluRyxJQUFJLENBQUUsSUFBSUosS0FBSyxDQUFDLENBQUMsRUFBRXNCLGlCQUFrQixDQUFDO0lBQ2hFLE1BQU1rRixnQkFBZ0IsR0FBRyxJQUFJckcsSUFBSSxDQUFDLENBQUM7SUFDbkMsTUFBTXNHLFdBQVcsR0FBRyxJQUFJbkcsSUFBSSxDQUFFLEdBQUcsRUFBRW9CLGtCQUFtQixDQUFDO0lBRXZELEtBQUssQ0FBRTtNQUNMZ0IsUUFBUSxFQUFFLENBQUU2RCxhQUFhLEVBQUVDLGdCQUFnQixDQUFFO01BQzdDM0MsUUFBUSxFQUFFO0lBQ1osQ0FBRSxDQUFDOztJQUVIO0lBQ0E7SUFDQXpCLEtBQUssQ0FBQzZCLDBCQUEwQixDQUFDQyxJQUFJLENBQUVDLGtCQUFrQixJQUFJO01BRTNELE1BQU11QyxVQUFVLEdBQUd2QyxrQkFBa0IsQ0FBQ3dDLG1CQUFtQixDQUFFNUcsT0FBTyxDQUFDNkcsSUFBSyxDQUFDO01BQ3pFLE1BQU1DLGNBQWMsR0FBRyxJQUFJN0csS0FBSyxDQUFDLENBQUM7TUFDbEMsTUFBTThHLFVBQVUsR0FBRyxFQUFFO01BRXJCLElBQUsxRSxLQUFLLENBQUNTLFdBQVcsS0FBS3BDLGlCQUFpQixDQUFDcUMsUUFBUSxFQUFHO1FBRXREO1FBQ0EsTUFBTWlFLFVBQVUsR0FBRzNFLEtBQUssQ0FBQ2lDLGdCQUFnQixDQUFDQyxJQUFJLEdBQUtsQyxLQUFLLENBQUNpQyxnQkFBZ0IsQ0FBQ0MsSUFBSSxHQUFHcEQsa0JBQW9CO1FBQ3JHLEtBQU0sSUFBSTZELE1BQU0sR0FBR2dDLFVBQVUsRUFBRWhDLE1BQU0sSUFBSTNDLEtBQUssQ0FBQ2lDLGdCQUFnQixDQUFDRyxJQUFJLEVBQUVPLE1BQU0sR0FBR0EsTUFBTSxHQUFHN0Qsa0JBQWtCLEVBQUc7VUFDM0csTUFBTThGLFVBQVUsR0FBS2pDLE1BQU0sS0FBSyxDQUFDLEdBQUsxRCxrQkFBa0IsR0FBR0QsV0FBVyxDQUFDLENBQUM7VUFDeEV5RixjQUFjLENBQUM3QixNQUFNLENBQUVELE1BQU0sRUFBRSxDQUFDaUMsVUFBVSxHQUFHLENBQUUsQ0FBQyxDQUFDL0IsY0FBYyxDQUFFK0IsVUFBVSxHQUFHLENBQUUsQ0FBQztRQUNuRjs7UUFFQTtRQUNBLE1BQU1DLFdBQVcsR0FBRzdFLEtBQUssQ0FBQ2lDLGdCQUFnQixDQUFDQyxJQUFJLEdBQUtsQyxLQUFLLENBQUNpQyxnQkFBZ0IsQ0FBQ0MsSUFBSSxHQUFHdkMsa0JBQW9CO1FBQ3RHLEtBQU0sSUFBSWdELE1BQU0sR0FBR2tDLFdBQVcsRUFBRWxDLE1BQU0sSUFBSTNDLEtBQUssQ0FBQ2lDLGdCQUFnQixDQUFDRyxJQUFJLEVBQUVPLE1BQU0sR0FBR0EsTUFBTSxHQUFHaEQsa0JBQWtCLEVBQUc7VUFDNUcsSUFBS2dELE1BQU0sS0FBSyxDQUFDLEVBQUc7WUFDbEIsTUFBTW1DLFNBQVMsR0FBRyxJQUFJNUcsSUFBSSxDQUFFeUUsTUFBTSxFQUFFckQsa0JBQW1CLENBQUM7WUFDeER3RixTQUFTLENBQUNmLE9BQU8sR0FBR2hDLGtCQUFrQixDQUFDbUMsWUFBWSxDQUFFdkIsTUFBTyxDQUFDO1lBQzdEbUMsU0FBUyxDQUFDYixHQUFHLEdBQUdLLFVBQVUsQ0FBQ1QsQ0FBQyxHQUFHaEUsbUJBQW1CO1lBQ2xENkUsVUFBVSxDQUFDL0QsSUFBSSxDQUFFbUUsU0FBVSxDQUFDO1VBQzlCO1FBQ0Y7TUFDRjtNQUVBLElBQUs5RSxLQUFLLENBQUNTLFdBQVcsS0FBS3BDLGlCQUFpQixDQUFDd0MsVUFBVSxFQUFHO1FBRXhEO1FBQ0EsTUFBTWtFLFVBQVUsR0FBRy9FLEtBQUssQ0FBQ2lDLGdCQUFnQixDQUFDSyxJQUFJLEdBQUt0QyxLQUFLLENBQUNpQyxnQkFBZ0IsQ0FBQ0ssSUFBSSxHQUFHeEQsa0JBQW9CO1FBQ3JHLEtBQU0sSUFBSWlFLE1BQU0sR0FBR2dDLFVBQVUsRUFBRWhDLE1BQU0sSUFBSS9DLEtBQUssQ0FBQ2lDLGdCQUFnQixDQUFDTyxJQUFJLEVBQUVPLE1BQU0sR0FBR0EsTUFBTSxHQUFHakUsa0JBQWtCLEVBQUc7VUFDM0csTUFBTThGLFVBQVUsR0FBSzdCLE1BQU0sS0FBSyxDQUFDLEdBQUs5RCxrQkFBa0IsR0FBR0QsV0FBVyxDQUFDLENBQUM7VUFDeEV5RixjQUFjLENBQUM3QixNQUFNLENBQUUsQ0FBQ2dDLFVBQVUsR0FBRyxDQUFDLEVBQUU3QixNQUFPLENBQUMsQ0FBQ0MsZ0JBQWdCLENBQUU0QixVQUFVLEdBQUcsQ0FBRSxDQUFDO1FBQ3JGOztRQUVBO1FBQ0EsTUFBTUksV0FBVyxHQUFHaEYsS0FBSyxDQUFDaUMsZ0JBQWdCLENBQUNLLElBQUksR0FBS3RDLEtBQUssQ0FBQ2lDLGdCQUFnQixDQUFDSyxJQUFJLEdBQUczQyxrQkFBb0I7UUFDdEcsS0FBTSxJQUFJb0QsTUFBTSxHQUFHaUMsV0FBVyxFQUFFakMsTUFBTSxJQUFJL0MsS0FBSyxDQUFDaUMsZ0JBQWdCLENBQUNPLElBQUksRUFBRU8sTUFBTSxHQUFHQSxNQUFNLEdBQUdwRCxrQkFBa0IsRUFBRztVQUM1RyxJQUFLb0QsTUFBTSxLQUFLLENBQUMsRUFBRztZQUNsQixNQUFNK0IsU0FBUyxHQUFHLElBQUk1RyxJQUFJLENBQUU2RSxNQUFNLEVBQUV6RCxrQkFBbUIsQ0FBQztZQUN4RHdGLFNBQVMsQ0FBQ25CLEtBQUssR0FBR1csVUFBVSxDQUFDZCxDQUFDLEdBQUc1RCxtQkFBbUI7WUFDcERrRixTQUFTLENBQUNsQixPQUFPLEdBQUc3QixrQkFBa0IsQ0FBQytCLFlBQVksQ0FBRWYsTUFBTyxDQUFDO1lBQzdEMkIsVUFBVSxDQUFDL0QsSUFBSSxDQUFFbUUsU0FBVSxDQUFDO1VBQzlCO1FBQ0Y7TUFDRjs7TUFFQTtNQUNBLElBQUs5RSxLQUFLLENBQUNTLFdBQVcsS0FBS3BDLGlCQUFpQixDQUFDNEcsZUFBZSxFQUFHO1FBRTdEUCxVQUFVLENBQUMvRCxJQUFJLENBQUUwRCxXQUFZLENBQUM7UUFFOUIsSUFBS3JFLEtBQUssQ0FBQ1MsV0FBVyxLQUFLcEMsaUJBQWlCLENBQUN3QyxVQUFVLEVBQUc7VUFDeER3RCxXQUFXLENBQUNOLE9BQU8sR0FBR08sVUFBVSxDQUFDZCxDQUFDO1VBQ2xDYSxXQUFXLENBQUNKLEdBQUcsR0FBR0ssVUFBVSxDQUFDVCxDQUFDLEdBQUdoRSxtQkFBbUI7UUFDdEQsQ0FBQyxNQUNJO1VBQ0h3RSxXQUFXLENBQUNWLEtBQUssR0FBR1csVUFBVSxDQUFDZCxDQUFDLEdBQUc1RCxtQkFBbUI7VUFDdER5RSxXQUFXLENBQUNULE9BQU8sR0FBR1UsVUFBVSxDQUFDVCxDQUFDO1FBQ3BDO01BQ0Y7TUFFQU0sYUFBYSxDQUFDMUIsS0FBSyxHQUFHVixrQkFBa0IsQ0FBQ21CLGdCQUFnQixDQUFFdUIsY0FBZSxDQUFDO01BQzNFTCxnQkFBZ0IsQ0FBQzlELFFBQVEsR0FBR29FLFVBQVU7SUFDeEMsQ0FBRSxDQUFDO0VBQ0w7QUFDRjtBQUVBdkcsY0FBYyxDQUFDK0csUUFBUSxDQUFFLFdBQVcsRUFBRXBGLFNBQVUsQ0FBQyIsImlnbm9yZUxpc3QiOltdfQ==