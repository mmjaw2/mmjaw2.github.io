// Copyright 2019-2023, University of Colorado Boulder

/**
 * View for a ComponentVector
 *
 * Extends RootVectorNode but add the following functionality:
 *  - determines visibility by the component style (i.e. should be invisible on ComponentVectorStyles.INVISIBLE)
 *  - draws lines for the PROJECTION component vector style
 *  - custom label positioning
 *  - distinct appearance
 *
 * @author Brandon Li
 */

import Multilink from '../../../../axon/js/Multilink.js';
import Vector2 from '../../../../dot/js/Vector2.js';
import { Shape } from '../../../../kite/js/imports.js';
import merge from '../../../../phet-core/js/merge.js';
import { Path } from '../../../../scenery/js/imports.js';
import vectorAddition from '../../vectorAddition.js';
import ComponentVectorStyles from '../model/ComponentVectorStyles.js';
import ComponentVectorTypes from '../model/ComponentVectorTypes.js';
import VectorAdditionColors from '../VectorAdditionColors.js';
import VectorAdditionConstants from '../VectorAdditionConstants.js';
import RootVectorNode from './RootVectorNode.js';
import optionize from '../../../../phet-core/js/optionize.js';
// constants

// offset of the label
const COMPONENT_LABEL_OFFSET = VectorAdditionConstants.VECTOR_LABEL_OFFSET;

// Line dash for leader lines, displayed when component vectors are projected onto axes
const NON_ACTIVE_LEADER_LINES_DASH = [3, 10];
const ACTIVE_LEADER_LINES_DASH = [];
export default class ComponentVectorNode extends RootVectorNode {
  // leader lines, displayed when component vectors are projected onto axes

  /**
   * @param componentVector - the component vector model the node represents
   * @param graph - the graph the component vector belongs to
   * @param componentStyleProperty
   * @param valuesVisibleProperty
   * @param [providedOptions]
   */
  constructor(componentVector, graph, componentStyleProperty, valuesVisibleProperty, providedOptions) {
    const options = optionize()({
      // RootVectorNodeOptions
      arrowType: 'dashed',
      arrowOptions: merge({}, VectorAdditionConstants.COMPONENT_VECTOR_ARROW_OPTIONS, {
        fill: componentVector.vectorColorPalette.componentFill
      })
    }, providedOptions);
    super(componentVector, graph.modelViewTransformProperty, valuesVisibleProperty, graph.activeVectorProperty, options);

    //----------------------------------------------------------------------------------------

    // Create a path that represents the dashed lines corresponding to the PROJECTION style.
    // The shape of the path will be updated later.

    this.leaderLinesPath = new Path(new Shape(), {
      lineWidth: 0.5,
      lineDash: NON_ACTIVE_LEADER_LINES_DASH
    });
    this.addChild(this.leaderLinesPath);

    //----------------------------------------------------------------------------------------
    // Create a multilink to observe:
    //  - componentStyleProperty - to determine visibility (i.e. components shouldn't be visible on INVISIBLE)
    //                             and to draw lines on the PROJECTION componentStyle
    //  - isOnGraphProperty - components shouldn't be visible if the vector isn't on the graph
    //  - vectorComponentsProperty - to update the leader lines drawings positions
    //
    // dispose is required.
    const componentVectorMultilink = Multilink.multilink([componentStyleProperty, componentVector.isParentVectorActiveProperty, componentVector.isOnGraphProperty, componentVector.vectorComponentsProperty], (componentStyle, isParentActive) => {
      this.updateComponentVector(componentVector, graph.modelViewTransformProperty.value, componentStyle, isParentActive);
    });

    // Highlight the component vector's label when its parent vector is selected.
    // unlink is required on dispose.
    const activeVectorListener = activeVector => {
      this.labelNode.setHighlighted(activeVector === componentVector.parentVector);
    };
    graph.activeVectorProperty.link(activeVectorListener);
    this.disposeComponentVectorNode = () => {
      componentVectorMultilink.dispose();
      if (graph.activeVectorProperty.hasListener(activeVectorListener)) {
        graph.activeVectorProperty.unlink(activeVectorListener);
      }
    };
  }
  dispose() {
    this.disposeComponentVectorNode();
    super.dispose();
  }

  /**
   * Updates the component vector node:
   *  - Draws leader lines when componentStyle is ON_AXIS
   *  - Determines visibility (i.e. components shouldn't be visible on INVISIBLE)
   */
  updateComponentVector(componentVector, modelViewTransform, componentStyle, isParentActive) {
    // Component vectors are visible when it isn't INVISIBLE, and it is on the graph.
    this.visible = componentVector.isOnGraphProperty.value && componentStyle !== ComponentVectorStyles.INVISIBLE;
    if (componentStyle === ComponentVectorStyles.PROJECTION) {
      this.labelNode.visible = componentVector.magnitude !== 0;
    } else {
      // Hide the label if either of the parent vector's components is zero,
      // see https://github.com/phetsims/vector-addition/issues/264
      this.labelNode.visible = !componentVector.parentVector.hasZeroComponent();
    }

    // Leader lines are only visible when component vectors are projected onto axes
    this.leaderLinesPath.visible = componentStyle === ComponentVectorStyles.PROJECTION;

    // Update leader lines only if they are visible (with PROJECTION style)
    if (this.leaderLinesPath.visible) {
      // Since the leader lines are a child of this view, the origin of the view is at the tail of the component
      // vector. Get the tip position relative to the tail of the component vector (which is the components)
      const tipPosition = modelViewTransform.modelToViewDelta(componentVector.vectorComponents);

      // Get the parent tail position relative to the origin of the view (the tail of the component vector)
      const parentTailPosition = modelViewTransform.modelToViewDelta(componentVector.parentTail.minus(componentVector.tail));

      // Get the parent tip position relative to the origin of the view (the tail of the component vector)
      const parentTipPosition = modelViewTransform.modelToViewDelta(componentVector.parentTip.minus(componentVector.tail));

      // Create new shape for the leader lines
      this.leaderLinesPath.shape = new Shape().moveToPoint(Vector2.ZERO).lineToPoint(parentTailPosition).moveToPoint(tipPosition).lineToPoint(parentTipPosition);
      if (isParentActive) {
        this.leaderLinesPath.stroke = VectorAdditionColors.LEADER_LINES_ACTIVE_STROKE;
        this.leaderLinesPath.lineDash = ACTIVE_LEADER_LINES_DASH;
      } else {
        this.leaderLinesPath.stroke = VectorAdditionColors.LEADER_LINES_NON_ACTIVE_STROKE;
        this.leaderLinesPath.lineDash = NON_ACTIVE_LEADER_LINES_DASH;
      }
    }
  }

  /**
   * Updates the label positioning of the vector component. Vector components have a unique label positioning.
   */
  updateLabelPositioning(componentVector, modelViewTransform, valuesVisible) {
    // If the magnitude of the componentVector is 0, then position the label node on the 'tail'
    if (componentVector.magnitude === 0) {
      this.labelNode.center = Vector2.ZERO;
      return;
    }

    // Flag to indicate the label offset translation.
    const labelOffset = new Vector2(0, 0);

    // Convenience variables
    const componentMidPoint = componentVector.midPoint;
    const parentMidPoint = componentVector.parentMidPoint;
    if (componentVector.componentType === ComponentVectorTypes.X_COMPONENT) {
      // Get the label height. Negative since the y axis is inverted in the view
      const labelHeight = modelViewTransform.viewToModelDeltaY(-this.labelNode.height);

      // If the component is below the parent, position the label below, otherwise position it above
      if (componentMidPoint.y <= parentMidPoint.y) {
        labelOffset.setXY(0, -COMPONENT_LABEL_OFFSET - labelHeight / 2);
      } else {
        labelOffset.setXY(0, COMPONENT_LABEL_OFFSET + labelHeight / 2);
      }
    } else if (componentVector.componentType === ComponentVectorTypes.Y_COMPONENT) {
      const labelWidth = modelViewTransform.viewToModelDeltaX(this.labelNode.width);

      // If the component is to the left of the parent, position the label to the left, otherwise to the right
      if (componentMidPoint.x < parentMidPoint.x) {
        labelOffset.setXY(-COMPONENT_LABEL_OFFSET - labelWidth / 2, 0);
      } else {
        labelOffset.setXY(COMPONENT_LABEL_OFFSET + labelWidth / 2, 0);
      }
    }

    // Position the label
    this.labelNode.center = RootVectorNode.computeLabelCenter(componentVector, modelViewTransform, labelOffset);
  }
}
vectorAddition.register('ComponentVectorNode', ComponentVectorNode);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJNdWx0aWxpbmsiLCJWZWN0b3IyIiwiU2hhcGUiLCJtZXJnZSIsIlBhdGgiLCJ2ZWN0b3JBZGRpdGlvbiIsIkNvbXBvbmVudFZlY3RvclN0eWxlcyIsIkNvbXBvbmVudFZlY3RvclR5cGVzIiwiVmVjdG9yQWRkaXRpb25Db2xvcnMiLCJWZWN0b3JBZGRpdGlvbkNvbnN0YW50cyIsIlJvb3RWZWN0b3JOb2RlIiwib3B0aW9uaXplIiwiQ09NUE9ORU5UX0xBQkVMX09GRlNFVCIsIlZFQ1RPUl9MQUJFTF9PRkZTRVQiLCJOT05fQUNUSVZFX0xFQURFUl9MSU5FU19EQVNIIiwiQUNUSVZFX0xFQURFUl9MSU5FU19EQVNIIiwiQ29tcG9uZW50VmVjdG9yTm9kZSIsImNvbnN0cnVjdG9yIiwiY29tcG9uZW50VmVjdG9yIiwiZ3JhcGgiLCJjb21wb25lbnRTdHlsZVByb3BlcnR5IiwidmFsdWVzVmlzaWJsZVByb3BlcnR5IiwicHJvdmlkZWRPcHRpb25zIiwib3B0aW9ucyIsImFycm93VHlwZSIsImFycm93T3B0aW9ucyIsIkNPTVBPTkVOVF9WRUNUT1JfQVJST1dfT1BUSU9OUyIsImZpbGwiLCJ2ZWN0b3JDb2xvclBhbGV0dGUiLCJjb21wb25lbnRGaWxsIiwibW9kZWxWaWV3VHJhbnNmb3JtUHJvcGVydHkiLCJhY3RpdmVWZWN0b3JQcm9wZXJ0eSIsImxlYWRlckxpbmVzUGF0aCIsImxpbmVXaWR0aCIsImxpbmVEYXNoIiwiYWRkQ2hpbGQiLCJjb21wb25lbnRWZWN0b3JNdWx0aWxpbmsiLCJtdWx0aWxpbmsiLCJpc1BhcmVudFZlY3RvckFjdGl2ZVByb3BlcnR5IiwiaXNPbkdyYXBoUHJvcGVydHkiLCJ2ZWN0b3JDb21wb25lbnRzUHJvcGVydHkiLCJjb21wb25lbnRTdHlsZSIsImlzUGFyZW50QWN0aXZlIiwidXBkYXRlQ29tcG9uZW50VmVjdG9yIiwidmFsdWUiLCJhY3RpdmVWZWN0b3JMaXN0ZW5lciIsImFjdGl2ZVZlY3RvciIsImxhYmVsTm9kZSIsInNldEhpZ2hsaWdodGVkIiwicGFyZW50VmVjdG9yIiwibGluayIsImRpc3Bvc2VDb21wb25lbnRWZWN0b3JOb2RlIiwiZGlzcG9zZSIsImhhc0xpc3RlbmVyIiwidW5saW5rIiwibW9kZWxWaWV3VHJhbnNmb3JtIiwidmlzaWJsZSIsIklOVklTSUJMRSIsIlBST0pFQ1RJT04iLCJtYWduaXR1ZGUiLCJoYXNaZXJvQ29tcG9uZW50IiwidGlwUG9zaXRpb24iLCJtb2RlbFRvVmlld0RlbHRhIiwidmVjdG9yQ29tcG9uZW50cyIsInBhcmVudFRhaWxQb3NpdGlvbiIsInBhcmVudFRhaWwiLCJtaW51cyIsInRhaWwiLCJwYXJlbnRUaXBQb3NpdGlvbiIsInBhcmVudFRpcCIsInNoYXBlIiwibW92ZVRvUG9pbnQiLCJaRVJPIiwibGluZVRvUG9pbnQiLCJzdHJva2UiLCJMRUFERVJfTElORVNfQUNUSVZFX1NUUk9LRSIsIkxFQURFUl9MSU5FU19OT05fQUNUSVZFX1NUUk9LRSIsInVwZGF0ZUxhYmVsUG9zaXRpb25pbmciLCJ2YWx1ZXNWaXNpYmxlIiwiY2VudGVyIiwibGFiZWxPZmZzZXQiLCJjb21wb25lbnRNaWRQb2ludCIsIm1pZFBvaW50IiwicGFyZW50TWlkUG9pbnQiLCJjb21wb25lbnRUeXBlIiwiWF9DT01QT05FTlQiLCJsYWJlbEhlaWdodCIsInZpZXdUb01vZGVsRGVsdGFZIiwiaGVpZ2h0IiwieSIsInNldFhZIiwiWV9DT01QT05FTlQiLCJsYWJlbFdpZHRoIiwidmlld1RvTW9kZWxEZWx0YVgiLCJ3aWR0aCIsIngiLCJjb21wdXRlTGFiZWxDZW50ZXIiLCJyZWdpc3RlciJdLCJzb3VyY2VzIjpbIkNvbXBvbmVudFZlY3Rvck5vZGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTktMjAyMywgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXHJcblxyXG4vKipcclxuICogVmlldyBmb3IgYSBDb21wb25lbnRWZWN0b3JcclxuICpcclxuICogRXh0ZW5kcyBSb290VmVjdG9yTm9kZSBidXQgYWRkIHRoZSBmb2xsb3dpbmcgZnVuY3Rpb25hbGl0eTpcclxuICogIC0gZGV0ZXJtaW5lcyB2aXNpYmlsaXR5IGJ5IHRoZSBjb21wb25lbnQgc3R5bGUgKGkuZS4gc2hvdWxkIGJlIGludmlzaWJsZSBvbiBDb21wb25lbnRWZWN0b3JTdHlsZXMuSU5WSVNJQkxFKVxyXG4gKiAgLSBkcmF3cyBsaW5lcyBmb3IgdGhlIFBST0pFQ1RJT04gY29tcG9uZW50IHZlY3RvciBzdHlsZVxyXG4gKiAgLSBjdXN0b20gbGFiZWwgcG9zaXRpb25pbmdcclxuICogIC0gZGlzdGluY3QgYXBwZWFyYW5jZVxyXG4gKlxyXG4gKiBAYXV0aG9yIEJyYW5kb24gTGlcclxuICovXHJcblxyXG5pbXBvcnQgRW51bWVyYXRpb25Qcm9wZXJ0eSBmcm9tICcuLi8uLi8uLi8uLi9heG9uL2pzL0VudW1lcmF0aW9uUHJvcGVydHkuanMnO1xyXG5pbXBvcnQgTXVsdGlsaW5rIGZyb20gJy4uLy4uLy4uLy4uL2F4b24vanMvTXVsdGlsaW5rLmpzJztcclxuaW1wb3J0IFZlY3RvcjIgZnJvbSAnLi4vLi4vLi4vLi4vZG90L2pzL1ZlY3RvcjIuanMnO1xyXG5pbXBvcnQgeyBTaGFwZSB9IGZyb20gJy4uLy4uLy4uLy4uL2tpdGUvanMvaW1wb3J0cy5qcyc7XHJcbmltcG9ydCBtZXJnZSBmcm9tICcuLi8uLi8uLi8uLi9waGV0LWNvcmUvanMvbWVyZ2UuanMnO1xyXG5pbXBvcnQgeyBQYXRoIH0gZnJvbSAnLi4vLi4vLi4vLi4vc2NlbmVyeS9qcy9pbXBvcnRzLmpzJztcclxuaW1wb3J0IHZlY3RvckFkZGl0aW9uIGZyb20gJy4uLy4uL3ZlY3RvckFkZGl0aW9uLmpzJztcclxuaW1wb3J0IENvbXBvbmVudFZlY3RvciBmcm9tICcuLi9tb2RlbC9Db21wb25lbnRWZWN0b3IuanMnO1xyXG5pbXBvcnQgQ29tcG9uZW50VmVjdG9yU3R5bGVzIGZyb20gJy4uL21vZGVsL0NvbXBvbmVudFZlY3RvclN0eWxlcy5qcyc7XHJcbmltcG9ydCBDb21wb25lbnRWZWN0b3JUeXBlcyBmcm9tICcuLi9tb2RlbC9Db21wb25lbnRWZWN0b3JUeXBlcy5qcyc7XHJcbmltcG9ydCBHcmFwaCBmcm9tICcuLi9tb2RlbC9HcmFwaC5qcyc7XHJcbmltcG9ydCBWZWN0b3JBZGRpdGlvbkNvbG9ycyBmcm9tICcuLi9WZWN0b3JBZGRpdGlvbkNvbG9ycy5qcyc7XHJcbmltcG9ydCBWZWN0b3JBZGRpdGlvbkNvbnN0YW50cyBmcm9tICcuLi9WZWN0b3JBZGRpdGlvbkNvbnN0YW50cy5qcyc7XHJcbmltcG9ydCBSb290VmVjdG9yTm9kZSwgeyBSb290VmVjdG9yTm9kZU9wdGlvbnMgfSBmcm9tICcuL1Jvb3RWZWN0b3JOb2RlLmpzJztcclxuaW1wb3J0IFRSZWFkT25seVByb3BlcnR5IGZyb20gJy4uLy4uLy4uLy4uL2F4b24vanMvVFJlYWRPbmx5UHJvcGVydHkuanMnO1xyXG5pbXBvcnQgb3B0aW9uaXplLCB7IEVtcHR5U2VsZk9wdGlvbnMgfSBmcm9tICcuLi8uLi8uLi8uLi9waGV0LWNvcmUvanMvb3B0aW9uaXplLmpzJztcclxuaW1wb3J0IFZlY3RvciBmcm9tICcuLi9tb2RlbC9WZWN0b3IuanMnO1xyXG5pbXBvcnQgTW9kZWxWaWV3VHJhbnNmb3JtMiBmcm9tICcuLi8uLi8uLi8uLi9waGV0Y29tbW9uL2pzL3ZpZXcvTW9kZWxWaWV3VHJhbnNmb3JtMi5qcyc7XHJcblxyXG4vLyBjb25zdGFudHNcclxuXHJcbi8vIG9mZnNldCBvZiB0aGUgbGFiZWxcclxuY29uc3QgQ09NUE9ORU5UX0xBQkVMX09GRlNFVCA9IFZlY3RvckFkZGl0aW9uQ29uc3RhbnRzLlZFQ1RPUl9MQUJFTF9PRkZTRVQ7XHJcblxyXG4vLyBMaW5lIGRhc2ggZm9yIGxlYWRlciBsaW5lcywgZGlzcGxheWVkIHdoZW4gY29tcG9uZW50IHZlY3RvcnMgYXJlIHByb2plY3RlZCBvbnRvIGF4ZXNcclxuY29uc3QgTk9OX0FDVElWRV9MRUFERVJfTElORVNfREFTSDogbnVtYmVyW10gPSBbIDMsIDEwIF07XHJcbmNvbnN0IEFDVElWRV9MRUFERVJfTElORVNfREFTSDogbnVtYmVyW10gPSBbXTtcclxuXHJcbnR5cGUgU2VsZk9wdGlvbnMgPSBFbXB0eVNlbGZPcHRpb25zO1xyXG5leHBvcnQgdHlwZSBDb21wb25lbnRWZWN0b3JOb2RlT3B0aW9ucyA9IFNlbGZPcHRpb25zICYgUm9vdFZlY3Rvck5vZGVPcHRpb25zO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29tcG9uZW50VmVjdG9yTm9kZSBleHRlbmRzIFJvb3RWZWN0b3JOb2RlIHtcclxuXHJcbiAgLy8gbGVhZGVyIGxpbmVzLCBkaXNwbGF5ZWQgd2hlbiBjb21wb25lbnQgdmVjdG9ycyBhcmUgcHJvamVjdGVkIG9udG8gYXhlc1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgbGVhZGVyTGluZXNQYXRoOiBQYXRoO1xyXG5cclxuICBwcml2YXRlIHJlYWRvbmx5IGRpc3Bvc2VDb21wb25lbnRWZWN0b3JOb2RlOiAoKSA9PiB2b2lkO1xyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0gY29tcG9uZW50VmVjdG9yIC0gdGhlIGNvbXBvbmVudCB2ZWN0b3IgbW9kZWwgdGhlIG5vZGUgcmVwcmVzZW50c1xyXG4gICAqIEBwYXJhbSBncmFwaCAtIHRoZSBncmFwaCB0aGUgY29tcG9uZW50IHZlY3RvciBiZWxvbmdzIHRvXHJcbiAgICogQHBhcmFtIGNvbXBvbmVudFN0eWxlUHJvcGVydHlcclxuICAgKiBAcGFyYW0gdmFsdWVzVmlzaWJsZVByb3BlcnR5XHJcbiAgICogQHBhcmFtIFtwcm92aWRlZE9wdGlvbnNdXHJcbiAgICovXHJcbiAgcHVibGljIGNvbnN0cnVjdG9yKCBjb21wb25lbnRWZWN0b3I6IENvbXBvbmVudFZlY3RvcixcclxuICAgICAgICAgICAgICAgICAgICAgIGdyYXBoOiBHcmFwaCxcclxuICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudFN0eWxlUHJvcGVydHk6IEVudW1lcmF0aW9uUHJvcGVydHk8Q29tcG9uZW50VmVjdG9yU3R5bGVzPixcclxuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlc1Zpc2libGVQcm9wZXJ0eTogVFJlYWRPbmx5UHJvcGVydHk8Ym9vbGVhbj4sXHJcbiAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlZE9wdGlvbnM/OiBDb21wb25lbnRWZWN0b3JOb2RlT3B0aW9ucyApIHtcclxuXHJcbiAgICBjb25zdCBvcHRpb25zID0gb3B0aW9uaXplPENvbXBvbmVudFZlY3Rvck5vZGVPcHRpb25zLCBTZWxmT3B0aW9ucywgUm9vdFZlY3Rvck5vZGVPcHRpb25zPigpKCB7XHJcblxyXG4gICAgICAvLyBSb290VmVjdG9yTm9kZU9wdGlvbnNcclxuICAgICAgYXJyb3dUeXBlOiAnZGFzaGVkJyxcclxuICAgICAgYXJyb3dPcHRpb25zOiBtZXJnZSgge30sIFZlY3RvckFkZGl0aW9uQ29uc3RhbnRzLkNPTVBPTkVOVF9WRUNUT1JfQVJST1dfT1BUSU9OUywge1xyXG4gICAgICAgIGZpbGw6IGNvbXBvbmVudFZlY3Rvci52ZWN0b3JDb2xvclBhbGV0dGUuY29tcG9uZW50RmlsbFxyXG4gICAgICB9IClcclxuICAgIH0sIHByb3ZpZGVkT3B0aW9ucyApO1xyXG5cclxuICAgIHN1cGVyKCBjb21wb25lbnRWZWN0b3IsIGdyYXBoLm1vZGVsVmlld1RyYW5zZm9ybVByb3BlcnR5LCB2YWx1ZXNWaXNpYmxlUHJvcGVydHksIGdyYXBoLmFjdGl2ZVZlY3RvclByb3BlcnR5LCBvcHRpb25zICk7XHJcblxyXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gICAgLy8gQ3JlYXRlIGEgcGF0aCB0aGF0IHJlcHJlc2VudHMgdGhlIGRhc2hlZCBsaW5lcyBjb3JyZXNwb25kaW5nIHRvIHRoZSBQUk9KRUNUSU9OIHN0eWxlLlxyXG4gICAgLy8gVGhlIHNoYXBlIG9mIHRoZSBwYXRoIHdpbGwgYmUgdXBkYXRlZCBsYXRlci5cclxuXHJcbiAgICB0aGlzLmxlYWRlckxpbmVzUGF0aCA9IG5ldyBQYXRoKCBuZXcgU2hhcGUoKSwge1xyXG4gICAgICBsaW5lV2lkdGg6IDAuNSxcclxuICAgICAgbGluZURhc2g6IE5PTl9BQ1RJVkVfTEVBREVSX0xJTkVTX0RBU0hcclxuICAgIH0gKTtcclxuICAgIHRoaXMuYWRkQ2hpbGQoIHRoaXMubGVhZGVyTGluZXNQYXRoICk7XHJcblxyXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvLyBDcmVhdGUgYSBtdWx0aWxpbmsgdG8gb2JzZXJ2ZTpcclxuICAgIC8vICAtIGNvbXBvbmVudFN0eWxlUHJvcGVydHkgLSB0byBkZXRlcm1pbmUgdmlzaWJpbGl0eSAoaS5lLiBjb21wb25lbnRzIHNob3VsZG4ndCBiZSB2aXNpYmxlIG9uIElOVklTSUJMRSlcclxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmQgdG8gZHJhdyBsaW5lcyBvbiB0aGUgUFJPSkVDVElPTiBjb21wb25lbnRTdHlsZVxyXG4gICAgLy8gIC0gaXNPbkdyYXBoUHJvcGVydHkgLSBjb21wb25lbnRzIHNob3VsZG4ndCBiZSB2aXNpYmxlIGlmIHRoZSB2ZWN0b3IgaXNuJ3Qgb24gdGhlIGdyYXBoXHJcbiAgICAvLyAgLSB2ZWN0b3JDb21wb25lbnRzUHJvcGVydHkgLSB0byB1cGRhdGUgdGhlIGxlYWRlciBsaW5lcyBkcmF3aW5ncyBwb3NpdGlvbnNcclxuICAgIC8vXHJcbiAgICAvLyBkaXNwb3NlIGlzIHJlcXVpcmVkLlxyXG4gICAgY29uc3QgY29tcG9uZW50VmVjdG9yTXVsdGlsaW5rID0gTXVsdGlsaW5rLm11bHRpbGluayhcclxuICAgICAgWyBjb21wb25lbnRTdHlsZVByb3BlcnR5LCBjb21wb25lbnRWZWN0b3IuaXNQYXJlbnRWZWN0b3JBY3RpdmVQcm9wZXJ0eSxcclxuICAgICAgICBjb21wb25lbnRWZWN0b3IuaXNPbkdyYXBoUHJvcGVydHksIGNvbXBvbmVudFZlY3Rvci52ZWN0b3JDb21wb25lbnRzUHJvcGVydHkgXSxcclxuICAgICAgKCBjb21wb25lbnRTdHlsZSwgaXNQYXJlbnRBY3RpdmUgKSA9PiB7XHJcblxyXG4gICAgICAgIHRoaXMudXBkYXRlQ29tcG9uZW50VmVjdG9yKCBjb21wb25lbnRWZWN0b3IsXHJcbiAgICAgICAgICBncmFwaC5tb2RlbFZpZXdUcmFuc2Zvcm1Qcm9wZXJ0eS52YWx1ZSxcclxuICAgICAgICAgIGNvbXBvbmVudFN0eWxlLFxyXG4gICAgICAgICAgaXNQYXJlbnRBY3RpdmUgKTtcclxuICAgICAgfSApO1xyXG5cclxuICAgIC8vIEhpZ2hsaWdodCB0aGUgY29tcG9uZW50IHZlY3RvcidzIGxhYmVsIHdoZW4gaXRzIHBhcmVudCB2ZWN0b3IgaXMgc2VsZWN0ZWQuXHJcbiAgICAvLyB1bmxpbmsgaXMgcmVxdWlyZWQgb24gZGlzcG9zZS5cclxuICAgIGNvbnN0IGFjdGl2ZVZlY3Rvckxpc3RlbmVyID0gKCBhY3RpdmVWZWN0b3I6IFZlY3RvciB8IG51bGwgKSA9PiB7XHJcbiAgICAgIHRoaXMubGFiZWxOb2RlLnNldEhpZ2hsaWdodGVkKCBhY3RpdmVWZWN0b3IgPT09IGNvbXBvbmVudFZlY3Rvci5wYXJlbnRWZWN0b3IgKTtcclxuICAgIH07XHJcbiAgICBncmFwaC5hY3RpdmVWZWN0b3JQcm9wZXJ0eS5saW5rKCBhY3RpdmVWZWN0b3JMaXN0ZW5lciApO1xyXG5cclxuICAgIHRoaXMuZGlzcG9zZUNvbXBvbmVudFZlY3Rvck5vZGUgPSAoKSA9PiB7XHJcbiAgICAgIGNvbXBvbmVudFZlY3Rvck11bHRpbGluay5kaXNwb3NlKCk7XHJcbiAgICAgIGlmICggZ3JhcGguYWN0aXZlVmVjdG9yUHJvcGVydHkuaGFzTGlzdGVuZXIoIGFjdGl2ZVZlY3Rvckxpc3RlbmVyICkgKSB7XHJcbiAgICAgICAgZ3JhcGguYWN0aXZlVmVjdG9yUHJvcGVydHkudW5saW5rKCBhY3RpdmVWZWN0b3JMaXN0ZW5lciApO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgcHVibGljIG92ZXJyaWRlIGRpc3Bvc2UoKTogdm9pZCB7XHJcbiAgICB0aGlzLmRpc3Bvc2VDb21wb25lbnRWZWN0b3JOb2RlKCk7XHJcbiAgICBzdXBlci5kaXNwb3NlKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGVzIHRoZSBjb21wb25lbnQgdmVjdG9yIG5vZGU6XHJcbiAgICogIC0gRHJhd3MgbGVhZGVyIGxpbmVzIHdoZW4gY29tcG9uZW50U3R5bGUgaXMgT05fQVhJU1xyXG4gICAqICAtIERldGVybWluZXMgdmlzaWJpbGl0eSAoaS5lLiBjb21wb25lbnRzIHNob3VsZG4ndCBiZSB2aXNpYmxlIG9uIElOVklTSUJMRSlcclxuICAgKi9cclxuICBwcm90ZWN0ZWQgdXBkYXRlQ29tcG9uZW50VmVjdG9yKCBjb21wb25lbnRWZWN0b3I6IENvbXBvbmVudFZlY3RvciwgbW9kZWxWaWV3VHJhbnNmb3JtOiBNb2RlbFZpZXdUcmFuc2Zvcm0yLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudFN0eWxlOiBDb21wb25lbnRWZWN0b3JTdHlsZXMsIGlzUGFyZW50QWN0aXZlOiBib29sZWFuICk6IHZvaWQge1xyXG5cclxuICAgIC8vIENvbXBvbmVudCB2ZWN0b3JzIGFyZSB2aXNpYmxlIHdoZW4gaXQgaXNuJ3QgSU5WSVNJQkxFLCBhbmQgaXQgaXMgb24gdGhlIGdyYXBoLlxyXG4gICAgdGhpcy52aXNpYmxlID0gY29tcG9uZW50VmVjdG9yLmlzT25HcmFwaFByb3BlcnR5LnZhbHVlICYmXHJcbiAgICAgICAgICAgICAgICAgICBjb21wb25lbnRTdHlsZSAhPT0gQ29tcG9uZW50VmVjdG9yU3R5bGVzLklOVklTSUJMRTtcclxuXHJcbiAgICBpZiAoIGNvbXBvbmVudFN0eWxlID09PSBDb21wb25lbnRWZWN0b3JTdHlsZXMuUFJPSkVDVElPTiApIHtcclxuICAgICAgdGhpcy5sYWJlbE5vZGUudmlzaWJsZSA9ICggY29tcG9uZW50VmVjdG9yLm1hZ25pdHVkZSAhPT0gMCApO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcblxyXG4gICAgICAvLyBIaWRlIHRoZSBsYWJlbCBpZiBlaXRoZXIgb2YgdGhlIHBhcmVudCB2ZWN0b3IncyBjb21wb25lbnRzIGlzIHplcm8sXHJcbiAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vcGhldHNpbXMvdmVjdG9yLWFkZGl0aW9uL2lzc3Vlcy8yNjRcclxuICAgICAgdGhpcy5sYWJlbE5vZGUudmlzaWJsZSA9ICFjb21wb25lbnRWZWN0b3IucGFyZW50VmVjdG9yLmhhc1plcm9Db21wb25lbnQoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBMZWFkZXIgbGluZXMgYXJlIG9ubHkgdmlzaWJsZSB3aGVuIGNvbXBvbmVudCB2ZWN0b3JzIGFyZSBwcm9qZWN0ZWQgb250byBheGVzXHJcbiAgICB0aGlzLmxlYWRlckxpbmVzUGF0aC52aXNpYmxlID0gKCBjb21wb25lbnRTdHlsZSA9PT0gQ29tcG9uZW50VmVjdG9yU3R5bGVzLlBST0pFQ1RJT04gKTtcclxuXHJcbiAgICAvLyBVcGRhdGUgbGVhZGVyIGxpbmVzIG9ubHkgaWYgdGhleSBhcmUgdmlzaWJsZSAod2l0aCBQUk9KRUNUSU9OIHN0eWxlKVxyXG4gICAgaWYgKCB0aGlzLmxlYWRlckxpbmVzUGF0aC52aXNpYmxlICkge1xyXG5cclxuICAgICAgLy8gU2luY2UgdGhlIGxlYWRlciBsaW5lcyBhcmUgYSBjaGlsZCBvZiB0aGlzIHZpZXcsIHRoZSBvcmlnaW4gb2YgdGhlIHZpZXcgaXMgYXQgdGhlIHRhaWwgb2YgdGhlIGNvbXBvbmVudFxyXG4gICAgICAvLyB2ZWN0b3IuIEdldCB0aGUgdGlwIHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSB0YWlsIG9mIHRoZSBjb21wb25lbnQgdmVjdG9yICh3aGljaCBpcyB0aGUgY29tcG9uZW50cylcclxuICAgICAgY29uc3QgdGlwUG9zaXRpb24gPSBtb2RlbFZpZXdUcmFuc2Zvcm0ubW9kZWxUb1ZpZXdEZWx0YSggY29tcG9uZW50VmVjdG9yLnZlY3RvckNvbXBvbmVudHMgKTtcclxuXHJcbiAgICAgIC8vIEdldCB0aGUgcGFyZW50IHRhaWwgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIG9yaWdpbiBvZiB0aGUgdmlldyAodGhlIHRhaWwgb2YgdGhlIGNvbXBvbmVudCB2ZWN0b3IpXHJcbiAgICAgIGNvbnN0IHBhcmVudFRhaWxQb3NpdGlvbiA9IG1vZGVsVmlld1RyYW5zZm9ybS5tb2RlbFRvVmlld0RlbHRhKCBjb21wb25lbnRWZWN0b3IucGFyZW50VGFpbFxyXG4gICAgICAgIC5taW51cyggY29tcG9uZW50VmVjdG9yLnRhaWwgKSApO1xyXG5cclxuICAgICAgLy8gR2V0IHRoZSBwYXJlbnQgdGlwIHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSBvcmlnaW4gb2YgdGhlIHZpZXcgKHRoZSB0YWlsIG9mIHRoZSBjb21wb25lbnQgdmVjdG9yKVxyXG4gICAgICBjb25zdCBwYXJlbnRUaXBQb3NpdGlvbiA9IG1vZGVsVmlld1RyYW5zZm9ybS5tb2RlbFRvVmlld0RlbHRhKCBjb21wb25lbnRWZWN0b3IucGFyZW50VGlwXHJcbiAgICAgICAgLm1pbnVzKCBjb21wb25lbnRWZWN0b3IudGFpbCApICk7XHJcblxyXG4gICAgICAvLyBDcmVhdGUgbmV3IHNoYXBlIGZvciB0aGUgbGVhZGVyIGxpbmVzXHJcbiAgICAgIHRoaXMubGVhZGVyTGluZXNQYXRoLnNoYXBlID0gbmV3IFNoYXBlKClcclxuICAgICAgICAubW92ZVRvUG9pbnQoIFZlY3RvcjIuWkVSTyApXHJcbiAgICAgICAgLmxpbmVUb1BvaW50KCBwYXJlbnRUYWlsUG9zaXRpb24gKVxyXG4gICAgICAgIC5tb3ZlVG9Qb2ludCggdGlwUG9zaXRpb24gKVxyXG4gICAgICAgIC5saW5lVG9Qb2ludCggcGFyZW50VGlwUG9zaXRpb24gKTtcclxuXHJcbiAgICAgIGlmICggaXNQYXJlbnRBY3RpdmUgKSB7XHJcbiAgICAgICAgdGhpcy5sZWFkZXJMaW5lc1BhdGguc3Ryb2tlID0gVmVjdG9yQWRkaXRpb25Db2xvcnMuTEVBREVSX0xJTkVTX0FDVElWRV9TVFJPS0U7XHJcbiAgICAgICAgdGhpcy5sZWFkZXJMaW5lc1BhdGgubGluZURhc2ggPSBBQ1RJVkVfTEVBREVSX0xJTkVTX0RBU0g7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgdGhpcy5sZWFkZXJMaW5lc1BhdGguc3Ryb2tlID0gVmVjdG9yQWRkaXRpb25Db2xvcnMuTEVBREVSX0xJTkVTX05PTl9BQ1RJVkVfU1RST0tFO1xyXG4gICAgICAgIHRoaXMubGVhZGVyTGluZXNQYXRoLmxpbmVEYXNoID0gTk9OX0FDVElWRV9MRUFERVJfTElORVNfREFTSDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlcyB0aGUgbGFiZWwgcG9zaXRpb25pbmcgb2YgdGhlIHZlY3RvciBjb21wb25lbnQuIFZlY3RvciBjb21wb25lbnRzIGhhdmUgYSB1bmlxdWUgbGFiZWwgcG9zaXRpb25pbmcuXHJcbiAgICovXHJcbiAgcHJvdGVjdGVkIG92ZXJyaWRlIHVwZGF0ZUxhYmVsUG9zaXRpb25pbmcoIGNvbXBvbmVudFZlY3RvcjogQ29tcG9uZW50VmVjdG9yLCBtb2RlbFZpZXdUcmFuc2Zvcm06IE1vZGVsVmlld1RyYW5zZm9ybTIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlc1Zpc2libGU6IGJvb2xlYW4gKTogdm9pZCB7XHJcblxyXG4gICAgLy8gSWYgdGhlIG1hZ25pdHVkZSBvZiB0aGUgY29tcG9uZW50VmVjdG9yIGlzIDAsIHRoZW4gcG9zaXRpb24gdGhlIGxhYmVsIG5vZGUgb24gdGhlICd0YWlsJ1xyXG4gICAgaWYgKCBjb21wb25lbnRWZWN0b3IubWFnbml0dWRlID09PSAwICkge1xyXG4gICAgICB0aGlzLmxhYmVsTm9kZS5jZW50ZXIgPSBWZWN0b3IyLlpFUk87XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBGbGFnIHRvIGluZGljYXRlIHRoZSBsYWJlbCBvZmZzZXQgdHJhbnNsYXRpb24uXHJcbiAgICBjb25zdCBsYWJlbE9mZnNldCA9IG5ldyBWZWN0b3IyKCAwLCAwICk7XHJcblxyXG4gICAgLy8gQ29udmVuaWVuY2UgdmFyaWFibGVzXHJcbiAgICBjb25zdCBjb21wb25lbnRNaWRQb2ludCA9IGNvbXBvbmVudFZlY3Rvci5taWRQb2ludDtcclxuICAgIGNvbnN0IHBhcmVudE1pZFBvaW50ID0gY29tcG9uZW50VmVjdG9yLnBhcmVudE1pZFBvaW50O1xyXG5cclxuICAgIGlmICggY29tcG9uZW50VmVjdG9yLmNvbXBvbmVudFR5cGUgPT09IENvbXBvbmVudFZlY3RvclR5cGVzLlhfQ09NUE9ORU5UICkge1xyXG5cclxuICAgICAgLy8gR2V0IHRoZSBsYWJlbCBoZWlnaHQuIE5lZ2F0aXZlIHNpbmNlIHRoZSB5IGF4aXMgaXMgaW52ZXJ0ZWQgaW4gdGhlIHZpZXdcclxuICAgICAgY29uc3QgbGFiZWxIZWlnaHQgPSBtb2RlbFZpZXdUcmFuc2Zvcm0udmlld1RvTW9kZWxEZWx0YVkoIC10aGlzLmxhYmVsTm9kZS5oZWlnaHQgKTtcclxuXHJcbiAgICAgIC8vIElmIHRoZSBjb21wb25lbnQgaXMgYmVsb3cgdGhlIHBhcmVudCwgcG9zaXRpb24gdGhlIGxhYmVsIGJlbG93LCBvdGhlcndpc2UgcG9zaXRpb24gaXQgYWJvdmVcclxuICAgICAgaWYgKCBjb21wb25lbnRNaWRQb2ludC55IDw9IHBhcmVudE1pZFBvaW50LnkgKSB7XHJcbiAgICAgICAgbGFiZWxPZmZzZXQuc2V0WFkoIDAsIC1DT01QT05FTlRfTEFCRUxfT0ZGU0VUIC0gbGFiZWxIZWlnaHQgLyAyICk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgbGFiZWxPZmZzZXQuc2V0WFkoIDAsIENPTVBPTkVOVF9MQUJFTF9PRkZTRVQgKyBsYWJlbEhlaWdodCAvIDIgKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoIGNvbXBvbmVudFZlY3Rvci5jb21wb25lbnRUeXBlID09PSBDb21wb25lbnRWZWN0b3JUeXBlcy5ZX0NPTVBPTkVOVCApIHtcclxuXHJcbiAgICAgIGNvbnN0IGxhYmVsV2lkdGggPSBtb2RlbFZpZXdUcmFuc2Zvcm0udmlld1RvTW9kZWxEZWx0YVgoIHRoaXMubGFiZWxOb2RlLndpZHRoICk7XHJcblxyXG4gICAgICAvLyBJZiB0aGUgY29tcG9uZW50IGlzIHRvIHRoZSBsZWZ0IG9mIHRoZSBwYXJlbnQsIHBvc2l0aW9uIHRoZSBsYWJlbCB0byB0aGUgbGVmdCwgb3RoZXJ3aXNlIHRvIHRoZSByaWdodFxyXG4gICAgICBpZiAoIGNvbXBvbmVudE1pZFBvaW50LnggPCBwYXJlbnRNaWRQb2ludC54ICkge1xyXG4gICAgICAgIGxhYmVsT2Zmc2V0LnNldFhZKCAtQ09NUE9ORU5UX0xBQkVMX09GRlNFVCAtIGxhYmVsV2lkdGggLyAyLCAwICk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgbGFiZWxPZmZzZXQuc2V0WFkoIENPTVBPTkVOVF9MQUJFTF9PRkZTRVQgKyBsYWJlbFdpZHRoIC8gMiwgMCApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUG9zaXRpb24gdGhlIGxhYmVsXHJcbiAgICB0aGlzLmxhYmVsTm9kZS5jZW50ZXIgPSBSb290VmVjdG9yTm9kZS5jb21wdXRlTGFiZWxDZW50ZXIoIGNvbXBvbmVudFZlY3RvciwgbW9kZWxWaWV3VHJhbnNmb3JtLCBsYWJlbE9mZnNldCApO1xyXG4gIH1cclxufVxyXG5cclxudmVjdG9yQWRkaXRpb24ucmVnaXN0ZXIoICdDb21wb25lbnRWZWN0b3JOb2Rl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