// Copyright 2019-2023, University of Colorado Boulder

/**
 * VectorAngleNode is the angle indicator that appears on vectors on the graph when the angle checkbox is checked.
 * Only shows if the vector model is active.
 *
 * @author Brandon Li
 */

import Multilink from '../../../../axon/js/Multilink.js';
import Utils from '../../../../dot/js/Utils.js';
import MathSymbols from '../../../../scenery-phet/js/MathSymbols.js';
import { Color, Line, Node, Text } from '../../../../scenery/js/imports.js';
import vectorAddition from '../../vectorAddition.js';
import VectorAdditionConstants from '../VectorAdditionConstants.js';
import CurvedArrowNode from './CurvedArrowNode.js';
// constants

// maximum radius of the curved arrow - the radius is changed to keep the curved arrow smaller than the vector.
const MAX_CURVED_ARROW_RADIUS = 25;

// the percent symbol of curved arrow radius when compared to the magnitude of the vector - as long as it's less than
// the max curved arrow radius
const MAX_RADIUS_SCALE = 0.79;

// maximum length of the baseline that is parallel to the x axis
const MAX_BASELINE_WIDTH = 55;

// the maximum percentage of the baseline when compared to the radius of the curved arrow.
const MAX_BASELINE_SCALE = 0.60;

// the offset of the angle label from the curved arrow
const LABEL_OFFSET = 3.5;

// Angles greater than 35 deg position the label between the vector and the baseline, and angles under 35
// place the label on the other side of the baseline. See
// https://docs.google.com/document/d/1opnDgqIqIroo8VK0CbOyQ5608_g11MSGZXnFlI8k5Ds/edit#bookmark=id.on5p73bbry7g.
const ANGLE_UNDER_BASELINE_THRESHOLD = 35;
export default class VectorAngleNode extends Node {
  // line that is parallel to the x-axis

  // arrow in a circle shape from the baseline to the vector

  constructor(vector, anglesVisibleProperty, modelViewTransformProperty) {
    super();
    this.baseLine = new Line(0, 0, MAX_BASELINE_WIDTH, 0, {
      stroke: Color.BLACK
    });
    this.curvedArrow = new CurvedArrowNode(MAX_CURVED_ARROW_RADIUS, vector.angle ? vector.angle : 0);

    // set to an arbitrary string for now.
    this.labelText = new Text('', {
      font: VectorAdditionConstants.ANGLE_LABEL_FONT
    });
    this.setChildren([this.baseLine, this.curvedArrow, this.labelText]);

    // Update the angle and its visibility. Must be disposed on dispose.
    const angleVisibleMultilink = Multilink.multilink([anglesVisibleProperty, vector.isOnGraphProperty, vector.vectorComponentsProperty], (angleVisible, isOnGraph, vectorComponents) => {
      this.visible = angleVisible && isOnGraph && vector.magnitude !== 0;
      if (this.visible) {
        this.updateAngleNode(vector, modelViewTransformProperty.value);
      }
    });
    this.disposeVectorAngleNode = () => {
      Multilink.unmultilink(angleVisibleMultilink);
    };
  }
  dispose() {
    this.disposeVectorAngleNode();
    super.dispose();
  }

  /**
   * Updates the angle node: (called when the vector model's components change)
   *  - Curved arrow node angle
   *  - Curved arrow node radius
   *  - Label Text
   *  - baseline length
   */
  updateAngleNode(vector, modelViewTransform) {
    // convenience reference.
    const angleDegrees = vector.angleDegrees;

    // Update the curved arrow node angle
    this.curvedArrow.setAngle(vector.angle ? vector.angle : 0);

    // Update the label text.
    this.labelText.setString(angleDegrees === null ? '' : `${Utils.toFixed(angleDegrees, VectorAdditionConstants.VECTOR_VALUE_DECIMAL_PLACES)}${MathSymbols.DEGREES}`);

    // Update the curved arrow radius
    const viewMagnitude = modelViewTransform.modelToViewDeltaX(vector.magnitude);
    if (viewMagnitude !== 0) {
      this.curvedArrow.setRadius(_.min([MAX_RADIUS_SCALE * viewMagnitude, MAX_CURVED_ARROW_RADIUS]));
    }
    const curvedArrowRadius = this.curvedArrow.getRadius();
    const vectorAngle = vector.angle;
    assert && assert(vectorAngle !== null);

    // Update the baseline
    this.baseLine.setX2(_.min([curvedArrowRadius / MAX_BASELINE_SCALE, MAX_BASELINE_WIDTH]));

    // Position the label text
    if (angleDegrees !== null) {
      if (angleDegrees > ANGLE_UNDER_BASELINE_THRESHOLD) {
        // Position the label next to the arc, halfway across the arc
        this.labelText.setTranslation((curvedArrowRadius + LABEL_OFFSET) * Math.cos(vectorAngle / 2), -(curvedArrowRadius + LABEL_OFFSET) * Math.sin(vectorAngle / 2));
      } else if (angleDegrees >= 0) {
        // Position the label halfway across, but on the other side of the baseline
        this.labelText.setTranslation(curvedArrowRadius / 2, curvedArrowRadius / 2);
      } else if (angleDegrees > -ANGLE_UNDER_BASELINE_THRESHOLD) {
        // Position the label halfway across, but on the other side of the baseline
        this.labelText.setTranslation(curvedArrowRadius / 2, -curvedArrowRadius / 2 + this.labelText.height / 2);
      } else {
        // Position the label next to the arc, halfway across the arc
        this.labelText.setTranslation((curvedArrowRadius + LABEL_OFFSET) * Math.cos(vectorAngle / 2), -(curvedArrowRadius + LABEL_OFFSET) * Math.sin(vectorAngle / 2) + this.labelText.height / 2);
      }
    }
  }
}
vectorAddition.register('VectorAngleNode', VectorAngleNode);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJNdWx0aWxpbmsiLCJVdGlscyIsIk1hdGhTeW1ib2xzIiwiQ29sb3IiLCJMaW5lIiwiTm9kZSIsIlRleHQiLCJ2ZWN0b3JBZGRpdGlvbiIsIlZlY3RvckFkZGl0aW9uQ29uc3RhbnRzIiwiQ3VydmVkQXJyb3dOb2RlIiwiTUFYX0NVUlZFRF9BUlJPV19SQURJVVMiLCJNQVhfUkFESVVTX1NDQUxFIiwiTUFYX0JBU0VMSU5FX1dJRFRIIiwiTUFYX0JBU0VMSU5FX1NDQUxFIiwiTEFCRUxfT0ZGU0VUIiwiQU5HTEVfVU5ERVJfQkFTRUxJTkVfVEhSRVNIT0xEIiwiVmVjdG9yQW5nbGVOb2RlIiwiY29uc3RydWN0b3IiLCJ2ZWN0b3IiLCJhbmdsZXNWaXNpYmxlUHJvcGVydHkiLCJtb2RlbFZpZXdUcmFuc2Zvcm1Qcm9wZXJ0eSIsImJhc2VMaW5lIiwic3Ryb2tlIiwiQkxBQ0siLCJjdXJ2ZWRBcnJvdyIsImFuZ2xlIiwibGFiZWxUZXh0IiwiZm9udCIsIkFOR0xFX0xBQkVMX0ZPTlQiLCJzZXRDaGlsZHJlbiIsImFuZ2xlVmlzaWJsZU11bHRpbGluayIsIm11bHRpbGluayIsImlzT25HcmFwaFByb3BlcnR5IiwidmVjdG9yQ29tcG9uZW50c1Byb3BlcnR5IiwiYW5nbGVWaXNpYmxlIiwiaXNPbkdyYXBoIiwidmVjdG9yQ29tcG9uZW50cyIsInZpc2libGUiLCJtYWduaXR1ZGUiLCJ1cGRhdGVBbmdsZU5vZGUiLCJ2YWx1ZSIsImRpc3Bvc2VWZWN0b3JBbmdsZU5vZGUiLCJ1bm11bHRpbGluayIsImRpc3Bvc2UiLCJtb2RlbFZpZXdUcmFuc2Zvcm0iLCJhbmdsZURlZ3JlZXMiLCJzZXRBbmdsZSIsInNldFN0cmluZyIsInRvRml4ZWQiLCJWRUNUT1JfVkFMVUVfREVDSU1BTF9QTEFDRVMiLCJERUdSRUVTIiwidmlld01hZ25pdHVkZSIsIm1vZGVsVG9WaWV3RGVsdGFYIiwic2V0UmFkaXVzIiwiXyIsIm1pbiIsImN1cnZlZEFycm93UmFkaXVzIiwiZ2V0UmFkaXVzIiwidmVjdG9yQW5nbGUiLCJhc3NlcnQiLCJzZXRYMiIsInNldFRyYW5zbGF0aW9uIiwiTWF0aCIsImNvcyIsInNpbiIsImhlaWdodCIsInJlZ2lzdGVyIl0sInNvdXJjZXMiOlsiVmVjdG9yQW5nbGVOb2RlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDE5LTIwMjMsIFVuaXZlcnNpdHkgb2YgQ29sb3JhZG8gQm91bGRlclxyXG5cclxuLyoqXHJcbiAqIFZlY3RvckFuZ2xlTm9kZSBpcyB0aGUgYW5nbGUgaW5kaWNhdG9yIHRoYXQgYXBwZWFycyBvbiB2ZWN0b3JzIG9uIHRoZSBncmFwaCB3aGVuIHRoZSBhbmdsZSBjaGVja2JveCBpcyBjaGVja2VkLlxyXG4gKiBPbmx5IHNob3dzIGlmIHRoZSB2ZWN0b3IgbW9kZWwgaXMgYWN0aXZlLlxyXG4gKlxyXG4gKiBAYXV0aG9yIEJyYW5kb24gTGlcclxuICovXHJcblxyXG5pbXBvcnQgTXVsdGlsaW5rIGZyb20gJy4uLy4uLy4uLy4uL2F4b24vanMvTXVsdGlsaW5rLmpzJztcclxuaW1wb3J0IFV0aWxzIGZyb20gJy4uLy4uLy4uLy4uL2RvdC9qcy9VdGlscy5qcyc7XHJcbmltcG9ydCBNb2RlbFZpZXdUcmFuc2Zvcm0yIGZyb20gJy4uLy4uLy4uLy4uL3BoZXRjb21tb24vanMvdmlldy9Nb2RlbFZpZXdUcmFuc2Zvcm0yLmpzJztcclxuaW1wb3J0IE1hdGhTeW1ib2xzIGZyb20gJy4uLy4uLy4uLy4uL3NjZW5lcnktcGhldC9qcy9NYXRoU3ltYm9scy5qcyc7XHJcbmltcG9ydCB7IENvbG9yLCBMaW5lLCBOb2RlLCBUZXh0IH0gZnJvbSAnLi4vLi4vLi4vLi4vc2NlbmVyeS9qcy9pbXBvcnRzLmpzJztcclxuaW1wb3J0IHZlY3RvckFkZGl0aW9uIGZyb20gJy4uLy4uL3ZlY3RvckFkZGl0aW9uLmpzJztcclxuaW1wb3J0IFZlY3RvciBmcm9tICcuLi9tb2RlbC9WZWN0b3IuanMnO1xyXG5pbXBvcnQgVmVjdG9yQWRkaXRpb25Db25zdGFudHMgZnJvbSAnLi4vVmVjdG9yQWRkaXRpb25Db25zdGFudHMuanMnO1xyXG5pbXBvcnQgQ3VydmVkQXJyb3dOb2RlIGZyb20gJy4vQ3VydmVkQXJyb3dOb2RlLmpzJztcclxuaW1wb3J0IFRSZWFkT25seVByb3BlcnR5IGZyb20gJy4uLy4uLy4uLy4uL2F4b24vanMvVFJlYWRPbmx5UHJvcGVydHkuanMnO1xyXG5cclxuLy8gY29uc3RhbnRzXHJcblxyXG4vLyBtYXhpbXVtIHJhZGl1cyBvZiB0aGUgY3VydmVkIGFycm93IC0gdGhlIHJhZGl1cyBpcyBjaGFuZ2VkIHRvIGtlZXAgdGhlIGN1cnZlZCBhcnJvdyBzbWFsbGVyIHRoYW4gdGhlIHZlY3Rvci5cclxuY29uc3QgTUFYX0NVUlZFRF9BUlJPV19SQURJVVMgPSAyNTtcclxuXHJcbi8vIHRoZSBwZXJjZW50IHN5bWJvbCBvZiBjdXJ2ZWQgYXJyb3cgcmFkaXVzIHdoZW4gY29tcGFyZWQgdG8gdGhlIG1hZ25pdHVkZSBvZiB0aGUgdmVjdG9yIC0gYXMgbG9uZyBhcyBpdCdzIGxlc3MgdGhhblxyXG4vLyB0aGUgbWF4IGN1cnZlZCBhcnJvdyByYWRpdXNcclxuY29uc3QgTUFYX1JBRElVU19TQ0FMRSA9IDAuNzk7XHJcblxyXG4vLyBtYXhpbXVtIGxlbmd0aCBvZiB0aGUgYmFzZWxpbmUgdGhhdCBpcyBwYXJhbGxlbCB0byB0aGUgeCBheGlzXHJcbmNvbnN0IE1BWF9CQVNFTElORV9XSURUSCA9IDU1O1xyXG5cclxuLy8gdGhlIG1heGltdW0gcGVyY2VudGFnZSBvZiB0aGUgYmFzZWxpbmUgd2hlbiBjb21wYXJlZCB0byB0aGUgcmFkaXVzIG9mIHRoZSBjdXJ2ZWQgYXJyb3cuXHJcbmNvbnN0IE1BWF9CQVNFTElORV9TQ0FMRSA9IDAuNjA7XHJcblxyXG4vLyB0aGUgb2Zmc2V0IG9mIHRoZSBhbmdsZSBsYWJlbCBmcm9tIHRoZSBjdXJ2ZWQgYXJyb3dcclxuY29uc3QgTEFCRUxfT0ZGU0VUID0gMy41O1xyXG5cclxuLy8gQW5nbGVzIGdyZWF0ZXIgdGhhbiAzNSBkZWcgcG9zaXRpb24gdGhlIGxhYmVsIGJldHdlZW4gdGhlIHZlY3RvciBhbmQgdGhlIGJhc2VsaW5lLCBhbmQgYW5nbGVzIHVuZGVyIDM1XHJcbi8vIHBsYWNlIHRoZSBsYWJlbCBvbiB0aGUgb3RoZXIgc2lkZSBvZiB0aGUgYmFzZWxpbmUuIFNlZVxyXG4vLyBodHRwczovL2RvY3MuZ29vZ2xlLmNvbS9kb2N1bWVudC9kLzFvcG5EZ3FJcUlyb284VkswQ2JPeVE1NjA4X2cxMU1TR1pYbkZsSThrNURzL2VkaXQjYm9va21hcms9aWQub241cDczYmJyeTdnLlxyXG5jb25zdCBBTkdMRV9VTkRFUl9CQVNFTElORV9USFJFU0hPTEQgPSAzNTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZlY3RvckFuZ2xlTm9kZSBleHRlbmRzIE5vZGUge1xyXG5cclxuICAvLyBsaW5lIHRoYXQgaXMgcGFyYWxsZWwgdG8gdGhlIHgtYXhpc1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgYmFzZUxpbmU6IExpbmU7XHJcblxyXG4gIC8vIGFycm93IGluIGEgY2lyY2xlIHNoYXBlIGZyb20gdGhlIGJhc2VsaW5lIHRvIHRoZSB2ZWN0b3JcclxuICBwcml2YXRlIHJlYWRvbmx5IGN1cnZlZEFycm93OiBDdXJ2ZWRBcnJvd05vZGU7XHJcblxyXG4gIHByaXZhdGUgcmVhZG9ubHkgbGFiZWxUZXh0OiBUZXh0O1xyXG5cclxuICBwcml2YXRlIHJlYWRvbmx5IGRpc3Bvc2VWZWN0b3JBbmdsZU5vZGU6ICgpID0+IHZvaWQ7XHJcblxyXG4gIHB1YmxpYyBjb25zdHJ1Y3RvciggdmVjdG9yOiBWZWN0b3IsIGFuZ2xlc1Zpc2libGVQcm9wZXJ0eTogVFJlYWRPbmx5UHJvcGVydHk8Ym9vbGVhbj4sIG1vZGVsVmlld1RyYW5zZm9ybVByb3BlcnR5OiBUUmVhZE9ubHlQcm9wZXJ0eTxNb2RlbFZpZXdUcmFuc2Zvcm0yPiApIHtcclxuXHJcbiAgICBzdXBlcigpO1xyXG5cclxuICAgIHRoaXMuYmFzZUxpbmUgPSBuZXcgTGluZSggMCwgMCwgTUFYX0JBU0VMSU5FX1dJRFRILCAwLCB7IHN0cm9rZTogQ29sb3IuQkxBQ0sgfSApO1xyXG5cclxuICAgIHRoaXMuY3VydmVkQXJyb3cgPSBuZXcgQ3VydmVkQXJyb3dOb2RlKCBNQVhfQ1VSVkVEX0FSUk9XX1JBRElVUywgdmVjdG9yLmFuZ2xlID8gdmVjdG9yLmFuZ2xlIDogMCApO1xyXG5cclxuICAgIC8vIHNldCB0byBhbiBhcmJpdHJhcnkgc3RyaW5nIGZvciBub3cuXHJcbiAgICB0aGlzLmxhYmVsVGV4dCA9IG5ldyBUZXh0KCAnJywgeyBmb250OiBWZWN0b3JBZGRpdGlvbkNvbnN0YW50cy5BTkdMRV9MQUJFTF9GT05UIH0gKTtcclxuXHJcbiAgICB0aGlzLnNldENoaWxkcmVuKCBbIHRoaXMuYmFzZUxpbmUsIHRoaXMuY3VydmVkQXJyb3csIHRoaXMubGFiZWxUZXh0IF0gKTtcclxuXHJcbiAgICAvLyBVcGRhdGUgdGhlIGFuZ2xlIGFuZCBpdHMgdmlzaWJpbGl0eS4gTXVzdCBiZSBkaXNwb3NlZCBvbiBkaXNwb3NlLlxyXG4gICAgY29uc3QgYW5nbGVWaXNpYmxlTXVsdGlsaW5rID0gTXVsdGlsaW5rLm11bHRpbGluayhcclxuICAgICAgWyBhbmdsZXNWaXNpYmxlUHJvcGVydHksIHZlY3Rvci5pc09uR3JhcGhQcm9wZXJ0eSwgdmVjdG9yLnZlY3RvckNvbXBvbmVudHNQcm9wZXJ0eSBdLFxyXG4gICAgICAoIGFuZ2xlVmlzaWJsZSwgaXNPbkdyYXBoLCB2ZWN0b3JDb21wb25lbnRzICkgPT4ge1xyXG4gICAgICAgIHRoaXMudmlzaWJsZSA9ICggYW5nbGVWaXNpYmxlICYmIGlzT25HcmFwaCAmJiB2ZWN0b3IubWFnbml0dWRlICE9PSAwICk7XHJcbiAgICAgICAgaWYgKCB0aGlzLnZpc2libGUgKSB7XHJcbiAgICAgICAgICB0aGlzLnVwZGF0ZUFuZ2xlTm9kZSggdmVjdG9yLCBtb2RlbFZpZXdUcmFuc2Zvcm1Qcm9wZXJ0eS52YWx1ZSApO1xyXG4gICAgICAgIH1cclxuICAgICAgfSApO1xyXG5cclxuICAgIHRoaXMuZGlzcG9zZVZlY3RvckFuZ2xlTm9kZSA9ICgpID0+IHtcclxuICAgICAgTXVsdGlsaW5rLnVubXVsdGlsaW5rKCBhbmdsZVZpc2libGVNdWx0aWxpbmsgKTtcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgb3ZlcnJpZGUgZGlzcG9zZSgpOiB2b2lkIHtcclxuICAgIHRoaXMuZGlzcG9zZVZlY3RvckFuZ2xlTm9kZSgpO1xyXG4gICAgc3VwZXIuZGlzcG9zZSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlcyB0aGUgYW5nbGUgbm9kZTogKGNhbGxlZCB3aGVuIHRoZSB2ZWN0b3IgbW9kZWwncyBjb21wb25lbnRzIGNoYW5nZSlcclxuICAgKiAgLSBDdXJ2ZWQgYXJyb3cgbm9kZSBhbmdsZVxyXG4gICAqICAtIEN1cnZlZCBhcnJvdyBub2RlIHJhZGl1c1xyXG4gICAqICAtIExhYmVsIFRleHRcclxuICAgKiAgLSBiYXNlbGluZSBsZW5ndGhcclxuICAgKi9cclxuICBwcml2YXRlIHVwZGF0ZUFuZ2xlTm9kZSggdmVjdG9yOiBWZWN0b3IsIG1vZGVsVmlld1RyYW5zZm9ybTogTW9kZWxWaWV3VHJhbnNmb3JtMiApOiB2b2lkIHtcclxuXHJcbiAgICAvLyBjb252ZW5pZW5jZSByZWZlcmVuY2UuXHJcbiAgICBjb25zdCBhbmdsZURlZ3JlZXMgPSB2ZWN0b3IuYW5nbGVEZWdyZWVzO1xyXG5cclxuICAgIC8vIFVwZGF0ZSB0aGUgY3VydmVkIGFycm93IG5vZGUgYW5nbGVcclxuICAgIHRoaXMuY3VydmVkQXJyb3cuc2V0QW5nbGUoIHZlY3Rvci5hbmdsZSA/IHZlY3Rvci5hbmdsZSA6IDAgKTtcclxuXHJcbiAgICAvLyBVcGRhdGUgdGhlIGxhYmVsIHRleHQuXHJcbiAgICB0aGlzLmxhYmVsVGV4dC5zZXRTdHJpbmcoXHJcbiAgICAgICggYW5nbGVEZWdyZWVzID09PSBudWxsICkgPyAnJyA6XHJcbiAgICAgIGAke1V0aWxzLnRvRml4ZWQoIGFuZ2xlRGVncmVlcywgVmVjdG9yQWRkaXRpb25Db25zdGFudHMuVkVDVE9SX1ZBTFVFX0RFQ0lNQUxfUExBQ0VTICl9JHtNYXRoU3ltYm9scy5ERUdSRUVTfWBcclxuICAgICk7XHJcblxyXG4gICAgLy8gVXBkYXRlIHRoZSBjdXJ2ZWQgYXJyb3cgcmFkaXVzXHJcbiAgICBjb25zdCB2aWV3TWFnbml0dWRlID0gbW9kZWxWaWV3VHJhbnNmb3JtLm1vZGVsVG9WaWV3RGVsdGFYKCB2ZWN0b3IubWFnbml0dWRlICk7XHJcbiAgICBpZiAoIHZpZXdNYWduaXR1ZGUgIT09IDAgKSB7XHJcbiAgICAgIHRoaXMuY3VydmVkQXJyb3cuc2V0UmFkaXVzKCBfLm1pbiggWyBNQVhfUkFESVVTX1NDQUxFICogdmlld01hZ25pdHVkZSwgTUFYX0NVUlZFRF9BUlJPV19SQURJVVMgXSApISApO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGN1cnZlZEFycm93UmFkaXVzID0gdGhpcy5jdXJ2ZWRBcnJvdy5nZXRSYWRpdXMoKTtcclxuICAgIGNvbnN0IHZlY3RvckFuZ2xlID0gdmVjdG9yLmFuZ2xlITtcclxuICAgIGFzc2VydCAmJiBhc3NlcnQoIHZlY3RvckFuZ2xlICE9PSBudWxsICk7XHJcblxyXG4gICAgLy8gVXBkYXRlIHRoZSBiYXNlbGluZVxyXG4gICAgdGhpcy5iYXNlTGluZS5zZXRYMiggXy5taW4oIFsgY3VydmVkQXJyb3dSYWRpdXMgLyBNQVhfQkFTRUxJTkVfU0NBTEUsIE1BWF9CQVNFTElORV9XSURUSCBdICkhICk7XHJcblxyXG4gICAgLy8gUG9zaXRpb24gdGhlIGxhYmVsIHRleHRcclxuICAgIGlmICggYW5nbGVEZWdyZWVzICE9PSBudWxsICkge1xyXG5cclxuICAgICAgaWYgKCBhbmdsZURlZ3JlZXMgPiBBTkdMRV9VTkRFUl9CQVNFTElORV9USFJFU0hPTEQgKSB7XHJcblxyXG4gICAgICAgIC8vIFBvc2l0aW9uIHRoZSBsYWJlbCBuZXh0IHRvIHRoZSBhcmMsIGhhbGZ3YXkgYWNyb3NzIHRoZSBhcmNcclxuICAgICAgICB0aGlzLmxhYmVsVGV4dC5zZXRUcmFuc2xhdGlvbiggKCBjdXJ2ZWRBcnJvd1JhZGl1cyArIExBQkVMX09GRlNFVCApICogTWF0aC5jb3MoIHZlY3RvckFuZ2xlIC8gMiApLFxyXG4gICAgICAgICAgLSggY3VydmVkQXJyb3dSYWRpdXMgKyBMQUJFTF9PRkZTRVQgKSAqIE1hdGguc2luKCB2ZWN0b3JBbmdsZSAvIDIgKSApO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2UgaWYgKCBhbmdsZURlZ3JlZXMgPj0gMCApIHtcclxuXHJcbiAgICAgICAgLy8gUG9zaXRpb24gdGhlIGxhYmVsIGhhbGZ3YXkgYWNyb3NzLCBidXQgb24gdGhlIG90aGVyIHNpZGUgb2YgdGhlIGJhc2VsaW5lXHJcbiAgICAgICAgdGhpcy5sYWJlbFRleHQuc2V0VHJhbnNsYXRpb24oIGN1cnZlZEFycm93UmFkaXVzIC8gMiwgY3VydmVkQXJyb3dSYWRpdXMgLyAyICk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSBpZiAoIGFuZ2xlRGVncmVlcyA+IC1BTkdMRV9VTkRFUl9CQVNFTElORV9USFJFU0hPTEQgKSB7XHJcblxyXG4gICAgICAgIC8vIFBvc2l0aW9uIHRoZSBsYWJlbCBoYWxmd2F5IGFjcm9zcywgYnV0IG9uIHRoZSBvdGhlciBzaWRlIG9mIHRoZSBiYXNlbGluZVxyXG4gICAgICAgIHRoaXMubGFiZWxUZXh0LnNldFRyYW5zbGF0aW9uKCBjdXJ2ZWRBcnJvd1JhZGl1cyAvIDIsXHJcbiAgICAgICAgICAtY3VydmVkQXJyb3dSYWRpdXMgLyAyICsgdGhpcy5sYWJlbFRleHQuaGVpZ2h0IC8gMiApO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG5cclxuICAgICAgICAvLyBQb3NpdGlvbiB0aGUgbGFiZWwgbmV4dCB0byB0aGUgYXJjLCBoYWxmd2F5IGFjcm9zcyB0aGUgYXJjXHJcbiAgICAgICAgdGhpcy5sYWJlbFRleHQuc2V0VHJhbnNsYXRpb24oICggY3VydmVkQXJyb3dSYWRpdXMgKyBMQUJFTF9PRkZTRVQgKSAqIE1hdGguY29zKCB2ZWN0b3JBbmdsZSAvIDIgKSxcclxuICAgICAgICAgIC0oIGN1cnZlZEFycm93UmFkaXVzICsgTEFCRUxfT0ZGU0VUICkgKiBNYXRoLnNpbiggdmVjdG9yQW5nbGUgLyAyICkgKyB0aGlzLmxhYmVsVGV4dC5oZWlnaHQgLyAyXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxudmVjdG9yQWRkaXRpb24ucmVnaXN0ZXIoICdWZWN0b3JBbmdsZU5vZGUnLCBWZWN0b3JBbmdsZU5vZGUgKTsiXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPQSxTQUFTLE1BQU0sa0NBQWtDO0FBQ3hELE9BQU9DLEtBQUssTUFBTSw2QkFBNkI7QUFFL0MsT0FBT0MsV0FBVyxNQUFNLDRDQUE0QztBQUNwRSxTQUFTQyxLQUFLLEVBQUVDLElBQUksRUFBRUMsSUFBSSxFQUFFQyxJQUFJLFFBQVEsbUNBQW1DO0FBQzNFLE9BQU9DLGNBQWMsTUFBTSx5QkFBeUI7QUFFcEQsT0FBT0MsdUJBQXVCLE1BQU0sK0JBQStCO0FBQ25FLE9BQU9DLGVBQWUsTUFBTSxzQkFBc0I7QUFHbEQ7O0FBRUE7QUFDQSxNQUFNQyx1QkFBdUIsR0FBRyxFQUFFOztBQUVsQztBQUNBO0FBQ0EsTUFBTUMsZ0JBQWdCLEdBQUcsSUFBSTs7QUFFN0I7QUFDQSxNQUFNQyxrQkFBa0IsR0FBRyxFQUFFOztBQUU3QjtBQUNBLE1BQU1DLGtCQUFrQixHQUFHLElBQUk7O0FBRS9CO0FBQ0EsTUFBTUMsWUFBWSxHQUFHLEdBQUc7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBLE1BQU1DLDhCQUE4QixHQUFHLEVBQUU7QUFFekMsZUFBZSxNQUFNQyxlQUFlLFNBQVNYLElBQUksQ0FBQztFQUVoRDs7RUFHQTs7RUFPT1ksV0FBV0EsQ0FBRUMsTUFBYyxFQUFFQyxxQkFBaUQs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QUFNLENBQUVELFdBQVcsS0FBSyxJQUFLLENBQUM7O0lBRXhDO0lBQ0EsSUFBSSxDQUFDckMsUUFBUSxDQUFDdUMsS0FBSyxDQUFFTixDQUFDLENBQUNDLEdBQUcsQ0FBRSxDQUFFQyxpQkFBaUIsR0FBRzNDLGtCQUFrQixFQUFFRCxrQkFBa0IsQ0FBRyxDQUFHLENBQUM7O0lBRS9GO0lBQ0EsSUFBS2lDLFlBQVksS0FBSyxJQUFJLEVBQUc7TUFFM0IsSUFBS0EsWUFBWSxHQUFHOUIsOEJBQThCLEVBQUc7UUFFbkQ7UUFDQSxJQUFJLENBQUNXLFNBQVMsQ0FBQ21DLGNBQWMsQ0FBRSxDQUFFTCxpQkFBaUIsR0FBRzFDLFlBQVksSUFBS2dELElBQUksQ0FBQ0MsR0FBRyxDQUFFTCxXQUFXLEdBQUcsQ0FBRSxDQUFDLEVBQy9GLEVBQUdGLGlCQUFpQixHQUFHMUMsWUFBWSxDQUFFLEdBQUdnRCxJQUFJLENBQUNFLEdBQUcsQ0FBRU4sV0FBVyxHQUFHLENBQUUsQ0FBRSxDQUFDO01BQ3pFLENBQUMsTUFDSSxJQUFLYixZQUFZLElBQUksQ0FBQyxFQUFHO1FBRTVCO1FBQ0EsSUFBSSxDQUFDbkIsU0FBUyxDQUFDbUMsY0FBYyxDQUFFTCxpQkFBaUIsR0FBRyxDQUFDLEVBQUVBLGlCQUFpQixHQUFHLENBQUUsQ0FBQztNQUMvRSxDQUFDLE1BQ0ksSUFBS1gsWUFBWSxHQUFHLENBQUM5Qiw4QkFBOEIsRUFBRztRQUV6RDtRQUNBLElBQUksQ0FBQ1csU0FBUyxDQUFDbUMsY0FBYyxDQUFFTCxpQkFBaUIsR0FBRyxDQUFDLEVBQ2xELENBQUNBLGlCQUFpQixHQUFHLENBQUMsR0FBRyxJQUFJLENBQUM5QixTQUFTLENBQUN1QyxNQUFNLEdBQUcsQ0FBRSxDQUFDO01BQ3hELENBQUMsTUFDSTtRQUVIO1FBQ0EsSUFBSSxDQUFDdkMsU0FBUyxDQUFDbUMsY0FBYyxDQUFFLENBQUVMLGlCQUFpQixHQUFHMUMsWUFBWSxJQUFLZ0QsSUFBSSxDQUFDQyxHQUFHLENBQUVMLFdBQVcsR0FBRyxDQUFFLENBQUMsRUFDL0YsRUFBR0YsaUJBQWlCLEdBQUcxQyxZQUFZLENBQUUsR0FBR2dELElBQUksQ0FBQ0UsR0FBRyxDQUFFTixXQUFXLEdBQUcsQ0FBRSxDQUFDLEdBQUcsSUFBSSxDQUFDaEMsU0FBUyxDQUFDdUMsTUFBTSxHQUFHLENBQ2hHLENBQUM7TUFDSDtJQUNGO0VBQ0Y7QUFDRjtBQUVBMUQsY0FBYyxDQUFDMkQsUUFBUSxDQUFFLGlCQUFpQixFQUFFbEQsZUFBZ0IsQ0FBQyIsImlnbm9yZUxpc3QiOltdfQ==