// Copyright 2019-2023, University of Colorado Boulder

/**
 * Base class for vector views for all types of vectors (sum, component, etc.).
 * Primarily responsibilities are:
 *  - Create an ArrowNode or DashedArrowNode that displays a vector's tail/tip position
 *  - Create other Nodes that ALL vectors in the sim have (i.e. labels etc.)
 *
 * For an overview of the class hierarchy,
 * see https://github.com/phetsims/vector-addition/blob/main/doc/implementation-notes.md
 *
 * @author Brandon Li
 */

import Multilink from '../../../../axon/js/Multilink.js';
import Vector2 from '../../../../dot/js/Vector2.js';
import ArrowNode from '../../../../scenery-phet/js/ArrowNode.js';
import { Node } from '../../../../scenery/js/imports.js';
import vectorAddition from '../../vectorAddition.js';
import VectorAdditionConstants from '../VectorAdditionConstants.js';
import DashedArrowNode from './DashedArrowNode.js';
import VectorLabelNode from './VectorLabelNode.js';
import optionize from '../../../../phet-core/js/optionize.js';

// constants

// Used to prevent vector label from going off-screen. This is the magnitude of a vector that fills the
// graph along a diagonal, minus the margin that constrains dragging of the vector's tail.
// See https://github.com/phetsims/vector-addition/issues/212#issuecomment-537628386 for a screenshot.
const MAX_LABEL_VECTOR_MAGNITUDE = new Vector2(VectorAdditionConstants.DEFAULT_GRAPH_BOUNDS.width - VectorAdditionConstants.VECTOR_TAIL_DRAG_MARGIN, VectorAdditionConstants.DEFAULT_GRAPH_BOUNDS.height - VectorAdditionConstants.VECTOR_TAIL_DRAG_MARGIN).magnitude;

// options passed to ArrowNode or DashedArrowNode

export default class RootVectorNode extends Node {
  constructor(rootVector, modelViewTransformProperty, valuesVisibleProperty, activeVectorProperty, providedOptions) {
    const options = optionize()({
      // SelfOptions
      arrowType: 'solid',
      arrowOptions: {
        cursor: 'move'
      }
    }, providedOptions);

    //----------------------------------------------------------------------------------------

    super(options);

    // Define a vector node in which the tail position (view coordinates) is (0, 0). Get the tip position in view coordinates.
    const tipDeltaPosition = modelViewTransformProperty.value.modelToViewDelta(rootVector.vectorComponents);
    if (options.arrowType === 'solid') {
      this.arrowNode = new ArrowNode(0, 0, tipDeltaPosition.x, tipDeltaPosition.y, options.arrowOptions);
    } else {
      this.arrowNode = new DashedArrowNode(0, 0, tipDeltaPosition.x, tipDeltaPosition.y, options.arrowOptions);
    }

    // Create a label for the vector that is displayed 'next' to the arrow.
    // The position of this depends on the angle of the vector. Since the positioning of 'next' is different for every
    // vector, use an overridable method to position it. ( updateLabelPositioning() )
    // dispose is required because this observes the Properties that are passed to it.
    this.labelNode = new VectorLabelNode(rootVector, valuesVisibleProperty, activeVectorProperty);

    // Add children to this node
    this.setChildren([this.arrowNode, this.labelNode]);

    //----------------------------------------------------------------------------------------
    // Update the tail/tip position when the vector's tail/tip position changes

    // Observe changes to the tail/tip and mirror the positioning. If the values visibility changes, update the
    // view as well.  unmultilink is required on dispose.
    const updateMultilink = Multilink.multilink([valuesVisibleProperty, rootVector.tailPositionProperty, rootVector.tipPositionProperty, activeVectorProperty], valuesVisible => {
      // Update the appearance of the vector
      this.updateVector(rootVector, modelViewTransformProperty.value);

      // Update the appearance of the label
      this.updateLabelPositioning(rootVector, modelViewTransformProperty.value, valuesVisible);
    });
    this.disposeRootVectorNode = () => {
      this.labelNode.dispose();
      Multilink.unmultilink(updateMultilink);
    };
  }
  dispose() {
    this.disposeRootVectorNode();
    super.dispose();
  }

  /**
   * Updates the tail and tip position of the view. Called when the model changes tail/tip.
   */
  updateVector(rootVector, modelViewTransform) {
    // Since the tail is defined at (0, 0) for the vector, the vector must be translated.
    this.translation = modelViewTransform.modelToViewPosition(rootVector.tail);

    // Get the tip position in view coordinates
    const tipDeltaPosition = modelViewTransform.modelToViewDelta(rootVector.vectorComponents);
    this.arrowNode.setTip(tipDeltaPosition.x, tipDeltaPosition.y);

    // Make the arrow easier to grab by setting pointer areas
    if (rootVector.magnitude > VectorAdditionConstants.ZERO_THRESHOLD && this.arrowNode instanceof ArrowNode) {
      const arrowShape = this.arrowNode.shape;
      assert && assert(arrowShape !== null);
      this.arrowNode.mouseArea = arrowShape.getOffsetShape(VectorAdditionConstants.VECTOR_MOUSE_AREA_DILATION);
      this.arrowNode.touchArea = arrowShape.getOffsetShape(VectorAdditionConstants.VECTOR_TOUCH_AREA_DILATION);
    }

    // See https://github.com/phetsims/vector-addition/issues/252
    this.arrowNode.visible = rootVector.magnitude > VectorAdditionConstants.ZERO_THRESHOLD;
  }

  /**
   * Updates the label positioning, called when the vector is changing or the value checkbox is clicked.
   * This can be overridden if the positioning isn't appropriate (e.g. component nodes have different positioning)
   */
  updateLabelPositioning(rootVector, modelViewTransform, valuesVisible) {
    // Reset the rotation
    this.labelNode.setRotation(0);

    // If the magnitude is effectively 0, center the label on the vector's position.
    // See https://github.com/phetsims/vector-addition/issues/260
    if (rootVector.magnitude < VectorAdditionConstants.ZERO_THRESHOLD) {
      this.labelNode.center = modelViewTransform.modelToViewDelta(Vector2.ZERO);
      return;
    }

    // Angle of the vector in radians (ranging from -Pi to Pi)
    const modelAngle = rootVector.angle;
    assert && assert(modelAngle !== null);

    //----------------------------------------------------------------------------------------
    // Determine how the labels should be positioned.

    // Add a flip if x is negative
    const xFlip = rootVector.xComponent < 0 ? Math.PI : 0;

    // Add a flip if y is negative
    const yFlip = rootVector.yComponent < 0 ? Math.PI : 0;

    //----------------------------------------------------------------------------------------
    // Add extra offset to consider the size of the label. The offset is the margin between the arrow and the label

    const labelSize = rootVector.yComponent >= 0 ? modelViewTransform.viewToModelDeltaX(this.labelNode.height / 2) : -modelViewTransform.viewToModelDeltaY(this.labelNode.height / 2);

    //----------------------------------------------------------------------------------------
    if (valuesVisible) {
      // Since the y-axis is inverted, the angle is the view is opposite to the model
      const viewAngle = -modelAngle;

      // Rotate label along the angle if x is positive, but flipped if x is negative
      this.labelNode.setRotation(viewAngle + xFlip);
    }

    // Create an offset that is perpendicular to the vector
    const offset = Vector2.createPolar(VectorAdditionConstants.VECTOR_LABEL_OFFSET + labelSize, modelAngle + Math.PI / 2 + yFlip);

    // Position the label
    this.labelNode.center = RootVectorNode.computeLabelCenter(rootVector, modelViewTransform, offset);
  }

  /**
   * Computes the center position for the label.
   * See https://github.com/phetsims/vector-addition/issues/212
   *
   * @param vector
   * @param modelViewTransform
   * @param offset - perpendicular offset
   */
  static computeLabelCenter(vector, modelViewTransform, offset) {
    // Create a vector parallel to rootVector that determines where the label will be placed.
    let labelVector = null;
    if (vector.vectorComponents.magnitude < MAX_LABEL_VECTOR_MAGNITUDE) {
      labelVector = vector.vectorComponents;
    } else {
      labelVector = vector.vectorComponents.normalized().timesScalar(MAX_LABEL_VECTOR_MAGNITUDE);
    }
    return modelViewTransform.modelToViewDelta(labelVector.timesScalar(0.5).plus(offset));
  }
}
vectorAddition.register('RootVectorNode', RootVectorNode);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJNdWx0aWxpbmsiLCJWZWN0b3IyIiwiQXJyb3dOb2RlIiwiTm9kZSIsInZlY3RvckFkZGl0aW9uIiwiVmVjdG9yQWRkaXRpb25Db25zdGFudHMiLCJEYXNoZWRBcnJvd05vZGUiLCJWZWN0b3JMYWJlbE5vZGUiLCJvcHRpb25pemUiLCJNQVhfTEFCRUxfVkVDVE9SX01BR05JVFVERSIsIkRFRkFVTFRfR1JBUEhfQk9VTkRTIiwid2lkdGgiLCJWRUNUT1JfVEFJTF9EUkFHX01BUkdJTiIsImhlaWdodCIsIm1hZ25pdHVkZSIsIlJvb3RWZWN0b3JOb2RlIiwiY29uc3RydWN0b3IiLCJyb290VmVjdG9yIiwibW9kZWxWaWV3VHJhbnNmb3JtUHJvcGVydHkiLCJ2YWx1ZXNWaXNpYmxlUHJvcGVydHkiLCJhY3RpdmVWZWN0b3JQcm9wZXJ0eSIsInByb3ZpZGVkT3B0aW9ucyIsIm9wdGlvbnMiLCJhcnJvd1R5cGUiLCJhcnJvd09wdGlvbnMiLCJjdXJzb3IiLCJ0aXBEZWx0YVBvc2l0aW9uIiwidmFsdWUiLCJtb2RlbFRvVmlld0RlbHRhIiwidmVjdG9yQ29tcG9uZW50cyIsImFycm93Tm9kZSIsIngiLCJ5IiwibGFiZWxOb2RlIiwic2V0Q2hpbGRyZW4iLCJ1cGRhdGVNdWx0aWxpbmsiLCJtdWx0aWxpbmsiLCJ0YWlsUG9zaXRpb25Qcm9wZXJ0eSIsInRpcFBvc2l0aW9uUHJvcGVydHkiLCJ2YWx1ZXNWaXNpYmxlIiwidXBkYXRlVmVjdG9yIiwidXBkYXRlTGFiZWxQb3NpdGlvbmluZyIsImRpc3Bvc2VSb290VmVjdG9yTm9kZSIsImRpc3Bvc2UiLCJ1bm11bHRpbGluayIsIm1vZGVsVmlld1RyYW5zZm9ybSIsInRyYW5zbGF0aW9uIiwibW9kZWxUb1ZpZXdQb3NpdGlvbiIsInRhaWwiLCJzZXRUaXAiLCJaRVJPX1RIUkVTSE9MRCIsImFycm93U2hhcGUiLCJzaGFwZSIsImFzc2VydCIsIm1vdXNlQXJlYSIsImdldE9mZnNldFNoYXBlIiwiVkVDVE9SX01PVVNFX0FSRUFfRElMQVRJT04iLCJ0b3VjaEFyZWEiLCJWRUNUT1JfVE9VQ0hfQVJFQV9ESUxBVElPTiIsInZpc2libGUiLCJzZXRSb3RhdGlvbiIsImNlbnRlciIsIlpFUk8iLCJtb2RlbEFuZ2xlIiwiYW5nbGUiLCJ4RmxpcCIsInhDb21wb25lbnQiLCJNYXRoIiwiUEkiLCJ5RmxpcCIsInlDb21wb25lbnQiLCJsYWJlbFNpemUiLCJ2aWV3VG9Nb2RlbERlbHRhWCIsInZpZXdUb01vZGVsRGVsdGFZIiwidmlld0FuZ2xlIiwib2Zmc2V0IiwiY3JlYXRlUG9sYXIiLCJWRUNUT1JfTEFCRUxfT0ZGU0VUIiwiY29tcHV0ZUxhYmVsQ2VudGVyIiwidmVjdG9yIiwibGFiZWxWZWN0b3IiLCJub3JtYWxpemVkIiwidGltZXNTY2FsYXIiLCJwbHVzIiwicmVnaXN0ZXIiXSwic291cmNlcyI6WyJSb290VmVjdG9yTm9kZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAxOS0yMDIzLCBVbml2ZXJzaXR5IG9mIENvbG9yYWRvIEJvdWxkZXJcclxuXHJcbi8qKlxyXG4gKiBCYXNlIGNsYXNzIGZvciB2ZWN0b3Igdmlld3MgZm9yIGFsbCB0eXBlcyBvZiB2ZWN0b3JzIChzdW0sIGNvbXBvbmVudCwgZXRjLikuXHJcbiAqIFByaW1hcmlseSByZXNwb25zaWJpbGl0aWVzIGFyZTpcclxuICogIC0gQ3JlYXRlIGFuIEFycm93Tm9kZSBvciBEYXNoZWRBcnJvd05vZGUgdGhhdCBkaXNwbGF5cyBhIHZlY3RvcidzIHRhaWwvdGlwIHBvc2l0aW9uXHJcbiAqICAtIENyZWF0ZSBvdGhlciBOb2RlcyB0aGF0IEFMTCB2ZWN0b3JzIGluIHRoZSBzaW0gaGF2ZSAoaS5lLiBsYWJlbHMgZXRjLilcclxuICpcclxuICogRm9yIGFuIG92ZXJ2aWV3IG9mIHRoZSBjbGFzcyBoaWVyYXJjaHksXHJcbiAqIHNlZSBodHRwczovL2dpdGh1Yi5jb20vcGhldHNpbXMvdmVjdG9yLWFkZGl0aW9uL2Jsb2IvbWFpbi9kb2MvaW1wbGVtZW50YXRpb24tbm90ZXMubWRcclxuICpcclxuICogQGF1dGhvciBCcmFuZG9uIExpXHJcbiAqL1xyXG5cclxuaW1wb3J0IE11bHRpbGluayBmcm9tICcuLi8uLi8uLi8uLi9heG9uL2pzL011bHRpbGluay5qcyc7XHJcbmltcG9ydCBWZWN0b3IyIGZyb20gJy4uLy4uLy4uLy4uL2RvdC9qcy9WZWN0b3IyLmpzJztcclxuaW1wb3J0IE1vZGVsVmlld1RyYW5zZm9ybTIgZnJvbSAnLi4vLi4vLi4vLi4vcGhldGNvbW1vbi9qcy92aWV3L01vZGVsVmlld1RyYW5zZm9ybTIuanMnO1xyXG5pbXBvcnQgQXJyb3dOb2RlLCB7IEFycm93Tm9kZU9wdGlvbnMgfSBmcm9tICcuLi8uLi8uLi8uLi9zY2VuZXJ5LXBoZXQvanMvQXJyb3dOb2RlLmpzJztcclxuaW1wb3J0IHsgTm9kZSwgTm9kZU9wdGlvbnMgfSBmcm9tICcuLi8uLi8uLi8uLi9zY2VuZXJ5L2pzL2ltcG9ydHMuanMnO1xyXG5pbXBvcnQgdmVjdG9yQWRkaXRpb24gZnJvbSAnLi4vLi4vdmVjdG9yQWRkaXRpb24uanMnO1xyXG5pbXBvcnQgUm9vdFZlY3RvciBmcm9tICcuLi9tb2RlbC9Sb290VmVjdG9yLmpzJztcclxuaW1wb3J0IFZlY3RvckFkZGl0aW9uQ29uc3RhbnRzIGZyb20gJy4uL1ZlY3RvckFkZGl0aW9uQ29uc3RhbnRzLmpzJztcclxuaW1wb3J0IERhc2hlZEFycm93Tm9kZSwgeyBEYXNoZWRBcnJvd05vZGVPcHRpb25zIH0gZnJvbSAnLi9EYXNoZWRBcnJvd05vZGUuanMnO1xyXG5pbXBvcnQgVmVjdG9yTGFiZWxOb2RlIGZyb20gJy4vVmVjdG9yTGFiZWxOb2RlLmpzJztcclxuaW1wb3J0IFRSZWFkT25seVByb3BlcnR5IGZyb20gJy4uLy4uLy4uLy4uL2F4b24vanMvVFJlYWRPbmx5UHJvcGVydHkuanMnO1xyXG5pbXBvcnQgb3B0aW9uaXplIGZyb20gJy4uLy4uLy4uLy4uL3BoZXQtY29yZS9qcy9vcHRpb25pemUuanMnO1xyXG5cclxuLy8gY29uc3RhbnRzXHJcblxyXG4vLyBVc2VkIHRvIHByZXZlbnQgdmVjdG9yIGxhYmVsIGZyb20gZ29pbmcgb2ZmLXNjcmVlbi4gVGhpcyBpcyB0aGUgbWFnbml0dWRlIG9mIGEgdmVjdG9yIHRoYXQgZmlsbHMgdGhlXHJcbi8vIGdyYXBoIGFsb25nIGEgZGlhZ29uYWwsIG1pbnVzIHRoZSBtYXJnaW4gdGhhdCBjb25zdHJhaW5zIGRyYWdnaW5nIG9mIHRoZSB2ZWN0b3IncyB0YWlsLlxyXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL3ZlY3Rvci1hZGRpdGlvbi9pc3N1ZXMvMjEyI2lzc3VlY29tbWVudC01Mzc2MjgzODYgZm9yIGEgc2NyZWVuc2hvdC5cclxuY29uc3QgTUFYX0xBQkVMX1ZFQ1RPUl9NQUdOSVRVREUgPSBuZXcgVmVjdG9yMihcclxuICBWZWN0b3JBZGRpdGlvbkNvbnN0YW50cy5ERUZBVUxUX0dSQVBIX0JPVU5EUy53aWR0aCAtIFZlY3RvckFkZGl0aW9uQ29uc3RhbnRzLlZFQ1RPUl9UQUlMX0RSQUdfTUFSR0lOLFxyXG4gIFZlY3RvckFkZGl0aW9uQ29uc3RhbnRzLkRFRkFVTFRfR1JBUEhfQk9VTkRTLmhlaWdodCAtIFZlY3RvckFkZGl0aW9uQ29uc3RhbnRzLlZFQ1RPUl9UQUlMX0RSQUdfTUFSR0lOXHJcbikubWFnbml0dWRlO1xyXG5cclxudHlwZSBBcnJvd1R5cGUgPSAnc29saWQnIHwgJ2Rhc2hlZCc7XHJcblxyXG4vLyBvcHRpb25zIHBhc3NlZCB0byBBcnJvd05vZGUgb3IgRGFzaGVkQXJyb3dOb2RlXHJcbmV4cG9ydCB0eXBlIFJvb3RWZWN0b3JBcnJvd05vZGVPcHRpb25zID0gQXJyb3dOb2RlT3B0aW9ucyB8IERhc2hlZEFycm93Tm9kZU9wdGlvbnM7XHJcblxyXG50eXBlIFNlbGZPcHRpb25zID0ge1xyXG4gIGFycm93VHlwZT86IEFycm93VHlwZTtcclxuICBhcnJvd09wdGlvbnM/OiBSb290VmVjdG9yQXJyb3dOb2RlT3B0aW9ucztcclxufTtcclxuXHJcbmV4cG9ydCB0eXBlIFJvb3RWZWN0b3JOb2RlT3B0aW9ucyA9IFNlbGZPcHRpb25zO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUm9vdFZlY3Rvck5vZGUgZXh0ZW5kcyBOb2RlIHtcclxuXHJcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IGFycm93Tm9kZTogQXJyb3dOb2RlIHwgRGFzaGVkQXJyb3dOb2RlO1xyXG4gIHByb3RlY3RlZCByZWFkb25seSBsYWJlbE5vZGU6IFZlY3RvckxhYmVsTm9kZTtcclxuICBwcml2YXRlIHJlYWRvbmx5IGRpc3Bvc2VSb290VmVjdG9yTm9kZTogKCkgPT4gdm9pZDtcclxuXHJcbiAgcHJvdGVjdGVkIGNvbnN0cnVjdG9yKCByb290VmVjdG9yOiBSb290VmVjdG9yLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWxWaWV3VHJhbnNmb3JtUHJvcGVydHk6IFRSZWFkT25seVByb3BlcnR5PE1vZGVsVmlld1RyYW5zZm9ybTI+LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzVmlzaWJsZVByb3BlcnR5OiBUUmVhZE9ubHlQcm9wZXJ0eTxib29sZWFuPixcclxuICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZVZlY3RvclByb3BlcnR5OiBUUmVhZE9ubHlQcm9wZXJ0eTxSb290VmVjdG9yIHwgbnVsbD4sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlZE9wdGlvbnM/OiBSb290VmVjdG9yTm9kZU9wdGlvbnMgKSB7XHJcblxyXG4gICAgY29uc3Qgb3B0aW9ucyA9IG9wdGlvbml6ZTxSb290VmVjdG9yTm9kZU9wdGlvbnMsIFNlbGZPcHRpb25zLCBOb2RlT3B0aW9ucz4oKSgge1xyXG5cclxuICAgICAgLy8gU2VsZk9wdGlvbnNcclxuICAgICAgYXJyb3dUeXBlOiAnc29saWQnLFxyXG4gICAgICBhcnJvd09wdGlvbnM6IHtcclxuICAgICAgICBjdXJzb3I6ICdtb3ZlJ1xyXG4gICAgICB9XHJcbiAgICB9LCBwcm92aWRlZE9wdGlvbnMgKTtcclxuXHJcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgICBzdXBlciggb3B0aW9ucyApO1xyXG5cclxuICAgIC8vIERlZmluZSBhIHZlY3RvciBub2RlIGluIHdoaWNoIHRoZSB0YWlsIHBvc2l0aW9uICh2aWV3IGNvb3JkaW5hdGVzKSBpcyAoMCwgMCkuIEdldCB0aGUgdGlwIHBvc2l0aW9uIGluIHZpZXcgY29vcmRpbmF0ZXMuXHJcbiAgICBjb25zdCB0aXBEZWx0YVBvc2l0aW9uID0gbW9kZWxWaWV3VHJhbnNmb3JtUHJvcGVydHkudmFsdWUubW9kZWxUb1ZpZXdEZWx0YSggcm9vdFZlY3Rvci52ZWN0b3JDb21wb25lbnRzICk7XHJcblxyXG4gICAgaWYgKCBvcHRpb25zLmFycm93VHlwZSA9PT0gJ3NvbGlkJyApIHtcclxuICAgICAgdGhpcy5hcnJvd05vZGUgPSBuZXcgQXJyb3dOb2RlKCAwLCAwLCB0aXBEZWx0YVBvc2l0aW9uLngsIHRpcERlbHRhUG9zaXRpb24ueSwgb3B0aW9ucy5hcnJvd09wdGlvbnMgKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICB0aGlzLmFycm93Tm9kZSA9IG5ldyBEYXNoZWRBcnJvd05vZGUoIDAsIDAsIHRpcERlbHRhUG9zaXRpb24ueCwgdGlwRGVsdGFQb3NpdGlvbi55LCBvcHRpb25zLmFycm93T3B0aW9ucyApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENyZWF0ZSBhIGxhYmVsIGZvciB0aGUgdmVjdG9yIHRoYXQgaXMgZGlzcGxheWVkICduZXh0JyB0byB0aGUgYXJyb3cuXHJcbiAgICAvLyBUaGUgcG9zaXRpb24gb2YgdGhpcyBkZXBlbmRzIG9uIHRoZSBhbmdsZSBvZiB0aGUgdmVjdG9yLiBTaW5jZSB0aGUgcG9zaXRpb25pbmcgb2YgJ25leHQnIGlzIGRpZmZlcmVudCBmb3IgZXZlcnlcclxuICAgIC8vIHZlY3RvciwgdXNlIGFuIG92ZXJyaWRhYmxlIG1ldGhvZCB0byBwb3NpdGlvbiBpdC4gKCB1cGRhdGVMYWJlbFBvc2l0aW9uaW5nKCkgKVxyXG4gICAgLy8gZGlzcG9zZSBpcyByZXF1aXJlZCBiZWNhdXNlIHRoaXMgb2JzZXJ2ZXMgdGhlIFByb3BlcnRpZXMgdGhhdCBhcmUgcGFzc2VkIHRvIGl0LlxyXG4gICAgdGhpcy5sYWJlbE5vZGUgPSBuZXcgVmVjdG9yTGFiZWxOb2RlKCByb290VmVjdG9yLCB2YWx1ZXNWaXNpYmxlUHJvcGVydHksIGFjdGl2ZVZlY3RvclByb3BlcnR5ICk7XHJcblxyXG4gICAgLy8gQWRkIGNoaWxkcmVuIHRvIHRoaXMgbm9kZVxyXG4gICAgdGhpcy5zZXRDaGlsZHJlbiggWyB0aGlzLmFycm93Tm9kZSwgdGhpcy5sYWJlbE5vZGUgXSApO1xyXG5cclxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gVXBkYXRlIHRoZSB0YWlsL3RpcCBwb3NpdGlvbiB3aGVuIHRoZSB2ZWN0b3IncyB0YWlsL3RpcCBwb3NpdGlvbiBjaGFuZ2VzXHJcblxyXG4gICAgLy8gT2JzZXJ2ZSBjaGFuZ2VzIHRvIHRoZSB0YWlsL3RpcCBhbmQgbWlycm9yIHRoZSBwb3NpdGlvbmluZy4gSWYgdGhlIHZhbHVlcyB2aXNpYmlsaXR5IGNoYW5nZXMsIHVwZGF0ZSB0aGVcclxuICAgIC8vIHZpZXcgYXMgd2VsbC4gIHVubXVsdGlsaW5rIGlzIHJlcXVpcmVkIG9uIGRpc3Bvc2UuXHJcbiAgICBjb25zdCB1cGRhdGVNdWx0aWxpbmsgPSBNdWx0aWxpbmsubXVsdGlsaW5rKFxyXG4gICAgICBbIHZhbHVlc1Zpc2libGVQcm9wZXJ0eSwgcm9vdFZlY3Rvci50YWlsUG9zaXRpb25Qcm9wZXJ0eSwgcm9vdFZlY3Rvci50aXBQb3NpdGlvblByb3BlcnR5LCBhY3RpdmVWZWN0b3JQcm9wZXJ0eSBdLFxyXG4gICAgICB2YWx1ZXNWaXNpYmxlID0+IHtcclxuXHJcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBhcHBlYXJhbmNlIG9mIHRoZSB2ZWN0b3JcclxuICAgICAgICB0aGlzLnVwZGF0ZVZlY3Rvciggcm9vdFZlY3RvciwgbW9kZWxWaWV3VHJhbnNmb3JtUHJvcGVydHkudmFsdWUgKTtcclxuXHJcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBhcHBlYXJhbmNlIG9mIHRoZSBsYWJlbFxyXG4gICAgICAgIHRoaXMudXBkYXRlTGFiZWxQb3NpdGlvbmluZyggcm9vdFZlY3RvciwgbW9kZWxWaWV3VHJhbnNmb3JtUHJvcGVydHkudmFsdWUsIHZhbHVlc1Zpc2libGUgKTtcclxuICAgICAgfSApO1xyXG5cclxuICAgIHRoaXMuZGlzcG9zZVJvb3RWZWN0b3JOb2RlID0gKCkgPT4ge1xyXG4gICAgICB0aGlzLmxhYmVsTm9kZS5kaXNwb3NlKCk7XHJcbiAgICAgIE11bHRpbGluay51bm11bHRpbGluayggdXBkYXRlTXVsdGlsaW5rICk7XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgcHVibGljIG92ZXJyaWRlIGRpc3Bvc2UoKTogdm9pZCB7XHJcbiAgICB0aGlzLmRpc3Bvc2VSb290VmVjdG9yTm9kZSgpO1xyXG4gICAgc3VwZXIuZGlzcG9zZSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlcyB0aGUgdGFpbCBhbmQgdGlwIHBvc2l0aW9uIG9mIHRoZSB2aWV3LiBDYWxsZWQgd2hlbiB0aGUgbW9kZWwgY2hhbmdlcyB0YWlsL3RpcC5cclxuICAgKi9cclxuICBwcm90ZWN0ZWQgdXBkYXRlVmVjdG9yKCByb290VmVjdG9yOiBSb290VmVjdG9yLCBtb2RlbFZpZXdUcmFuc2Zvcm06IE1vZGVsVmlld1RyYW5zZm9ybTIgKTogdm9pZCB7XHJcblxyXG4gICAgLy8gU2luY2UgdGhlIHRhaWwgaXMgZGVmaW5lZCBhdCAoMCwgMCkgZm9yIHRoZSB2ZWN0b3IsIHRoZSB2ZWN0b3IgbXVzdCBiZSB0cmFuc2xhdGVkLlxyXG4gICAgdGhpcy50cmFuc2xhdGlvbiA9IG1vZGVsVmlld1RyYW5zZm9ybS5tb2RlbFRvVmlld1Bvc2l0aW9uKCByb290VmVjdG9yLnRhaWwgKTtcclxuXHJcbiAgICAvLyBHZXQgdGhlIHRpcCBwb3NpdGlvbiBpbiB2aWV3IGNvb3JkaW5hdGVzXHJcbiAgICBjb25zdCB0aXBEZWx0YVBvc2l0aW9uID0gbW9kZWxWaWV3VHJhbnNmb3JtLm1vZGVsVG9WaWV3RGVsdGEoIHJvb3RWZWN0b3IudmVjdG9yQ29tcG9uZW50cyApO1xyXG4gICAgdGhpcy5hcnJvd05vZGUuc2V0VGlwKCB0aXBEZWx0YVBvc2l0aW9uLngsIHRpcERlbHRhUG9zaXRpb24ueSApO1xyXG5cclxuICAgIC8vIE1ha2UgdGhlIGFycm93IGVhc2llciB0byBncmFiIGJ5IHNldHRpbmcgcG9pbnRlciBhcmVhc1xyXG4gICAgaWYgKCByb290VmVjdG9yLm1hZ25pdHVkZSA+IFZlY3RvckFkZGl0aW9uQ29uc3RhbnRzLlpFUk9fVEhSRVNIT0xEICYmIHRoaXMuYXJyb3dOb2RlIGluc3RhbmNlb2YgQXJyb3dOb2RlICkge1xyXG4gICAgICBjb25zdCBhcnJvd1NoYXBlID0gdGhpcy5hcnJvd05vZGUuc2hhcGUhO1xyXG4gICAgICBhc3NlcnQgJiYgYXNzZXJ0KCBhcnJvd1NoYXBlICE9PSBudWxsICk7XHJcbiAgICAgIHRoaXMuYXJyb3dOb2RlLm1vdXNlQXJlYSA9IGFycm93U2hhcGUuZ2V0T2Zmc2V0U2hhcGUoIFZlY3RvckFkZGl0aW9uQ29uc3RhbnRzLlZFQ1RPUl9NT1VTRV9BUkVBX0RJTEFUSU9OICk7XHJcbiAgICAgIHRoaXMuYXJyb3dOb2RlLnRvdWNoQXJlYSA9IGFycm93U2hhcGUuZ2V0T2Zmc2V0U2hhcGUoIFZlY3RvckFkZGl0aW9uQ29uc3RhbnRzLlZFQ1RPUl9UT1VDSF9BUkVBX0RJTEFUSU9OICk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waGV0c2ltcy92ZWN0b3ItYWRkaXRpb24vaXNzdWVzLzI1MlxyXG4gICAgdGhpcy5hcnJvd05vZGUudmlzaWJsZSA9ICggcm9vdFZlY3Rvci5tYWduaXR1ZGUgPiBWZWN0b3JBZGRpdGlvbkNvbnN0YW50cy5aRVJPX1RIUkVTSE9MRCApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlcyB0aGUgbGFiZWwgcG9zaXRpb25pbmcsIGNhbGxlZCB3aGVuIHRoZSB2ZWN0b3IgaXMgY2hhbmdpbmcgb3IgdGhlIHZhbHVlIGNoZWNrYm94IGlzIGNsaWNrZWQuXHJcbiAgICogVGhpcyBjYW4gYmUgb3ZlcnJpZGRlbiBpZiB0aGUgcG9zaXRpb25pbmcgaXNuJ3QgYXBwcm9wcmlhdGUgKGUuZy4gY29tcG9uZW50IG5vZGVzIGhhdmUgZGlmZmVyZW50IHBvc2l0aW9uaW5nKVxyXG4gICAqL1xyXG4gIHByb3RlY3RlZCB1cGRhdGVMYWJlbFBvc2l0aW9uaW5nKCByb290VmVjdG9yOiBSb290VmVjdG9yLCBtb2RlbFZpZXdUcmFuc2Zvcm06IE1vZGVsVmlld1RyYW5zZm9ybTIsIHZhbHVlc1Zpc2libGU6IGJvb2xlYW4gKTogdm9pZCB7XHJcblxyXG4gICAgLy8gUmVzZXQgdGhlIHJvdGF0aW9uXHJcbiAgICB0aGlzLmxhYmVsTm9kZS5zZXRSb3RhdGlvbiggMCApO1xyXG5cclxuICAgIC8vIElmIHRoZSBtYWduaXR1ZGUgaXMgZWZmZWN0aXZlbHkgMCwgY2VudGVyIHRoZSBsYWJlbCBvbiB0aGUgdmVjdG9yJ3MgcG9zaXRpb24uXHJcbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL3ZlY3Rvci1hZGRpdGlvbi9pc3N1ZXMvMjYwXHJcbiAgICBpZiAoIHJvb3RWZWN0b3IubWFnbml0dWRlIDwgVmVjdG9yQWRkaXRpb25Db25zdGFudHMuWkVST19USFJFU0hPTEQgKSB7XHJcbiAgICAgIHRoaXMubGFiZWxOb2RlLmNlbnRlciA9IG1vZGVsVmlld1RyYW5zZm9ybS5tb2RlbFRvVmlld0RlbHRhKCBWZWN0b3IyLlpFUk8gKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEFuZ2xlIG9mIHRoZSB2ZWN0b3IgaW4gcmFkaWFucyAocmFuZ2luZyBmcm9tIC1QaSB0byBQaSlcclxuICAgIGNvbnN0IG1vZGVsQW5nbGUgPSByb290VmVjdG9yLmFuZ2xlITtcclxuICAgIGFzc2VydCAmJiBhc3NlcnQoIG1vZGVsQW5nbGUgIT09IG51bGwgKTtcclxuXHJcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vIERldGVybWluZSBob3cgdGhlIGxhYmVscyBzaG91bGQgYmUgcG9zaXRpb25lZC5cclxuXHJcbiAgICAvLyBBZGQgYSBmbGlwIGlmIHggaXMgbmVnYXRpdmVcclxuICAgIGNvbnN0IHhGbGlwID0gKCByb290VmVjdG9yLnhDb21wb25lbnQgPCAwICkgPyBNYXRoLlBJIDogMDtcclxuXHJcbiAgICAvLyBBZGQgYSBmbGlwIGlmIHkgaXMgbmVnYXRpdmVcclxuICAgIGNvbnN0IHlGbGlwID0gKCByb290VmVjdG9yLnlDb21wb25lbnQgPCAwICkgPyBNYXRoLlBJIDogMDtcclxuXHJcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vIEFkZCBleHRyYSBvZmZzZXQgdG8gY29uc2lkZXIgdGhlIHNpemUgb2YgdGhlIGxhYmVsLiBUaGUgb2Zmc2V0IGlzIHRoZSBtYXJnaW4gYmV0d2VlbiB0aGUgYXJyb3cgYW5kIHRoZSBsYWJlbFxyXG5cclxuICAgIGNvbnN0IGxhYmVsU2l6ZSA9ICggcm9vdFZlY3Rvci55Q29tcG9uZW50ID49IDAgKSA/XHJcbiAgICAgICAgICAgICAgICAgICAgICBtb2RlbFZpZXdUcmFuc2Zvcm0udmlld1RvTW9kZWxEZWx0YVgoIHRoaXMubGFiZWxOb2RlLmhlaWdodCAvIDIgKSA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAtbW9kZWxWaWV3VHJhbnNmb3JtLnZpZXdUb01vZGVsRGVsdGFZKCB0aGlzLmxhYmVsTm9kZS5oZWlnaHQgLyAyICk7XHJcblxyXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBpZiAoIHZhbHVlc1Zpc2libGUgKSB7XHJcblxyXG4gICAgICAvLyBTaW5jZSB0aGUgeS1heGlzIGlzIGludmVydGVkLCB0aGUgYW5nbGUgaXMgdGhlIHZpZXcgaXMgb3Bwb3NpdGUgdG8gdGhlIG1vZGVsXHJcbiAgICAgIGNvbnN0IHZpZXdBbmdsZSA9IC1tb2RlbEFuZ2xlO1xyXG5cclxuICAgICAgLy8gUm90YXRlIGxhYmVsIGFsb25nIHRoZSBhbmdsZSBpZiB4IGlzIHBvc2l0aXZlLCBidXQgZmxpcHBlZCBpZiB4IGlzIG5lZ2F0aXZlXHJcbiAgICAgIHRoaXMubGFiZWxOb2RlLnNldFJvdGF0aW9uKCB2aWV3QW5nbGUgKyB4RmxpcCApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENyZWF0ZSBhbiBvZmZzZXQgdGhhdCBpcyBwZXJwZW5kaWN1bGFyIHRvIHRoZSB2ZWN0b3JcclxuICAgIGNvbnN0IG9mZnNldCA9IFZlY3RvcjIuY3JlYXRlUG9sYXIoIFZlY3RvckFkZGl0aW9uQ29uc3RhbnRzLlZFQ1RPUl9MQUJFTF9PRkZTRVQgKyBsYWJlbFNpemUsIG1vZGVsQW5nbGUgKyBNYXRoLlBJIC8gMiArIHlGbGlwICk7XHJcblxyXG4gICAgLy8gUG9zaXRpb24gdGhlIGxhYmVsXHJcbiAgICB0aGlzLmxhYmVsTm9kZS5jZW50ZXIgPSBSb290VmVjdG9yTm9kZS5jb21wdXRlTGFiZWxDZW50ZXIoIHJvb3RWZWN0b3IsIG1vZGVsVmlld1RyYW5zZm9ybSwgb2Zmc2V0ICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb21wdXRlcyB0aGUgY2VudGVyIHBvc2l0aW9uIGZvciB0aGUgbGFiZWwuXHJcbiAgICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waGV0c2ltcy92ZWN0b3ItYWRkaXRpb24vaXNzdWVzLzIxMlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHZlY3RvclxyXG4gICAqIEBwYXJhbSBtb2RlbFZpZXdUcmFuc2Zvcm1cclxuICAgKiBAcGFyYW0gb2Zmc2V0IC0gcGVycGVuZGljdWxhciBvZmZzZXRcclxuICAgKi9cclxuICBwdWJsaWMgc3RhdGljIGNvbXB1dGVMYWJlbENlbnRlciggdmVjdG9yOiBSb290VmVjdG9yLCBtb2RlbFZpZXdUcmFuc2Zvcm06IE1vZGVsVmlld1RyYW5zZm9ybTIsIG9mZnNldDogVmVjdG9yMiApOiBWZWN0b3IyIHtcclxuXHJcbiAgICAvLyBDcmVhdGUgYSB2ZWN0b3IgcGFyYWxsZWwgdG8gcm9vdFZlY3RvciB0aGF0IGRldGVybWluZXMgd2hlcmUgdGhlIGxhYmVsIHdpbGwgYmUgcGxhY2VkLlxyXG4gICAgbGV0IGxhYmVsVmVjdG9yID0gbnVsbDtcclxuICAgIGlmICggdmVjdG9yLnZlY3RvckNvbXBvbmVudHMubWFnbml0dWRlIDwgTUFYX0xBQkVMX1ZFQ1RPUl9NQUdOSVRVREUgKSB7XHJcbiAgICAgIGxhYmVsVmVjdG9yID0gdmVjdG9yLnZlY3RvckNvbXBvbmVudHM7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgbGFiZWxWZWN0b3IgPSB2ZWN0b3IudmVjdG9yQ29tcG9uZW50cy5ub3JtYWxpemVkKCkudGltZXNTY2FsYXIoIE1BWF9MQUJFTF9WRUNUT1JfTUFHTklUVURFICk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG1vZGVsVmlld1RyYW5zZm9ybS5tb2RlbFRvVmlld0RlbHRhKCBsYWJlbFZlY3Rvci50aW1lc1NjYWxhciggMC41ICkucGx1cyggb2Zmc2V0ICkgKTtcclxuICB9XHJcbn1cclxuXHJcbnZlY3RvckFkZGl0aW9uLnJlZ2lzdGVyKCAnUm9vdFZlY3Rvck5vZGUnLCBSb290VmVjdG9yTm9kZSApOyJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPQSxTQUFTLE1BQU0sa0NBQWtDO0FBQ3hELE9BQU9DLE9BQU8sTUFBTSwrQkFBK0I7QUFFbkQsT0FBT0MsU0FBUyxNQUE0QiwwQ0FBMEM7QUFDdEYsU0FBU0MsSUFBSSxRQUFxQixtQ0FBbUM7QUFDckUsT0FBT0MsY0FBYyxNQUFNLHlCQUF5QjtBQUVwRCxPQUFPQyx1QkFBdUIsTUFBTSwrQkFBK0I7QUFDbkUsT0FBT0MsZUFBZSxNQUFrQyxzQkFBc0I7QUFDOUUsT0FBT0MsZUFBZSxNQUFNLHNCQUFzQjtBQUVsRCxPQUFPQyxTQUFTLE1BQU0sdUNBQXVDOztBQUU3RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNQywwQkFBMEIsR0FBRyxJQUFJUixPQUFPLENBQzVDSSx1QkFBdUIsQ0FBQ0ssb0JBQW9CLENBQUNDLEtBQUssR0FBR04sdUJBQXVCLENBQUNPLHVCQUF1QixFQUNwR1AsdUJBQXVCLENBQUNLLG9CQUFvQixDQUFDRyxNQUFNLEdBQUdSLHVCQUF1QixDQUFDTyx1QkFDaEYsQ0FBQyxDQUFDRSxTQUFTOztBQUlYOztBQVVBLGVBQWUsTUFBTUMsY0FBYyxTQUFTWixJQUFJLENBQUM7RUFNckNhLFdBQVdBLENBQUVDLFVBQXNCLEVBQ3RCQywwQkFBa0UsRUFDbEVDLHFCQUFpRCxFQUNqREMsb0JBQTBELEVBQzFEQyxlQUF1QyxFQUFHO0lBRS9ELE1BQU1DLE9BQU8sR0FBR2QsU0FBUyxDQUFrRCxDQUFDLENBQUU7TUFFNUU7TUFDQWUsU0FBUyxFQUFFLE9BQU87TUFDbEJDLFlBQVksRUFBRTtRQUNaQyxNQUFNLEVB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QkFBa0IsQ0FBQzJCLGlCQUFpQixDQUFFLElBQUksQ0FBQ3ZDLFNBQVMsQ0FBQ3BCLE1BQU0sR0FBRyxDQUFFLENBQUMsR0FDakUsQ0FBQ2dDLGtCQUFrQixDQUFDNEIsaUJBQWlCLENBQUUsSUFBSSxDQUFDeEMsU0FBUyxDQUFDcEIsTUFBTSxHQUFHLENBQUUsQ0FBQzs7SUFFcEY7SUFDQSxJQUFLMEIsYUFBYSxFQUFHO01BRW5CO01BQ0EsTUFBTW1DLFNBQVMsR0FBRyxDQUFDWCxVQUFVOztNQUU3QjtNQUNBLElBQUksQ0FBQzlCLFNBQVMsQ0FBQzJCLFdBQVcsQ0FBRWMsU0FBUyxHQUFHVCxLQUFNLENBQUM7SUFDakQ7O0lBRUE7SUFDQSxNQUFNVSxNQUFNLEdBQUcxRSxPQUFPLENBQUMyRSxXQUFXLENBQUV2RSx1QkFBdUIsQ0FBQ3dFLG1CQUFtQixHQUFHTixTQUFTLEVBQUVSLFVBQVUsR0FBR0ksSUFBSSxDQUFDQyxFQUFFLEdBQUcsQ0FBQyxHQUFHQyxLQUFNLENBQUM7O0lBRS9IO0lBQ0EsSUFBSSxDQUFDcEMsU0FBUyxDQUFDNEIsTUFBTSxHQUFHOUMsY0FBYyxDQUFDK0Qsa0JBQWtCLENBQUU3RCxVQUFVLEVBQUU0QixrQkFBa0IsRUFBRThCLE1BQU8sQ0FBQztFQUNyRzs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0UsT0FBY0csa0JBQWtCQSxDQUFFQyxNQUFrQixFQUFFbEMsa0JBQXVDLEVBQUU4QixNQUFlLEVBQVk7SUFFeEg7SUFDQSxJQUFJSyxXQUFXLEdBQUcsSUFBSTtJQUN0QixJQUFLRCxNQUFNLENBQUNsRCxnQkFBZ0IsQ0FBQ2YsU0FBUyxHQUFHTCwwQkFBMEIsRUFBRztNQUNwRXVFLFdBQVcsR0FBR0QsTUFBTSxDQUFDbEQsZ0JBQWdCO0lBQ3ZDLENBQUMsTUFDSTtNQUNIbUQsV0FBVyxHQUFHRCxNQUFNLENBQUNsRCxnQkFBZ0IsQ0FBQ29ELFVBQVUsQ0FBQyxDQUFDLENBQUNDLFdBQVcsQ0FBRXpFLDBCQUEyQixDQUFDO0lBQzlGO0lBRUEsT0FBT29DLGtCQUFrQixDQUFDakIsZ0JBQWdCLENBQUVvRCxXQUFXLENBQUNFLFdBQVcsQ0FBRSxHQUFJLENBQUMsQ0FBQ0MsSUFBSSxDQUFFUixNQUFPLENBQUUsQ0FBQztFQUM3RjtBQUNGO0FBRUF2RSxjQUFjLENBQUNnRixRQUFRLENBQUUsZ0JBQWdCLEVBQUVyRSxjQUFlLENBQUMiLCJpZ25vcmVMaXN0IjpbXX0=