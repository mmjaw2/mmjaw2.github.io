// Copyright 2019-2023, University of Colorado Boulder

/**
 * DashedArrowNode draws an arrow with a solid head and dashed tail.
 *
 * This implementation is specific to vector-addition. It's a simplified version of SCENERY_PHET/LineArrowNode with
 * a solid tip. See https://github.com/phetsims/vector-addition/issues/177#issuecomment-531876724.
 *
 * An attempt was made to add a dashed-tail feature to SCENERY_PHET/ArrowNode, but the current implementation of
 * ArrowNode made that virtually impossible. See https://github.com/phetsims/scenery-phet/issues/533.
 *
 * @author Chris Malley (PixelZoom, Inc.)
 */

import Vector2 from '../../../../dot/js/Vector2.js';
import { Shape } from '../../../../kite/js/imports.js';
import { Node, Path } from '../../../../scenery/js/imports.js';
import vectorAddition from '../../vectorAddition.js';
import optionize from '../../../../phet-core/js/optionize.js';
export default class DashedArrowNode extends Node {
  constructor(tailX, tailY, tipX, tipY, providedOptions) {
    const options = optionize()({
      // SelfOptions
      tailDash: [3, 3],
      headHeight: 10,
      headWidth: 10,
      tailWidth: 5,
      fill: 'black',
      isHeadDynamic: false,
      fractionalHeadHeight: 0.5
    }, providedOptions);
    const headNode = new Path(null, {
      fill: options.fill
    });
    const tailNode = new Path(null, {
      stroke: options.fill,
      lineWidth: options.tailWidth,
      lineDash: options.tailDash
    });
    options.children = [tailNode, headNode];
    super(options);
    this._tailX = tailX;
    this._tailY = tailY;
    this._tipX = tipX;
    this._tipY = tipY;
    this.headHeight = options.headHeight;
    this.headWidth = options.headWidth;
    this.isHeadDynamic = options.isHeadDynamic;
    this.fractionalHeadHeight = options.fractionalHeadHeight;
    this.tailNode = tailNode;
    this.headNode = headNode;

    // initialize
    this.setTailAndTip(tailX, tailY, tipX, tipY);
  }
  get tailX() {
    return this._tailX;
  }
  get tailY() {
    return this._tailY;
  }
  get tipX() {
    return this._tipX;
  }
  get tipY() {
    return this._tipY;
  }

  /**
   * Sets the tail and tip positions.
   */
  setTailAndTip(tailX, tailY, tipX, tipY) {
    this._tailX = tailX;
    this._tailY = tailY;
    this._tipX = tipX;
    this._tipY = tipY;
    this.update();
  }

  /**
   * Sets the tip position.
   */
  setTip(tipX, tipY) {
    this.setTailAndTip(this.tailX, this.tailY, tipX, tipY);
  }
  update() {
    // Represent the arrow as a vector
    const vector = new Vector2(this._tipX - this._tailX, this._tipY - this._tailY);
    if (vector.magnitude === 0) {
      // if the arrow has zero magnitude, then nothing will be drawn
      this.tailNode.shape = null;
      this.headNode.shape = null;
    } else {
      const length = vector.magnitude;

      // Set up a coordinate frame that goes from tail to tip.
      const xHatUnit = vector.normalized();
      const yHatUnit = xHatUnit.rotated(Math.PI / 2);
      const getPoint = (xHat, yHat) => {
        const x = xHatUnit.x * xHat + yHatUnit.x * yHat + this._tailX;
        const y = xHatUnit.y * xHat + yHatUnit.y * yHat + this._tailY;
        return new Vector2(x, y);
      };

      // Limit the head height to the tail length.
      let headHeight = Math.min(this.headHeight, 0.99 * length);

      // Scale the head, if enabled and necessary.
      if (this.isHeadDynamic && this.headHeight > this.fractionalHeadHeight * length) {
        headHeight = this.fractionalHeadHeight * length;
      }

      // Adjust the end of the tail towards the tip, so that it doesn't overlap the head.
      const scaledUnit = xHatUnit.times(length - headHeight);
      const tailX2 = this.tailX + scaledUnit.x;
      const tailY2 = this.tailY + scaledUnit.y;

      // Describe the tail as a line segment.
      this.tailNode.shape = Shape.lineSegment(this.tailX, this.tailY, tailX2, tailY2);

      // Describe the head as a triangle
      this.headNode.shape = new Shape().moveToPoint(getPoint(length - headHeight, this.headWidth / 2)).lineToPoint(getPoint(length, 0)).lineToPoint(getPoint(length - headHeight, -this.headWidth / 2)).close();
    }
  }
}
vectorAddition.register('DashedArrowNode', DashedArrowNode);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJWZWN0b3IyIiwiU2hhcGUiLCJOb2RlIiwiUGF0aCIsInZlY3RvckFkZGl0aW9uIiwib3B0aW9uaXplIiwiRGFzaGVkQXJyb3dOb2RlIiwiY29uc3RydWN0b3IiLCJ0YWlsWCIsInRhaWxZIiwidGlwWCIsInRpcFkiLCJwcm92aWRlZE9wdGlvbnMiLCJvcHRpb25zIiwidGFpbERhc2giLCJoZWFkSGVpZ2h0IiwiaGVhZFdpZHRoIiwidGFpbFdpZHRoIiwiZmlsbCIsImlzSGVhZER5bmFtaWMiLCJmcmFjdGlvbmFsSGVhZEhlaWdodCIsImhlYWROb2RlIiwidGFpbE5vZGUiLCJzdHJva2UiLCJsaW5lV2lkdGgiLCJsaW5lRGFzaCIsImNoaWxkcmVuIiwiX3RhaWxYIiwiX3RhaWxZIiwiX3RpcFgiLCJfdGlwWSIsInNldFRhaWxBbmRUaXAiLCJ1cGRhdGUiLCJzZXRUaXAiLCJ2ZWN0b3IiLCJtYWduaXR1ZGUiLCJzaGFwZSIsImxlbmd0aCIsInhIYXRVbml0Iiwibm9ybWFsaXplZCIsInlIYXRVbml0Iiwicm90YXRlZCIsIk1hdGgiLCJQSSIsImdldFBvaW50IiwieEhhdCIsInlIYXQiLCJ4IiwieSIsIm1pbiIsInNjYWxlZFVuaXQiLCJ0aW1lcyIsInRhaWxYMiIsInRhaWxZMiIsImxpbmVTZWdtZW50IiwibW92ZVRvUG9pbnQiLCJsaW5lVG9Qb2ludCIsImNsb3NlIiwicmVnaXN0ZXIiXSwic291cmNlcyI6WyJEYXNoZWRBcnJvd05vZGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTktMjAyMywgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXHJcblxyXG4vKipcclxuICogRGFzaGVkQXJyb3dOb2RlIGRyYXdzIGFuIGFycm93IHdpdGggYSBzb2xpZCBoZWFkIGFuZCBkYXNoZWQgdGFpbC5cclxuICpcclxuICogVGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBzcGVjaWZpYyB0byB2ZWN0b3ItYWRkaXRpb24uIEl0J3MgYSBzaW1wbGlmaWVkIHZlcnNpb24gb2YgU0NFTkVSWV9QSEVUL0xpbmVBcnJvd05vZGUgd2l0aFxyXG4gKiBhIHNvbGlkIHRpcC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waGV0c2ltcy92ZWN0b3ItYWRkaXRpb24vaXNzdWVzLzE3NyNpc3N1ZWNvbW1lbnQtNTMxODc2NzI0LlxyXG4gKlxyXG4gKiBBbiBhdHRlbXB0IHdhcyBtYWRlIHRvIGFkZCBhIGRhc2hlZC10YWlsIGZlYXR1cmUgdG8gU0NFTkVSWV9QSEVUL0Fycm93Tm9kZSwgYnV0IHRoZSBjdXJyZW50IGltcGxlbWVudGF0aW9uIG9mXHJcbiAqIEFycm93Tm9kZSBtYWRlIHRoYXQgdmlydHVhbGx5IGltcG9zc2libGUuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcGhldHNpbXMvc2NlbmVyeS1waGV0L2lzc3Vlcy81MzMuXHJcbiAqXHJcbiAqIEBhdXRob3IgQ2hyaXMgTWFsbGV5IChQaXhlbFpvb20sIEluYy4pXHJcbiAqL1xyXG5cclxuaW1wb3J0IFZlY3RvcjIgZnJvbSAnLi4vLi4vLi4vLi4vZG90L2pzL1ZlY3RvcjIuanMnO1xyXG5pbXBvcnQgeyBTaGFwZSB9IGZyb20gJy4uLy4uLy4uLy4uL2tpdGUvanMvaW1wb3J0cy5qcyc7XHJcbmltcG9ydCB7IE5vZGUsIE5vZGVPcHRpb25zLCBQYXRoIH0gZnJvbSAnLi4vLi4vLi4vLi4vc2NlbmVyeS9qcy9pbXBvcnRzLmpzJztcclxuaW1wb3J0IHZlY3RvckFkZGl0aW9uIGZyb20gJy4uLy4uL3ZlY3RvckFkZGl0aW9uLmpzJztcclxuaW1wb3J0IG9wdGlvbml6ZSBmcm9tICcuLi8uLi8uLi8uLi9waGV0LWNvcmUvanMvb3B0aW9uaXplLmpzJztcclxuaW1wb3J0IHsgQXJyb3dOb2RlT3B0aW9ucyB9IGZyb20gJy4uLy4uLy4uLy4uL3NjZW5lcnktcGhldC9qcy9BcnJvd05vZGUuanMnO1xyXG5pbXBvcnQgUGlja09wdGlvbmFsIGZyb20gJy4uLy4uLy4uLy4uL3BoZXQtY29yZS9qcy90eXBlcy9QaWNrT3B0aW9uYWwuanMnO1xyXG5cclxudHlwZSBTZWxmT3B0aW9ucyA9IHtcclxuICB0YWlsRGFzaD86IG51bWJlcltdOyAvLyBkZXNjcmliZXMgdGhlIGRhc2gsIHNpbWlsYXIgdG8gU0NFTkVSWS9MaW5lU3R5bGUgbGluZURhc2hcclxufSAmIFBpY2tPcHRpb25hbDxBcnJvd05vZGVPcHRpb25zLCAnaGVhZEhlaWdodCcgfCAnaGVhZFdpZHRoJyB8ICd0YWlsV2lkdGgnIHwgJ2ZpbGwnIHwgJ2lzSGVhZER5bmFtaWMnIHwgJ2ZyYWN0aW9uYWxIZWFkSGVpZ2h0Jz47XHJcblxyXG5leHBvcnQgdHlwZSBEYXNoZWRBcnJvd05vZGVPcHRpb25zID0gU2VsZk9wdGlvbnMgJiBQaWNrT3B0aW9uYWw8Tm9kZU9wdGlvbnMsICdjdXJzb3InPjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERhc2hlZEFycm93Tm9kZSBleHRlbmRzIE5vZGUge1xyXG5cclxuICBwcml2YXRlIF90YWlsWDogbnVtYmVyO1xyXG4gIHByaXZhdGUgX3RhaWxZOiBudW1iZXI7XHJcbiAgcHJpdmF0ZSBfdGlwWDogbnVtYmVyO1xyXG4gIHByaXZhdGUgX3RpcFk6IG51bWJlcjtcclxuXHJcbiAgcHJpdmF0ZSByZWFkb25seSBoZWFkSGVpZ2h0OiBudW1iZXI7XHJcbiAgcHJpdmF0ZSByZWFkb25seSBoZWFkV2lkdGg6IG51bWJlcjtcclxuICBwcml2YXRlIHJlYWRvbmx5IGlzSGVhZER5bmFtaWM6IGJvb2xlYW47XHJcbiAgcHJpdmF0ZSByZWFkb25seSBmcmFjdGlvbmFsSGVhZEhlaWdodDogbnVtYmVyO1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgdGFpbE5vZGU6IFBhdGg7XHJcbiAgcHJpdmF0ZSByZWFkb25seSBoZWFkTm9kZTogUGF0aDtcclxuXHJcbiAgcHVibGljIGNvbnN0cnVjdG9yKCB0YWlsWDogbnVtYmVyLCB0YWlsWTogbnVtYmVyLCB0aXBYOiBudW1iZXIsIHRpcFk6IG51bWJlciwgcHJvdmlkZWRPcHRpb25zPzogRGFzaGVkQXJyb3dOb2RlT3B0aW9ucyApIHtcclxuXHJcbiAgICBjb25zdCBvcHRpb25zID0gb3B0aW9uaXplPERhc2hlZEFycm93Tm9kZU9wdGlvbnMsIFNlbGZPcHRpb25zLCBOb2RlT3B0aW9ucz4oKSgge1xyXG5cclxuICAgICAgLy8gU2VsZk9wdGlvbnNcclxuICAgICAgdGFpbERhc2g6IFsgMywgMyBdLFxyXG4gICAgICBoZWFkSGVpZ2h0OiAxMCxcclxuICAgICAgaGVhZFdpZHRoOiAxMCxcclxuICAgICAgdGFpbFdpZHRoOiA1LFxyXG4gICAgICBmaWxsOiAnYmxhY2snLFxyXG4gICAgICBpc0hlYWREeW5hbWljOiBmYWxzZSxcclxuICAgICAgZnJhY3Rpb25hbEhlYWRIZWlnaHQ6IDAuNVxyXG4gICAgfSwgcHJvdmlkZWRPcHRpb25zICk7XHJcblxyXG4gICAgY29uc3QgaGVhZE5vZGUgPSBuZXcgUGF0aCggbnVsbCwge1xyXG4gICAgICBmaWxsOiBvcHRpb25zLmZpbGxcclxuICAgIH0gKTtcclxuXHJcbiAgICBjb25zdCB0YWlsTm9kZSA9IG5ldyBQYXRoKCBudWxsLCB7XHJcbiAgICAgIHN0cm9rZTogb3B0aW9ucy5maWxsLFxyXG4gICAgICBsaW5lV2lkdGg6IG9wdGlvbnMudGFpbFdpZHRoLFxyXG4gICAgICBsaW5lRGFzaDogb3B0aW9ucy50YWlsRGFzaFxyXG4gICAgfSApO1xyXG5cclxuICAgIG9wdGlvbnMuY2hpbGRyZW4gPSBbIHRhaWxOb2RlLCBoZWFkTm9kZSBdO1xyXG5cclxuICAgIHN1cGVyKCBvcHRpb25zICk7XHJcblxyXG4gICAgdGhpcy5fdGFpbFggPSB0YWlsWDtcclxuICAgIHRoaXMuX3RhaWxZID0gdGFpbFk7XHJcbiAgICB0aGlzLl90aXBYID0gdGlwWDtcclxuICAgIHRoaXMuX3RpcFkgPSB0aXBZO1xyXG5cclxuICAgIHRoaXMuaGVhZEhlaWdodCA9IG9wdGlvbnMuaGVhZEhlaWdodDtcclxuICAgIHRoaXMuaGVhZFdpZHRoID0gb3B0aW9ucy5oZWFkV2lkdGg7XHJcbiAgICB0aGlzLmlzSGVhZER5bmFtaWMgPSBvcHRpb25zLmlzSGVhZER5bmFtaWM7XHJcbiAgICB0aGlzLmZyYWN0aW9uYWxIZWFkSGVpZ2h0ID0gb3B0aW9ucy5mcmFjdGlvbmFsSGVhZEhlaWdodDtcclxuICAgIHRoaXMudGFpbE5vZGUgPSB0YWlsTm9kZTtcclxuICAgIHRoaXMuaGVhZE5vZGUgPSBoZWFkTm9kZTtcclxuXHJcbiAgICAvLyBpbml0aWFsaXplXHJcbiAgICB0aGlzLnNldFRhaWxBbmRUaXAoIHRhaWxYLCB0YWlsWSwgdGlwWCwgdGlwWSApO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIGdldCB0YWlsWCgpOiBudW1iZXIgeyByZXR1cm4gdGhpcy5fdGFpbFg7IH1cclxuXHJcbiAgcHVibGljIGdldCB0YWlsWSgpOiBudW1iZXIgeyByZXR1cm4gdGhpcy5fdGFpbFk7IH1cclxuXHJcbiAgcHVibGljIGdldCB0aXBYKCk6IG51bWJlciB7IHJldHVybiB0aGlzLl90aXBYOyB9XHJcblxyXG4gIHB1YmxpYyBnZXQgdGlwWSgpOiBudW1iZXIgeyByZXR1cm4gdGhpcy5fdGlwWTsgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXRzIHRoZSB0YWlsIGFuZCB0aXAgcG9zaXRpb25zLlxyXG4gICAqL1xyXG4gIHB1YmxpYyBzZXRUYWlsQW5kVGlwKCB0YWlsWDogbnVtYmVyLCB0YWlsWTogbnVtYmVyLCB0aXBYOiBudW1iZXIsIHRpcFk6IG51bWJlciApOiB2b2lkIHtcclxuXHJcbiAgICB0aGlzLl90YWlsWCA9IHRhaWxYO1xyXG4gICAgdGhpcy5fdGFpbFkgPSB0YWlsWTtcclxuICAgIHRoaXMuX3RpcFggPSB0aXBYO1xyXG4gICAgdGhpcy5fdGlwWSA9IHRpcFk7XHJcblxyXG4gICAgdGhpcy51cGRhdGUoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgdGhlIHRpcCBwb3NpdGlvbi5cclxuICAgKi9cclxuICBwdWJsaWMgc2V0VGlwKCB0aXBYOiBudW1iZXIsIHRpcFk6IG51bWJlciApOiB2b2lkIHtcclxuICAgIHRoaXMuc2V0VGFpbEFuZFRpcCggdGhpcy50YWlsWCwgdGhpcy50YWlsWSwgdGlwWCwgdGlwWSApO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSB1cGRhdGUoKTogdm9pZCB7XHJcblxyXG4gICAgLy8gUmVwcmVzZW50IHRoZSBhcnJvdyBhcyBhIHZlY3RvclxyXG4gICAgY29uc3QgdmVjdG9yID0gbmV3IFZlY3RvcjIoIHRoaXMuX3RpcFggLSB0aGlzLl90YWlsWCwgdGhpcy5fdGlwWSAtIHRoaXMuX3RhaWxZICk7XHJcblxyXG4gICAgaWYgKCB2ZWN0b3IubWFnbml0dWRlID09PSAwICkge1xyXG5cclxuICAgICAgLy8gaWYgdGhlIGFycm93IGhhcyB6ZXJvIG1hZ25pdHVkZSwgdGhlbiBub3RoaW5nIHdpbGwgYmUgZHJhd25cclxuICAgICAgdGhpcy50YWlsTm9kZS5zaGFwZSA9IG51bGw7XHJcbiAgICAgIHRoaXMuaGVhZE5vZGUuc2hhcGUgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcblxyXG4gICAgICBjb25zdCBsZW5ndGggPSB2ZWN0b3IubWFnbml0dWRlO1xyXG5cclxuICAgICAgLy8gU2V0IHVwIGEgY29vcmRpbmF0ZSBmcmFtZSB0aGF0IGdvZXMgZnJvbSB0YWlsIHRvIHRpcC5cclxuICAgICAgY29uc3QgeEhhdFVuaXQgPSB2ZWN0b3Iubm9ybWFsaXplZCgpO1xyXG4gICAgICBjb25zdCB5SGF0VW5pdCA9IHhIYXRVbml0LnJvdGF0ZWQoIE1hdGguUEkgLyAyICk7XHJcblxyXG4gICAgICBjb25zdCBnZXRQb2ludCA9ICggeEhhdDogbnVtYmVyLCB5SGF0OiBudW1iZXIgKSA9PiB7XHJcbiAgICAgICAgY29uc3QgeCA9IHhIYXRVbml0LnggKiB4SGF0ICsgeUhhdFVuaXQueCAqIHlIYXQgKyB0aGlzLl90YWlsWDtcclxuICAgICAgICBjb25zdCB5ID0geEhhdFVuaXQueSAqIHhIYXQgKyB5SGF0VW5pdC55ICogeUhhdCArIHRoaXMuX3RhaWxZO1xyXG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yMiggeCwgeSApO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgLy8gTGltaXQgdGhlIGhlYWQgaGVpZ2h0IHRvIHRoZSB0YWlsIGxlbmd0aC5cclxuICAgICAgbGV0IGhlYWRIZWlnaHQgPSBNYXRoLm1pbiggdGhpcy5oZWFkSGVpZ2h0LCAwLjk5ICogbGVuZ3RoICk7XHJcblxyXG4gICAgICAvLyBTY2FsZSB0aGUgaGVhZCwgaWYgZW5hYmxlZCBhbmQgbmVjZXNzYXJ5LlxyXG4gICAgICBpZiAoIHRoaXMuaXNIZWFkRHluYW1pYyAmJiAoIHRoaXMuaGVhZEhlaWdodCA+IHRoaXMuZnJhY3Rpb25hbEhlYWRIZWlnaHQgKiBsZW5ndGggKSApIHtcclxuICAgICAgICBoZWFkSGVpZ2h0ID0gdGhpcy5mcmFjdGlvbmFsSGVhZEhlaWdodCAqIGxlbmd0aDtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQWRqdXN0IHRoZSBlbmQgb2YgdGhlIHRhaWwgdG93YXJkcyB0aGUgdGlwLCBzbyB0aGF0IGl0IGRvZXNuJ3Qgb3ZlcmxhcCB0aGUgaGVhZC5cclxuICAgICAgY29uc3Qgc2NhbGVkVW5pdCA9IHhIYXRVbml0LnRpbWVzKCBsZW5ndGggLSBoZWFkSGVpZ2h0ICk7XHJcbiAgICAgIGNvbnN0IHRhaWxYMiA9IHRoaXMudGFpbFggKyBzY2FsZWRVbml0Lng7XHJcbiAgICAgIGNvbnN0IHRhaWxZMiA9IHRoaXMudGFpbFkgKyBzY2FsZWRVbml0Lnk7XHJcblxyXG4gICAgICAvLyBEZXNjcmliZSB0aGUgdGFpbCBhcyBhIGxpbmUgc2VnbWVudC5cclxuICAgICAgdGhpcy50YWlsTm9kZS5zaGFwZSA9IFNoYXBlLmxpbmVTZWdtZW50KCB0aGlzLnRhaWxYLCB0aGlzLnRhaWxZLCB0YWlsWDIsIHRhaWxZMiApO1xyXG5cclxuICAgICAgLy8gRGVzY3JpYmUgdGhlIGhlYWQgYXMgYSB0cmlhbmdsZVxyXG4gICAgICB0aGlzLmhlYWROb2RlLnNoYXBlID0gbmV3IFNoYXBlKClcclxuICAgICAgICAubW92ZVRvUG9pbnQoIGdldFBvaW50KCBsZW5ndGggLSBoZWFkSGVpZ2h0LCB0aGlzLmhlYWRXaWR0aCAvIDIgKSApXHJcbiAgICAgICAgLmxpbmVUb1BvaW50KCBnZXRQb2ludCggbGVuZ3RoLCAwICkgKVxyXG4gICAgICAgIC5saW5lVG9Qb2ludCggZ2V0UG9pbnQoIGxlbmd0aCAtIGhlYWRIZWlnaHQsIC10aGlzLmhlYWRXaWR0aCAvIDIgKSApXHJcbiAgICAgICAgLmNsb3NlKCk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG52ZWN0b3JBZGRpdGlvbi5yZWdpc3RlciggJ0Rhc2hlZEFycm93Tm9kZScsIERhc2hlZEFycm93Tm9kZSApOyJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPQSxPQUFPLE1BQU0sK0JBQStCO0FBQ25ELFNBQVNDLEtBQUssUUFBUSxnQ0FBZ0M7QUFDdEQsU0FBU0MsSUFBSSxFQUFlQyxJQUFJLFFBQVEsbUNBQW1DO0FBQzNFLE9BQU9DLGNBQWMsTUFBTSx5QkFBeUI7QUFDcEQsT0FBT0MsU0FBUyxNQUFNLHVDQUF1QztBQVU3RCxlQUFlLE1BQU1DLGVBQWUsU0FBU0osSUFBSSxDQUFDO0VBY3pDSyxXQUFXQSxDQUFFQyxLQUFhLEVBQUVDLEtBQWEsRUFBRUMsSUFBWSxFQUFFQyxJQUFZLEVBQUVDLGVBQXdDLEVBQUc7SUFFdkgsTUFBTUMsT0FBTyxHQUFHUixTQUFTLENBQW1ELENBQUMsQ0FBRTtNQUU3RTtNQUNBUyxRQUFRLEVBQUUsQ0FBRSxDQUFDLEVBQUUsQ0FBQyxDQUFFO01BQ2xCQyxVQUFVLEVBQUUsRUFBRTtNQUNkQyxTQUFTLEVBQUUsRUFBRTtNQUNiQyxTQUFTLEVBQUUsQ0FBQztNQUNaQyxJQUFJLEVBQUUsT0FBTztNQUNiQyxhQUFhLEVBQUUsS0FBSztNQUNwQkMsb0JBQW9CLEVB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