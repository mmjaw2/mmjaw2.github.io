// Copyright 2019-2023, University of Colorado Boulder

/**
 * BaseVectorsAccordionBox appears on the right side of the 'Equations' screen. It contains pickers for modifying the
 * base vectors, and a checkbox to show/hide the base vectors.
 *
 * 'Is a' relationship with AccordionBox but adds the following functionality:
 *  - allow users to change the components of the Vectors on Cartesian mode (via numberPicker)
 *  - allow users to change the angle and the magnitude of the Vectors on polar mode (via numberPicker)
 *  - allow users to toggle the visibility of the Base Vectors (via checkbox)
 *
 * This AccordionBox is not meant to be disposed.
 *
 * @author Brandon Li
 */

import Property from '../../../../axon/js/Property.js';
import MathSymbols from '../../../../scenery-phet/js/MathSymbols.js';
import { HBox, HStrut, Node, RichText, Text, VBox } from '../../../../scenery/js/imports.js';
import AccordionBox from '../../../../sun/js/AccordionBox.js';
import NumberPicker from '../../../../sun/js/NumberPicker.js';
import CoordinateSnapModes from '../../common/model/CoordinateSnapModes.js';
import VectorAdditionConstants from '../../common/VectorAdditionConstants.js';
import VectorSymbolNode from '../../common/view/VectorSymbolNode.js';
import vectorAddition from '../../vectorAddition.js';
import VectorAdditionStrings from '../../VectorAdditionStrings.js';
import BaseVectorsCheckbox from './BaseVectorsCheckbox.js';
import { combineOptions, optionize4 } from '../../../../phet-core/js/optionize.js';
import CartesianBaseVector from '../../common/model/CartesianBaseVector.js';
import PolarBaseVector from '../../common/model/PolarBaseVector.js';

// constants
const LABEL_MAX_WIDTH = 30; // maxWidth for picker labels, determined empirically
const X_SPACING = 11; // horizontal spacing between the left NumberPicker and the right label
const Y_SPACING = 17; // vertical spacing between UI components
const CONTENT_WIDTH = VectorAdditionConstants.BASE_VECTORS_ACCORDION_BOX_CONTENT_WIDTH; // fixed content width

export default class BaseVectorsAccordionBox extends AccordionBox {
  constructor(baseVectorsVisibleProperty, coordinateSnapMode, vectorSet, providedOptions) {
    const options = optionize4()({}, VectorAdditionConstants.ACCORDION_BOX_OPTIONS, {
      // AccordionBoxOptions
      titleNode: new Text(VectorAdditionStrings.baseVectors, {
        font: VectorAdditionConstants.TITLE_FONT,
        maxWidth: 0.75 * CONTENT_WIDTH
      }),
      isDisposable: false
    }, providedOptions);

    //----------------------------------------------------------------------------------------
    // Create the Number Pickers / labels
    //
    // Each Vector in the vectorSet gets 2 NumberPickers displayed horizontally. Each NumberPicker has
    // a 'label'.
    //
    // On Cartesian, the two NumberPickers toggle the X and the Y component respectively.
    // On Polar, the two NumberPickers toggle the magnitude and the angle respectively.
    //----------------------------------------------------------------------------------------

    const pickers = []; // pairs of pickers and their labels

    // Each Vector in the vectorSet gets 2 NumberPickers, so loop through the vectorSet
    vectorSet.equationsVectors.forEach(vector => {
      const baseVector = vector.baseVector; // convenience reference

      // Empty references to the 2 NumberPickers/labels per Vector. To be set later.
      let leftNumberPickerAndLabel;
      let rightNumberPickerAndLabel;
      if (coordinateSnapMode === CoordinateSnapModes.CARTESIAN) {
        const cartesianBaseVector = baseVector;
        assert && assert(cartesianBaseVector instanceof CartesianBaseVector); // eslint-disable-line no-simple-type-checking-assertions

        // X Component
        leftNumberPickerAndLabel = createNumberPickerWithLabel(cartesianBaseVector.xComponentProperty, VectorAdditionConstants.COMPONENT_RANGE, new VectorSymbolNode({
          symbol: `${baseVector.symbol}<sub>${VectorAdditionStrings.symbol.x}</sub>`,
          showVectorArrow: false,
          maxWidth: LABEL_MAX_WIDTH
        }));

        // Y Component
        rightNumberPickerAndLabel = createNumberPickerWithLabel(cartesianBaseVector.yComponentProperty, VectorAdditionConstants.COMPONENT_RANGE, new VectorSymbolNode({
          symbol: `${baseVector.symbol}<sub>${VectorAdditionStrings.symbol.y}</sub>`,
          showVectorArrow: false,
          maxWidth: LABEL_MAX_WIDTH
        }));
      } else {
        const polarBaseVector = baseVector;
        assert && assert(polarBaseVector instanceof PolarBaseVector); // eslint-disable-line no-simple-type-checking-assertions

        // Magnitude
        leftNumberPickerAndLabel = createNumberPickerWithLabel(polarBaseVector.magnitudeProperty, VectorAdditionConstants.MAGNITUDE_RANGE, new VectorSymbolNode({
          symbol: baseVector.symbol,
          includeAbsoluteValueBars: true,
          maxWidth: LABEL_MAX_WIDTH
        }));

        // Angle
        rightNumberPickerAndLabel = createNumberPickerWithLabel(polarBaseVector.angleDegreesProperty, VectorAdditionConstants.ANGLE_RANGE, new RichText(`${MathSymbols.THETA}<sub>${baseVector.symbol}</sub>`, {
          font: VectorAdditionConstants.EQUATION_SYMBOL_FONT,
          maxWidth: LABEL_MAX_WIDTH
        }), {
          // increment by the polar angle interval
          incrementFunction: value => value + VectorAdditionConstants.POLAR_ANGLE_INTERVAL,
          decrementFunction: value => value - VectorAdditionConstants.POLAR_ANGLE_INTERVAL
        });
      }

      // Displayed Horizontally, push a HBox to the content children array
      pickers.push(new HBox({
        align: 'origin',
        spacing: X_SPACING,
        children: [leftNumberPickerAndLabel, rightNumberPickerAndLabel]
      }));
    });
    const pickersVBox = new VBox({
      children: pickers,
      spacing: Y_SPACING,
      align: 'center'
    });

    // Ensure that the accordion box is a fixed width.
    const strut = new HStrut(CONTENT_WIDTH, {
      pickable: false,
      center: pickersVBox.center
    });
    const fixedWidthPickers = new Node({
      children: [strut, pickersVBox]
    });

    // Create the checkbox that toggles the visibility of Base Vectors
    const baseVectorsCheckbox = new BaseVectorsCheckbox(baseVectorsVisibleProperty, vectorSet.vectorColorPalette);
    const accordionBoxContent = new VBox({
      children: [fixedWidthPickers, baseVectorsCheckbox],
      spacing: Y_SPACING,
      align: 'left',
      maxWidth: CONTENT_WIDTH
    });
    super(accordionBoxContent, options);

    // When the box is collapsed, cancel interactions.
    // unlink is not necessary, exists for the lifetime of the sim.
    this.expandedProperty.lazyLink(expanded => {
      if (!expanded) {
        this.interruptSubtreeInput();
      }
    });
  }
}

/**
 * Layouts a VectorSymbolNode, a equals sign (Text), and a NumberPicker horizontally in a HBox.
 *
 * The VectorSymbolNode is then aligned in a AlignBox to ensure the correct alignment and sizing, which ensures that
 * all HBoxes have equal widths (since the NumberPicker and the equals sign Text don't change size).
 *
 * @param numberProperty - number Property that goes in the NumberPicker
 * @param numberRange - static numberRange of the number Property
 * @param vectorSymbolNode
 * @param [numberPickerOptions]
 */
function createNumberPickerWithLabel(numberProperty, numberRange, vectorSymbolNode, numberPickerOptions) {
  const equalsSign = new Text(MathSymbols.EQUAL_TO, {
    font: VectorAdditionConstants.EQUATION_FONT
  });

  // Empirically set the vertical position of the NumberPicker, and wrap it in a Node to work with HBox.
  // See https://github.com/phetsims/vector-addition/issues/209
  const numberPicker = new NumberPicker(numberProperty, new Property(numberRange), combineOptions({}, VectorAdditionConstants.NUMBER_PICKER_OPTIONS, {
    touchAreaXDilation: 20,
    touchAreaYDilation: 10
  }, numberPickerOptions));
  numberPicker.centerY = -equalsSign.height / 3;
  const numberPickerParent = new Node({
    children: [numberPicker]
  });
  return new HBox({
    align: 'origin',
    spacing: 3,
    // space around the equals sign
    children: [vectorSymbolNode, equalsSign, numberPickerParent]
  });
}
vectorAddition.register('BaseVectorsAccordionBox', BaseVectorsAccordionBox);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJQcm9wZXJ0eSIsIk1hdGhTeW1ib2xzIiwiSEJveCIsIkhTdHJ1dCIsIk5vZGUiLCJSaWNoVGV4dCIsIlRleHQiLCJWQm94IiwiQWNjb3JkaW9uQm94IiwiTnVtYmVyUGlja2VyIiwiQ29vcmRpbmF0ZVNuYXBNb2RlcyIsIlZlY3RvckFkZGl0aW9uQ29uc3RhbnRzIiwiVmVjdG9yU3ltYm9sTm9kZSIsInZlY3RvckFkZGl0aW9uIiwiVmVjdG9yQWRkaXRpb25TdHJpbmdzIiwiQmFzZVZlY3RvcnNDaGVja2JveCIsImNvbWJpbmVPcHRpb25zIiwib3B0aW9uaXplNCIsIkNhcnRlc2lhbkJhc2VWZWN0b3IiLCJQb2xhckJhc2VWZWN0b3IiLCJMQUJFTF9NQVhfV0lEVEgiLCJYX1NQQUNJTkciLCJZX1NQQUNJTkciLCJDT05URU5UX1dJRFRIIiwiQkFTRV9WRUNUT1JTX0FDQ09SRElPTl9CT1hfQ09OVEVOVF9XSURUSCIsIkJhc2VWZWN0b3JzQWNjb3JkaW9uQm94IiwiY29uc3RydWN0b3IiLCJiYXNlVmVjdG9yc1Zpc2libGVQcm9wZXJ0eSIsImNvb3JkaW5hdGVTbmFwTW9kZSIsInZlY3RvclNldCIsInByb3ZpZGVkT3B0aW9ucyIsIm9wdGlvbnMiLCJBQ0NPUkRJT05fQk9YX09QVElPTlMiLCJ0aXRsZU5vZGUiLCJiYXNlVmVjdG9ycyIsImZvbnQiLCJUSVRMRV9GT05UIiwibWF4V2lkdGgiLCJpc0Rpc3Bvc2FibGUiLCJwaWNrZXJzIiwiZXF1YXRpb25zVmVjdG9ycyIsImZvckVhY2giLCJ2ZWN0b3IiLCJiYXNlVmVjdG9yIiwibGVmdE51bWJlclBpY2tlckFuZExhYmVsIiwicmlnaHROdW1iZXJQaWNrZXJBbmRMYWJlbCIsIkNBUlRFU0lBTiIsImNhcnRlc2lhbkJhc2VWZWN0b3IiLCJhc3NlcnQiLCJjcmVhdGVOdW1iZXJQaWNrZXJXaXRoTGFiZWwiLCJ4Q29tcG9uZW50UHJvcGVydHkiLCJDT01QT05FTlRfUkFOR0UiLCJzeW1ib2wiLCJ4Iiwic2hvd1ZlY3RvckFycm93IiwieUNvbXBvbmVudFByb3BlcnR5IiwieSIsInBvbGFyQmFzZVZlY3RvciIsIm1hZ25pdHVkZVByb3BlcnR5IiwiTUFHTklUVURFX1JBTkdFIiwiaW5jbHVkZUFic29sdXRlVmFsdWVCYXJzIiwiYW5nbGVEZWdyZWVzUHJvcGVydHkiLCJBTkdMRV9SQU5HRSIsIlRIRVRBIiwiRVFVQVRJT05fU1lNQk9MX0ZPTlQiLCJpbmNyZW1lbnRGdW5jdGlvbiIsInZhbHVlIiwiUE9MQVJfQU5HTEVfSU5URVJWQUwiLCJkZWNyZW1lbnRGdW5jdGlvbiIsInB1c2giLCJhbGlnbiIsInNwYWNpbmciLCJjaGlsZHJlbiIsInBpY2tlcnNWQm94Iiwic3RydXQiLCJwaWNrYWJsZSIsImNlbnRlciIsImZpeGVkV2lkdGhQaWNrZXJzIiwiYmFzZVZlY3RvcnNDaGVja2JveCIsInZlY3RvckNvbG9yUGFsZXR0ZSIsImFjY29yZGlvbkJveENvbnRlbnQiLCJleHBhbmRlZFByb3BlcnR5IiwibGF6eUxpbmsiLCJleHBhbmRlZCIsImludGVycnVwdFN1YnRyZWVJbnB1dCIsIm51bWJlclByb3BlcnR5IiwibnVtYmVyUmFuZ2UiLCJ2ZWN0b3JTeW1ib2xOb2RlIiwibnVtYmVyUGlja2VyT3B0aW9ucyIsImVxdWFsc1NpZ24iLCJFUVVBTF9UTyIsIkVRVUFUSU9OX0ZPTlQiLCJudW1iZXJQaWNrZXIiLCJOVU1CRVJfUElDS0VSX09QVElPTlMiLCJ0b3VjaEFyZWFYRGlsYXRpb24iLCJ0b3VjaEFyZWFZRGlsYXRpb24iLCJjZW50ZXJZIiwiaGVpZ2h0IiwibnVtYmVyUGlja2VyUGFyZW50IiwicmVnaXN0ZXIiXSwic291cmNlcyI6WyJCYXNlVmVjdG9yc0FjY29yZGlvbkJveC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAxOS0yMDIzLCBVbml2ZXJzaXR5IG9mIENvbG9yYWRvIEJvdWxkZXJcclxuXHJcbi8qKlxyXG4gKiBCYXNlVmVjdG9yc0FjY29yZGlvbkJveCBhcHBlYXJzIG9uIHRoZSByaWdodCBzaWRlIG9mIHRoZSAnRXF1YXRpb25zJyBzY3JlZW4uIEl0IGNvbnRhaW5zIHBpY2tlcnMgZm9yIG1vZGlmeWluZyB0aGVcclxuICogYmFzZSB2ZWN0b3JzLCBhbmQgYSBjaGVja2JveCB0byBzaG93L2hpZGUgdGhlIGJhc2UgdmVjdG9ycy5cclxuICpcclxuICogJ0lzIGEnIHJlbGF0aW9uc2hpcCB3aXRoIEFjY29yZGlvbkJveCBidXQgYWRkcyB0aGUgZm9sbG93aW5nIGZ1bmN0aW9uYWxpdHk6XHJcbiAqICAtIGFsbG93IHVzZXJzIHRvIGNoYW5nZSB0aGUgY29tcG9uZW50cyBvZiB0aGUgVmVjdG9ycyBvbiBDYXJ0ZXNpYW4gbW9kZSAodmlhIG51bWJlclBpY2tlcilcclxuICogIC0gYWxsb3cgdXNlcnMgdG8gY2hhbmdlIHRoZSBhbmdsZSBhbmQgdGhlIG1hZ25pdHVkZSBvZiB0aGUgVmVjdG9ycyBvbiBwb2xhciBtb2RlICh2aWEgbnVtYmVyUGlja2VyKVxyXG4gKiAgLSBhbGxvdyB1c2VycyB0byB0b2dnbGUgdGhlIHZpc2liaWxpdHkgb2YgdGhlIEJhc2UgVmVjdG9ycyAodmlhIGNoZWNrYm94KVxyXG4gKlxyXG4gKiBUaGlzIEFjY29yZGlvbkJveCBpcyBub3QgbWVhbnQgdG8gYmUgZGlzcG9zZWQuXHJcbiAqXHJcbiAqIEBhdXRob3IgQnJhbmRvbiBMaVxyXG4gKi9cclxuXHJcbmltcG9ydCBQcm9wZXJ0eSBmcm9tICcuLi8uLi8uLi8uLi9heG9uL2pzL1Byb3BlcnR5LmpzJztcclxuaW1wb3J0IFJhbmdlIGZyb20gJy4uLy4uLy4uLy4uL2RvdC9qcy9SYW5nZS5qcyc7XHJcbmltcG9ydCBNYXRoU3ltYm9scyBmcm9tICcuLi8uLi8uLi8uLi9zY2VuZXJ5LXBoZXQvanMvTWF0aFN5bWJvbHMuanMnO1xyXG5pbXBvcnQgeyBIQm94LCBIU3RydXQsIE5vZGUsIE5vZGVUcmFuc2xhdGlvbk9wdGlvbnMsIFJpY2hUZXh0LCBUZXh0LCBWQm94IH0gZnJvbSAnLi4vLi4vLi4vLi4vc2NlbmVyeS9qcy9pbXBvcnRzLmpzJztcclxuaW1wb3J0IEFjY29yZGlvbkJveCwgeyBBY2NvcmRpb25Cb3hPcHRpb25zIH0gZnJvbSAnLi4vLi4vLi4vLi4vc3VuL2pzL0FjY29yZGlvbkJveC5qcyc7XHJcbmltcG9ydCBOdW1iZXJQaWNrZXIsIHsgTnVtYmVyUGlja2VyT3B0aW9ucyB9IGZyb20gJy4uLy4uLy4uLy4uL3N1bi9qcy9OdW1iZXJQaWNrZXIuanMnO1xyXG5pbXBvcnQgQ29vcmRpbmF0ZVNuYXBNb2RlcyBmcm9tICcuLi8uLi9jb21tb24vbW9kZWwvQ29vcmRpbmF0ZVNuYXBNb2Rlcy5qcyc7XHJcbmltcG9ydCBWZWN0b3JBZGRpdGlvbkNvbnN0YW50cyBmcm9tICcuLi8uLi9jb21tb24vVmVjdG9yQWRkaXRpb25Db25zdGFudHMuanMnO1xyXG5pbXBvcnQgVmVjdG9yU3ltYm9sTm9kZSBmcm9tICcuLi8uLi9jb21tb24vdmlldy9WZWN0b3JTeW1ib2xOb2RlLmpzJztcclxuaW1wb3J0IHZlY3RvckFkZGl0aW9uIGZyb20gJy4uLy4uL3ZlY3RvckFkZGl0aW9uLmpzJztcclxuaW1wb3J0IFZlY3RvckFkZGl0aW9uU3RyaW5ncyBmcm9tICcuLi8uLi9WZWN0b3JBZGRpdGlvblN0cmluZ3MuanMnO1xyXG5pbXBvcnQgRXF1YXRpb25zVmVjdG9yU2V0IGZyb20gJy4uL21vZGVsL0VxdWF0aW9uc1ZlY3RvclNldC5qcyc7XHJcbmltcG9ydCBCYXNlVmVjdG9yc0NoZWNrYm94IGZyb20gJy4vQmFzZVZlY3RvcnNDaGVja2JveC5qcyc7XHJcbmltcG9ydCB7IGNvbWJpbmVPcHRpb25zLCBFbXB0eVNlbGZPcHRpb25zLCBvcHRpb25pemU0IH0gZnJvbSAnLi4vLi4vLi4vLi4vcGhldC1jb3JlL2pzL29wdGlvbml6ZS5qcyc7XHJcbmltcG9ydCBQaWNrUmVxdWlyZWQgZnJvbSAnLi4vLi4vLi4vLi4vcGhldC1jb3JlL2pzL3R5cGVzL1BpY2tSZXF1aXJlZC5qcyc7XHJcbmltcG9ydCBOdW1iZXJQcm9wZXJ0eSBmcm9tICcuLi8uLi8uLi8uLi9heG9uL2pzL051bWJlclByb3BlcnR5LmpzJztcclxuaW1wb3J0IENhcnRlc2lhbkJhc2VWZWN0b3IgZnJvbSAnLi4vLi4vY29tbW9uL21vZGVsL0NhcnRlc2lhbkJhc2VWZWN0b3IuanMnO1xyXG5pbXBvcnQgUG9sYXJCYXNlVmVjdG9yIGZyb20gJy4uLy4uL2NvbW1vbi9tb2RlbC9Qb2xhckJhc2VWZWN0b3IuanMnO1xyXG5cclxuLy8gY29uc3RhbnRzXHJcbmNvbnN0IExBQkVMX01BWF9XSURUSCA9IDMwOyAvLyBtYXhXaWR0aCBmb3IgcGlja2VyIGxhYmVscywgZGV0ZXJtaW5lZCBlbXBpcmljYWxseVxyXG5jb25zdCBYX1NQQUNJTkcgPSAxMTsgLy8gaG9yaXpvbnRhbCBzcGFjaW5nIGJldHdlZW4gdGhlIGxlZnQgTnVtYmVyUGlja2VyIGFuZCB0aGUgcmlnaHQgbGFiZWxcclxuY29uc3QgWV9TUEFDSU5HID0gMTc7IC8vIHZlcnRpY2FsIHNwYWNpbmcgYmV0d2VlbiBVSSBjb21wb25lbnRzXHJcbmNvbnN0IENPTlRFTlRfV0lEVEggPSBWZWN0b3JBZGRpdGlvbkNvbnN0YW50cy5CQVNFX1ZFQ1RPUlNfQUNDT1JESU9OX0JPWF9DT05URU5UX1dJRFRIOyAvLyBmaXhlZCBjb250ZW50IHdpZHRoXHJcblxyXG50eXBlIFNlbGZPcHRpb25zID0gRW1wdHlTZWxmT3B0aW9ucztcclxuXHJcbnR5cGUgQmFzZVZlY3RvcnNBY2NvcmRpb25Cb3hPcHRpb25zID0gU2VsZk9wdGlvbnMgJiBOb2RlVHJhbnNsYXRpb25PcHRpb25zICZcclxuICBQaWNrUmVxdWlyZWQ8QWNjb3JkaW9uQm94T3B0aW9ucywgJ2V4cGFuZGVkUHJvcGVydHknPjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJhc2VWZWN0b3JzQWNjb3JkaW9uQm94IGV4dGVuZHMgQWNjb3JkaW9uQm94IHtcclxuXHJcbiAgcHVibGljIGNvbnN0cnVjdG9yKCBiYXNlVmVjdG9yc1Zpc2libGVQcm9wZXJ0eTogUHJvcGVydHk8Ym9vbGVhbj4sXHJcbiAgICAgICAgICAgICAgICAgICAgICBjb29yZGluYXRlU25hcE1vZGU6IENvb3JkaW5hdGVTbmFwTW9kZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICB2ZWN0b3JTZXQ6IEVxdWF0aW9uc1ZlY3RvclNldCxcclxuICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVkT3B0aW9uczogQmFzZVZlY3RvcnNBY2NvcmRpb25Cb3hPcHRpb25zICkge1xyXG5cclxuICAgIGNvbnN0IG9wdGlvbnMgPSBvcHRpb25pemU0PEJhc2VWZWN0b3JzQWNjb3JkaW9uQm94T3B0aW9ucywgU2VsZk9wdGlvbnMsIEFjY29yZGlvbkJveE9wdGlvbnM+KCkoXHJcbiAgICAgIHt9LCBWZWN0b3JBZGRpdGlvbkNvbnN0YW50cy5BQ0NPUkRJT05fQk9YX09QVElPTlMsIHtcclxuXHJcbiAgICAgICAgLy8gQWNjb3JkaW9uQm94T3B0aW9uc1xyXG4gICAgICAgIHRpdGxlTm9kZTogbmV3IFRleHQoIFZlY3RvckFkZGl0aW9uU3RyaW5ncy5iYXNlVmVjdG9ycywge1xyXG4gICAgICAgICAgZm9udDogVmVjdG9yQWRkaXRpb25Db25zdGFudHMuVElUTEVfRk9OVCxcclxuICAgICAgICAgIG1heFdpZHRoOiAwLjc1ICogQ09OVEVOVF9XSURUSFxyXG4gICAgICAgIH0gKSxcclxuICAgICAgICBpc0Rpc3Bvc2FibGU6IGZhbHNlXHJcbiAgICAgIH0sIHByb3ZpZGVkT3B0aW9ucyApO1xyXG5cclxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gQ3JlYXRlIHRoZSBOdW1iZXIgUGlja2VycyAvIGxhYmVsc1xyXG4gICAgLy9cclxuICAgIC8vIEVhY2ggVmVjdG9yIGluIHRoZSB2ZWN0b3JTZXQgZ2V0cyAyIE51bWJlclBpY2tlcnMgZGlzcGxheWVkIGhvcml6b250YWxseS4gRWFjaCBOdW1iZXJQaWNrZXIgaGFzXHJcbiAgICAvLyBhICdsYWJlbCcuXHJcbiAgICAvL1xyXG4gICAgLy8gT24gQ2FydGVzaWFuLCB0aGUgdHdvIE51bWJlclBpY2tlcnMgdG9nZ2xlIHRoZSBYIGFuZCB0aGUgWSBjb21wb25lbnQgcmVzcGVjdGl2ZWx5LlxyXG4gICAgLy8gT24gUG9sYXIsIHRoZSB0d28gTnVtYmVyUGlja2VycyB0b2dnbGUgdGhlIG1hZ25pdHVkZSBhbmQgdGhlIGFuZ2xlIHJlc3BlY3RpdmVseS5cclxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuICAgIGNvbnN0IHBpY2tlcnM6IE5vZGVbXSA9IFtdOyAvLyBwYWlycyBvZiBwaWNrZXJzIGFuZCB0aGVpciBsYWJlbHNcclxuXHJcbiAgICAvLyBFYWNoIFZlY3RvciBpbiB0aGUgdmVjdG9yU2V0IGdldHMgMiBOdW1iZXJQaWNrZXJzLCBzbyBsb29wIHRocm91Z2ggdGhlIHZlY3RvclNldFxyXG4gICAgdmVjdG9yU2V0LmVxdWF0aW9uc1ZlY3RvcnMuZm9yRWFjaCggdmVjdG9yID0+IHtcclxuXHJcbiAgICAgIGNvbnN0IGJhc2VWZWN0b3IgPSB2ZWN0b3IuYmFzZVZlY3RvcjsgLy8gY29udmVuaWVuY2UgcmVmZXJlbmNlXHJcblxyXG4gICAgICAvLyBFbXB0eSByZWZlcmVuY2VzIHRvIHRoZSAyIE51bWJlclBpY2tlcnMvbGFiZWxzIHBlciBWZWN0b3IuIFRvIGJlIHNldCBsYXRlci5cclxuICAgICAgbGV0IGxlZnROdW1iZXJQaWNrZXJBbmRMYWJlbDtcclxuICAgICAgbGV0IHJpZ2h0TnVtYmVyUGlja2VyQW5kTGFiZWw7XHJcblxyXG4gICAgICBpZiAoIGNvb3JkaW5hdGVTbmFwTW9kZSA9PT0gQ29vcmRpbmF0ZVNuYXBNb2Rlcy5DQVJURVNJQU4gKSB7XHJcblxyXG4gICAgICAgIGNvbnN0IGNhcnRlc2lhbkJhc2VWZWN0b3IgPSBiYXNlVmVjdG9yIGFzIENhcnRlc2lhbkJhc2VWZWN0b3I7XHJcbiAgICAgICAgYXNzZXJ0ICYmIGFzc2VydCggY2FydGVzaWFuQmFzZVZlY3RvciBpbnN0YW5jZW9mIENhcnRlc2lhbkJhc2VWZWN0b3IgKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zaW1wbGUtdHlwZS1jaGVja2luZy1hc3NlcnRpb25zXHJcblxyXG4gICAgICAgIC8vIFggQ29tcG9uZW50XHJcbiAgICAgICAgbGVmdE51bWJlclBpY2tlckFuZExhYmVsID0gY3JlYXRlTnVtYmVyUGlja2VyV2l0aExhYmVsKFxyXG4gICAgICAgICAgY2FydGVzaWFuQmFzZVZlY3Rvci54Q29tcG9uZW50UHJvcGVydHksXHJcbiAgICAgICAgICBWZWN0b3JBZGRpdGlvbkNvbnN0YW50cy5DT01QT05FTlRfUkFOR0UsXHJcbiAgICAgICAgICBuZXcgVmVjdG9yU3ltYm9sTm9kZSgge1xyXG4gICAgICAgICAgICBzeW1ib2w6IGAke2Jhc2VWZWN0b3Iuc3ltYm9sfTxzdWI+JHtWZWN0b3JBZGRpdGlvblN0cmluZ3Muc3ltYm9sLnh9PC9zdWI+YCxcclxuICAgICAgICAgICAgc2hvd1ZlY3RvckFycm93OiBmYWxzZSxcclxuICAgICAgICAgICAgbWF4V2lkdGg6IExBQkVMX01BWF9XSURUSFxyXG4gICAgICAgICAgfSApICk7XHJcblxyXG4gICAgICAgIC8vIFkgQ29tcG9uZW50XHJcbiAgICAgICAgcmlnaHROdW1iZXJQaWNrZXJBbmRMYWJlbCA9IGNyZWF0ZU51bWJlclBpY2tlcldpdGhMYWJlbChcclxuICAgICAgICAgIGNhcnRlc2lhbkJhc2VWZWN0b3IueUNvbXBvbmVudFByb3BlcnR5LFxyXG4gICAgICAgICAgVmVjdG9yQWRkaXRpb25Db25zdGFudHMuQ09NUE9ORU5UX1JBTkdFLFxyXG4gICAgICAgICAgbmV3IFZlY3RvclN5bWJvbE5vZGUoIHtcclxuICAgICAgICAgICAgc3ltYm9sOiBgJHtiYXNlVmVjdG9yLnN5bWJvbH08c3ViPiR7VmVjdG9yQWRkaXRpb25TdHJpbmdzLnN5bWJvbC55fTwvc3ViPmAsXHJcbiAgICAgICAgICAgIHNob3dWZWN0b3JBcnJvdzogZmFsc2UsXHJcbiAgICAgICAgICAgIG1heFdpZHRoOiBMQUJFTF9NQVhfV0lEVEhcclxuICAgICAgICAgIH0gKSApO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IHBvbGFyQmFzZVZlY3RvciA9IGJhc2VWZWN0b3IgYXMgUG9sYXJCYXNlVmVjdG9yO1xyXG4gICAgICAgIGFzc2VydCAmJiBhc3NlcnQoIHBvbGFyQmFzZVZlY3RvciBpbnN0YW5jZW9mIFBvbGFyQmFzZVZlY3RvciApOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNpbXBsZS10eXBlLWNoZWNraW5nLWFzc2VydGlvbnNcclxuXHJcbiAgICAgICAgLy8gTWFnbml0dWRlXHJcbiAgICAgICAgbGVmdE51bWJlclBpY2tlckFuZExhYmVsID0gY3JlYXRlTnVtYmVyUGlja2VyV2l0aExhYmVsKFxyXG4gICAgICAgICAgcG9sYXJCYXNlVmVjdG9yLm1hZ25pdHVkZVByb3BlcnR5LFxyXG4gICAgICAgICAgVmVjdG9yQWRkaXRpb25Db25zdGFudHMuTUFHTklUVURFX1JBTkdFLFxyXG4gICAgICAgICAgbmV3IFZlY3RvclN5bWJvbE5vZGUoIHtcclxuICAgICAgICAgICAgc3ltYm9sOiBiYXNlVmVjdG9yLnN5bWJvbCxcclxuICAgICAgICAgICAgaW5jbHVkZUFic29sdXRlVmFsdWVCYXJzOiB0cnVlLFxyXG4gICAgICAgICAgICBtYXhXaWR0aDogTEFCRUxfTUFYX1dJRFRIXHJcbiAgICAgICAgICB9ICkgKTtcclxuXHJcbiAgICAgICAgLy8gQW5nbGVcclxuICAgICAgICByaWdodE51bWJlclBpY2tlckFuZExhYmVsID0gY3JlYXRlTnVtYmVyUGlja2VyV2l0aExhYmVsKFxyXG4gICAgICAgICAgcG9sYXJCYXNlVmVjdG9yLmFuZ2xlRGVncmVlc1Byb3BlcnR5LFxyXG4gICAgICAgICAgVmVjdG9yQWRkaXRpb25Db25zdGFudHMuQU5HTEVfUkFOR0UsXHJcbiAgICAgICAgICBuZXcgUmljaFRleHQoIGAke01hdGhTeW1ib2xzLlRIRVRBfTxzdWI+JHtiYXNlVmVjdG9yLnN5bWJvbH08L3N1Yj5gLCB7XHJcbiAgICAgICAgICAgIGZvbnQ6IFZlY3RvckFkZGl0aW9uQ29uc3RhbnRzLkVRVUFUSU9OX1NZTUJPTF9GT05ULFxyXG4gICAgICAgICAgICBtYXhXaWR0aDogTEFCRUxfTUFYX1dJRFRIXHJcbiAgICAgICAgICB9ICksIHtcclxuICAgICAgICAgICAgLy8gaW5jcmVtZW50IGJ5IHRoZSBwb2xhciBhbmdsZSBpbnRlcnZhbFxyXG4gICAgICAgICAgICBpbmNyZW1lbnRGdW5jdGlvbjogdmFsdWUgPT4gdmFsdWUgKyBWZWN0b3JBZGRpdGlvbkNvbnN0YW50cy5QT0xBUl9BTkdMRV9JTlRFUlZBTCxcclxuICAgICAgICAgICAgZGVjcmVtZW50RnVuY3Rpb246IHZhbHVlID0+IHZhbHVlIC0gVmVjdG9yQWRkaXRpb25Db25zdGFudHMuUE9MQVJfQU5HTEVfSU5URVJWQUxcclxuICAgICAgICAgIH0gKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gRGlzcGxheWVkIEhvcml6b250YWxseSwgcHVzaCBhIEhCb3ggdG8gdGhlIGNvbnRlbnQgY2hpbGRyZW4gYXJyYXlcclxuICAgICAgcGlja2Vycy5wdXNoKCBuZXcgSEJveCgge1xyXG4gICAgICAgIGFsaWduOiAnb3JpZ2luJyxcclxuICAgICAgICBzcGFjaW5nOiBYX1NQQUNJTkcsXHJcbiAgICAgICAgY2hpbGRyZW46IFsgbGVmdE51bWJlclBpY2tlckFuZExhYmVsLCByaWdodE51bWJlclBpY2tlckFuZExhYmVsIF1cclxuICAgICAgfSApICk7XHJcbiAgICB9ICk7XHJcblxyXG4gICAgY29uc3QgcGlja2Vyc1ZCb3ggPSBuZXcgVkJveCgge1xyXG4gICAgICBjaGlsZHJlbjogcGlja2VycyxcclxuICAgICAgc3BhY2luZzogWV9TUEFDSU5HLFxyXG4gICAgICBhbGlnbjogJ2NlbnRlcidcclxuICAgIH0gKTtcclxuXHJcbiAgICAvLyBFbnN1cmUgdGhhdCB0aGUgYWNjb3JkaW9uIGJveCBpcyBhIGZpeGVkIHdpZHRoLlxyXG4gICAgY29uc3Qgc3RydXQgPSBuZXcgSFN0cnV0KCBDT05URU5UX1dJRFRILCB7XHJcbiAgICAgIHBpY2thYmxlOiBmYWxzZSxcclxuICAgICAgY2VudGVyOiBwaWNrZXJzVkJveC5jZW50ZXJcclxuICAgIH0gKTtcclxuICAgIGNvbnN0IGZpeGVkV2lkdGhQaWNrZXJzID0gbmV3IE5vZGUoIHsgY2hpbGRyZW46IFsgc3RydXQsIHBpY2tlcnNWQm94IF0gfSApO1xyXG5cclxuICAgIC8vIENyZWF0ZSB0aGUgY2hlY2tib3ggdGhhdCB0b2dnbGVzIHRoZSB2aXNpYmlsaXR5IG9mIEJhc2UgVmVjdG9yc1xyXG4gICAgY29uc3QgYmFzZVZlY3RvcnNDaGVja2JveCA9IG5ldyBCYXNlVmVjdG9yc0NoZWNrYm94KCBiYXNlVmVjdG9yc1Zpc2libGVQcm9wZXJ0eSwgdmVjdG9yU2V0LnZlY3RvckNvbG9yUGFsZXR0ZSApO1xyXG5cclxuICAgIGNvbnN0IGFjY29yZGlvbkJveENvbnRlbnQgPSBuZXcgVkJveCgge1xyXG4gICAgICBjaGlsZHJlbjogWyBmaXhlZFdpZHRoUGlja2VycywgYmFzZVZlY3RvcnNDaGVja2JveCBdLFxyXG4gICAgICBzcGFjaW5nOiBZX1NQQUNJTkcsXHJcbiAgICAgIGFsaWduOiAnbGVmdCcsXHJcbiAgICAgIG1heFdpZHRoOiBDT05URU5UX1dJRFRIXHJcbiAgICB9ICk7XHJcblxyXG4gICAgc3VwZXIoIGFjY29yZGlvbkJveENvbnRlbnQsIG9wdGlvbnMgKTtcclxuXHJcbiAgICAvLyBXaGVuIHRoZSBib3ggaXMgY29sbGFwc2VkLCBjYW5jZWwgaW50ZXJhY3Rpb25zLlxyXG4gICAgLy8gdW5saW5rIGlzIG5vdCBuZWNlc3NhcnksIGV4aXN0cyBmb3IgdGhlIGxpZmV0aW1lIG9mIHRoZSBzaW0uXHJcbiAgICB0aGlzLmV4cGFuZGVkUHJvcGVydHkubGF6eUxpbmsoIGV4cGFuZGVkID0+IHtcclxuICAgICAgaWYgKCAhZXhwYW5kZWQgKSB7XHJcbiAgICAgICAgdGhpcy5pbnRlcnJ1cHRTdWJ0cmVlSW5wdXQoKTtcclxuICAgICAgfVxyXG4gICAgfSApO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIExheW91dHMgYSBWZWN0b3JTeW1ib2xOb2RlLCBhIGVxdWFscyBzaWduIChUZXh0KSwgYW5kIGEgTnVtYmVyUGlja2VyIGhvcml6b250YWxseSBpbiBhIEhCb3guXHJcbiAqXHJcbiAqIFRoZSBWZWN0b3JTeW1ib2xOb2RlIGlzIHRoZW4gYWxpZ25lZCBpbiBhIEFsaWduQm94IHRvIGVuc3VyZSB0aGUgY29ycmVjdCBhbGlnbm1lbnQgYW5kIHNpemluZywgd2hpY2ggZW5zdXJlcyB0aGF0XHJcbiAqIGFsbCBIQm94ZXMgaGF2ZSBlcXVhbCB3aWR0aHMgKHNpbmNlIHRoZSBOdW1iZXJQaWNrZXIgYW5kIHRoZSBlcXVhbHMgc2lnbiBUZXh0IGRvbid0IGNoYW5nZSBzaXplKS5cclxuICpcclxuICogQHBhcmFtIG51bWJlclByb3BlcnR5IC0gbnVtYmVyIFByb3BlcnR5IHRoYXQgZ29lcyBpbiB0aGUgTnVtYmVyUGlja2VyXHJcbiAqIEBwYXJhbSBudW1iZXJSYW5nZSAtIHN0YXRpYyBudW1iZXJSYW5nZSBvZiB0aGUgbnVtYmVyIFByb3BlcnR5XHJcbiAqIEBwYXJhbSB2ZWN0b3JTeW1ib2xOb2RlXHJcbiAqIEBwYXJhbSBbbnVtYmVyUGlja2VyT3B0aW9uc11cclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZU51bWJlclBpY2tlcldpdGhMYWJlbCggbnVtYmVyUHJvcGVydHk6IE51bWJlclByb3BlcnR5LCBudW1iZXJSYW5nZTogUmFuZ2UsIHZlY3RvclN5bWJvbE5vZGU6IE5vZGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVtYmVyUGlja2VyT3B0aW9ucz86IE51bWJlclBpY2tlck9wdGlvbnMgKTogTm9kZSB7XHJcblxyXG4gIGNvbnN0IGVxdWFsc1NpZ24gPSBuZXcgVGV4dCggTWF0aFN5bWJvbHMuRVFVQUxfVE8sIHtcclxuICAgIGZvbnQ6IFZlY3RvckFkZGl0aW9uQ29uc3RhbnRzLkVRVUFUSU9OX0ZPTlRcclxuICB9ICk7XHJcblxyXG4gIC8vIEVtcGlyaWNhbGx5IHNldCB0aGUgdmVydGljYWwgcG9zaXRpb24gb2YgdGhlIE51bWJlclBpY2tlciwgYW5kIHdyYXAgaXQgaW4gYSBOb2RlIHRvIHdvcmsgd2l0aCBIQm94LlxyXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcGhldHNpbXMvdmVjdG9yLWFkZGl0aW9uL2lzc3Vlcy8yMDlcclxuICBjb25zdCBudW1iZXJQaWNrZXIgPSBuZXcgTnVtYmVyUGlja2VyKCBudW1iZXJQcm9wZXJ0eSwgbmV3IFByb3BlcnR5KCBudW1iZXJSYW5nZSApLFxyXG4gICAgY29tYmluZU9wdGlvbnM8TnVtYmVyUGlja2VyT3B0aW9ucz4oIHt9LCBWZWN0b3JBZGRpdGlvbkNvbnN0YW50cy5OVU1CRVJfUElDS0VSX09QVElPTlMsIHtcclxuICAgICAgdG91Y2hBcmVhWERpbGF0aW9uOiAyMCxcclxuICAgICAgdG91Y2hBcmVhWURpbGF0aW9uOiAxMFxyXG4gICAgfSwgbnVtYmVyUGlja2VyT3B0aW9ucyApXHJcbiAgKTtcclxuICBudW1iZXJQaWNrZXIuY2VudGVyWSA9IC1lcXVhbHNTaWduLmhlaWdodCAvIDM7XHJcbiAgY29uc3QgbnVtYmVyUGlja2VyUGFyZW50ID0gbmV3IE5vZGUoIHsgY2hpbGRyZW46IFsgbnVtYmVyUGlja2VyIF0gfSApO1xyXG5cclxuICByZXR1cm4gbmV3IEhCb3goIHtcclxuICAgIGFsaWduOiAnb3JpZ2luJyxcclxuICAgIHNwYWNpbmc6IDMsIC8vIHNwYWNlIGFyb3VuZCB0aGUgZXF1YWxzIHNpZ25cclxuICAgIGNoaWxkcmVuOiBbIHZlY3RvclN5bWJvbE5vZGUsIGVxdWFsc1NpZ24sIG51bWJlclBpY2tlclBhcmVudCBdXHJcbiAgfSApO1xyXG59XHJcblxyXG52ZWN0b3JBZGRpdGlvbi5yZWdpc3RlciggJ0Jhc2VWZWN0b3JzQWNjb3JkaW9uQm94JywgQmFzZVZlY3RvcnNBY2NvcmRpb25Cb3ggKTsiXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU9BLFFBQVEsTUFBTSxpQ0FBaUM7QUFFdEQsT0FBT0MsV0FBVyxNQUFNLDRDQUE0QztBQUNwRSxTQUFTQyxJQUFJLEVBQUVDLE1BQU0sRUFBRUMsSUFBSSxFQUEwQkMsUUFBUSxFQUFFQyxJQUFJLEVBQUVDLElBQUksUUFBUSxtQ0FBbUM7QUFDcEgsT0FBT0MsWUFBWSxNQUErQixvQ0FBb0M7QUFDdEYsT0FBT0MsWUFBWSxNQUErQixvQ0FBb0M7QUFDdEYsT0FBT0MsbUJBQW1CLE1BQU0sMkNBQTJDO0FBQzNFLE9BQU9DLHVCQUF1QixNQUFNLHlDQUF5QztBQUM3RSxPQUFPQyxnQkFBZ0IsTUFBTSx1Q0FBdUM7QUFDcEUsT0FBT0MsY0FBYyxNQUFNLHlCQUF5QjtBQUNwRCxPQUFPQyxxQkFBcUIsTUFBTSxnQ0FBZ0M7QUFFbEUsT0FBT0MsbUJBQW1CLE1BQU0sMEJBQTBCO0FBQzFELFNBQVNDLGNBQWMsRUFBb0JDLFVBQVUsUUFBUSx1Q0FBdUM7QUFHcEcsT0FBT0MsbUJBQW1CLE1BQU0sMkNBQTJDO0FBQzNFLE9BQU9DLGVBQWUsTUFBTSx1Q0FBdUM7O0FBRW5FO0FBQ0EsTUFBTUMsZUFBZSxHQUFHLEVBQUUsQ0FBQyxDQUFDO0FBQzVCLE1BQU1DLFNBQVMsR0FBRyxFQUFFLENBQUMsQ0FBQztBQUN0QixNQUFNQyxTQUFTLEdBQUcsRUFBRSxDQUFDLENBQUM7QUFDdEIsTUFBTUMsYUFBYSxHQUFHWix1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