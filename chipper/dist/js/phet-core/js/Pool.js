// Copyright 2022-2024, University of Colorado Boulder

/**
 * PROTOTYPE version for better support
 *
 * Object pooling mixin, for cases where creating new objects is expensive, and we'd rather mark some objects as able
 * to be reused (i.e. 'in the pool'). This provides a pool of objects for each type it is invoked on. It allows for
 * getting "new" objects that can either be constructed OR pulled in from a pool, and requires that the objects are
 * essentially able to "re-run" the constructor. Then when putting the object back in the pool, references should be
 * released, so memory isn't leaked.
 *
 * With this style of pooling, the following should be standard boilerplate within the class:

  public freeToPool(): void {
    MyType.pool.freeToPool( this );
  }

  public static readonly pool = new Pool( MyType );

 * and can additionally implement TPoolable to make it clear that the type is pooled
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

import phetCore from './phetCore.js';
import optionize from './optionize.js';

// Our linter complains that {} should be either Record<string, unknown>, unknown, or Record<string, never>. However in
// this case, we actually want it to be any type of non-nullish structural type, to see if there is anything required.

// eslint-disable-line @typescript-eslint/ban-types

export default class Pool {
  objects = [];
  // The `initialize` option is required if the type doesn't have a correctly-typed initialize method. Therefore, we
  // do some Typescript magic to require providedOptions if that's the case (otherwise providedOptions is optional).
  constructor(type, ...providedOptionsSpread) {
    const options = optionize()({
      defaultArguments: [],
      initialize: type.prototype.initialize,
      maxSize: 100,
      initialSize: 0,
      useDefaultConstruction: false
    }, providedOptionsSpread[0]);
    assert && assert(options.maxSize >= 0);
    assert && assert(options.initialSize >= 0);
    this._maxPoolSize = options.maxSize;

    // There is a madness to this craziness. We'd want to use the method noted at
    // https://stackoverflow.com/questions/1606797/use-of-apply-with-new-operator-is-this-possible, but the type is
    // not provided in the arguments array below. By calling bind on itself, we're able to get a version of bind that
    // inserts the constructor as the first argument of the .apply called later so we don't create garbage by having
    // to pack `arguments` into an array AND THEN concatenate it with a new first element (the type itself).
    this.partialConstructor = Function.prototype.bind.bind(type, type);

    // Basically our type constructor, but with the default arguments included already.
    this.DefaultConstructor = this.partialConstructor(...options.defaultArguments); // eslint-disable-line @typescript-eslint/no-unnecessary-type-assertion

    this.initialize = options.initialize;
    assert && assert(this.initialize, 'Either pass in an initialize option, or provide a method named initialize on the type with the proper signature');
    this.useDefaultConstruction = options.useDefaultConstruction;

    // Initialize the pool (if it should have objects)
    while (this.objects.length < options.initialSize) {
      this.objects.push(this.createDefaultObject());
    }
  }
  createDefaultObject() {
    return new this.DefaultConstructor();
  }

  /**
   * Returns an object with arbitrary state (possibly constructed with the default arguments).
   */
  fetch() {
    return this.objects.length ? this.objects.pop() : this.createDefaultObject();
  }

  /**
   * Returns an object that behaves as if it was constructed with the given arguments. May result in a new object
   * being created (if the pool is empty), or it may use the constructor to mutate an object from the pool.
   */
  create(...args) {
    let result;
    if (this.objects.length) {
      result = this.objects.pop();
      this.initialize.apply(result, args);
    } else if (this.useDefaultConstruction) {
      result = this.createDefaultObject();
      this.initialize.apply(result, args);
    } else {
      result = new (this.partialConstructor(...args))();
    }
    return result;
  }

  /**
   * Returns the current size of the pool.
   */
  get poolSize() {
    return this.objects.length;
  }

  /**
   * Sets the maximum pool size.
   */
  set maxPoolSize(value) {
    assert && assert(value === Number.POSITIVE_INFINITY || Number.isInteger(value) && value >= 0, 'maxPoolSize should be a non-negative integer or infinity');
    this._maxPoolSize = value;
  }

  /**
   * Returns the maximum pool size.
   */
  get maxPoolSize() {
    return this._maxPoolSize;
  }
  freeToPool(object) {
    if (this.objects.length < this.maxPoolSize) {
      this.objects.push(object);
    }
  }
  forEach(callback) {
    this.objects.forEach(callback);
  }
}
phetCore.register('Pool', Pool);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJwaGV0Q29yZSIsIm9wdGlvbml6ZSIsIlBvb2wiLCJvYmplY3RzIiwiY29uc3RydWN0b3IiLCJ0eXBlIiwicHJvdmlkZWRPcHRpb25zU3ByZWFkIiwib3B0aW9ucyIsImRlZmF1bHRBcmd1bWVudHMiLCJpbml0aWFsaXplIiwicHJvdG90eXBlIiwibWF4U2l6ZSIsImluaXRpYWxTaXplIiwidXNlRGVmYXVsdENvbnN0cnVjdGlvbiIsImFzc2VydCIsIl9tYXhQb29sU2l6ZSIsInBhcnRpYWxDb25zdHJ1Y3RvciIsIkZ1bmN0aW9uIiwiYmluZCIsIkRlZmF1bHRDb25zdHJ1Y3RvciIsImxlbmd0aCIsInB1c2giLCJjcmVhdGVEZWZhdWx0T2JqZWN0IiwiZmV0Y2giLCJwb3AiLCJjcmVhdGUiLCJhcmdzIiwicmVzdWx0IiwiYXBwbHkiLCJwb29sU2l6ZSIsIm1heFBvb2xTaXplIiwidmFsdWUiLCJOdW1iZXIiLCJQT1NJVElWRV9JTkZJTklUWSIsImlzSW50ZWdlciIsImZyZWVUb1Bvb2wiLCJvYmplY3QiLCJmb3JFYWNoIiwiY2FsbGJhY2siLCJyZWdpc3RlciJdLCJzb3VyY2VzIjpbIlBvb2wudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMjItMjAyNCwgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXHJcblxyXG4vKipcclxuICogUFJPVE9UWVBFIHZlcnNpb24gZm9yIGJldHRlciBzdXBwb3J0XHJcbiAqXHJcbiAqIE9iamVjdCBwb29saW5nIG1peGluLCBmb3IgY2FzZXMgd2hlcmUgY3JlYXRpbmcgbmV3IG9iamVjdHMgaXMgZXhwZW5zaXZlLCBhbmQgd2UnZCByYXRoZXIgbWFyayBzb21lIG9iamVjdHMgYXMgYWJsZVxyXG4gKiB0byBiZSByZXVzZWQgKGkuZS4gJ2luIHRoZSBwb29sJykuIFRoaXMgcHJvdmlkZXMgYSBwb29sIG9mIG9iamVjdHMgZm9yIGVhY2ggdHlwZSBpdCBpcyBpbnZva2VkIG9uLiBJdCBhbGxvd3MgZm9yXHJcbiAqIGdldHRpbmcgXCJuZXdcIiBvYmplY3RzIHRoYXQgY2FuIGVpdGhlciBiZSBjb25zdHJ1Y3RlZCBPUiBwdWxsZWQgaW4gZnJvbSBhIHBvb2wsIGFuZCByZXF1aXJlcyB0aGF0IHRoZSBvYmplY3RzIGFyZVxyXG4gKiBlc3NlbnRpYWxseSBhYmxlIHRvIFwicmUtcnVuXCIgdGhlIGNvbnN0cnVjdG9yLiBUaGVuIHdoZW4gcHV0dGluZyB0aGUgb2JqZWN0IGJhY2sgaW4gdGhlIHBvb2wsIHJlZmVyZW5jZXMgc2hvdWxkIGJlXHJcbiAqIHJlbGVhc2VkLCBzbyBtZW1vcnkgaXNuJ3QgbGVha2VkLlxyXG4gKlxyXG4gKiBXaXRoIHRoaXMgc3R5bGUgb2YgcG9vbGluZywgdGhlIGZvbGxvd2luZyBzaG91bGQgYmUgc3RhbmRhcmQgYm9pbGVycGxhdGUgd2l0aGluIHRoZSBjbGFzczpcclxuXHJcbiAgcHVibGljIGZyZWVUb1Bvb2woKTogdm9pZCB7XHJcbiAgICBNeVR5cGUucG9vbC5mcmVlVG9Qb29sKCB0aGlzICk7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IHBvb2wgPSBuZXcgUG9vbCggTXlUeXBlICk7XHJcblxyXG4gKiBhbmQgY2FuIGFkZGl0aW9uYWxseSBpbXBsZW1lbnQgVFBvb2xhYmxlIHRvIG1ha2UgaXQgY2xlYXIgdGhhdCB0aGUgdHlwZSBpcyBwb29sZWRcclxuICpcclxuICogQGF1dGhvciBKb25hdGhhbiBPbHNvbiA8am9uYXRoYW4ub2xzb25AY29sb3JhZG8uZWR1PlxyXG4gKi9cclxuXHJcbmltcG9ydCBDb25zdHJ1Y3RvciBmcm9tICcuL3R5cGVzL0NvbnN0cnVjdG9yLmpzJztcclxuaW1wb3J0IHBoZXRDb3JlIGZyb20gJy4vcGhldENvcmUuanMnO1xyXG5pbXBvcnQgb3B0aW9uaXplIGZyb20gJy4vb3B0aW9uaXplLmpzJztcclxuaW1wb3J0IEludGVudGlvbmFsQW55IGZyb20gJy4vdHlwZXMvSW50ZW50aW9uYWxBbnkuanMnO1xyXG5cclxudHlwZSBTZWxmUG9vbGFibGVPcHRpb25zPFQgZXh0ZW5kcyBDb25zdHJ1Y3Rvcj4gPSB7XHJcbiAgLy8gSWYgYW4gb2JqZWN0IG5lZWRzIHRvIGJlIGNyZWF0ZWQgd2l0aG91dCBhIGRpcmVjdCBjYWxsIChzYXksIHRvIGZpbGwgdGhlIHBvb2wgaW5pdGlhbGx5KSwgdGhlc2UgYXJlIHRoZSBhcmd1bWVudHNcclxuICAvLyB0aGF0IHdpbGwgYmUgcGFzc2VkIGludG8gdGhlIGNvbnN0cnVjdG9yXHJcbiAgZGVmYXVsdEFyZ3VtZW50cz86IENvbnN0cnVjdG9yUGFyYW1ldGVyczxUPjtcclxuXHJcbiAgLy8gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgb24gdGhlIG9iamVjdHMgdG8gcmVpbml0aWFsaXplIHRoZW0gKHRoYXQgaXMgZWl0aGVyIHRoZSBjb25zdHJ1Y3Rvciwgb3IgYWN0cyBsaWtlIHRoZVxyXG4gIC8vIGNvbnN0cnVjdG9yKS4gTk9URTogVGhpcyBzaG91bGQgcmV0dXJuIHRoZSBvYmplY3QgaXRzZWxmIVxyXG4gIGluaXRpYWxpemU/OiBQb29sYWJsZUluaXRpYWxpemVyPFQ+O1xyXG5cclxuICAvLyBBIGxpbWl0IGZvciB0aGUgcG9vbCBzaXplIChzbyB3ZSBkb24ndCBsZWFrIG1lbW9yeSBieSBncm93aW5nIHRoZSBwb29sIGZhc3RlciB0aGFuIHdlIHRha2UgdGhpbmdzIGZyb20gaXQpLiBDYW4gYmVcclxuICAvLyBjdXN0b21pemVkIGJ5IHNldHRpbmcgVHlwZS5tYXhQb29sU2l6ZVxyXG4gIG1heFNpemU/OiBudW1iZXI7XHJcblxyXG4gIC8vIFRoZSBpbml0aWFsIHNpemUgb2YgdGhlIHBvb2wuIFRvIGZpbGwgaXQsIG9iamVjdHMgd2lsbCBiZSBjcmVhdGVkIHdpdGggdGhlIGRlZmF1bHQgYXJndW1lbnRzLlxyXG4gIGluaXRpYWxTaXplPzogbnVtYmVyO1xyXG5cclxuICAvLyBJZiB0cnVlLCB3aGVuIGNvbnN0cnVjdGluZyB0aGUgZGVmYXVsdCBhcmd1bWVudHMgd2lsbCBhbHdheXMgYmUgdXNlZCAoYW5kIHRoZW4gaW5pdGlhbGl6ZWQgd2l0aCB0aGUgaW5pdGlhbGl6ZXIpXHJcbiAgLy8gaW5zdGVhZCBvZiBqdXN0IHByb3ZpZGluZyB0aGUgYXJndW1lbnRzIHN0cmFpZ2h0IHRvIHRoZSBjb25zdHJ1Y3Rvci5cclxuICB1c2VEZWZhdWx0Q29uc3RydWN0aW9uPzogYm9vbGVhbjtcclxufTtcclxuXHJcbmV4cG9ydCB0eXBlIFBvb2xhYmxlT3B0aW9uczxUIGV4dGVuZHMgQ29uc3RydWN0b3I+ID1cclxuICBTZWxmUG9vbGFibGVPcHRpb25zPFQ+ICYgKCBJbnN0YW5jZVR5cGU8VD4gZXh0ZW5kcyB7IGluaXRpYWxpemU6IFBvb2xhYmxlSW5pdGlhbGl6ZXI8VD4gfSA/IHVua25vd24gOiB7XHJcbiAgICAvLyBSZXF1aXJlIGluaXRpYWxpemUgaWYgb3VyIHR5cGUgZG9lc24ndCBoYXZlIGEgY29tcGF0aWJsZSBpbml0aWFsaXplIG1ldGhvZC5cclxuICAgIGluaXRpYWxpemU6IFBvb2xhYmxlSW5pdGlhbGl6ZXI8VD47XHJcbiAgfSApO1xyXG50eXBlIFBvb2xhYmxlSW5pdGlhbGl6ZXI8VCBleHRlbmRzIENvbnN0cnVjdG9yPiA9ICggLi4uYXJnczogQ29uc3RydWN0b3JQYXJhbWV0ZXJzPFQ+ICkgPT4gSW5zdGFuY2VUeXBlPFQ+O1xyXG5cclxuZXhwb3J0IHR5cGUgVFBvb2xhYmxlID0ge1xyXG5cclxuICAvLyBBZGRzIHRoaXMgb2JqZWN0IGludG8gdGhlIHBvb2wsIHNvIHRoYXQgaXQgY2FuIGJlIHJldXNlZCBlbHNld2hlcmUuIEdlbmVyYWxseSB3aGVuIHRoaXMgaXMgZG9uZSwgbm8gb3RoZXJcclxuICAvLyByZWZlcmVuY2VzIHRvIHRoZSBvYmplY3Qgc2hvdWxkIGJlIGhlbGQgKHNpbmNlIHRoZXkgc2hvdWxkIG5vdCBiZSB1c2VkIGF0IGFsbCkuXHJcbiAgZnJlZVRvUG9vbDogKCkgPT4gdm9pZDtcclxufTtcclxuXHJcbi8vIE91ciBsaW50ZXIgY29tcGxhaW5zIHRoYXQge30gc2hvdWxkIGJlIGVpdGhlciBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiwgdW5rbm93biwgb3IgUmVjb3JkPHN0cmluZywgbmV2ZXI+LiBIb3dldmVyIGluXHJcbi8vIHRoaXMgY2FzZSwgd2UgYWN0dWFsbHkgd2FudCBpdCB0byBiZSBhbnkgdHlwZSBvZiBub24tbnVsbGlzaCBzdHJ1Y3R1cmFsIHR5cGUsIHRvIHNlZSBpZiB0aGVyZSBpcyBhbnl0aGluZyByZXF1aXJlZC5cclxuZXhwb3J0IHR5cGUgUG9zc2libHlSZXF1aXJlZFBhcmFtZXRlclNwcmVhZDxUPiA9ICgge30gZXh0ZW5kcyBUID8gWyBUPyBdIDogWyBUIF0gKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXR5cGVzXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQb29sPFQgZXh0ZW5kcyBDb25zdHJ1Y3Rvcj4ge1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgb2JqZWN0czogSW5zdGFuY2VUeXBlPFQ+W10gPSBbXTtcclxuXHJcbiAgcHJpdmF0ZSBfbWF4UG9vbFNpemU6IG51bWJlcjtcclxuICBwcml2YXRlIHJlYWRvbmx5IHBhcnRpYWxDb25zdHJ1Y3RvcjogKCAuLi5hcmdzOiBJbnRlbnRpb25hbEFueVtdICkgPT4gSW50ZW50aW9uYWxBbnk7XHJcbiAgcHJpdmF0ZSByZWFkb25seSBEZWZhdWx0Q29uc3RydWN0b3I6IEludGVudGlvbmFsQW55O1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgaW5pdGlhbGl6ZTogUG9vbGFibGVJbml0aWFsaXplcjxUPjtcclxuICBwcml2YXRlIHJlYWRvbmx5IHVzZURlZmF1bHRDb25zdHJ1Y3Rpb246IGJvb2xlYW47XHJcblxyXG4gIC8vIFRoZSBgaW5pdGlhbGl6ZWAgb3B0aW9uIGlzIHJlcXVpcmVkIGlmIHRoZSB0eXBlIGRvZXNuJ3QgaGF2ZSBhIGNvcnJlY3RseS10eXBlZCBpbml0aWFsaXplIG1ldGhvZC4gVGhlcmVmb3JlLCB3ZVxyXG4gIC8vIGRvIHNvbWUgVHlwZXNjcmlwdCBtYWdpYyB0byByZXF1aXJlIHByb3ZpZGVkT3B0aW9ucyBpZiB0aGF0J3MgdGhlIGNhc2UgKG90aGVyd2lzZSBwcm92aWRlZE9wdGlvbnMgaXMgb3B0aW9uYWwpLlxyXG4gIHB1YmxpYyBjb25zdHJ1Y3RvciggdHlwZTogVCwgLi4ucHJvdmlkZWRPcHRpb25zU3ByZWFkOiBQb3NzaWJseVJlcXVpcmVkUGFyYW1ldGVyU3ByZWFkPFBvb2xhYmxlT3B0aW9uczxUPj4gKSB7XHJcbiAgICBjb25zdCBvcHRpb25zID0gb3B0aW9uaXplPFNlbGZQb29sYWJsZU9wdGlvbnM8VD4sIFNlbGZQb29sYWJsZU9wdGlvbnM8VD4+KCkoIHtcclxuXHJcbiAgICAgIGRlZmF1bHRBcmd1bWVudHM6IFtdIGFzIHVua25vd24gYXMgQ29uc3RydWN0b3JQYXJhbWV0ZXJzPFQ+LFxyXG4gICAgICBpbml0aWFsaXplOiAoIHR5cGUucHJvdG90eXBlIGFzIHVua25vd24gYXMgeyBpbml0aWFsaXplOiBQb29sYWJsZUluaXRpYWxpemVyPFQ+IH0gKS5pbml0aWFsaXplLFxyXG4gICAgICBtYXhTaXplOiAxMDAsXHJcbiAgICAgIGluaXRpYWxTaXplOiAwLFxyXG4gICAgICB1c2VEZWZhdWx0Q29uc3RydWN0aW9uOiBmYWxzZVxyXG4gICAgfSwgcHJvdmlkZWRPcHRpb25zU3ByZWFkWyAwIF0gKTtcclxuXHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCBvcHRpb25zLm1heFNpemUgPj0gMCApO1xyXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggb3B0aW9ucy5pbml0aWFsU2l6ZSA+PSAwICk7XHJcblxyXG4gICAgdGhpcy5fbWF4UG9vbFNpemUgPSBvcHRpb25zLm1heFNpemU7XHJcblxyXG4gICAgLy8gVGhlcmUgaXMgYSBtYWRuZXNzIHRvIHRoaXMgY3JhemluZXNzLiBXZSdkIHdhbnQgdG8gdXNlIHRoZSBtZXRob2Qgbm90ZWQgYXRcclxuICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE2MDY3OTcvdXNlLW9mLWFwcGx5LXdpdGgtbmV3LW9wZXJhdG9yLWlzLXRoaXMtcG9zc2libGUsIGJ1dCB0aGUgdHlwZSBpc1xyXG4gICAgLy8gbm90IHByb3ZpZGVkIGluIHRoZSBhcmd1bWVudHMgYXJyYXkgYmVsb3cuIEJ5IGNhbGxpbmcgYmluZCBvbiBpdHNlbGYsIHdlJ3JlIGFibGUgdG8gZ2V0IGEgdmVyc2lvbiBvZiBiaW5kIHRoYXRcclxuICAgIC8vIGluc2VydHMgdGhlIGNvbnN0cnVjdG9yIGFzIHRoZSBmaXJzdCBhcmd1bWVudCBvZiB0aGUgLmFwcGx5IGNhbGxlZCBsYXRlciBzbyB3ZSBkb24ndCBjcmVhdGUgZ2FyYmFnZSBieSBoYXZpbmdcclxuICAgIC8vIHRvIHBhY2sgYGFyZ3VtZW50c2AgaW50byBhbiBhcnJheSBBTkQgVEhFTiBjb25jYXRlbmF0ZSBpdCB3aXRoIGEgbmV3IGZpcnN0IGVsZW1lbnQgKHRoZSB0eXBlIGl0c2VsZikuXHJcbiAgICB0aGlzLnBhcnRpYWxDb25zdHJ1Y3RvciA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmJpbmQoIHR5cGUsIHR5cGUgKTtcclxuXHJcbiAgICAvLyBCYXNpY2FsbHkgb3VyIHR5cGUgY29uc3RydWN0b3IsIGJ1dCB3aXRoIHRoZSBkZWZhdWx0IGFyZ3VtZW50cyBpbmNsdWRlZCBhbHJlYWR5LlxyXG4gICAgdGhpcy5EZWZhdWx0Q29uc3RydWN0b3IgPSB0aGlzLnBhcnRpYWxDb25zdHJ1Y3RvciggLi4ub3B0aW9ucy5kZWZhdWx0QXJndW1lbnRzISApOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS10eXBlLWFzc2VydGlvblxyXG5cclxuICAgIHRoaXMuaW5pdGlhbGl6ZSA9IG9wdGlvbnMuaW5pdGlhbGl6ZTtcclxuICAgIGFzc2VydCAmJiBhc3NlcnQoIHRoaXMuaW5pdGlhbGl6ZSwgJ0VpdGhlciBwYXNzIGluIGFuIGluaXRpYWxpemUgb3B0aW9uLCBvciBwcm92aWRlIGEgbWV0aG9kIG5hbWVkIGluaXRpYWxpemUgb24gdGhlIHR5cGUgd2l0aCB0aGUgcHJvcGVyIHNpZ25hdHVyZScgKTtcclxuXHJcbiAgICB0aGlzLnVzZURlZmF1bHRDb25zdHJ1Y3Rpb24gPSBvcHRpb25zLnVzZURlZmF1bHRDb25zdHJ1Y3Rpb247XHJcblxyXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgcG9vbCAoaWYgaXQgc2hvdWxkIGhhdmUgb2JqZWN0cylcclxuICAgIHdoaWxlICggdGhpcy5vYmplY3RzLmxlbmd0aCA8IG9wdGlvbnMuaW5pdGlhbFNpemUgKSB7XHJcbiAgICAgIHRoaXMub2JqZWN0cy5wdXNoKCB0aGlzLmNyZWF0ZURlZmF1bHRPYmplY3QoKSApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBjcmVhdGVEZWZhdWx0T2JqZWN0KCk6IEluc3RhbmNlVHlwZTxUPiB7XHJcbiAgICByZXR1cm4gbmV3ICggdGhpcy5EZWZhdWx0Q29uc3RydWN0b3IgKSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBhbiBvYmplY3Qgd2l0aCBhcmJpdHJhcnkgc3RhdGUgKHBvc3NpYmx5IGNvbnN0cnVjdGVkIHdpdGggdGhlIGRlZmF1bHQgYXJndW1lbnRzKS5cclxuICAgKi9cclxuICBwdWJsaWMgZmV0Y2goKTogSW5zdGFuY2VUeXBlPFQ+IHtcclxuICAgIHJldHVybiB0aGlzLm9iamVjdHMubGVuZ3RoID8gdGhpcy5vYmplY3RzLnBvcCgpISA6IHRoaXMuY3JlYXRlRGVmYXVsdE9iamVjdCgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBhbiBvYmplY3QgdGhhdCBiZWhhdmVzIGFzIGlmIGl0IHdhcyBjb25zdHJ1Y3RlZCB3aXRoIHRoZSBnaXZlbiBhcmd1bWVudHMuIE1heSByZXN1bHQgaW4gYSBuZXcgb2JqZWN0XHJcbiAgICogYmVpbmcgY3JlYXRlZCAoaWYgdGhlIHBvb2wgaXMgZW1wdHkpLCBvciBpdCBtYXkgdXNlIHRoZSBjb25zdHJ1Y3RvciB0byBtdXRhdGUgYW4gb2JqZWN0IGZyb20gdGhlIHBvb2wuXHJcbiAgICovXHJcbiAgcHVibGljIGNyZWF0ZSggLi4uYXJnczogQ29uc3RydWN0b3JQYXJhbWV0ZXJzPFQ+ICk6IEluc3RhbmNlVHlwZTxUPiB7XHJcbiAgICBsZXQgcmVzdWx0O1xyXG5cclxuICAgIGlmICggdGhpcy5vYmplY3RzLmxlbmd0aCApIHtcclxuICAgICAgcmVzdWx0ID0gdGhpcy5vYmplY3RzLnBvcCgpO1xyXG4gICAgICB0aGlzLmluaXRpYWxpemUuYXBwbHkoIHJlc3VsdCwgYXJncyApO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoIHRoaXMudXNlRGVmYXVsdENvbnN0cnVjdGlvbiApIHtcclxuICAgICAgcmVzdWx0ID0gdGhpcy5jcmVhdGVEZWZhdWx0T2JqZWN0KCk7XHJcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZS5hcHBseSggcmVzdWx0LCBhcmdzICk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgcmVzdWx0ID0gbmV3ICggdGhpcy5wYXJ0aWFsQ29uc3RydWN0b3IoIC4uLmFyZ3MgKSApKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgc2l6ZSBvZiB0aGUgcG9vbC5cclxuICAgKi9cclxuICBwdWJsaWMgZ2V0IHBvb2xTaXplKCk6IG51bWJlciB7XHJcbiAgICByZXR1cm4gdGhpcy5vYmplY3RzLmxlbmd0aDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgdGhlIG1heGltdW0gcG9vbCBzaXplLlxyXG4gICAqL1xyXG4gIHB1YmxpYyBzZXQgbWF4UG9vbFNpemUoIHZhbHVlOiBudW1iZXIgKSB7XHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCB2YWx1ZSA9PT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZIHx8ICggTnVtYmVyLmlzSW50ZWdlciggdmFsdWUgKSAmJiB2YWx1ZSA+PSAwICksICdtYXhQb29sU2l6ZSBzaG91bGQgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlciBvciBpbmZpbml0eScgKTtcclxuXHJcbiAgICB0aGlzLl9tYXhQb29sU2l6ZSA9IHZhbHVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgbWF4aW11bSBwb29sIHNpemUuXHJcbiAgICovXHJcbiAgcHVibGljIGdldCBtYXhQb29sU2l6ZSgpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIHRoaXMuX21heFBvb2xTaXplO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIGZyZWVUb1Bvb2woIG9iamVjdDogSW5zdGFuY2VUeXBlPFQ+ICk6IHZvaWQge1xyXG4gICAgaWYgKCB0aGlzLm9iamVjdHMubGVuZ3RoIDwgdGhpcy5tYXhQb29sU2l6ZSApIHtcclxuICAgICAgdGhpcy5vYmplY3RzLnB1c2goIG9iamVjdCApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHVibGljIGZvckVhY2goIGNhbGxiYWNrOiAoIG9iamVjdDogSW5zdGFuY2VUeXBlPFQ+ICkgPT4gdm9pZCApOiB2b2lkIHtcclxuICAgIHRoaXMub2JqZWN0cy5mb3JFYWNoKCBjYWxsYmFjayApO1xyXG4gIH1cclxufVxyXG5cclxucGhldENvcmUucmVnaXN0ZXIoICdQb29sJywgUG9vbCApOyJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUdBLE9BQU9BLFFBQVEsTUFBTSxlQUFlO0FBQ3BDLE9BQU9DLFNBQVMsTUFBTSxnQkFBZ0I7O0FBc0N0QztBQUNBOztBQUNvRjs7QUFFcEYsZUFBZSxNQUFNQyxJQUFJLENBQXdCO0VBQzlCQyxPQUFPLEdBQXNCLEVBQUU7RUFRaEQ7RUFDQTtFQUNPQyxXQUFX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