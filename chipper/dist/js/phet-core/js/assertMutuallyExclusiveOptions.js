// Copyright 2019-2023, University of Colorado Boulder

/**
 * Throws an assertion error if mutually exclusive options are specified.
 *
 * @example
 * assertMutuallyExclusiveOptions( { tree:1, flower:2 }, [ 'tree' ], [ 'flower' ] ) => error
 * assertMutuallyExclusiveOptions( { flower:2 }, [ 'tree' ], [ 'flower' ] ) => no error
 * assertMutuallyExclusiveOptions( { tree:1 }, [ 'tree' ], [ 'flower' ] ) => no error
 * assertMutuallyExclusiveOptions( { tree:1, mountain:2 }, [ 'tree', 'mountain' ], [ 'flower' ] ) => no error
 *
 * @author Sam Reid (PhET Interactive Simulations)
 */

import phetCore from './phetCore.js';

/**
 * @param options - an options object.  Could be before or after merge, and may therefore
 *                                        - be null or undefined
 * @param sets - families of mutually exclusive option keys, see examples above.
 */
const assertMutuallyExclusiveOptions = function (options, ...sets) {
  if (assert && options) {
    // Determine which options are used from each set
    const usedElementsFromEachSet = sets.map(set => Object.keys(_.pick(options, ...set)));

    // If any element is used from more than one set...
    if (usedElementsFromEachSet.filter(usedElements => usedElements.length > 0).length > 1) {
      // Output the errant options.
      assert && assert(false, `Cannot simultaneously specify ${usedElementsFromEachSet.join(' and ')}`);
    }
  }
};
phetCore.register('assertMutuallyExclusiveOptions', assertMutuallyExclusiveOptions);
export default assertMutuallyExclusiveOptions;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJwaGV0Q29yZSIsImFzc2VydE11dHVhbGx5RXhjbHVzaXZlT3B0aW9ucyIsIm9wdGlvbnMiLCJzZXRzIiwiYXNzZXJ0IiwidXNlZEVsZW1lbnRzRnJvbUVhY2hTZXQiLCJtYXAiLCJzZXQiLCJPYmplY3QiLCJrZXlzIiwiXyIsInBpY2siLCJmaWx0ZXIiLCJ1c2VkRWxlbWVudHMiLCJsZW5ndGgiLCJqb2luIiwicmVnaXN0ZXIiXSwic291cmNlcyI6WyJhc3NlcnRNdXR1YWxseUV4Y2x1c2l2ZU9wdGlvbnMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTktMjAyMywgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXHJcblxyXG4vKipcclxuICogVGhyb3dzIGFuIGFzc2VydGlvbiBlcnJvciBpZiBtdXR1YWxseSBleGNsdXNpdmUgb3B0aW9ucyBhcmUgc3BlY2lmaWVkLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBhc3NlcnRNdXR1YWxseUV4Y2x1c2l2ZU9wdGlvbnMoIHsgdHJlZToxLCBmbG93ZXI6MiB9LCBbICd0cmVlJyBdLCBbICdmbG93ZXInIF0gKSA9PiBlcnJvclxyXG4gKiBhc3NlcnRNdXR1YWxseUV4Y2x1c2l2ZU9wdGlvbnMoIHsgZmxvd2VyOjIgfSwgWyAndHJlZScgXSwgWyAnZmxvd2VyJyBdICkgPT4gbm8gZXJyb3JcclxuICogYXNzZXJ0TXV0dWFsbHlFeGNsdXNpdmVPcHRpb25zKCB7IHRyZWU6MSB9LCBbICd0cmVlJyBdLCBbICdmbG93ZXInIF0gKSA9PiBubyBlcnJvclxyXG4gKiBhc3NlcnRNdXR1YWxseUV4Y2x1c2l2ZU9wdGlvbnMoIHsgdHJlZToxLCBtb3VudGFpbjoyIH0sIFsgJ3RyZWUnLCAnbW91bnRhaW4nIF0sIFsgJ2Zsb3dlcicgXSApID0+IG5vIGVycm9yXHJcbiAqXHJcbiAqIEBhdXRob3IgU2FtIFJlaWQgKFBoRVQgSW50ZXJhY3RpdmUgU2ltdWxhdGlvbnMpXHJcbiAqL1xyXG5cclxuaW1wb3J0IHBoZXRDb3JlIGZyb20gJy4vcGhldENvcmUuanMnO1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSBvcHRpb25zIC0gYW4gb3B0aW9ucyBvYmplY3QuICBDb3VsZCBiZSBiZWZvcmUgb3IgYWZ0ZXIgbWVyZ2UsIGFuZCBtYXkgdGhlcmVmb3JlXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gYmUgbnVsbCBvciB1bmRlZmluZWRcclxuICogQHBhcmFtIHNldHMgLSBmYW1pbGllcyBvZiBtdXR1YWxseSBleGNsdXNpdmUgb3B0aW9uIGtleXMsIHNlZSBleGFtcGxlcyBhYm92ZS5cclxuICovXHJcbmNvbnN0IGFzc2VydE11dHVhbGx5RXhjbHVzaXZlT3B0aW9ucyA9IGZ1bmN0aW9uKCBvcHRpb25zOiBvYmplY3QgfCBudWxsIHwgdW5kZWZpbmVkLCAuLi5zZXRzOiBzdHJpbmdbXVtdICk6IHZvaWQge1xyXG4gIGlmICggYXNzZXJ0ICYmIG9wdGlvbnMgKSB7XHJcblxyXG4gICAgLy8gRGV0ZXJtaW5lIHdoaWNoIG9wdGlvbnMgYXJlIHVzZWQgZnJvbSBlYWNoIHNldFxyXG4gICAgY29uc3QgdXNlZEVsZW1lbnRzRnJvbUVhY2hTZXQgPSBzZXRzLm1hcCggc2V0ID0+IE9iamVjdC5rZXlzKCBfLnBpY2soIG9wdGlvbnMsIC4uLnNldCApICkgKTtcclxuXHJcbiAgICAvLyBJZiBhbnkgZWxlbWVudCBpcyB1c2VkIGZyb20gbW9yZSB0aGFuIG9uZSBzZXQuLi5cclxuICAgIGlmICggdXNlZEVsZW1lbnRzRnJvbUVhY2hTZXQuZmlsdGVyKCB1c2VkRWxlbWVudHMgPT4gdXNlZEVsZW1lbnRzLmxlbmd0aCA+IDAgKS5sZW5ndGggPiAxICkge1xyXG5cclxuICAgICAgLy8gT3V0cHV0IHRoZSBlcnJhbnQgb3B0aW9ucy5cclxuICAgICAgYXNzZXJ0ICYmIGFzc2VydCggZmFsc2UsIGBDYW5ub3Qgc2ltdWx0YW5lb3VzbHkgc3BlY2lmeSAke3VzZWRFbGVtZW50c0Zyb21FYWNoU2V0LmpvaW4oICcgYW5kICcgKX1gICk7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxucGhldENvcmUucmVnaXN0ZXIoICdhc3NlcnRNdXR1YWxseUV4Y2x1c2l2ZU9wdGlvbnMnLCBhc3NlcnRNdXR1YWxseUV4Y2x1c2l2ZU9wdGlvbnMgKTtcclxuZXhwb3J0IGRlZmF1bHQgYXNzZXJ0TXV0dWFsbHlFeGNsdXNpdmVPcHRpb25zOyJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPQSxRQUFRLE1BQU0sZUFBZTs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU1DLDhCQUE4QixHQUFHLFNBQUFBLENBQVVDLE9BQWtDLEVBQUUsR0FBR0MsSUFBZ0IsRUFBUztFQUMvRyxJQUFLQyxNQUFNLElBQUlGLE9BQU8sRUFBRztJQUV2QjtJQUNBLE1BQU1HLHVCQUF1QixHQUFHRixJQUFJLENBQUNHLEdBQUcsQ0FBRUMsR0FBRyxJQUFJQyxNQUFNLENBQUNDLElBQUksQ0FBRUMsQ0FBQyxDQUFDQyxJQUFJLENBQUVULE9BQU8sRUFBRSxHQUFHSyxHQUFJLENBQUUsQ0FBRSxDQUFDOztJQUUzRjtJQUNBLElBQUtGLHVCQUF1QixDQUFDTyxNQUFNLENBQUVDLFlBQVksSUFBSUEsWUFBWSxDQUFDQyxNQUFNLEdBQUcsQ0FBRSxDQUFDLENBQUNBLE1BQU0sR0FBRyxDQUFDLEVBQUc7TUFFMUY7TUFDQVYsTUFBTSxJQUFJQSxNQUFNLENBQUUsS0FBSyxFQUFHLGlDQUFnQ0MsdUJBQXVCLENBQUNVLElBQUksQ0FBRSxPQUFRLENBQUUsRUFBRSxDQUFDO0lBQ3ZHO0VBQ0Y7QUFDRixDQUFDO0FBRURmLFFBQVEsQ0FBQ2dCLFFBQVEsQ0FBRSxnQ0FBZ0MsRUFBRWYsOEJBQStCLENBQUM7QUFDckYsZUFBZUEsOEJBQThCIiwiaWdub3JlTGlzdCI6W119